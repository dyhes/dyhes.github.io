---
title: 【Shopee】Graph
date: 2025-09-27 00:00:00+0000
categories: [nutrition]
tags: [Shopee]
---

## Louvain

Louvain算法是一种高效的社区发现算法，适用于大规模网络分析。下面这张流程图概括了它的核心工作流程，帮助你快速把握其整体框架：

```
flowchart TD
    A[初始化每个节点为独立社区] --> B[模块度优化阶段<br>节点移动至模块度增益最大的社区]
    B --> C{所有节点社区<br>是否稳定？}
    C -->|否| B
    C -->|是| D[网络凝聚阶段<br>合并社区为超级节点]
    D --> E{模块度是否<br>显著提升？}
    E -->|是| A
    E -->|否| F[输出最终社区结构]
```

接下来，我们将深入探讨Louvain算法的各个方面。

### 🔍 理解模块度

**模块度**是衡量社区划分好坏的核心指标，其值域通常为**[-0.5, 1)**。它衡量了社区内部连接的紧密程度相对于随机连接期望的偏离。一个**高模块度**值意味着社区内部连接紧密，社区之间连接稀疏，这正是理想的社区结构。

模块度的计算公式如下：

```
Q=2m1i,j∑[Aij−2mkikj]δ(ci,cj)
```

其中：

- Aij表示节点i和节点j之间的边权重。
- ki和 kj分别表示节点i和节点j的度（即与之相连的所有边的权重之和）。
- m是网络中所有边的权重之和。
- δ(ci,cj)是指示函数，当节点i和节点j属于同一社区时值为1，否则为0。

公式中的 2mkikj部分表示了在随机连接的情况下，节点i和节点j之间存在边的期望权重。因此，模块度实际衡量的是社区内部实际连接强度与随机连接期望强度之间的差值。通常，模块度在**0.3到0.7**之间表明社区划分效果较好。

### ⚙️ Louvain算法的工作原理

Louvain算法通过迭代以下两个阶段来最大化模块度：

1. **模块度优化阶段**：算法遍历网络中的每个节点，计算将其移动到每个邻居节点所在社区时带来的**模块度增益** ΔQ。节点将被移动到能带来**最大正模块度增益**的社区中。这一过程反复进行，直到任何节点的移动都不能再提高模块度为止。

   模块度增益 ΔQ的计算公式（当将节点i移动到社区C时）为：

   ```
   ΔQ=[2mΣin+ki,in−(2mΣtot+ki)2]−[2mΣin−(2mΣtot)2−(2mki)2]
   ```

   其中 Σin是社区C内部所有边的权重和，Σtot是与社区C内节点相连的所有边的权重和，ki,in是从节点i连接到社区C内节点的边的权重和，ki是与节点i相连的所有边的权重和。

2. **网络凝聚阶段**：在第一个阶段完成后，将每个社区**合并为一个新的超级节点**。超级节点之间的边权重为原始社区之间所有边的权重之和，而社区内部的边权重则会转化为新节点的自环权重。

上述两个阶段构成一次迭代。迭代过程会一直进行，直到整个网络的模块度不再发生显著变化为止。这种层次化的处理使得算法能够揭示出网络在不同粒度下的社区结构。

### 💻 代码实现与应用

在实际应用中，你可以使用现有的库来方便地调用Louvain算法。例如，在Python中，可以使用 `python-louvain`库：

```
import community as community_louvain
import networkx as nx

# 加载一个示例图（Zachary空手道俱乐部网络）
G = nx.karate_club_graph()

# 使用Louvain算法找到最佳社区划分
partition = community_louvain.best_partition(G)

# 计算划分后的模块度
modularity = community_louvain.modularity(partition, G)
print("Modularity:", modularity)

# 打印社区划分结果
print("Community membership:", partition)
```

Louvain算法在许多领域都有广泛应用：

- **社交网络分析**：识别具有共同兴趣或紧密联系的用户群体。
- **生物信息学**：分析蛋白质相互作用网络，发现功能相似的蛋白质复合物。
- **单细胞转录组学**：根据基因表达模式对细胞进行聚类。
- **推荐系统**：根据用户行为相似性进行用户分群，实现更精准的推荐。

### 📊 算法性能与特点

Louvain算法有以下显著特点：

- **高效性**：算法的时间复杂度约为 O(nlogn)，其中 n是节点数量，这使得它能够处理包含数百万节点的大规模网络。
- **无需预设社区数**：算法自动确定最终的社区数量。
- **层次化结构**：通过多次迭代，能够揭示网络在不同尺度上的社区结构。
- **局限性**：
  - 可能产生规模较大的社区。
  - 模块度函数存在分辨率限制，可能无法识别出较小的社区。
  - 由于采用贪心策略，结果可能受节点遍历顺序影响。

### ⚖️ 与其他算法比较

与其他社区发现算法相比，Louvain算法有其独特优势：

- **与Girvan-Newman算法比较**：Girvan-Newman算法基于边介数，能找到更精确的社区结构，但时间复杂度高（O(n3)），难以应用于大规模网络。Louvain算法在效率和可扩展性上优势明显。
- **与标签传播算法比较**：标签传播算法更简单高效，但对噪声敏感，结果稳定性较差。
- **与Infomap算法比较**：Infomap算法基于信息论，适用于有向图，但概念和实现相对复杂。

### 💎 总结与展望

Louvain算法因其**高效率**和**良好的社区划分效果**，已成为社区发现领域最流行和实用的算法之一。虽然它也存在一些局限性（如可能无法识别小社区），并且在某些情况下已被更先进的算法（如Leiden算法）所改进，但它仍然是许多网络分析任务的首选起点。

希望这份详细的介绍能帮助你全面理解Louvain算法。如果你对某个特定方面还有疑问，或者想了解如何在实际项目中调整参数优化结果，我们可以继续深入探讨。

## Leiden

Leiden算法是2019年提出的一种先进的社区发现算法，它有效地解决了经典Louvain算法可能产生连通性不佳的社区的问题，同时在运行速度和结果质量上都有显著提升。下面这张流程图直观地展示了它的核心工作流程，你可以先通过它建立一个整体印象。

```
flowchart TD
    A[初始化每个节点为独立社区] --> B[快速局部移动<br>仅处理邻居变化的节点]
    B --> C[分区细化<br>保证社区内部连通性]
    C --> D[网络聚合<br>基于细化分区构建新网络]
    D --> E{模块度是否<br>显著提升？}
    E -->|是| A
    E -->|否| F[输出最终社区结构]
```

### 🔍 理解Leiden算法的核心改进

要理解Leiden的巧妙之处，我们需要先看看它的前辈Louvain算法的主要缺陷：**可能产生内部连通性很差甚至完全不连通的社区**。

想象一个场景，在一个社区中，有一个核心节点（比如节点0）像一座桥梁，连接着社区内的两个部分。Louvain算法在优化过程中，可能会因为模块度增益而将这座“桥”移动到另一个社区。这会导致原来的社区被分裂成两个互不连通的部分，但由于算法只考虑单个节点的移动，它无法察觉这种分裂，从而将这两个部分仍然视为一个社区。Leiden算法正是通过引入**分区细化阶段** 来解决这个问题，保证最终产生的每个社区都是内部连通的。

### ⚙️ 详解算法的三个阶段

Leiden算法的每次迭代都包含以下三个关键阶段：

1. **快速局部移动**

   此阶段的目标是初步优化分区。与Louvain算法反复遍历所有节点不同，Leiden采用了一种更高效的策略：

   - **初始化队列**：将所有节点随机放入一个队列中。
   - **处理节点**：从队列前端取出一个节点，计算将其移动到任一邻居社区所带来的模块度增益。如果存在正增益，则将其移动到能带来**最大增益**的社区。
   - **更新队列**：如果一个节点被移动，则将其**不属于新社区且不在队列中的邻居节点**加入队列尾部。这个过程持续到队列为空，确保只处理那些邻居状态发生变化的节点，大大提升了效率。

2. **分区细化**

   这是Leiden算法的核心创新，旨在保证社区的连通性。它对上一步得到的分区进行局部调整：

   - **初始化细化分区**：将当前分区中的每个社区内的所有节点都视为独立的单节点社区。
   - **局部合并**：尝试将这些单节点社区在**原社区内部**进行合并。合并必须满足两个条件：一是能提高质量函数（如模块度），二是合并后必须保证子集是**良好连通的**。合并过程引入了一定的随机性，并非总是选择最优增益，这有助于探索更广阔的解空间。

3. **网络聚合**

   基于**细化后的高质量分区**，将每个社区凝聚成一个新的超级节点，构建出一个规模更小的新网络。然后，算法将这个新网络作为输入，开始下一次迭代，直到模块度不再显著提升为止。

### 📊 与Louvain算法的对比

| 对比维度       | **Louvain算法**                                      | **Leiden算法**                                             |
| -------------- | ---------------------------------------------------- | ---------------------------------------------------------- |
| **核心保证**   | 保证没有单个节点可以移动，但没有连通性保证。         | **保证所有社区内部连通**，且社区的子集也是局部最优的。     |
| **社区质量**   | 可能产生连通性差甚至不连通的社区，尤其在多次迭代后。 | 社区质量**显著更高**，结构更合理，能发现更细微的社区结构。 |
| **运行效率**   | 每次迭代需遍历所有节点，相对较低效。                 | 采用快速局部移动，**速度更快**，尤其适合大规模网络。       |
| **算法复杂度** | 相对简单。                                           | 增加了细化步骤，更复杂，但能避免后续不必要的计算。         |

### 💻 实践与应用

在实际应用中，你可以使用现有的库来轻松运行Leiden算法。例如，在Python中，结合`igraph`和`leidenalg`库：

```
import igraph as ig
import leidenalg

# 读取或创建一个图
# g = ig.Graph.Read_Edgelist("your_network.edgelist")
# 以著名的Zachary空手道俱乐部网络为例
g = ig.Graph.Famous('Zachary')

# 使用Leiden算法进行社区划分，以模块度为优化目标
partition = leidenalg.find_partition(g, leidenalg.ModularityVertexPartition)

# 查看划分结果和模块度值
print("Community membership:", list(partition))
print("Modularity of the partition:", partition.modularity)
```

Leiden算法因其高效和高质量的结果，已被广泛应用于多个领域：

- **单细胞基因组学**：在分析单细胞RNA测序数据时，用于对细胞进行聚类，识别不同的细胞类型。例如，分析工具Scanpy就已用Leiden替代了Louvain作为默认的聚类算法。
- **社交网络分析**：识别具有紧密联系的用户群体或兴趣社区。
- **生物信息学**：在蛋白质相互作用网络或基因调控网络中，发现功能模块。
- **推荐系统与金融风控**：识别用户群体或发现潜在的风险关联团伙。

### 💎 总结

总的来说，Leiden算法通过引入**分区细化阶段**，在继承Louvain算法高效层次化处理优点的同时，**从根本上解决了社区连通性问题**，并往往能获得质量更高、更合理的社区划分结果。虽然它对参数（如分辨率参数）的选择可能比较敏感，但毫无疑问，它已成为当前社区发现领域**性能更优越、更值得推荐的标准算法之一**。

希望这份详细的介绍能帮助你全面理解Leiden算法。如果你对某个技术细节或应用场景有进一步的疑问，我们可以继续深入探讨。