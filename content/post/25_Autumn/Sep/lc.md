---
title: 【LeetCode-C】Sep 2025
date: 2025-09-09 00:00:00+0000
categories: [snow]
tags: [LeetCode-C]
---

## 取模

取模运算（Modulo Operation）遵循一系列重要的运算律，这些规则在与加、减、乘和幂运算结合时尤其有用。下面通过一个表格汇总了它的主要运算律，并附上了简要说明和应用提示。

| 运算类型     | 运算律           | 数学表达式                                                | 说明                                                         |
| ------------ | ---------------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| **基本运算** | 模加             | `(a + b) % p = (a % p + b % p) % p`                       | 和的模等于模的和再取模。这可以防止中间结果溢出。             |
|              | 模减             | `(a - b) % p = (a % p - b % p) % p`                       | **注意**：结果可能为负，通常需调整：`(a % p - b % p + p) % p` |
|              | 模乘             | `(a * b) % p = (a % p * b % p) % p`                       | 积的模等于模的积再取模。同样有助于避免大数相乘溢出。         |
|              | 模幂             | `a^b % p = ((a % p)^b) % p`                               | 幂的模等于底数取模后再求幂并取模。是快速幂算法的基础。       |
| **结合律**   | 模加结合律       | `((a+b) % p + c) % p = (a + (b+c) % p) % p`               | 模加法满足结合律，意味着分组计算不影响最终结果。             |
|              | 模乘结合律       | `((a*b) % p * c) % p = (a * (b*c) % p) % p`               | 模乘法满足结合律，计算顺序可调整。                           |
| **交换律**   | 模加交换律       | `(a + b) % p = (b + a) % p`                               | 模加法满足交换律，顺序可交换。                               |
|              | 模乘交换律       | `(a * b) % p = (b * a) % p`                               | 模乘法满足交换律，顺序可交换。                               |
| **分配律**   | 乘法对模加分配律 | `((a + b) % p * c) % p = ((a * c) % p + (b * c) % p) % p` | 模运算下，乘法对加法满足分配律。                             |

### 💡 运算律的核心价值与同余性质

这些运算律的核心价值在于，它们允许我们在进行加、减、乘、幂运算时，**随时对中间结果取模**而不影响最终结果的正确性（相对于同样的运算最后再取模而言）。这能有效防止计算过程中数值过大而导致的溢出问题，在编程和算法设计中非常重要。

此外，取模运算还与**同余关系**密切相关。如果 `a ≡ b (mod p)`（表示 `a`和 `b`除以 `p`的余数相同），那么对于任意整数 `c`，通常有：

- `(a + c) ≡ (b + c) (mod p)`
- `(a * c) ≡ (b * c) (mod p)`
- 若还有 `c ≡ d (mod p)`，则 `(a + c) ≡ (b + d) (mod p)`, `(a * c) ≡ (b * d) (mod p)`

### ⚠️ 重要提醒：除法与负数

- **除法（逆元）**：表格中未列出直接的模除运算律。因为普通的除法分配律在模运算中**并不成立**（即 `(a / b) % p ≠ (a % p) / (b % p) % p`）。在模运算中，“除法”通常通过乘以其**模逆元**来实现，但这要求 `b`与 `p`互质。
- **负数取模**：不同编程语言对负数取模的结果定义可能不同（主要区别在于商向0舍入还是向负无穷舍入），这会影响到 `a % p`的具体值（可能为负）。上述部分运算律（如模减）在涉及负数时，为了确保得到非负结果，可能需要额外的调整（如加上 `p`再取模）。

### 📊 取模 (Mod) 与取余 (Rem) 的细微差别

虽然“取模”和“取余”都得到除法后的余数，但对于**负整数**，两者的结果可能不同。

- 区别主要源于**商向哪个方向取整**：
  - **取余 (Remainder)**: 商向 **0** 取整 (truncated division)。**结果的符号与被除数 `a`相同**。常见于 C/C++、Java、JavaScript 等语言中的 `%`运算符。
  - **取模 (Modulo)**: 商向 **负无穷** 取整 (floored division)。**结果的符号与除数 `p`相同**。常见于 Python、Ruby 等语言中的 `%`运算符。
- **示例 (`-7 mod 4`或 `-7 % 4`)**:
  - 取余操作（商向0取整）：`c = trunc(-7/4) = trunc(-1.75) = -1`, 余数 `r = -7 - (-1)*4 = -3`。
  - 取模操作（商向负无穷取整）：`c = floor(-7/4) = floor(-1.75) = -2`, 余数 `r = -7 - (-2)*4 = 1`。
- 当 `a`和 `p`同号时，两者结果相同；异号时则不同。 在编程时，务必了解你所用语言的 `%`运算符定义。

掌握这些运算律能帮助你在许多计算场景中更加得心应手。

## tolower

在 C++ 中，将 `char`字符转换为小写字母主要有两种方法：使用标准库函数和手动转换。下面是一个快速的对比表格，帮助你了解它们的主要区别：

| 特性         | 标准库函数 (`std::tolower`)                                  | 手动转换 (ASCII 加减)                                        |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **核心机制** | 使用 C++ 标准库 `<cctype>`中提供的函数                       | 利用大写字母 ('A'-'Z') 和小写字母 ('a'-'z') 之间 ASCII 码相差 32 的特性 |
| **优点**     | **推荐方法**，代码简洁直观，能自动处理非字母字符（保持不变） | 有助于理解底层原理，不依赖特定头文件                         |
| **注意事项** | 需要包含 `<cctype>`头文件，函数返回 `int`类型                | 需手动检查字符范围，否则可能误改数字、符号等非字母字符       |
| **适用场景** | **大多数情况下推荐使用**                                     | 学习、理解原理，或在无法使用标准库的特定环境                 |

### 📌 使用方法

#### 使用标准库函数 `std::tolower`

这是**最常用且推荐**的方法。`std::tolower`函数在 `<cctype>`头文件中定义。

**示例代码：**

```
#include <iostream>
#include <cctype> // 必需包含的头文件

int main() {
    char upperChar = 'G';

    // 使用 std::tolower 转换
    char lowerChar = std::tolower(upperChar); // 函数返回 int 类型，但赋值给 char 时会隐式转换

    std::cout << "原始字符: " << upperChar << std::endl;
    std::cout << "转换后: " << lowerChar << std::endl;

    // 处理字符串中的每个字符
    std::string str = "Hello, World!";
    for (char &c : str) { // 使用引用以修改原字符串
        c = std::tolower(c); // 逐个字符转换
    }
    std::cout << "转换后的字符串: " << str << std::endl; // 输出 "hello, world!"

    return 0;
}
```

**注意**：`std::tolower`函数接收一个 `int`类型参数（代表字符的 ASCII 码），并返回一个 `int`值。通常将其赋值给 `char`变量或直接用于字符操作时，类型转换是安全的。

#### 手动转换 (基于 ASCII 码)

这种方法通过直接操作字符的 ASCII 码值进行转换。

**示例代码：**

```
#include <iostream>

// 自定义大写转小写函数
char toLowerAscii(char c) {
    // 检查是否为大写字母 (ASCII 范围 65-'A' 到 90-'Z')
    if (c >= 'A' && c <= 'Z') {
        return c + 32; // 大写字母 ASCII 码加 32 得到对应小写
    }
    return c; // 不是大写字母则原样返回
}

int main() {
    char testChar = 'B';
    char lowerChar = toLowerAscii(testChar);

    std::cout << "原始字符: " << testChar << std::endl;
    std::cout << "手动转换后: " << lowerChar << std::endl; // 输出 'b'

    return 0;
}
```

这种方法需要**确保字符是英文大写字母**，否则加减 32 可能会得到非预期结果。

### ⚠️ 重要注意事项

1. **本地化设置 (`Locale`)**：`std::tolower`和 `std::toupper`的行为可能会受到当前系统区域设置 (`locale`) 的影响，这对于处理英文以外的字符（如带重音的字母）可能重要。大多数情况下，基本 ASCII 字符处理不受影响。
2. **非字母字符**：两种方法对非字母字符（如数字、标点符号）通常都是**保持原状**。
3. **返回值处理**：`std::tolower`返回的是 `int`类型，这是为了可能处理文件结束符 (`EOF`) 等特殊情况。在给 `char`变量赋值时，通常可以安全地隐式转换或使用 `static_cast<char>`。
4. **Unicode 字符**：上述方法主要适用于 **ASCII 字符集**。如果你需要处理 Unicode 字符串（如中文拼音、德文、法文等）中的大小写转换，则需要使用专门的库（如 ICU - International Components for Unicode）。

### 💡 简单建议

- 对于**大多数日常用途**，直接使用 **`std::tolower`** 是最简单、最清晰且不易出错的方式。
- 如果你想**理解背后的原理**或在不方便使用标准库的环境中（极少见），可以使用手动 ASCII 转换的方法。
- 如果需要处理**英文以外的语言**，请务必寻找支持 Unicode 的库。

## 下标 String

。在 C++ 中，如果你希望在遍历 `std::string`时同时获取每个字符的下标，有几种方法可以实现。虽然标准的范围 for 循环 (`for (auto ch : str)`) 本身不直接提供下标，但你可以通过一些调整来达成目的。

下面是一个汇总了常见方法的表格，帮助你快速了解选择和区别：

| 方法                       | 优点                           | 缺点                               | 适用场景                                     |
| -------------------------- | ------------------------------ | ---------------------------------- | -------------------------------------------- |
| **传统下标循环**           | 直观，直接控制下标             | 语法稍显繁琐                       | 需要频繁使用下标进行随机访问或修改的场景     |
| **范围for循环+手动下标**   | 代码简洁（循环部分），可读性好 | 需额外维护下标变量                 | 需要顺序遍历并同时知道下标时最优雅的方案     |
| **`std::for_each`+lambda** | 函数式风格，可封装复杂操作     | 语法相对复杂，需要理解lambda和算法 | 需要在遍历中进行复杂操作或希望代码更函数化时 |

接下来我们看看每种方法的具体代码示例。

### 1. 传统下标循环

这是最直接的方法，使用 `size()`方法获取字符串长度，并通过索引 `i`依次访问每个字符。

```
#include <iostream>
#include <string>

int main() {
    std::string str = "Hello";
    for (size_t i = 0; i < str.size(); ++i) { // 使用 size_t 类型作为下标，与 size() 返回类型一致
        std::cout << "Index: " << i << ", Character: " << str[i] << std::endl;
        // 你也可以通过 str.at(i) 来访问，它会在越界时抛出异常
    }
    return 0;
}
```

### 2. 范围for循环 + 手动维护下标

如果你偏爱范围 for 循环的简洁性，可以手动维护一个下标变量。

```
#include <iostream>
#include <string>

int main() {
    std::string str = "World";
    size_t index = 0; // 手动初始化下标
    for (auto ch : str) { // 范围for循环遍历每个字符
        std::cout << "Index: " << index << ", Character: " << ch << std::endl;
        ++index; // 每次循环手动增加下标
    }
    return 0;
}
```

### 3. 使用 `std::for_each`和 Lambda 表达式（带捕获）

`std::for_each`算法可以遍历容器，并结合 lambda 表达式来同时处理元素和下标。

```
#include <iostream>
#include <string>
#include <algorithm> // 需要包含 algorithm 头文件

int main() {
    std::string str = "C++";
    size_t idx = 0;
    std::for_each(str.begin(), str.end(), [&idx](char c) { // 通过引用捕获 [&idx] 来修改外部下标变量
        std::cout << "Index: " << idx << ", Character: " << c << std::endl;
        ++idx;
    });
    return 0;
}
```

### 💡 注意事项

- **下标类型**：`std::string::size()`返回的类型是 `size_t`（通常是无符号整数），**建议使用 `size_t`类型作为下标变量**，以避免有符号与无符号比较时编译器可能产生的警告。
- **修改字符**：如果需要在遍历时修改字符串中的字符，在上述方法中：
  - **方法1**：直接使用 `str[i] = new_char;`或 `str.at(i) = new_char;`。
  - **方法2**：将循环变量声明为引用 `for (auto &ch : str)`，然后对 `ch`赋值。
  - **方法3**：在 lambda 表达式中，如果字符串是非 const 的，参数可以声明为 `char &c`以便修改。
- **Unicode 字符串**：如果字符串包含多字节字符（如中文），直接按索引访问可能无法正确指向一个完整字符的起始位置，需要更复杂的处理逻辑。

### 🎯 如何选择

- 追求**代码简洁性**和**现代 C++ 风格**，且只需要**顺序遍历**，**“范围for循环 + 手动下标”（方法2）** 通常是直观且不错的选择。
- 如果需要**频繁的随机访问**或者** already习惯传统循环**，**传统下标循环（方法1）** 很直接。
- 如果遍历操作**逻辑比较复杂**，或者希望尝试**函数式编程风格**，可以选用 **`std::for_each`（方法3）**。

希望这些信息能帮助你有效地在 C++ 中遍历字符串并操作下标。

## 互质

理解“互质”这个概念对于学习数学，特别是数论、分数化简等领域很有帮助。下面我来为你解释一下什么是互质，以及它的一些特性和判断方法。

### 📊 互质的基本概念

互质，又被称为互素，指的是两个或多个整数的公约数只有1的非零自然数。也就是说，如果两个数 a 和 b 的最大公约数（Greatest Common Divisor, GCD）是1，即 GCD(a, b) = 1，那么我们就可以说 a 和 b 互质。

例如：

- 3 和 11 互质，因为它们的公约数只有1。
- 8 和 9 互质，因为 8 的因数有 1, 2, 4, 8；9 的因数有 1, 3, 9；它们唯一的公因数就是1。

值得注意的是，**互质的两个数并不一定都是质数**。两个合数也有可能互质，比如上面的 8 和 9 都是合数，但它们互质。

### 🔍 互质的性质与判断

理解互质的一些性质可以帮助我们更快地判断两个数是否互质：

- **1与任何自然数互质**：因为1的因数只有它自己，且1和任何自然数的最大公约数都是1（注意，1本身不是质数也不是合数）。
- **两个不同的质数一定互质**：例如 7 和 11。
- **相邻的两个自然数互质**：比如 15 和 16。
- **相邻的两个奇数常常互质**：例如 5 和 7，或者 49 和 51。
- **其他情况**：一个质数和一个合数，如果这个合数不是质数的倍数，则它们互质（如 3 和 10）；两个合数如果没有相同的质因数，则它们互质（如 9 和 10，9=3×3, 10=2×5，没有相同的质因数）。

判断两个数是否互质，最直接的方法是看它们的**最大公约数是否为1**。对于一些较大的数，可以采用以下方法：

- **分解判断法**：如果两个数都是合数，可以分别对它们进行质因数分解。如果**没有相同的质因数**，那么这两个数互质。例如，130 = 2 × 5 × 13, 231 = 3 × 7 × 11，没有相同的质因数，所以130和231互质。
- **求差判断法**：如果两个数相差不大，可以先求它们的差，再看这个差与其中较小的数是否互质。如果互质，则原来的两个数也互质。

### 🧮 互质的应用

互质的概念在数学和计算机科学中都有广泛的应用：

- **最简分数**：一个分数是最简分数（不能再约分），当且仅当其**分子和分母互质**。例如，分数 2/3 是最简分数，因为 GCD(2,3)=1。
- **数论与密码学**：互质是许多数论定理和算法的基础。例如，在**RSA公钥加密算法**中，需要选择两个互质的大质数来生成密钥。
- **模运算与逆元**：在模运算中，如果两个数互质，那么其中一个数在另一个数的模下存在**乘法逆元**，这对于求解线性同余方程等问题至关重要。
- **欧拉函数**：数论中的欧拉函数 φ(n) 定义为小于 n 且与 n 互质的正整数的个数。它在密码学和数论中都有重要应用。

### 💻 编程判断互质

在编程中，我们通常使用**欧几里得算法（辗转相除法）** 来高效地计算两个数的最大公约数。如果最大公约数是1，则两数互质。

以下是使用C语言实现判断两数是否互质的示例代码：

```
#include <stdio.h>

// 递归法求最大公约数
int gcd(int a, int b) {
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}

int main() {
    int x, y;
    printf("请输入两个正整数: ");
    scanf("%d %d", &x, &y);

    if (gcd(x, y) == 1) {
        printf("%d 和 %d 互质\n", x, y);
    } else {
        printf("%d 和 %d 不互质\n", x, y);
    }

    return 0;
}
```

希望这些信息能帮助你更好地理解“互质”的概念。

## 互质判断

判断两个数是否互质，关键在于确认它们的**最大公约数（GCD）是否为 1**。以下是常用的判断方法和一些规律，希望能帮你轻松掌握。

| 方法             | 做法                                             | 例子                                                       | 适用情况                                     |
| ---------------- | ------------------------------------------------ | ---------------------------------------------------------- | -------------------------------------------- |
| **最大公约数法** | 求两数的最大公约数，若为1则互质。                | GCD(8, 15) = 1，所以 8 和 15 互质。                        | 通用，最可靠，尤其适合较大或无明显规律的数。 |
| **概念判断法**   | 检查两数除了1以外是否有其他公因数。              | 9和11的公约数只有1，所以它们互质。                         | 适合因数较少或较小的数。                     |
| **分解判断法**   | 将两个合数分解质因数，若没有相同的质因数则互质。 | 130=2×5×13, 231=3×7×11，没有相同质因数，所以130和231互质。 | 当两个数都是合数，且便于进行质因数分解时。   |
| **求差判断法**   | 先求两数之差，若差与较小数互质，则原两数互质。   | 201-194=7，7和194互质，则194和201互质。                    | 两数相差不大时。                             |
| **求商判断法**   | 用大数除以小数，若余数与小数互质，则原两数互质。 | 317÷52=6……5，余数5与52互质，则317和52互质。                | 适用于除法计算方便时。                       |

### 🔢 快速判断的规律

掌握一些常见规律，能帮助你更快地做出判断：

1. **两个不同的质数一定互质**。例如 `7`和 `11`。
2. **1和任何自然数都互质**。例如 `1`和 `100`。
3. **相邻的两个自然数互质**。例如 `15`和 `16`。
4. **相邻的两个奇数常常互质**。例如 `5`和 `7`，或者 `49`和 `51`。
5. **较大数是质数，则两数互质**。例如 `97`和 `88`（97是质数）。
6. **小数是质数，大数不是小数的倍数，则两数互质**。例如 `2`和 `15`（2是质数，15不是2的倍数）。

### 🖥️ 编程实现判断

如果需要用程序判断，可以使用**欧几里得算法（辗转相除法）** 来计算最大公约数。这里提供一个C语言的例子：

```
#include <stdio.h>

// 递归函数计算最大公约数
int gcd(int a, int b) {
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
}

int main() {
    int num1, num2;
    printf("请输入两个正整数: ");
    scanf("%d %d", &num1, &num2);

    if (gcd(num1, num2) == 1) {
        printf("%d 和 %d 互质\n", num1, num2);
    } else {
        printf("%d 和 %d 不互质\n", num1, num2);
    }

    return 0;
}
```

### 🧠 互质的应用

判断两个数是否互质，在数学和计算机科学中有些重要应用：

- **分数约分**：当分数的分子和分母互质时，这个分数就是最简形式。
- **密码学**：例如RSA公钥加密算法，其安全性依赖于大质数的选择以及相关参数的互质关系。
- **模运算**：在模运算下，如果两个数互质，那么其中一个数存在乘法逆元。

希望这些方法能帮助你有效判断两个数是否互质。多练习一下，你会更加熟练。

## 辗转相除法

辗转相除法，也称欧几里得算法，是计算两个正整数最大公约数（Greatest Common Divisor, GCD）的一种高效方法。下面为你详细介绍它的原理、步骤、应用以及编程实现。

### 📊 基本原理

辗转相除法的核心原理是：**两个整数的最大公约数，等于其中较小的那个数和两数相除余数的最大公约数**。其计算公式为 `gcd(a, b) = gcd(b, a mod b)`。

### 📝 算法步骤

按照辗转相除法求两个非负整数 `a`和 `b`（假设 `a ≥ b`）的最大公约数的步骤如下：

1. **用较大数除以较小数**：计算 `a`除以 `b`的余数，记为 `r = a mod b`（即 `r = a % b`）。
2. **更新值**：将 `b`的值赋给 `a`，将余数 `r`的值赋给 `b`。
3. **判断余数**：若 `b`不为 `0`，则返回步骤 1，继续循环。
4. **终止条件**：当 `b`为 `0`时，此时的 `a`即为两数的最大公约数。

以下是该算法的流程图，可以帮你直观理解其执行过程：

```
flowchart TD
    A([开始]) --> B[用a除以b, 得余数r]
    B --> C{r等于0?}
    C -- 否 --> D[将b赋值给a<br>将r赋值给b]
    D --> B
    C -- 是 --> E[当前除数a即为最大公约数]
    E --> F([结束])
```

### 🧮 计算实例

让我们通过一个具体的例子来理解这个过程：求 **481** 和 **221** 的最大公约数。

| 步骤 | 被除数 (a) | 除数 (b) | 商   | 余数 (r) | 操作说明                        |
| ---- | ---------- | -------- | ---- | -------- | ------------------------------- |
| 1    | 481        | 221      | 2    | 39       | 481 ÷ 221，商2余39              |
| 2    | 221        | 39       | 5    | 26       | 用除数221 ÷ 上步余数39，商5余26 |
| 3    | 39         | 26       | 1    | 13       | 用除数39 ÷ 上步余数26，商1余13  |
| 4    | 26         | 13       | 2    | 0        | 用除数26 ÷ 上步余数13，商2余0   |
| 结果 |            |          |      |          | **余数为0，最大公约数为13**     |

所以，481 和 221 的最大公约数是 **13**。

### 🔍 原理证明

辗转相除法的有效性基于一个关键定理：**如果 `a`和 `b`是正整数，且 `a > b`，那么 `gcd(a, b) = gcd(b, a mod b)`**。

简单来说，这个定理之所以成立，是因为：

- 任何能同时整除 `a`和 `b`的数 `d`，也一定能整除余数 `r`（因为 `r = a - k*b`，`k`是商）。
- 反之，任何能同时整除 `b`和 `r`的数 `d`，也一定能整除 `a`。
- 因此，`a`和 `b`的公约数集合，与 `b`和 `r`的公约数集合完全相同，自然它们的最大公约数也相等。

### 💻 编程实现

辗转相除法在编程中既可以用递归实现，也可以用迭代（循环）实现。

#### 递归实现 (C++)

```
#include <iostream>
using namespace std;

int gcd(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return gcd(b, a % b);
    }
}

int main() {
    int num1 = 481, num2 = 221;
    cout << "GCD of " << num1 << " and " << num2 << " is " << gcd(num1, num2) << endl;
    return 0;
}
```

#### 迭代实现 (C++)

```
#include <iostream>
using namespace std;

int gcd_iterative(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int main() {
    int num1 = 481, num2 = 221;
    cout << "GCD of " << num1 << " and " << num2 << " is " << gcd_iterative(num1, num2) << endl;
    return 0;
}
```

**注意**：自 C++17 起，标准库 `<numeric>`中提供了 `std::gcd`函数，可以直接使用。

### ⚙️ 算法特性与应用

- **时间复杂度**：辗转相除法的时间复杂度是 **O(log(min(a, b)))**，效率非常高，即使对于非常大的整数也是如此。
- **主要应用**：
  - **化简分数**：用于将分数化为最简形式。
  - **密码学**：**RSA公钥加密算法**等密码学协议依赖于大整数的模逆元计算，而扩展欧几里得算法（辗转相除法的扩展）是求解模逆元的关键工具。
  - **求解线性同余方程**：扩展欧几里得算法可以找到整数 `x`和 `y`，使得方程 `a*x + b*y = gcd(a, b)`成立，这在数论和算法设计中非常重要。

### 🤔 与其他方法的比较

求最大公约数还有其他方法，例如**更相减损术**和**质因数分解法**。

- **更相减损术**：出自《九章算术》，以减法为主。当两个数字大小差别很大时，计算次数可能远多于辗转相除法。
- **质因数分解法**：先将两个数分解质因数，然后找出所有公共质因数并将其相乘。但当质因数很大时，分解本身可能非常困难，而辗转相避开了分解步骤，效率更高。

因此，辗转相除法因其高效性和实现的简洁性，成为了计算最大公约数最常用和最重要的算法。

希望这些信息能帮助你全面理解辗转相除法。

## 最小公倍数

辗转相除法，也称欧几里得算法，是计算两个正整数最大公约数（Greatest Common Divisor, GCD）的一种高效方法。下面为你详细介绍它的原理、步骤、应用以及编程实现。

### 📊 基本原理

辗转相除法的核心原理是：**两个整数的最大公约数，等于其中较小的那个数和两数相除余数的最大公约数**。其计算公式为 `gcd(a, b) = gcd(b, a mod b)`。

### 📝 算法步骤

按照辗转相除法求两个非负整数 `a`和 `b`（假设 `a ≥ b`）的最大公约数的步骤如下：

1. **用较大数除以较小数**：计算 `a`除以 `b`的余数，记为 `r = a mod b`（即 `r = a % b`）。
2. **更新值**：将 `b`的值赋给 `a`，将余数 `r`的值赋给 `b`。
3. **判断余数**：若 `b`不为 `0`，则返回步骤 1，继续循环。
4. **终止条件**：当 `b`为 `0`时，此时的 `a`即为两数的最大公约数。

以下是该算法的流程图，可以帮你直观理解其执行过程：

```
flowchart TD
    A([开始]) --> B[用a除以b, 得余数r]
    B --> C{r等于0?}
    C -- 否 --> D[将b赋值给a<br>将r赋值给b]
    D --> B
    C -- 是 --> E[当前除数a即为最大公约数]
    E --> F([结束])
```

### 🧮 计算实例

让我们通过一个具体的例子来理解这个过程：求 **481** 和 **221** 的最大公约数。

| 步骤 | 被除数 (a) | 除数 (b) | 商   | 余数 (r) | 操作说明                        |
| ---- | ---------- | -------- | ---- | -------- | ------------------------------- |
| 1    | 481        | 221      | 2    | 39       | 481 ÷ 221，商2余39              |
| 2    | 221        | 39       | 5    | 26       | 用除数221 ÷ 上步余数39，商5余26 |
| 3    | 39         | 26       | 1    | 13       | 用除数39 ÷ 上步余数26，商1余13  |
| 4    | 26         | 13       | 2    | 0        | 用除数26 ÷ 上步余数13，商2余0   |
| 结果 |            |          |      |          | **余数为0，最大公约数为13**     |

所以，481 和 221 的最大公约数是 **13**。

### 🔍 原理证明

辗转相除法的有效性基于一个关键定理：**如果 `a`和 `b`是正整数，且 `a > b`，那么 `gcd(a, b) = gcd(b, a mod b)`**。

简单来说，这个定理之所以成立，是因为：

- 任何能同时整除 `a`和 `b`的数 `d`，也一定能整除余数 `r`（因为 `r = a - k*b`，`k`是商）。
- 反之，任何能同时整除 `b`和 `r`的数 `d`，也一定能整除 `a`。
- 因此，`a`和 `b`的公约数集合，与 `b`和 `r`的公约数集合完全相同，自然它们的最大公约数也相等。

### 💻 编程实现

辗转相除法在编程中既可以用递归实现，也可以用迭代（循环）实现。

#### 递归实现 (C++)

```
#include <iostream>
using namespace std;

int gcd(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return gcd(b, a % b);
    }
}

int main() {
    int num1 = 481, num2 = 221;
    cout << "GCD of " << num1 << " and " << num2 << " is " << gcd(num1, num2) << endl;
    return 0;
}
```

#### 迭代实现 (C++)

```
#include <iostream>
using namespace std;

int gcd_iterative(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int main() {
    int num1 = 481, num2 = 221;
    cout << "GCD of " << num1 << " and " << num2 << " is " << gcd_iterative(num1, num2) << endl;
    return 0;
}
```

**注意**：自 C++17 起，标准库 `<numeric>`中提供了 `std::gcd`函数，可以直接使用。

### ⚙️ 算法特性与应用

- **时间复杂度**：辗转相除法的时间复杂度是 **O(log(min(a, b)))**，效率非常高，即使对于非常大的整数也是如此。
- **主要应用**：
  - **化简分数**：用于将分数化为最简形式。
  - **密码学**：**RSA公钥加密算法**等密码学协议依赖于大整数的模逆元计算，而扩展欧几里得算法（辗转相除法的扩展）是求解模逆元的关键工具。
  - **求解线性同余方程**：扩展欧几里得算法可以找到整数 `x`和 `y`，使得方程 `a*x + b*y = gcd(a, b)`成立，这在数论和算法设计中非常重要。

### 🤔 与其他方法的比较

求最大公约数还有其他方法，例如**更相减损术**和**质因数分解法**。

- **更相减损术**：出自《九章算术》，以减法为主。当两个数字大小差别很大时，计算次数可能远多于辗转相除法。
- **质因数分解法**：先将两个数分解质因数，然后找出所有公共质因数并将其相乘。但当质因数很大时，分解本身可能非常困难，而辗转相避开了分解步骤，效率更高。

因此，辗转相除法因其高效性和实现的简洁性，成为了计算最大公约数最常用和最重要的算法。

希望这些信息能帮助你全面理解辗转相除法。

## extract

在C++中，`extract`和 `erase`都是用于从容器中移除元素的操作，但它们在**工作机制**和**使用场景**上有着本质的区别。下面这个表格汇总了它们的核心差异，帮助你快速理解：

| 特性            | `extract`                                                    | `erase`                                                      |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **主要功能**    | 从容器中**移除**元素并返回一个**节点句柄（node_handle）**，**不销毁元素本身** | 从容器中**移除并销毁**元素，释放其资源                       |
| **所属库/类别** | C++17引入，是**关联容器**（如 `std::set`, `std::map`）的**成员函数** | 是大多数容器的**成员函数**（如 `std::vector`, `std::list`, `std::set`, `std::map`） |
| **对容器影响**  | 容器**大小减小**，但被提取元素的资源得以保留，可用于转移     | 容器**大小减小**，被删除元素的资源被释放                     |
| **返回值**      | 返回一个包含被移除元素的**节点句柄**（`node_handle`）        | 通常返回一个指向被删除元素之后元素的**迭代器**（对于序列容器），或返回删除的元素数量（对于关联容器） |
| **适用容器**    | 主要适用于**关联容器**：`std::set`, `std::map`, `std::unordered_set`, `std::unordered_map`等 | 适用于**绝大多数STL容器**，包括序列容器（如 `std::vector`, `std::list`, `std::deque`）和关联容器 |
| **性能特点**    | **高效转移元素**，避免不必要的拷贝或移动，适合在容器间转移元素 | 直接释放资源，但可能导致后续元素的移动（对于 `std::vector`等连续存储容器） |

### 🧰 深入了解 extract

`extract`是 C++17 为**关联容器**（如 `std::set`, `std::map`, `std::unordered_set`, `std::unordered_map`）引入的成员函数。它的核心思想是“**移除但不销毁**”。

- **工作原理**：`extract`将元素从容器中移除，容器大小减小，但会返回一个包含该元素的**节点句柄（`node_handle`）**。这个节点句柄拥有该元素的所有权，你可以用它来：

  - **插入到另一个同类型容器中**：这是最高效的元素转移方式，避免了拷贝或移动的开销。
  - **修改元素的键（key）**：对于 `std::map`和 `std::multimap`，可以通过节点句柄修改键值，而这在元素还在容器中时是不允许的。
  - **如果不再需要，直接销毁**：节点句柄析构时，会正常销毁其包含的元素。

- **示例代码**：

  ```
  #include <iostream>
  #include <set>
  
  int main() {
      std::set<int> source = {1, 2, 3, 4, 5};
      std::set<int> target;
  
      // 从 source 中提取元素 3
      auto node = source.extract(3); // node 的类型是 std::set<int>::node_type
  
      // 检查提取是否成功
      if (!node.empty()) {
          // 将提取出的节点插入到 target
          target.insert(std::move(node));
      }
  
      // 此时 source 包含：{1, 2, 4, 5}
      // target 包含：{3}
      // 元素 3 已被成功转移，而非拷贝
  }
  ```

### 🗑️ 深入了解 erase

`erase`是许多STL容器的成员函数，用于从容器中**移除并销毁**一个或多个元素。它的核心思想是“**移除并清理**”。

- **工作原理**：`erase`会永久性地从容器中删除指定的元素，释放其内存资源。对于像 `std::vector`和 `std::deque`这样的连续存储容器，删除元素后，**后面的所有元素都需要向前移动**以填补空隙，这可能会带来性能开销。它有不同的重载形式：

  - **接受迭代器**：删除迭代器指向的元素。
  - **接受迭代器范围**：删除 `[first, last)`范围内的所有元素。
  - **接受键值（关联容器）**：删除所有键等于给定值的元素（对于 `std::multimap`和 `std::multiset`会删除所有匹配项）。

- **示例代码**：

  ```
  #include <iostream>
  #include <vector>
  #include <set>
  
  int main() {
      // 1. 从 vector 中擦除（序列容器）
      std::vector<int> vec = {1, 2, 3, 4, 5};
      vec.erase(vec.begin() + 2); // 删除第三个元素（值为3）
      // vec 现在为：{1, 2, 4, 5}
  
      // 2. 从 set 中擦除（关联容器）
      std::set<int> mySet = {10, 20, 30, 40, 50};
      mySet.erase(30); // 删除值为30的元素
      // mySet 现在为：{10, 20, 40, 50}
  
      return 0;
  }
  ```

### 💡 如何选择 extract 还是 erase？

选择使用 `extract`还是 `erase`取决于你的具体需求：

- **需要高效地将元素从一个容器转移到另一个同类型容器**：使用 `extract`加 `insert`。这是最节省资源的方式，因为它避免了拷贝或移动构造新元素。
- **需要修改关联容器中元素的键（key）**：使用 `extract`取出节点，修改键，再插回（可以是同一个容器，也可以是另一个容器）。
- **只是简单地想从容器中删除元素，不再需要它**：使用 `erase`。这是最直接和常见的做法。
- **要删除容器中满足条件的多个元素**：对于关联容器，可以使用 `erase`循环（注意迭代器有效性）。或者结合 `std::erase_if`(C++20)。

### ⚠️ 注意事项

- **容器支持**：`extract`目前主要适用于关联容器（`set`, `map`, `unordered_set`, `unordered_map`及其多键版本）。`erase`则被更广泛的容器支持。
- **迭代器失效**：两者操作都可能使指向被操作元素的迭代器、指针或引用失效，使用时需特别注意。
- **错误处理**：使用 `extract`时，如果提供的键不存在，它会返回一个空的节点句柄（`node.empty()`为 `true`），操作是安全的。使用 `erase`删除不存在的元素通常也是安全的（对于关联容器，`erase`会返回0表示没有元素被删除）。

希望这些解释和示例能帮助你更好地理解 `extract`和 `erase`的区别！

## 懒删除堆

懒删除堆（Lazy Deletion Heap）是一种优化策略，它通过延迟实际删除操作来提升堆结构的性能，特别是在需要频繁删除非堆顶元素或进行复杂堆管理的场景。下面我们来看看它的核心原理、实现和适用场景。

### 🧠 核心思想与工作原理

懒删除堆的基本思路很直接：当需要删除一个元素时，并不立即将其从堆的物理结构中移除，而是先进行**标记**（例如标记为已删除）。实际的数据清除工作会推迟到后续某个必要的时刻（例如当被标记元素出现在堆顶，需要执行 `pop`操作时）才进行。

这种策略在处理**非堆顶元素删除**时优势明显，因为直接删除堆中的任意元素（尤其是在大顶堆或小顶堆中）通常代价较高，可能涉及大量的元素调整以维持堆性质。懒删除避免了这种即时调整的开销。

### 🔧 常见实现方式

懒删除堆有两种主流的实现方法：

1. **标记清理法**：为堆中的每个节点增加一个标志位（如 `deleted`）。进行删除操作时，仅将该标志位置为 `true`。在执行 `pop`操作时，检查堆顶元素的标志位，如果已被标记，则直接弹出并重复此过程，直到堆顶元素是有效的。

2. **双堆法**：维护两个堆：

   - **主堆（保存堆）**：负责所有元素的插入以及当前有效元素的维护。

   - **懒删除堆（删除堆）**：专门用于存放**已被标记删除**的元素。

     当需要获取堆顶元素（如最大值或最小值）时，检查主堆和懒删除堆的堆顶元素。**如果两者相同，说明主堆堆顶元素已被标记删除，于是将两者同时弹出**，重复此过程直到主堆堆顶元素有效或堆为空。

### ⚖️ 优缺点分析

#### ✅ 优点

- **提升性能**：延迟了实际删除操作，避免了频繁删除非堆顶元素时立即调整堆结构带来的开销，尤其利于**频繁删除插入**的场景。
- **简化逻辑**：对于某些数据结构（如优先队列），懒删除简化了任意元素删除的操作逻辑。
- **利于并发**：减少删除操作时所需的锁争用，在高并发环境下能提升性能。

#### ❌ 缺点

- **空间占用可能增加**：被标记删除的元素仍占用内存空间，只有在被清理时才会释放，可能导致**内存使用率较高**。
- **查询效率可能波动**：堆中积累过多已删除标记元素时，`pop`操作可能需要连续清理多个无效堆顶元素才能获取有效值，**最坏情况下时间复杂度会增高**。
- **数据一致性风险**：若清理机制实现不当，可能导致已标记元素未被及时清除，引发数据不一致问题。

### 🚀 典型应用场景

1. **需要频繁删除非堆顶元素的优先队列**：例如，Dijkstra算法中若需要更新优先队列中某节点的距离，可用懒删除标记旧值，插入新值。
2. **滑动窗口问题**：求解滑动窗口最大值或中位数时，当窗口移动，需移除离开窗口的元素。懒删除可高效处理这种移除操作。
3. **图算法中的优化**：如某些最小生成树算法或网络流算法中，需要动态管理边集，懒删除堆可帮助高效处理边的移除。
4. **高频数据流处理**：在需要实时维护当前最大/最小值的流数据处理中，懒删除能有效处理过期数据的移除。

### 📌 总结

懒删除堆通过**延迟实际删除操作**，以**空间换取时间效率**，特别适合**删除操作频繁**且**对实时性要求较高**的场景。当然，使用时也需注意其可能带来的**内存开销增加**及在**最坏情况下性能波动**的问题。

希望这些信息能帮助你更好地理解懒删除堆。如果你有具体的应用场景或更深入的问题，我很乐意继续讨论。

## 访问不存在的键

在C++中，使用 `unordered_map`的 `[]`操作符访问一个不存在的键，会导致该键**被自动插入到 map 中**，其对应的值则会进行**值初始化**（通常是该类型的默认值）。这是一个需要特别注意的行为。

为了更清晰地对比通过 `[]`访问和使用 `find()`方法查找可能不存在的键时的区别，请看下面的表格：

| 特性         | 使用 `[]`操作符访问                                          | 使用 `find()`方法查找                                    |
| ------------ | ------------------------------------------------------------ | -------------------------------------------------------- |
| **行为**     | 若键不存在，**自动插入**该键，值进行**值初始化** (如 `int`为 `0`) | 若键不存在，返回 **`end()`** 迭代器，**不修改**容器      |
| **返回值**   | 返回对应值的**引用**                                         | 返回指向键值对的**迭代器** (找到时) 或 `end()`(未找到时) |
| **容器修改** | **会**修改容器，可能增加新键值对                             | **不会**修改容器                                         |
| **常量性**   | 不能用于 `const std::unordered_map`                          | 可用于 `const std::unordered_map`(有 `const`重载)        |
| **适用场景** | 当**确定**键存在或**允许**自动插入新键时                     | 需要**安全地检查**键是否存在，并避免副作用时             |
| **性能影响** | 可能因意外插入新键导致 map **大小增加**，潜在影响后续操作    | 查找操作本身是**常数时间复杂度 O(1)** (平均情况下)       |

### 🔍 值初始化规则

当因为访问不存在的键而插入新元素时，其值会根据类型进行初始化：

- **内置类型**：如 `int`会初始化为 `0`，`double`初始化为 `0.0`，指针初始化为 `nullptr`。
- **标准库类型**：如 `std::string`会初始化为空字符串，`std::vector`会初始化为空容器。
- **自定义类型**：必须具有**默认构造函数**。如果没有，尝试使用 `[]`访问不存在的键会导致**编译错误**。

### 🛡️ 如何安全地检查键是否存在

为了避免意外插入键，你应该使用 `find()`方法来检查键是否存在。

```
#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    std::unordered_map<std::string, int> scores = {{"Alice", 90}, {"Bob", 85}};

    std::string key = "Charlie";
    
    // 安全的查找方法
    auto it = scores.find(key);
    if (it != scores.end()) {
        std::cout << key << "'s score is: " << it->second << std::endl;
    } else {
        std::cout << key << " not found in the map." << std::endl;
    }

    // 也可以使用 count()，对于 unordered_map 返回 0 或 1
    // if (scores.count(key)) {
    //     std::cout << "Found " << key << std::endl;
    // } else {
    //     std::cout << key << " not found." << std::endl;
    // }

    return 0;
}
```

### 💡 关键要点与建议

- **牢记 `[]`操作符的副作用**：在使用 `myMap[key]`之前，心里要很清楚，如果 `key`不存在，它就会被创建出来。
- **优先使用 `find()`进行存在性检查**：当你只是想确认一个键是否存在或者安全地获取其值而不希望改变 map 时，`find()`是你的首选方法。
- **`at()`方法作为替代**：`unordered_map`还提供了 `at(key)`方法。如果键存在，它返回对应的值；如果**键不存在，它会抛出 `std::out_of_range`异常**。这适用于你不希望自动插入新键，而是将键不存在视为错误情况的场景。
- **注意自定义类型**：如果你的 `unordered_map`的值类型是自定义类且没有默认构造函数，避免使用 `[]`操作符，否则会导致编译错误。

理解 `unordered_map`访问不存在键时的行为，对于编写正确、高效的C++代码至关重要。希望这些解释对你有帮助。

## split

C++ 标准库中并未直接提供字符串分割（split）函数，但可以通过多种方法实现这一功能。以下是几种常见的实现方式及其特点：

### 1. 使用 `std::stringstream`和 `std::getline`

这种方法适用于按**单字符分隔符**分割字符串，代码简洁易懂。

```
#include <sstream>
#include <vector>
#include <string>

std::vector<std::string> split(const std::string& s, char delimiter) {
    std::vector<std::string> tokens;
    std::string token;
    std::istringstream tokenStream(s);
    while (std::getline(tokenStream, token, delimiter)) {
        tokens.push_back(token);
    }
    return tokens;
}
```

**特点**：

- 简单直接，适用于简单场景。
- 会保留空字符串（例如连续分隔符产生的空段）。

### 2. 使用 `std::string::find`和 `std::string::substr`

这种方法支持**多字符分隔符**，并且可以灵活控制是否保留空字符串。

```
#include <vector>
#include <string>

std::vector<std::string> split(const std::string& str, const std::string& delimiter) {
    std::vector<std::string> tokens;
    size_t start = 0, end = 0;
    while ((end = str.find(delimiter, start)) != std::string::npos) {
        tokens.push_back(str.substr(start, end - start));
        start = end + delimiter.length();
    }
    tokens.push_back(str.substr(start));
    return tokens;
}
```

**特点**：

- 支持多字符分隔符。
- 通常也会保留空字符串，但逻辑可调整。

### 3. 使用 `std::string::find_first_not_of`和 `std::string::find_first_of`

这种方法可以**跳过空字符串**，只返回非空部分。

```
#include <vector>
#include <string>

std::vector<std::string> split(const std::string& s, const std::string& delimiters) {
    std::vector<std::string> tokens;
    size_t start = s.find_first_not_of(delimiters, 0);
    size_t end = s.find_first_of(delimiters, start);
    while (start != std::string::npos) {
        tokens.push_back(s.substr(start, end - start));
        start = s.find_first_not_of(delimiters, end);
        end = s.find_first_of(delimiters, start);
    }
    return tokens;
}
```

**特点**：

- 自动忽略分隔符之间的空字符串。
- 适用于需要清理空段的场景。

### 4. 使用正则表达式（C++11及以上）

这种方法功能强大，支持**复杂分隔规则**（如正则表达式模式）。

```
#include <regex>
#include <vector>
#include <string>

std::vector<std::string> split(const std::string& s, const std::regex& delimiter) {
    std::sregex_token_iterator it(s.begin(), s.end(), delimiter, -1);
    std::sregex_token_iterator end;
    return std::vector<std::string>(it, end);
}
```

**示例用法**：

```
std::regex delimiter("[\\s,]+"); // 按空格或逗号分割
auto tokens = split("one, two   three", delimiter);
```

**特点**：

- 最灵活，支持复杂分隔符。
- 可能性能开销较大，适合复杂场景。

### 5. 使用 `strtok`函数（C风格字符串）

适用于C风格字符串（`char*`），但**不安全**（修改原字符串且非线程安全）。

```
#include <cstring>
#include <vector>

std::vector<std::string> split(char* str, const char* delimiter) {
    std::vector<std::string> tokens;
    char* token = strtok(str, delimiter);
    while (token != nullptr) {
        tokens.push_back(token);
        token = strtok(nullptr, delimiter);
    }
    return tokens;
}
```

**特点**：

- 仅适用于C风格字符串。
- 会修改原始字符串，且非线程安全。

### 选择建议

- **简单字符分隔**：优先使用 `std::stringstream`和 `std::getline`。
- **多字符分隔或需保留空字符串**：使用 `find`和 `substr`。
- **需跳过空字符串**：使用 `find_first_not_of`和 `find_first_of`。
- **复杂分隔规则**：使用正则表达式。
- **处理C风格字符串**（且无并发问题）：可考虑 `strtok`。

### 注意事项

- 上述方法大多基于搜索结果的代码示例，实际使用时需注意边界条件（如字符串末尾的分隔符）。
- 性能敏感场景应避免正则表达式，优先选择基于字符串操作的方案。

更多实现细节和完整代码示例可参考提供的搜索结果。

## 长除法

长除法是一种用于计算两个数相除的详细方法，特别注重计算过程和商数的得出，通过结合乘法和减法操作，将复杂的除法问题分解为更小的步骤。它适用于整数、小数、多项式等多种情况。

下面是一个简单的整数长除法示例，演示 237 除以 13 的过程：

```
18
   ------
13|237
   -13
   ----
     107
    -104
    -----
       3
```

（说明：商为 18，余数为 3，所以 237 ÷ 13 = 18 余 3。）

📊 **长除法的基本步骤**

长除法的核心步骤可以概括为以下几点：

1. **准备阶段**：将除数和被除数按同一字母的降幂排列（多项式除法中尤为重要）。如果有某个次方的项缺失，需要用“0”补齐。
2. **开始试商**：从被除数的当前最高位或最高次项开始，取足够的位数或项，使其大于或等于除数。用此部分除以除数的最高位或最高次项，得到商的首位或首项。
3. **乘与减**：将得到的商的首位或首项与整个除数相乘，将乘积写在当前被除数的下方。然后进行减法，得到余数。
4. **下拉后续位**：将原被除数的下一位数字或下一项“下拉”到余数后面，形成新的被除数。
5. **重复循环**：以新的被除数重复步骤2、3、4（即试商、乘减、下拉）的过程，直到余数为零或余式的次数低于除式的次数（多项式除法中），或没有更多数字可下拉（整数、小数除法中）。
6. **得出结果**：最终横线上方的数字或多项式就是商，最后剩下的余数就是整个除法运算的余数。

🧮 **长除法的应用场景**

长除法作为一种基础而重要的算法，其应用范围包括：

- **数学学习基础**：是学习整数除法、小数除法和多项式除法的重要工具。
- **多项式运算**：在代数中用于多项式的因式分解、求最大公因式等。
- **其他专业领域**：在工程计算、计算机科学（特别是处理大数运算或特定算法）以及信号处理（如Z变换）中也有应用。

💡 **进行长除法需要注意**

- **排列顺序**：进行多项式长除法时，务必确保被除式和除式都按同一字母的**降幂**排列，并注意缺项补零。
- **耐心与细致**：长除法步骤较多，需一步步仔细计算，注意对齐数位和符号。
- **余数的意义**：要理解余数的含义，特别是在多项式除法中，最终结果常以“被除式 = 除式 × 商式 + 余式”的形式表示。

希望这些信息能帮助你更好地理解长除法。如果你在练习具体题目时遇到困难，可以随时再来问。

Push_back & +=

了解 `push_back`和 `+=`在 C++ string 中的区别，能帮助我们更好地编写高效且清晰的代码。下面是一个对比表格，帮你快速把握它们的核心差异：

| 特性         | `push_back()`                                          | `+=`操作符                                                   |
| ------------ | ------------------------------------------------------ | ------------------------------------------------------------ |
| **主要功能** | 在字符串**末尾添加单个字符**                           | 在字符串末尾**追加内容**，可以是单个字符、字符串或字符数组   |
| **返回值**   | `void`(无返回值)                                       | 返回对当前字符串的引用 (`string&`)，**支持链式调用**         |
| **参数类型** | 仅接受**单个字符** (`char`)                            | 接受单个字符 (`char`)、字符串 (`string`)、C风格字符串 (`const char*`) 等 |
| **使用场景** | 适合在**循环中逐个添加字符**或明确只添加一个字符的场景 | 适合需要**追加多个字符、字符串**或进行链式追加的场景         |
| **底层性能** | 追加单个字符时效率高，可能触发扩容                     | 追加单个字符时通常**内部调用 `push_back`**，追加字符串时有相应优化 |

💡 **简单选择建议**：

- 如果只想在字符串末尾加**一个字符**，`push_back()`和 `+=`都可以，用哪个主要看代码习惯和清晰度。
- 如果需要添加**多个字符、一个字符串或者进行链式操作**，`+=`更方便灵活。
- 在**循环中逐个添加字符**时，两者性能相近。

🧪 **代码示例**

```
#include <iostream>
#include <string>
using namespace std;

int main() {
    string str1 = "Hello";
    string str2 = "Hello";
    const char* cstr = " World";
    char newChar = '!';

    // 使用 push_back 添加单个字符
    str1.push_back(' '); // 添加一个空格
    str1.push_back('W'); // 添加字符 'W'
    // str1.push_back(cstr); // 错误！push_back 不能直接追加C风格字符串
    cout << "使用 push_back: " << str1 << endl; // 输出 "Hello W"

    // 使用 += 追加内容
    str2 += ' '; // 追加一个字符
    str2 += cstr; // 追加一个C风格字符串
    str2 += newChar; // 追加一个字符变量
    // 链式调用
    str2 += " Have a " + string("nice day"); // 混合追加
    cout << "使用 += : " << str2 << endl; // 输出 "Hello World! Have a nice day"

    return 0;
}
```

------

✨ **记住怎么选**

简单来说：

- 只想加**一个字符**时，`push_back()`和 `+=`都可以。
- 要加**更多东西**（多个字符、字符串）或者想**一连串地加**，用 `+=`更省事。
- 在**循环里一个一个加字符**时，两者差不多。

希望这些解释能帮助你更好地理解和使用它们。

## unordered_set & set 底层实现

C++ 中的 `std::set`和 `std::unordered_set`都是用于存储唯一元素的关联容器，但它们的底层实现和特性有显著差异。了解这些区别有助于你在不同场景下做出最合适的选择。

| 特性                         | `std::set`                                         | `std::unordered_set`                           |
| ---------------------------- | -------------------------------------------------- | ---------------------------------------------- |
| **底层数据结构**             | **红黑树** (自平衡二叉搜索树)                      | **哈希表** (桶数组 + 链表/开放寻址)            |
| **元素顺序**                 | **有序存储**，默认按升序排列（可自定义）           | **无序存储**，顺序由哈希函数决定               |
| **查找/插入/删除时间复杂度** | O(log n)                                           | **平均 O(1)**，最坏 O(n)                       |
| **内存占用**                 | 较高（需存储树结构指针）                           | 通常较低，但需为哈希桶分配空间                 |
| **迭代器稳定性**             | **稳定**，插入删除通常不使迭代器失效（除当前元素） | **不稳定**，插入可能触发重哈希使所有迭代器失效 |
| **键类型要求**               | 需定义 `<`运算符或提供自定义比较器                 | 需定义 `std::hash`和 `==`运算符                |
| **主要适用场景**             | 需要元素有序、范围查询或遍历                       | 需要快速查找、插入、删除，不关心顺序           |

### 🧠 底层实现揭秘

- **`std::set`基于红黑树**：红黑树是一种自平衡的二叉搜索树。它通过严格的规则（如节点颜色、从根到叶子的路径包含相同数量的黑节点）来保持树的平衡，从而确保插入、删除和查找操作的时间复杂度稳定在 **O(log n)**。元素在树中按顺序存储，因此遍历时是有序的 。
- **`std::unordered_set`基于哈希表**：哈希表的核心是哈希函数，它将元素映射到一个固定范围内的整数（桶索引）。理想情况下，每个元素均匀分布到不同的桶中，从而实现平均 **O(1)** 的访问时间。当多个元素被哈希到同一个桶时（哈希冲突），会通过链表法等解决 。如果冲突严重（如所有元素都映射到同一个桶），性能会退化为 O(n) 。哈希表会根据负载因子（元素数/桶数）自动进行重哈希（扩容并重新分配元素）以维持性能 。

### ⚖️ 如何选择

选择哪一个容器，取决于你的具体需求：

- **需要元素有序存储、进行范围查询（如查找所有大于某值的元素）或需要按顺序遍历**，应选择 `std::set`。
- **追求极致的查找、插入和删除速度，且不关心元素的顺序**，应选择 `std::unordered_set`。这在处理大量数据去重或快速判断元素是否存在时非常高效。
- **如果键类型没有良好的哈希函数**，使用 `std::set`可能更简单（仅需定义比较）。
- **如果内存非常敏感**，需要根据哈希函数的质量权衡。哈希函数分布均匀时 `std::unordered_set`内存效率可能更高，否则 `std::set`的内存使用更可预测 。

### 🛠 使用注意事项

- **为自定义类型使用 `std::unordered_set`**：你必须同时提供**哈希函数**和**相等比较函数**（通常重载 `operator==`）。

  ```
  struct Point {
      int x, y;
      // 相等比较运算符
      bool operator==(const Point &p) const {
          return x == p.x && y == p.y;
      }
  };
  
  // 自定义哈希函数
  struct HashPoint {
      size_t operator()(const Point &p) const {
          return std::hash<int>()(p.x) ^ (std::hash<int>()(p.y) << 1);
      }
  };
  
  std::unordered_set<Point, HashPoint> pointSet;
  ```

- **迭代器失效**：在 `std::unordered_set`中插入元素可能引发重哈希，导致**所有迭代器失效**。修改容器后，切勿使用之前的迭代器 。

### 💎 简单总结

记住一个简单的原则：**要顺序，选 `set`；要速度，选 `unordered_set`**。

希望这些信息能帮助你更好地理解和使用它们。

## tuple Hash

了解 `std::set<std::tuple<...>>`和 `std::unordered_set<std::tuple<...>>`对元组的处理方式非常重要，它直接影响到容器的行为和性能。下面是一个快速的对比表格，帮助你直观把握它们的核心区别：

| 特性             | `std::set<std::tuple<...>>`                               | `std::unordered_set<std::tuple<...>>`                        |
| ---------------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| **底层结构**     | 红黑树 (平衡二叉搜索树)                                   | 哈希表                                                       |
| **元素顺序**     | **有序** (按比较规则排序)                                 | **无序** (顺序取决于哈希函数和桶)                            |
| **比较行为**     | 使用 `std::less<>`(默认) 或自定义比较器进行**字典序比较** | 需要**自定义哈希函数**和**相等比较函数** (除非重载了 `std::hash`和 `operator==`) |
| **哈希行为**     | **不涉及**哈希                                            | 依赖 `std::hash<>`(默认) 或自定义哈希函数计算桶位置          |
| **时间复杂度**   | 插入、查找、删除: **O(log n)**                            | 插入、查找、删除: **平均 O(1), 最坏 O(n)**                   |
| **迭代器稳定性** | 稳定 (除非元素被删除)                                     | 插入操作可能引起重哈希，导致所有迭代器失效                   |
| **内存占用**     | 通常较高 (需存储树结构指针)                               | 通常较低，但需为哈希桶分配空间                               |

------

🔍 **详细说明**

### 1. `std::set<std::tuple<...>>`的比较行为

`std::set`是一个基于红黑树的有序关联容器，其元素始终是排序的 。它依赖于**比较函数**（默认为 `std::less`）来确定元素的顺序和唯一性。

对于 `std::tuple`，`std::less`会进行**字典序比较（Lexicographical Comparison）**：

- 从第一个元素开始比较。
- 如果第一个元素不相等，则根据第一个元素的大小关系确定整个元组的大小关系。
- 如果第一个元素相等，则比较第二个元素，以此类推，直到所有元素都比较完毕或找到不相等的元素。
- 所有元素的类型都必须支持 `<`运算符或自定义比较函数中定义的比较操作。

例如：

```
#include <set>
#include <tuple>

std::set<std::tuple<int, int, int>> s;
s.insert({1, 2, 3});
s.insert({1, 3, 2}); // 可以插入，因为 {1,2,3} 和 {1,3,2} 不同
s.insert({1, 2, 3}); // 不会插入，因为元组 {1,2,3} 已存在

// 遍历set，元素将按字典序排列：{1,2,3}, {1,3,2}
```

**如果需要自定义排序规则**，你可以提供自己的比较函数对象。

```
// 一个自定义的比较函数对象，只比较元组的前两个元素
struct MyTupleCompare {
    bool operator()(const std::tuple<int, int, int>& a, const std::tuple<int, int, int>& b) const {
        // 只比较前两个元素
        if (std::get<0>(a) != std::get<0>(b)) {
            return std::get<0>(a) < std::get<0>(b);
        }
        return std::get<1>(a) < std::get<1>(b);
        // 忽略第三个元素
    }
};

std::set<std::tuple<int, int, int>, MyTupleCompare> customSet;
customSet.insert({1, 2, 100});
customSet.insert({1, 2, 200}); // 不会插入，因为根据MyTupleCompare，{1,2,100}和{1,2,200}被视为“相同”
```

### 2. `std::unordered_set<std::tuple<...>>`的哈希与比较行为

`std::unordered_set`是一个基于哈希表的无序关联容器 。它依赖两个关键操作：

1. **哈希函数**：将元素映射到一个 `std::size_t`类型的哈希值，用于确定元素属于哪个“桶”（bucket）。**平均情况下，插入、查找和删除的时间复杂度为 O(1)**，但在最坏情况（如所有元素都哈希到同一个桶）下会退化为 O(n) 。
2. **相等比较函数**：当两个元素的哈希值映射到同一个桶时，需要用此函数来精确判断它们是否真的相等。**默认使用 `std::equal_to`**，它通常使用 `operator==`。

**关键点在于：C++ 标准库没有为 `std::tuple`提供默认的哈希函数 `std::hash<std::tuple<...>>`** 。因此，直接使用 `std::unordered_set<std::tuple<...>>`会导致编译错误。

#### 如何为 `std::tuple`实现自定义哈希函数？

你需要定义一个哈希函数对象，通常需要组合元组中每个元素的哈希值。一种常见且有效的方法是使用 `hash_combine`技术（灵感来源于 Boost 库）。

```
#include <unordered_set>
#include <tuple>
#include <functional>

// 辅助函数：哈希组合 (模仿Boost::hash_combine)
template <typename T>
inline void hash_combine(std::size_t& seed, const T& val) {
    std::hash<T> hasher;
    seed ^= hasher(val) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

// 递归模板：用于哈希元组的每个元素
template <typename... Types>
inline std::size_t hash_tuple(const std::tuple<Types...>& t) {
    std::size_t seed = 0;
    // 使用C++17的折叠表达式简化代码 (C++14及更早标准需用其他方法展开参数包)
    std::apply([&seed](const Types&... args) {
        (hash_combine(seed, args), ...); // C++17 折叠表达式
    }, t);
    return seed;
}

// 为 std::tuple<Types...> 特例化 std::hash
namespace std {
    template<typename... Types>
    struct hash<std::tuple<Types...>> {
        std::size_t operator()(const std::tuple<Types...>& t) const {
            return hash_tuple(t);
        }
    };
}
// 注意：在std命名空间内添加特化需谨慎，确保特化是正确且唯一的。

// 现在可以直接使用了
std::unordered_set<std::tuple<int, std::string, double>> us;
us.insert({1, "hello", 3.14});
```

*(上述代码中的 `hash_combine`和递归展开方法是处理 tuple 哈希的通用模式 。)*

如果不想特化 `std::hash`，也可以在声明 `unordered_set`时显式指定自定义哈希函数类型。

```
struct MyTupleHash {
    template <typename... Types>
    std::size_t operator()(const std::tuple<Types...>& t) const {
        return hash_tuple(t); // 使用上面定义的 hash_tuple 函数
    }
};

std::unordered_set<std::tuple<int, std::string, double>, MyTupleHash> us;
```

#### 相等比较行为

`std::unordered_set`默认使用 `std::equal_to`，对于 `std::tuple`，它会进行**逐元素的 `operator==`比较**（同样是字典序方式）。只有当所有对应元素都相等时，两个元组才被认为相等 。

如果元组中的元素类型没有定义 `operator==`，你需要为 `unordered_set`**提供一个自定义的相等比较函数对象**，并在模板参数中指定。

```
struct MyTupleEqual {
    bool operator()(const std::tuple<int, MyClass>& a, const std::tuple<int, MyClass>& b) const {
        return std::get<0>(a) == std::get<0>(b) && 
               std::get<1>(a).someMember == std::get<1>(b).someMember; // 自定义MyClass的比较逻辑
    }
};

// 使用时需要同时指定哈希函数和相等比较函数
std::unordered_set<std::tuple<int, MyClass>, MyTupleHash, MyTupleEqual> customUnorderedSet;
```

------

💡 **简单总结与选择建议**

- **需要元素有序**或**进行范围查询**（如找所有大于某值的元组），选择 `std::set`。它使用比较函数，无需关心哈希。
- **追求极致的查找、插入和删除速度**（平均O(1)），且不关心顺序，选择 `std::unordered_set`。但你必须为 `std::tuple`**提供有效的自定义哈希函数**（通常需要类似 `hash_combine`的方法来组合各元素哈希值），并确保元组元素类型支持所需的操作（哈希和相等比较）。

希望这些信息能帮助你。如果你还有其他关于 C++ 的问题，我很乐意为你解答。

## std::less & std::hash

这个编译错误是因为你尝试使用 `std::unordered_set<std::tuple<int, int, int>>`的默认构造函数，但 C++ 标准库没有为 `std::tuple`提供默认的哈希函数 (`std::hash<std::tuple<...>>`)，所以编译器无法生成有效的默认构造函数。

简单来说，`std::unordered_set`的底层实现依赖于哈希表，为了计算元素的存放位置，它需要两个关键的东西：

1. **哈希函数 (Hash function)**：知道如何计算你传入的元素类型的哈希值。
2. **相等比较函数 (Equality comparison function)**：当两个元素的哈希值相同时（哈希冲突），用来判断它们是否真的相等。

C++ 标准库为内置类型（如 `int`, `std::string`）和一些标准类型提供了这些函数的默认版本。但对于 `std::tuple`这样的复合类型，**标准库没有提供默认的哈希函数**，因此你需要自己提供。

| 问题核心     | `std::unordered_set<std::tuple<int, int, int>>`需要知道如何： |
| ------------ | ------------------------------------------------------------ |
|              | 1. **计算元组的哈希值** (Hash)                               |
|              | 2. **比较两个元组是否相等** (Equal)                          |
| **解决方案** | **为你使用的 `std::tuple`类型提供自定义的哈希函数和相等比较函数。** |

### 如何解决

你需要为 `std::unordered_set`提供自定义的哈希函数对象，有时还需要提供相等的比较函数对象（除非你的元素类型已经正确重载了 `operator==`）。

#### 方法一：自定义哈希函数对象（推荐，更灵活）

定义一个哈希函数对象，并作为模板参数传递给 `unordered_set`。

```
#include <unordered_set>
#include <tuple>
#include <functional> // 用于 std::hash

// 自定义哈希函数对象
struct TupleHash {
    size_t operator()(const std::tuple<int, int, int>& t) const {
        // 一种组合哈希值的常见方式，可有效减少冲突
        size_t seed = 0;
        // 使用 std::hash 计算每个分量的哈希值，然后组合它们
        seed ^= std::hash<int>{}(std::get<0>(t)) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
        seed ^= std::hash<int>{}(std::get<1>(t)) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
        seed ^= std::hash<int>{}(std::get<2>(t)) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
        return seed;
    }
};

// 如果你的元组元素没有内置的 == 比较，或者你想自定义，也可以提供一个比较函数对象
// 但 std::tuple 本身已重载了 ==，所以这里通常不需要，除非有特殊需求
struct TupleEqual {
    bool operator()(const std::tuple<int, int, int>& lhs, const std::tuple<int, int, int>& rhs) const {
        return lhs == rhs; // 直接使用 std::tuple 的默认比较
    }
};

// 在你的类中，这样声明 unordered_set 成员变量：
class Router {
private:
    // 在模板参数中指定哈希函数类型（和比较函数类型）
    std::unordered_set<std::tuple<int, int, int>, TupleHash> mySet;
    // 如果也需要指定比较函数，则：
    // std::unordered_set<std::tuple<int, int, int>, TupleHash, TupleEqual> mySet;
public:
    Router(int memoryLimit) {
        // 现在构造函数可以正常工作了
        // ... 其他初始化代码
    }
    // ... 其他成员函数
};
```

#### 方法二：特化 `std::hash`（更透明，但污染 std 命名空间）

你可以为 `std::tuple<int, int, int>`特化 `std::hash`模板。这样在声明 `unordered_set`时就不需要显式指定哈希函数类型了。

```
#include <unordered_set>
#include <tuple>
#include <functional>

namespace std {
    // 在 std 命名空间内特化 std::hash
    template <>
    struct hash<tuple<int, int, int>> {
        size_t operator()(const tuple<int, int, int>& t) const {
            size_t seed = 0;
            seed ^= hash<int>{}(get<0>(t)) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
            seed ^= hash<int>{}(get<1>(t)) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
            seed ^= hash<int>{}(get<2>(t)) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
            return seed;
        }
    };
}

// 在你的类中，现在可以像使用内置类型一样声明 unordered_set：
class Router {
private:
    std::unordered_set<std::tuple<int, int, int>> mySet; // 无需额外指定哈希器
public:
    Router(int memoryLimit) {
        // 构造函数现在可以正常工作
    }
    // ... 
};
```

**注意**：在 `std`命名空间中添加特化需谨慎，确保特化是正确且唯一的。

### 总结

错误的核心是 `std::unordered_set`不知道如何处理 `std::tuple`的哈希和比较。

- **提供哈希函数**：这是必须的，通过自定义函数对象或特化 `std::hash`实现。
- **提供比较函数**：如果元素类型（此处是 `std::tuple`）没有定义 `operator==`，你也需要提供。幸运的是，`std::tuple`已经重载了 `operator==`，所以通常不需要额外提供。

根据你的代码结构和个人偏好选择上述任一方法即可解决这个编译错误。

## Deque 底层实现

C++ 中 `std::deque`（双端队列）的底层实现是一个精巧的设计，它**通过分段连续的内存块和中央控制结构来模拟整体连续的空间**，从而高效地支持在序列两端的操作。

为了让你快速了解 `deque`的核心实现思路及其与 `vector`、`list`的主要区别，请看下表：

| 特性             | deque                                           | vector                            | list                        |
| ---------------- | ----------------------------------------------- | --------------------------------- | --------------------------- |
| **内存布局**     | 分段连续（多个固定大小的内存块 + 中央控制数组） | 一整块连续内存                    | 分散的节点，通过指针连接    |
| **随机访问**     | O(1) (需计算块和偏移，**实际常比vector慢**)     | O(1) (纯粹的指针运算，**非常快**) | O(n) (必须遍历)             |
| **头部插入删除** | O(1) (**高效**)                                 | O(n) (需移动所有元素，**低效**)   | O(1) (**高效**)             |
| **尾部插入删除** | O(1) (**高效**)                                 | O(1) (**高效**)                   | O(1) (**高效**)             |
| **中间插入删除** | O(n) (需移动元素，**低效**)                     | O(n) (需移动元素，**低效**)       | O(1) (找到位置后，**高效**) |
| **迭代器失效**   | 操作位置和类型复杂                              | 扩容时全部失效                    | 通常只影响操作点的迭代器    |
| **内存使用**     | 内存使用较分散，但比list紧凑                    | 内存连续，碎片少                  | 每个节点需额外指针，碎片多  |

------

### 🔧 底层实现核心

`deque`的底层结构主要由两部分组成：

1. **中央控制数组 (Map)**：一个动态数组（或指针数组），用于存储指向各个内存块（缓冲区）的指针。Map 可以动态扩容，其扩容成本相对较低，主要是拷贝指针而非实际数据。
2. **内存块 (Blocks / Buffers)**：多个固定大小的连续内存数组，实际存储元素。每个内存块的大小通常由实现定义（如 512 字节或 1024 字节）。

这种“**分段连续**”的设计，使得 `deque`在头部和尾部进行插入和删除操作时，通常不需要移动大量现有元素，只需在当前块操作或分配新块即可，因此效率很高（O(1)时间复杂度）。

### 🧭 迭代器设计

`deque`的迭代器比 `vector`的普通指针迭代器复杂，它是一个包含多个指针的类：

- `cur`: 指向当前元素。
- `first`: 指向当前所在内存块的首元素。
- `last`: 指向当前所在内存块的末尾（最后一个元素的下一个位置）。
- `node`: 指向中央控制数组中管理当前内存块的指针。

这种设计使迭代器在移动到当前内存块边界时，能跳转到下一个或上一个内存块，从而维护了“整体连续”的假象。

### 📈 扩容机制

当在两端插入元素且当前内存块已满时，`deque`会分配新的内存块，并在中央控制数组的首尾添加指向新块的指针。

若中央控制数组本身空间不足，则会重新分配一个更大的 Map，并将原有指针复制到新 Map 的中间位置（这有助于两端未来的平衡扩展），最后释放旧 Map。这种机制避免了 `vector`扩容时整体搬迁数据的高开销。

### ⚖️ 优缺点

**优点**：

- **高效的双端操作**：在序列开头和末尾添加/移除元素的时间复杂度为 O(1)。
- **高效的随机访问**：支持通过索引直接访问元素，时间复杂度为 O(1)（虽比 `vector`稍慢）。
- **按需扩容**：扩容成本相对 `vector`更低，不需要搬移所有元素。

**缺点**：

- **相对昂贵的随机访问**：虽然时间复杂度是 O(1)，但需要先计算元素所在的块和块内偏移，实际速度通常比 `vector`慢。
- **迭代器失效复杂**：在进行插入、删除操作时，迭代器失效的规则比 `vector`和 `list`更复杂，需要特别注意。
- **内存相对分散**：虽然比 `list`紧凑，但不如 `vector`完全连续，缓存局部性通常不如 `vector`。

### 🎯 典型应用

`deque`非常适合以下场景：

- **实现标准库的栈 (`stack`) 和队列 (`queue`)**：这正是 `deque`在 STL 中最主要的用途，因为它完美适配了它们只在两端操作的需求，并且效率高。
- **滑动窗口算法**：例如计算滑动窗口最大值。
- **需要频繁在序列两端进行添加和删除操作**，同时又偶尔需要随机访问。

### 💡 总结

简单来说，你可以把 `deque`想象成一个**动态的多页笔记本**。每一页（内存块）是连续书写的，页与页之间不需要连续存放。目录（中央控制数组）记录了每一页的起始位置。要找到某个位置的内容，先通过目录定位到页，再在该页找到具体内容。添加新内容时，如果当前页写满了，就直接新开一页，并在目录中更新，无需重抄所有旧内容。

这种设计是 `vector`（一整本连续装订的笔记本，改写开头麻烦）和 `list`（每句话都单独写在一张卡片上，查找慢）的一种折衷。

## Deque upper_bound & lower_bound complexity

在 C++ 中，对 `deque`（双端队列）使用 `lower_bound`和 `upper_bound`算法时，其**时间复杂度为 O(log n)**，其中 n 是 `deque`中的元素数量。

下面是关于这个问题的详细说明：

### 🔍 复杂度细节

`lower_bound`和 `upper_bound`是 C++ 标准模板库 (STL) 中定义在 `<algorithm>`头文件里的算法。它们基于**二分查找** (Binary Search) 原理工作，这要求范围内的元素必须已经排序。

虽然 `deque`在内存中的物理存储是**分段连续**的（由多个固定大小的内存块和中控映射表组成），但其迭代器是**随机访问迭代器** (Random Access Iterator)。这意味着迭代器可以像指针一样在常数时间内进行加减运算（例如 `it + n`），从而满足二分查找算法对迭代器类别的要求。

因此，即使在 `deque`这种结构稍复杂的容器上，`lower_bound`和 `upper_bound`也能保持对数级别的时间复杂度。

### ⚠️ 注意事项

- **序列必须有序**：`lower_bound`和 `upper_bound`都**必须在已排序的序列上使用**，否则结果是未定义的。
- **实际性能可能略低于 `vector`**：尽管时间复杂度相同，但由于 `deque`的分段连续存储结构导致其缓存局部性 (Cache Locality) 通常不如 `vector`那样完全连续的内存布局，因此在**实际运行时间上可能会比 `vector`稍慢一些**（大约慢 10%-30%）。在对性能极其敏感的场景下，这一点可能需要考虑。
- **迭代器失效**：需要注意，对 `deque`进行头尾插入或删除操作可能导致迭代器局部失效，进行中间插入、删除或排序操作则可能使所有迭代器失效。因此，在调用 `lower_bound`或 `upper_bound`后，如果修改了 `deque`，之前获取的迭代器可能需要重新计算。

### 📊 对比其他容器

| 容器 (Container)           | `lower_bound`/ `upper_bound`时间复杂度 | 说明                                                   |
| -------------------------- | -------------------------------------- | ------------------------------------------------------ |
| **`deque`**                | **O(log n)**                           | 随机访问迭代器，支持二分查找。                         |
| **`vector`**               | **O(log n)**                           | 随机访问迭代器，缓存友好，通常实际性能最佳。           |
| **`set`** / **`multiset`** | **O(log n)**                           | 本身是有序的，其内置的 `lower_bound`成员函数效率很高。 |
| **`list`**                 | **O(n)**                               | 仅支持双向迭代器，无法随机访问，只能顺序查找。         |

### 💡 使用示例

```
#include <iostream>
#include <deque>
#include <algorithm>

int main() {
    std::deque<int> dq = {1, 2, 4, 4, 5, 7, 8}; // 必须已排序

    // 查找第一个 >= 4 的元素
    auto lb = std::lower_bound(dq.begin(), dq.end(), 4);
    if (lb != dq.end()) {
        std::cout << "lower_bound points to: " << *lb << " at index " << (lb - dq.begin()) << std::endl;
    }

    // 查找第一个 > 4 的元素
    auto ub = std::upper_bound(dq.begin(), dq.end(), 4);
    if (ub != dq.end()) {
        std::cout << "upper_bound points to: " << *ub << " at index " << (ub - dq.begin()) << std::endl;
    }

    // 计算元素4的出现次数
    int count_4 = std::upper_bound(dq.begin(), dq.end(), 4) - std::lower_bound(dq.begin(), dq.end(), 4);
    std::cout << "Number of 4: " << count_4 << std::endl;

    return 0;
}
```

希望这些信息能帮助你。如果你还有其他关于 C++ 的问题，我很乐意为你解答。

## Upper_bound & lower_bound

lower_bound 和 upper_bound 是 C++ 标准库 <algorithm> 中提供的两种基于二分查找的算法函数，用于在**已排序**的序列（如数组、vector、deque 等）中快速查找元素。要理解它们的区别，可以记住一个核心概念：**`lower_bound`找的是第一个‘不小于’目标值的位置，而 `upper_bound`找的是第一个‘大于’目标值的位置**。

下面这个表格汇总了它们的主要区别，帮助你快速理解：

| 特性               | `std::lower_bound`                     | `std::upper_bound`                   |
| ------------------ | -------------------------------------- | ------------------------------------ |
| **比较条件**       | 第一个 **≥** (大于等于) 目标值的元素   | 第一个 **>** (严格大于) 目标值的元素 |
| **目标值存在时**   | 返回**第一个**匹配元素的迭代器         | 返回**最后一个匹配元素之后**的迭代器 |
| **目标值不存在时** | 返回第一个大于目标值的元素的迭代器     | 返回第一个大于目标值的元素的迭代器   |
| **典型应用**       | 查找插入点以保持升序、判断元素是否存在 | 确定元素范围的结束位置、统计元素个数 |

### 🔍 函数说明

- **`std::lower_bound`**:
  - 在有序序列中查找**第一个不小于**（即大于等于）给定值的元素。
  - 如果找到等于目标值的元素，则返回指向**第一个**该元素的迭代器。
  - 如果所有元素都小于目标值，则返回 `end`迭代器。
- **`std::upper_bound`**:
  - 在有序序列中查找**第一个大于**给定值的元素。
  - 如果存在等于目标值的元素，则返回指向**最后一个该元素之后**的迭代器。
  - 如果所有元素都不大于目标值，则返回 `end`迭代器。

### ⏱ 时间复杂度与前提

- **时间复杂度**：两者均为 **O(log n)**，因为其底层基于二分查找实现。
- **前提条件**：所查找的序列必须**已经按升序排列**（或按照你提供的比较规则排序）。如果序列未排序，结果将是未定义的。

### 🛠 基本用法

```
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 4, 4, 5, 7, 8}; // 必须已排序

    // 使用 lower_bound 查找第一个 >= 4 的元素
    auto low = std::lower_bound(vec.begin(), vec.end(), 4);
    std::cout << "lower_bound 指向索引: " << (low - vec.begin()) << ", 值: " << *low << std::endl; // 输出 2, 4

    // 使用 upper_bound 查找第一个 > 4 的元素
    auto up = std::upper_bound(vec.begin(), vec.end(), 4);
    std::cout << "upper_bound 指向索引: " << (up - vec.begin()) << ", 值: " << *up << std::endl; // 输出 4, 5

    return 0;
}
```

### 🎯 常见应用场景

1. **统计元素出现次数**

   通过计算 `upper_bound`和 `lower_bound`的差值，可以快速得知某个值在有序序列中出现的次数。

   ```
   int target = 4;
   int count = std::upper_bound(vec.begin(), vec.end(), target) 
             - std::lower_bound(vec.begin(), vec.end(), target);
   std::cout << "数字 " << target << " 出现了 " << count << " 次。"; // 输出 2 次
   ```

2. **在有序序列中插入元素**

   希望插入新元素后序列仍保持有序，可以使用 `upper_bound`或 `lower_bound`来查找合适的插入位置。

   - 使用 `upper_bound`查找插入点，新元素会插入到所有相同值的后面。

   ```
   int new_val = 4;
   auto insert_pos = std::upper_bound(vec.begin(), vec.end(), new_val); 
   vec.insert(insert_pos, new_val); // 插入后 vec: {1, 2, 4, 4, 4, 5, 7, 8}
   ```

   - 使用 `lower_bound`查找插入点，新元素会插入到所有相同值的前面。

   ```
   auto insert_pos = std::lower_bound(vec.begin(), vec.end(), new_val); 
   vec.insert(insert_pos, new_val); // 插入后 vec: {1, 2, 4, 4, 4, 5, 7, 8} (结果相同，因原值存在)
   ```

3. **检查元素是否存在**

   可以结合 `lower_bound`来检查元素是否存在于有序序列中。

   ```
   int target = 6;
   auto it = std::lower_bound(vec.begin(), vec.end(), target);
   if (it != vec.end() && *it == target) {
       std::cout << "元素 " << target << " 找到了。";
   } else {
       std::cout << "元素 " << target << " 未找到。";
   }
   ```

4. **处理降序序列或自定义比较**

   当序列为降序排列，或者元素是自定义类型时，需要提供相应的比较函数。

   ```
   std::vector<int> descending_vec = {10, 8, 5, 5, 2, 1}; // 降序
   int target = 5;
   // 使用 greater<int>() 显式指定比较规则
   auto low_desc = std::lower_bound(descending_vec.begin(), descending_vec.end(), target, std::greater<int>());
   std::cout << "在降序序列中，第一个小于等于 " << target << " 的元素是: " << *low_desc; // 输出 5
   ```

### ⚠️ 注意事项

- **务必保证有序**：使用前必须确保序列已按你指定的比较规则排序，否则结果不可预测。
- **迭代器有效性**：返回的迭代器在使用前（如解引用）应注意检查是否等于 `end()`，避免越界。
- **自定义比较函数的一致性**：如果序列排序时使用了自定义比较函数，那么在调用 `lower_bound`和 `upper_bound`时也必须使用**相同的比较规则**。

### 📚 替代与辅助函数

- **`std::equal_range`**：这个函数会返回一个 `pair`，其 `first`和 `second`分别相当于对相同值调用 `lower_bound`和 `upper_bound`的结果。当你需要同时获取一个值的起始和结束范围时，用它更方便。

希望这些信息能帮助你。如果你还有其他关于 C++ 的问题，我很乐意为你解答。

## vector 建堆

是的，C++ 中的 `std::priority_queue`完全可以传入一个 `vector`来初始化建堆。这是一种非常高效且常见的用法，可以直接将现有容器中的数据批量转换为堆结构。

下面是一个表格，帮助你快速了解几种常见的初始化方式：

| 初始化方式                     | 代码示例                                                     |
| ------------------------------ | ------------------------------------------------------------ |
| 使用 vector 的迭代器范围       | `priority_queue<int> pq(vec.begin(), vec.end());`            |
| 指定构建最小堆                 | `priority_queue<int, vector<int>, greater<int>> pq(vec.begin(), vec.end());` |
| 使用默认构造函数，然后逐个插入 | `priority_queue<int> pq; for(int num : vec) { pq.push(num); }` |

### 💡 详细用法与原理

1. **高效建堆**：使用迭代器范围构造 `priority_queue`时，底层会调用 `make_heap`算法进行批量建堆，其时间复杂度为 **O(n)**，这比逐个调用 `push()`方法的 **O(n log n)** 要高效得多。因此，当你已经拥有全部数据时，推荐使用这种方式。

2. **默认行为**：默认情况下，`priority_queue`会构建一个**大顶堆**（最大堆），即堆顶元素是最大的。这是因为其默认的比较标准是 `std::less<T>`，它会使数值较大的元素拥有更高的优先级。

3. **构建小顶堆**：如果你想构建一个**小顶堆**（最小堆），让最小的元素位于堆顶，需要在声明时显式指定三个模板参数，特别是将比较标准改为 `std::greater<T>`。语法如下：

   ```
   #include <queue>
   #include <vector>
   #include <functional> // 需要包含此头文件以使用 std::greater
   
   std::vector<int> vec = {5, 2, 8, 1};
   // 构建小顶堆
   std::priority_queue<int, std::vector<int>, std::greater<int>> min_pq(vec.begin(), vec.end());
   ```

### 🛠️ 实际代码示例

```
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int main() {
    // 1. 使用 vector 初始化一个大顶堆
    vector<int> myVec = {3, 1, 4, 1, 5, 9};
    priority_queue<int> max_heap(myVec.begin(), myVec.end());

    cout << "大顶堆（默认）出队顺序: ";
    while (!max_heap.empty()) {
        cout << max_heap.top() << " "; // 输出：9 5 4 3 1 1
        max_heap.pop();
    }
    cout << endl;

    // 2. 使用 vector 初始化一个小顶堆
    priority_queue<int, vector<int>, greater<int>> min_heap(myVec.begin(), myVec.end());

    cout << "小顶堆出队顺序: ";
    while (!min_heap.empty()) {
        cout << min_heap.top() << " "; // 输出：1 1 3 4 5 9
        min_heap.pop();
    }
    cout << endl;

    return 0;
}
```

### ⚠️ 重要注意事项

- **底层容器**：`priority_queue`是一个容器适配器，它默认使用 `vector`作为其底层容器来存储数据。你也可以选择 `deque`，但不能使用 `list`，因为建堆算法需要随机访问迭代器。
- **自定义类型**：如果你的 `vector`中存储的是自定义的数据类型（如结构体或类），则需要在该类型中重载 `<`运算符（对于大顶堆）或 `>`运算符（对于小顶堆），或者提供一个自定义的比较函数对象，以便 `priority_queue`知道如何比较元素的优先级。

希望这些信息能帮助你更好地使用 `priority_queue`。如果你对自定义类型的比较方式有疑问，或者想了解更高级的用法，我可以提供进一步的例子。

## 移动语义

是的，在满足特定条件时，`std::priority_queue`确实会**自动使用移动语义**来提升性能，尤其是在使用 `vector`进行初始化或日常操作时。这主要取决于你传递的是左值还是右值。

为了让你快速了解不同操作下的语义选择，请看下表：

| 操作场景                               | 语义选择         | 说明                                     |
| -------------------------------------- | ---------------- | ---------------------------------------- |
| 使用命名 `vector`初始化 (如 `myVec`)   | **拷贝语义**     | 源容器 `myVec`之后仍需使用，故进行拷贝。 |
| 使用临时 `vector`初始化 (如函数返回值) | **自动移动语义** | 识别为右值，自动移动，效率高。           |
| 使用 `std::move(myVec)`初始化          | **强制移动语义** | 明确转移资源，此后 `myVec`变为空。       |
| `push()`传入临时对象                   | **自动移动语义** | 识别为右值，自动调用 `push(T&&)`。       |
| `push()`传入命名对象                   | **拷贝语义**     | 源对象之后仍需使用，故进行拷贝。         |
| `emplace()`传入参数                    | **原位构造**     | 直接在容器内构造对象，避免拷贝和移动。   |

### 💻 代码示例：初始化与操作

下面的代码展示了不同情况下移动语义的应用：

```
#include <queue>
#include <vector>
#include <utility> // for std::move

int main() {
    std::vector<int> data = {5, 1, 8, 3};

    // 场景1：拷贝语义 - 使用已存在的命名vector初始化
    std::priority_queue<int> pq1(data); // data 被拷贝，此后 data 仍可正常使用
    // 此时 data.size() 仍为 4

    // 场景2：移动语义 - 使用std::move强制移动
    std::priority_queue<int> pq2(std::move(data)); // data 的资源被转移给 pq2
    // 此后 data 为空，data.size() 变为 0

    // 场景3：自动移动语义 - 使用临时vector（右值）初始化
    std::priority_queue<int> pq3(std::vector<int>{9, 2, 7}); // 自动移动，高效

    // 日常操作中的移动语义
    std::priority_queue<int> pq;

    // 拷贝：因为 value 是左值
    int value = 10;
    pq.push(value);

    // 自动移动：因为 std::move(value) 将左值转换为右值
    pq.push(std::move(value));

    // 自动移动：因为临时对象是右值
    pq.push(20);

    // 最佳选择：原位构造，避免创建临时对象
    pq.emplace(30);

    return 0;
}
```

### ⚠️ 重要注意事项

使用移动语义时，有两点需要特别注意：

1. **对象状态**：一旦一个容器（如 `vector`）被移动，它的资源（即内存所有权）就转移到了新的 `priority_queue`中。**源容器将变为空**，不再持有原来的数据。因此，除非你确定不再需要源容器的内容，否则不要轻易使用 `std::move`。
2. **触发条件**：移动语义的自动触发依赖于**右值**。对于命名变量，如果你希望移动它，必须使用 `std::move()`将其显式转换为右值引用。

### 💡 最佳实践建议

为了编写出更高效、更现代的 C++ 代码，建议你：

- **优先使用 `emplace`**：当需要向容器中添加新元素，尤其是自定义类型的对象时，`emplace`函数可以直接在容器内部使用给定的参数构造对象，从而避免创建临时对象，比 `push`更高效。
- **善用移动初始化**：当你有一个不再需要的 `vector`，并且想用它来初始化 `priority_queue`时，使用 `std::move`进行移动初始化是性能最佳的选择。

希望这些解释和示例能帮助你更好地理解 `priority_queue`中的移动语义。如果你还有其他疑问，随时可以提出。

## 迭代器初始化

关于使用迭代器初始化 `std::priority_queue`时是否会自动移动元素，核心答案是：**不会自动移动元素，而是进行拷贝**。使用迭代器范围初始化时，数据会从源容器复制到 `priority_queue`自己的底层容器中。

### 🔍 原理与原因

`std::priority_queue`的迭代器范围构造函数是通过遍历您提供的迭代器范围，并将每个元素**拷贝**到其底层容器（默认是 `std::vector`）来实现的。这个过程可以简化为：

```
template<class InputIterator>
priority_queue(InputIterator first, InputIterator last) {
    // 遍历迭代器范围，将元素拷贝到内部的容器中
    while (first != last) {
        _con.push_back(*first); // 这里是拷贝，因为 *first 是左值
        ++first;
    }
    // ... 然后进行建堆操作 ...
}
```

之所以采用拷贝而非移动，主要出于安全性和通用性的考虑。构造函数无法确定这些迭代器背后的源容器是否之后还需要被使用。如果贸然进行移动，可能会使源容器处于一种不确定的状态（例如元素被“掏空”），导致后续程序出现未定义行为。因此，拷贝是默认的、更安全的选择。

### ⚡ 如何实现移动初始化

如果您明确知道源容器在初始化 `priority_queue`之后不再需要，并且希望提升性能（特别是当元素是昂贵的拷贝对象时），您可以主动使用 `std::move`来将源容器**整体**传递给 `priority_queue`的构造函数。这会触发移动语义。

具体做法是使用 `std::move`将整个源容器作为右值引用传递：

```
#include <queue>
#include <vector>
#include <utility> // for std::move

int main() {
    std::vector<int> myVec = {1, 2, 3, 4, 5};

    // 方法：使用 std::move 将整个vector移动给priority_queue
    std::priority_queue<int> pq(std::move(myVec));

    // 注意：此时 myVec 可能为空，不应再使用
    // std::cout << myVec.size(); // 可能是 0

    return 0;
}
```

这种方式直接使用容器对象（如 `std::vector`）进行构造，而不是迭代器范围。`priority_queue`有一个接受容器右值引用的构造函数，此时会调用底层容器的移动构造函数，从而高效地转移资源所有权。

### 💡 核心要点与建议

为了帮助您更好地理解和使用，这里总结一下关键点：

| 初始化方式                                   | 语义     | 性能              | 源容器状态                             |
| -------------------------------------------- | -------- | ----------------- | -------------------------------------- |
| 使用迭代器范围 (如 `vec.begin(), vec.end()`) | **拷贝** | 相对较慢，O(N)    | 保持不变，可继续使用                   |
| 使用 `std::move(整个容器)`                   | **移动** | 高效，O(1) (通常) | 被移空，状态有效但不可预知，不应再使用 |

**最佳实践建议：**

- **需要保留源容器**：使用迭代器范围初始化。这是最安全、最常用的方式。
- **不需要保留源容器**：使用 `std::move(容器)`进行初始化。这可以避免不必要的拷贝，提升性能，尤其是在处理大型对象或自定义类型时。
- **使用 `emplace`添加新元素**：当需要向已存在的 `priority_queue`中添加新元素时，特别是对于自定义类型，优先使用 `emplace`函数，它可以直接在容器内构造对象，避免创建临时对象，从而可能避免拷贝或移动。

希望这个解释能帮助您清晰地理解 `priority_queue`初始化时的行为！如果您还有其他关于 C++ 标准库容器的问题，我很乐意继续为您解答。
