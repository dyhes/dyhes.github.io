---
title: 【NowCoder】Linux
date: 2025-09-09 00:00:00+0000
categories: [arts]
tags: [NowCoder]
---

## tcpdump

tcpdump 是一款强大且广泛使用的命令行网络数据包捕获和分析工具，它允许用户拦截和显示发送或经过计算机网络接口的数据包，是网络故障排查、性能分析和安全监控的利器。

下面是一个快速了解 tcpdump 常用命令的表格：

| 功能类别           | 命令示例                                                     | 说明                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **基本捕获**       | `tcpdump -i eth0`                                            | 捕获指定接口 (`eth0`) 的所有数据包。                         |
| **限制与保存**     | `tcpdump -i any -c 10 -w file.pcap`                          | 捕获所有接口的 10 个包并保存到 `file.pcap`。                 |
| **主机与端口过滤** | `tcpdump host 192.168.1.1` `tcpdump port 80` `tcpdump src host 192.168.1.1 and dst port 443` | 过滤特定主机、端口，或组合条件（如源主机+目标端口）。        |
| **协议过滤**       | `tcpdump icmp` `tcpdump tcp` `tcpdump udp`                   | 仅捕获特定协议的数据包（如 ICMP, TCP, UDP）。                |
| **高级过滤**       | `tcpdump 'net 192.168.1.0/24'` `tcpdump 'tcp port 80 and (tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420)'` | 使用 CIDR 过滤网段，或基于报文内容（如 HTTP GET 请求）进行过滤。 |

### 📜 核心功能

tcpdump 的核心功能包括：

- **数据包捕获**：实时捕获流经网络接口的原始网络数据包。
- **精准过滤**：使用 **BPF (Berkeley Packet Filter)** 语法，可以根据源/目标 IP、端口、协议类型甚至特定报文内容进行过滤，极大提升分析效率。
- **详细解析**：对多种网络协议（如 Ethernet, IP, TCP, UDP, ICMP 等）进行解析，并以可读格式显示报文头信息。
- **数据保存与离线分析**：可将捕获的数据包保存为 `.pcap`文件，便于日后使用 Wireshark 等图形化工具进行深入分析。

### 🛠️ 安装与基本使用

1. **安装 tcpdump**

   在许多 Linux 发行版中，可以使用包管理器安装：

   - Debian/Ubuntu: `sudo apt install tcpdump`
   - RHEL/CentOS: `sudo yum install tcpdump`
   - macOS (使用 Homebrew): `brew install tcpdump`

2. **基本命令格式**

   tcpdump 的基本命令格式为：`sudo tcpdump [选项] [过滤表达式]`

   常用选项包括：

   - `-i <接口>`: 指定网络接口，如 `eth0`, `wlan0`, 或 `any`（所有接口）。
   - `-c <数量>`: 捕获指定数量的数据包后停止。
   - `-w <文件>`: 将捕获的数据包写入文件。
   - `-r <文件>`: 从文件中读取数据包。
   - `-n`: 不将 IP 地址解析为主机名。
   - `-nn`: 不解析主机名和端口号。
   - `-v`, `-vv`, `-vvv`: 显示更详细的信息。
   - `-X`: 以十六进制和 ASCII 码形式显示数据包内容。
   - `-A`: 以 ASCII 格式打印数据包内容。
   - `-s <长度>`: 设置要捕获的数据包长度（`-s0`表示捕获完整数据包）。

### 🔧 常用过滤表达式

tcpdump 的威力在于其灵活的过滤表达式：

- **按主机过滤**：`host 192.168.1.1`(过滤该 IP 的流量)

- **按方向过滤**：`src host 192.168.1.1`(源地址), `dst host 192.168.1.1`(目标地址)

- **按端口过滤**：`port 80`, `dst port 53`

- **按协议过滤**：`tcp`, `udp`, `icmp`

- **逻辑组合**：使用 `and`(与), `or`(或), `not`(非) 组合条件，例如：

  `src host 192.168.1.100 and (dst port 80 or dst port 443)`

### 💡 实用场景与示例

1. **捕获特定主机的 ICMP 包 (如 Ping)**

   ```
   sudo tcpdump -i any -nn icmp and host 192.168.1.1
   ```

2. **捕获 HTTP 流量并显示内容**

   ```
   sudo tcpdump -i any -A -s0 port 80
   ```

3. **捕获特定端口的流量并保存到文件**

   ```
   sudo tcpdump -i eth0 -w web_traffic.pcap port 80 or port 443
   ```

4. **从保存的文件中读取数据包**

   ```
   sudo tcpdump -r web_traffic.pcap
   ```

5. **捕获 TCP 三次握手 (SYN, SYN-ACK, ACK)**

   ```
   sudo tcpdump -nn 'tcp[tcpflags] & (tcp-syn|tcp-ack) != 0'
   ```

### ⚠️ 注意事项

- **权限要求**：tcpdump 需要 root 权限（通常使用 `sudo`）来访问网络接口。
- **性能影响**：在高流量网络上捕获所有数据包可能消耗大量 CPU 和内存。务必使用过滤条件缩小范围，或用 `-c`限制包数量。
- **隐私与安全**：tcpdump 可能捕获明文传输的敏感信息（如密码）。请仅在授权范围内使用，并妥善处理捕获的数据。

### 🔄 替代方案

虽然 tcpdump 功能强大，但在某些场景下，其他工具可能更合适：

- **Wireshark/tshark**: 提供强大的图形化界面和更深入的分析功能，tshark 是其命令行版本。
- **对加密协议的分析**：tcpdump 无法解密 HTTPS 等加密流量的内容。

### 📖 学习建议

掌握 tcpdump 的最佳方式是**结合实践**。可以先从简单的过滤条件开始，如捕获特定 IP 或端口的流量，再逐步尝试更复杂的表达式。使用 `-w`选项保存数据包，然后用 Wireshark 打开进行对比分析，这能帮助你更好地理解网络协议和 tcpdump 的输出。

tcpdump 是网络工作者工具箱中不可或缺的利器，希望这些信息能帮助你更好地理解和使用它。

## 软硬链接

理解 Linux 中的硬链接和软链接对于高效管理文件系统至关重要。下面我将通过一个对比表格和详细解释，帮你彻底搞清楚它们的区别、工作原理以及如何选择。

| 特性               | **硬链接 (Hard Link)**                                       | **软链接 (Symbolic Link / Soft Link)**                       |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **本质**           | 是文件的一个**别名**，与源文件共享相同的 **inode** 和数据块  | 是一个**独立的文件**，其内容是目标文件的**路径字符串**，拥有自己的 inode |
| **inode 号**       | 与源文件**相同**                                             | 与目标文件**不同**，是独立的                                 |
| **跨文件系统**     | **不支持**（因为 inode 是文件系统内唯一的）                  | **支持**                                                     |
| **链接目录**       | **不能**（为防止循环引用，普通用户无法创建目录的硬链接）     | **可以**                                                     |
| **原始文件删除后** | **不受影响**（数据仍可通过任何硬链接访问，直到所有硬链接被删除） | **失效**（变成“悬空链接”或“断链”）                           |
| **存储内容**       | 直接指向文件数据的**磁盘块**                                 | 存储目标文件的**路径信息**                                   |
| **文件类型**       | 显示为普通文件（如 `-rw-r--r--`）                            | 显示为链接文件（如 `lrwxrwxrwx`），并以 `->`指示目标         |
| **创建命令**       | `ln <源文件> <链接名>`                                       | `ln -s <目标文件> <链接名>`                                  |
| **空间占用**       | 不额外占用磁盘空间（仅增加一个目录项）                       | 占用少量空间（用于存储路径字符串）                           |
| **访问速度**       | 较快（直接访问数据块）                                       | 稍慢（需额外解析路径）                                       |

------

### 📝 如何创建与查看

#### 创建链接

```
# 创建硬链接
ln original.txt hardlink.txt

# 创建软链接（使用绝对路径更可靠）
ln -s /absolute/path/to/original.txt softlink.txt
```

#### 查看链接信息

使用 `ls -li`命令可以查看文件的 inode 号和链接信息。硬链接与原文件 inode 号相同，软链接则不同且会显示指向路径。

```
ls -li original.txt hardlink.txt softlink.txt
```

输出示例：

```
25869085 -rw-r--r-- 2 user group 27 7月  8 17:39 hardlink.txt
25869085 -rw-r--r-- 2 user group 27 7月  8 17:39 original.txt
25869216 lrwxrwxrwx 1 user group 6 7月  8 17:47 softlink.txt -> original.txt
```

------

### ⚙️ 底层原理与行为差异

1. **inode 是关键**：

   inode 是文件系统的核心数据结构，记录文件的元数据（权限、大小、时间戳等）及数据块位置。**硬链接**通过共享同一 inode 实现，而**软链接**拥有独立 inode，仅存储路径信息。

2. **删除行为的本质**：

   - 在 Linux 中，删除文件 (`rm`) 的实际行为是**减少其 inode 的链接计数**。只有当链接计数降为 0 时，文件的数据块才会被标记为可覆盖。
   - 因此，删除一个**硬链接**只是减少了一个计数，数据依然存在。而删除**软链接**指向的原始文件，数据可能被真正删除，导致软链接失效。

3. **链接计数**：

   使用 `ls -l`看到的第二列数字就是硬链接的计数。新建普通文件的链接计数通常为 1，每创建一个硬链接，计数就会 +1。

------

### 🎯 如何选择：应用场景

- **硬链接的典型用途**：
  - **文件备份与快照**：用于创建文件系统的快照（如 `rsync --link-dest`），避免重复存储相同数据，节省空间。
  - **重要文件防误删**：为重要文件创建硬链接，即使原始路径被删，数据依然可通过硬链接访问。
  - **同一文件系统内多路径访问**：当需要在同一文件系统内通过多个不同路径访问同一份数据时。
- **软链接的典型用途**：
  - **快捷方式与动态引用**：为安装在不同位置的软件创建统一入口（如 `/usr/bin/python`-> `/usr/bin/python3.10`）。
  - **跨文件系统或挂载点链接**：例如，将家目录下的一个文件夹链接到另一个硬盘分区上。
  - **目录链接**：为深层目录创建方便的快捷访问方式。
  - **版本管理**：灵活切换不同版本的软件或配置文件（如 `node`-> `/opt/node-v18/bin/node`）。

------

### ⚠️ 注意事项与常见问题

1. **硬链接的限制**：
   - 不能跨文件系统（如从 ext4 链接到 NTFS）。
   - 普通用户不能为目录创建硬链接（主要是为了防止文件系统遍历时出现循环引用问题）。
2. **软链接的陷阱**：
   - **悬空链接**：目标文件被移动或删除后，软链接会失效。
   - **相对路径问题**：使用相对路径创建的软链接，如果其本身被移动，可能会解析失败。**建议创建时使用绝对路径**。
   - **循环链接**：虽然罕见，但软链接可以形成循环（如 A -> B, B -> A），某些工具可能无法正确处理。
3. **删除操作**：
   - 删除软链接使用 `rm softlink_name`，这**只会删除链接本身**，不会影响目标文件。
   - 删除硬链接使用 `rm hardlink_name`，这会减少 inode 的链接计数，**只有所有硬链接被删除后数据才会被释放**。

------

### 💎 总结

简单来说，**硬链接像是给文件起了个别名**，而**软链接更像是文件的快捷方式**。

选择时记住一个原则：如果你的需求集中在**同一文件系统内**的数据保护、节省空间和效率上，优先考虑**硬链接**。如果你需要**跨文件系统**、为目录创建链接或者更灵活的路径管理，**软链接**是你的不二之选。

希望这份详细的对比能帮助你彻底理解并灵活运用它们！

## tail & last

`tail`和 `last`是 Linux 中两个名称相似但功能完全不同的命令。简单来说，`tail`用于**查看文件的尾部内容**，而 `last`用于**查看系统的用户登录历史**。

下面这个表格汇总了它们的核心区别，帮你快速把握要点：

| 特性         | **`tail`**                                                   | **`last`**                                                   |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **核心功能** | 查看**文件末尾**的内容，支持实时追踪                         | 查看**用户登录历史**（成功、失败、重启事件）                 |
| **处理对象** | **任意文本文件**（如日志、配置文件）                         | **系统二进制日志文件**（`/var/log/wtmp`, `/var/log/btmp`）   |
| **数据性质** | 静态文件内容                                                 | 动态生成的系统登录记录                                       |
| **常用参数** | `-n <N>`(显示最后N行), `-f`(实时追踪), `-c <N>`(显示最后N字节) | `-n <N>`(显示最近N条记录), `-x`(显示关机重启), `-a`(显示登录IP/主机名) |
| **典型用途** | 实时监控日志、查看最新记录、提取文件尾部片段                 | 审计安全、排查故障、查看用户活动时间                         |
| **输出示例** | `Line 998` `Line 999` `Line 1000`                            | `user1 pts/0 192.168.1.100 Mon 10:30 - 11:30 (01:00)` `reboot system boot 5.4.0-72-generic Mon Nov 8 09:10 - 11:35 (02:25)` |

------

### 📝 命令详解与使用场景

#### 1. `tail`：查看文件尾部

`tail`命令读取**任意文本文件**的末尾部分，默认显示最后10行。它在运维和开发中极高频率使用。

- **核心功能与参数**：
  - `tail -n <N> <file>`：显示文件最后 `N`行。例如 `tail -n 20 system.log`显示最后20行。
  - `tail -f <file>`：**实时追踪**文件的新增内容。这是监控日志文件（如应用日志、系统日志）的利器。监控时会持续刷新显示新内容，直到用 `Ctrl+C`手动中断。
  - `tail -c <N> <file>`：显示文件最后 `N`个字节的内容。
- **典型使用场景**：
  - **实时监控日志**：故障排查时，常用 `tail -f /var/log/syslog`或 `tail -f application.log`来实时观察最新日志输出。
  - **查看最新记录**：检查作业执行结果或文件最近更新，如 `tail -n 50 output.txt`。
  - **提取文件片段**：结合重定向，保存文件尾部内容，如 `tail -n 100 largefile.log > last100.log`。

#### 2. `last`：查看登录历史

`last`命令查询的是系统**预定义的二进制日志文件**，专门记录用户登录、注销、重启等信息。主要用于系统管理和安全审计。

- **核心功能与参数**：
  - `last`：默认显示所有用户最近的登录记录，按时间倒序排列。
  - `last -n <N>`：仅显示最近 `N`条记录。如 `last -n 5`。
  - `last <username>`：查看特定用户的登录历史。如 `last root`。
  - `last -x`：显示**系统关机（halt）和重启（reboot）** 记录。
  - `last -a`：在最后一列显示登录的**IP地址或主机名**，使得输出更易读。
  - `last -f <file>`：指定读取的日志文件（默认为 `/var/log/wtmp`），高级用法。
- **数据来源**：
  - `/var/log/wtmp`：记录**成功的**用户登录会话（登录、注销、持续时间）。
  - `/var/log/btmp`：记录**失败的**登录尝试（需要指定 `-f /var/log/btmp`或使用 `lastb`命令）。
- **典型使用场景**：
  - **安全审计**：检查是否有异常时间或来源的登录，排查潜在入侵。
  - **故障排查**：查看系统重启时间是否与故障时间吻合，或用户是否成功登录。
  - **用户行为查看**：了解特定用户（如离职员工）近期的系统活动时间。

------

### ⚠️ 重要注意事项

1. **权限要求**：
   - `tail`：通常只需有对目标文件的读取权限即可。
   - `last`：普通用户只能查看到与自己相关的登录历史（某些系统配置下）。查看所有用户的完整历史通常需要 `root`权限。
2. **实时性**：
   - `tail -f`可以实时看到文件的最新写入。
   - `last`查询的是历史记录文件，其更新通常有轻微延迟，并且需要登录会话完全结束（用户注销或连接断开）后，记录才会完整写入。
3. **文件格式**：
   - `tail`处理的是可读的纯文本文件。
   - `last`读取的 `/var/log/wtmp`和 `/var/log/btmp`是**二进制格式**，不能用 `cat`或 `vi`直接查看，必须通过 `last`或专用工具（如 `utmpdump`）解析。

------

### 💎 总结与如何选择

记住一个简单的原则：

- 当你想**查看一个文本文件（尤其是日志）的最后部分内容，或者实时监控它的增长**时，就用 **`tail`**。
- 当你想**查看谁在什么时候登录了系统、系统何时重启过，或者是否有失败的登录尝试**时，就用 **`last`**。
