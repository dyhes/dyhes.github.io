---
title: 【NowCoder】Design Pattern
date: 2025-09-09 00:00:00+0000
categories: [arts]
tags: [NowCoder]
---

## 设计模式

“设计模式一般用来解决同一问题的不同表相” 这句话精妙地概括了设计模式的核心价值和应用逻辑。下面我来为你解释这句话的含义，并探讨其背后的思想。

### 🧠 核心思想解读

这句话的关键在于理解 **“同一问题”** 和 **“不同表相”**。

- **“同一问题”**：指的是在软件设计中反复出现的那些**核心的、本质性的设计挑战**。例如：
  - **如何灵活、高效地创建对象**（创建型模式要解决的问题）。
  - **如何组合类或对象以形成更大、更合理的结构**（结构型模式要解决的问题）。
  - **如何高效地分配职责和行为，使对象能够更好地协作**（行为型模式要解决的问题）。
- **“不同表相”**：指的是这些核心问题在**各种各样的具体业务场景中**所表现出来的具体形态。例如：
  - 同样是“创建对象”的问题，在快餐店点餐系统里是创建不同套餐，在家具店是创建不同风格的一套家具。
  - 同样是“协调对象行为”的问题，在客服系统是多级投诉处理，在机场是协调航班起降。

**因此，设计模式的价值就在于：它提炼出了一套针对这些“同一问题”的、经过验证的解决方案“模板”。当我们在“不同表相”的具体场景中遇到这些问题的本质时，就可以应用相应的设计模式，而不需要每次都从头开始设计。**

### 📊 如何理解与应用

为了更直观地理解，我们来看一个表格，它展示了**同一个核心问题（创建对象）** 如何在不同场景（表相）下，通过不同的设计模式来解决：

| 核心问题 (同一问题) | 场景 (不同表相)                                              | 适用的设计模式                                      | 模式如何解决该场景下的问题                                   |
| ------------------- | ------------------------------------------------------------ | --------------------------------------------------- | ------------------------------------------------------------ |
| **如何创建对象**    | 需要确保一个类只有一个实例（如打印机服务、配置管理器）       | **单例模式 (Singleton)**                            | 私有化构造器，提供全局访问点 `getInstance()`，确保全局唯一实例。 |
|                     | 需要创建多种不同类型的对象，但不想依赖具体类（如点餐系统、日志记录器） | **工厂方法模式 (Factory Method)**                   | 定义创建对象的接口，让子类决定实例化哪个类。将对象的创建与使用分离。 |
|                     | 需要创建一整族相关或依赖的对象（如搭配不同风格的家具）       | **抽象工厂模式 (Abstract Factory)**                 | 提供一个接口来创建一系列相关或依赖的对象，而不指定它们的具体类。 |
|                     | 需要分步骤构建一个复杂对象（如组装电脑）                     | **建造者模式 (Builder)**                            | 将复杂对象的构建过程分解为多个步骤，通过相同的构建过程可以创建不同的表示。 |
|                     | 需要高效地创建成本较高的对象实例（如复制复杂对象、游戏中的大量相似对象） | **原型模式 (Prototype)** / **享元模式 (Flyweight)** | **原型模式**：通过克隆现有对象来创建新对象，避免重复初始化。**享元模式**：通过共享相似对象的部分状态，来支持大量细粒度对象。 |

从这个表格可以看出，**“创建对象”** 这个核心问题，在不同的业务**表相**下，衍生出了多种不同的解决方案（模式）。每种模式都提供了解决该特定表相下痛点的最佳实践。

### 💡 模式选择的关键：识别“同一问题”

选择合适设计模式的关键，在于**拨开“不同表相”的迷雾，洞察背后“同一问题”的本质**。

1. **不要只看表面**：不要因为业务场景是“点餐”就生搬硬套“工厂模式”，而是要看当前代码面临的核心痛点是否是“需要隔离对象的创建与使用，避免对具体类的依赖”。
2. **理解模式意图**：深入学习每个设计模式要解决的**本质问题**（Intent）。例如，适配器模式解决**接口不兼容**的问题，观察者模式解决**一个对象状态改变需要通知其他对象**的问题。
3. **权衡与选择**：通常，同一个问题可能有多个模式看似都可选。这就需要权衡它们的**后果（Consequences）**。例如，为了扩展对象功能，是选择装饰器模式（动态添加职责）还是继承（静态扩展）？装饰器模式更灵活，但会引入更多小对象。

### ⚠️ 注意事项

1. **切忌过度设计**：不是所有情况都需要使用设计模式。**对于简单、稳定、不会变化的逻辑，直接实现可能是更好的选择**。设计模式是用来应对变化的复杂性，如果本身没有变化，引入模式反而会增加不必要的复杂度。
2. **理解优先于套用**：在理解模式背后的思想和原则（如开闭原则、依赖倒置原则等）之前，盲目套用模式名称和代码结构是危险的。
3. **模式是手段，不是目标**：应用的终极目标是写出**高内聚、低耦合、可复用、可维护**的代码。设计模式只是达成这些目标的一种优秀手段。

### 💎 总结

“设计模式一般用来解决同一问题的不同表相” 这句话告诉我们：

- 设计模式是**对通用设计问题的抽象和总结**，它超越了具体的业务场景。
- 学习设计模式，重要的是理解每种模式所要解决的**核心问题（Intent）**，而不仅仅是记住它的结构或代码。
- 在实际应用中，需要**透过具体业务的“表相”，识别出深层次的“同一问题”**，然后选择合适的模式来解决它。

希望以上的解释能帮助你更好地理解这句充满智慧的话。

