---
title: 【NowCoder】Top
date: 2025-10-10 00:00:00+0000
categories: [arts]
tags: [NowCoder]
---

## 进程与线程

简单来说，现代操作系统的调度器直接管理的对象是**线程**，而**进程**则主要作为资源分配的容器。为了让你快速把握核心信息，我先用一个表格总结它们的关键区别：

| 特性           | 进程                                       | 线程                                             |
| -------------- | ------------------------------------------ | ------------------------------------------------ |
| **调度角色**   | **资源分配的基本单位**                     | **CPU调度的基本单位**                            |
| **资源拥有**   | 拥有独立的地址空间、文件、内存等资源       | 共享进程的资源，但有自己的栈、寄存器等私有数据   |
| **上下文切换** | 开销大，需要切换页表、内存空间等           | 开销小，若属同一进程，只需切换私有数据           |
| **独立性**     | 进程间相互独立，一个崩溃通常不影响其他进程 | 线程间共享内存，一个线程崩溃可能导致整个进程终止 |

### 🔍 理解调度单位演变

理解为何线程成为调度单位，关键在于看清其设计初衷。

- **进程的“沉重”**：早期操作系统确实直接调度进程。但进程像一个“独栋别墅”，拥有完全独立的内存空间、文件描述符等全部系统资源。当调度器需要从一个进程切换到另一个进程时，就像让一个人从一栋别墅搬到另一栋别墅工作和生活，需要更换所有环境（切换完整的地址空间、更新寄存器、清除缓存等），这个过程称为**进程上下文切换**，**开销非常大**。
- **线程的“轻量”**：为了更高效地实现并发，线程被引入。线程是进程内部的执行流，可以看作是“别墅里的合租室友”。它们共享别墅的主要资源（如厨房、客厅，即进程的地址空间、全局变量、打开的文件），但每个线程有自己独立的“卧室”（即栈、寄存器状态和程序计数器）。当调度器在同一进程内的线程间切换时，就像让一个人从自己的卧室走到室友的卧室工作，大部分环境（别墅本身）无需改变，只需切换个人物品（线程的私有状态），这就是**线程上下文切换**，其**开销远小于进程切换**。

因此，将线程作为调度基本单位，可以在并发执行时大幅减少切换带来的性能损耗，提高CPU的利用率和系统的整体响应能力。

### ⚙️ 调度器的实际工作细节

调度器（Scheduler）是操作系统内核的一部分，它的核心任务是决定哪个可运行的线程接下来可以使用CPU核心。

- **调度队列**：操作系统会维护不同的队列来管理线程。最主要的是**就绪队列**，里面存放着所有已准备好、只等CPU资源的线程。当某个线程因为等待I/O操作（如读取文件、网络数据）或主动睡眠而暂停执行时，它会被移出就绪队列，进入相应的**等待队列**或**阻塞队列**。
- **调度触发时机**：调度并非随机发生，通常在以下情况被触发：
  - 正在运行的线程**时间片用完**（基于时间片轮转调度）。
  - 线程**主动阻塞**，例如进行I/O操作或调用`sleep()`。
  - 有**更高优先级的线程**进入就绪状态（抢占式调度）。
  - 当前线程**运行结束**或**被终止**。
- **调度算法**：调度器依据特定算法从就绪队列中选择线程，常见的有先来先服务、时间片轮转、优先级调度、多级反馈队列等，目标是平衡公平性、吞吐量、响应时间等指标。

### 💡 重要补充与注意事项

1. **单线程进程**：对于一个只包含一个线程的进程（单线程进程），调度线程就等于调度该进程本身。此时，进程和线程在调度视角上几乎合一。
2. **用户级线程与内核级线程**：线程的实现模型会影响调度。我们通常讨论的是**内核级线程**，其创建、管理和调度都由操作系统内核直接负责，因此能被分配到多个CPU核心上真正并行执行。而**用户级线程**是在用户空间由线程库管理的，内核并不知道它们的存在。对于内核来说，只看到其所属的进程。因此，如果一个进程有多个用户级线程，这些线程通常无法被内核直接调度到多个CPU核心上并行运行。
3. **进程依然至关重要**：尽管线程是调度单位，但进程作为**资源容器和所有权单位**的角色丝毫没有减弱。它为内部的线程提供了独立的、受保护的执行环境，这是操作系统实现稳定性和安全性的基石。

希望这些解释能帮助你更清晰地理解操作系统调度的工作原理！如果你对调度算法或者其他相关概念还有兴趣，我们可以继续深入探讨。

## 线程池工作流程

线程池的线程复用机制确实很精妙，它通过一种“**任务与线程解耦**”的设计，让少量线程能够处理大量任务，从而避免了频繁创建和销毁线程的巨大开销。

为了让你快速建立整体概念，下图清晰地展示了线程池处理任务时的核心流程与线程复用的关键环节：

```
flowchart TD
    A[提交任务] --> B{线程数 < 核心线程数?}
    B -- 是 --> C[创建新核心线程执行]
    B -- 否 --> D{任务队列已满?}
    D -- 否 --> E[任务入队等待]
    E --> F{有线程空闲?}
    F -- 是 --> G[线程从队列获取任务执行]
    D -- 是 --> H{线程数 < 最大线程数?}
    H -- 是 --> I[创建新非核心线程执行]
    H -- 否 --> J[执行拒绝策略]
    C --> K[线程执行任务]
    G --> K
    I --> K
    K --> L{获取新任务<br>getTask()}
    L -- 获取到任务 --> K
    L -- 超时未获取且线程数 > 核心数 --> M[线程终止回收]
```

下面，我们来详细解析这个流程中的关键环节。

### 🔧 核心引擎：Worker与循环机制

线程池复用的核心在于一个名为 **`Worker`** 的内部类。你可以把它想象成一个勤劳的工人，它持有一个线程（负责干活）和一系列待处理的任务。

每个 `Worker`被创建并启动后，会执行一个 **`runWorker`方法**，这个方法内部是一个关键的 `while`循环。这个循环不断地做两件事：

1. **获取任务**：通过 `getTask()`方法从任务队列中取出一个任务。
2. **执行任务**：直接调用任务的 `run()`方法，而不是创建新线程来执行。

这里正是线程复用的魔法所在！它跳过了传统的 `Thread.start()`，而是把任务当作一个普通的方法调用来执行。这样，同一个线程（`Worker`内的线程）就可以在循环中接连执行多个任务的 `run`方法，将这些任务串联起来，从而实现了复用。

### 📡 任务获取与线程等待

`getTask()`方法是线程池管理线程生命周期的智能中枢。它的主要工作是**从阻塞队列（BlockingQueue）中获取任务**。队列的行为直接影响线程的行为：

- **队列中有任务**：`getTask()`立即返回一个任务给 `Worker`执行。
- **队列为空时**：根据线程的类型，行为不同：
  - **对于核心线程**：默认会一直阻塞在 `getTask()`中的 `workQueue.take()`上，直到有新任务入队被唤醒。这使得核心线程能够**长期存活**，等待新任务。
  - **对于非核心线程**：会使用 `workQueue.poll(keepAliveTime, ...)`进行**超时等待**。如果在指定的 `keepAliveTime`时间内没有获取到新任务，`getTask()`会返回 `null`。这个 `null`信号会导致 `Worker`退出那个核心的 `while`循环，随后线程被终止回收。

这种机制使得线程池可以**动态调整活跃线程数量**，在负载高时创建更多线程，负载下降时回收多余线程，只保留核心线程。

### ⚙️ 线程池的工作流程与生命周期

结合最开始的流程图，线程池处理任务的全景图是这样的：

1. **任务提交**：当一个新任务提交时，线程池按以下顺序判断：
   - 如果当前运行的线程数 **小于** **`corePoolSize`**（核心线程数），即使有空闲线程，也会**立即创建新的核心线程**执行该任务。
   - 如果线程数 **大于等于** `corePoolSize`，任务会被尝试**放入任务队列**等待。
   - 如果**队列已满**，且线程数 **小于** **`maximumPoolSize`**（最大线程数），线程池会**创建新的非核心线程**来立即处理这个新任务（而不是队列里的任务）。
   - 如果**队列已满**且线程数 **达到** `maximumPoolSize`，线程池会**触发拒绝策略**来处理这个无法接纳的任务。
2. **线程生命周期**：
   - **核心线程**：默认情况下，即使空闲也会一直存活。可以通过设置 `allowCoreThreadTimeOut(true)`让核心线程也在空闲超时后被回收。
   - **非核心线程**：如流程所述，在空闲超过 `keepAliveTime`后会被自动回收。

### 💡 总结与优势

简单来说，线程池通过 **`Worker`内部类的循环机制**，将任务执行方式从“为每个任务创建新线程”转变为“**在现有线程上循环执行任务的方法**”，并结合**阻塞队列**和**超时控制**，巧妙地实现了线程的复用、数量的动态调节以及资源的有效管理。

这种设计带来的好处是显而易见的：

- **降低资源消耗**：大幅减少线程创建和销毁的性能开销。
- **提高响应速度**：任务到达时，通常有现成的空闲线程立即执行，无需等待线程创建。
- **提高线程可管理性**：可以统一监控、管理和调优线程资源。

希望这个解释能帮助你透彻地理解线程池的复用原理！如果你对特定类型的线程池（如 `CachedThreadPool`或 `ScheduledThreadPool`）或其拒绝策略等细节感兴趣，我们可以继续深入。

## (n - 1) & hash

您提到了一个在Java `HashMap`等高性能数据结构中至关重要的位运算技巧。简单来说，当 `n`是2的幂（如16, 32, 64）时，`(n - 1) & hash`在数学结果上完全等同于 `hash % n`，但执行效率却要高得多。

下面这个表格可以帮您快速把握两者的核心区别：

| 特性         | `(n - 1) & hash`                                | `hash % n`                                      |
| ------------ | ----------------------------------------------- | ----------------------------------------------- |
| **等价前提** | `n`必须是 **2 的幂次方**                        | 对 `n`无特殊要求                                |
| **计算本质** | **位与运算**：直接截取 `hash`值的低 `log₂(n)`位 | **取模运算**：需要做除法并取余数                |
| **性能表现** | **极高**，通常是1个CPU周期，直接操作二进制位    | **较低**，需要数十个CPU周期，涉及复杂的除法操作 |
| **主要应用** | 对性能要求极高的场景，如HashMap的索引计算       | 通用的数学计算                                  |

### 🔢 数学等价性的原理

为什么两者会等价呢？这背后的关键在于当 `n`是2的幂时，`n-1`的二进制表示会形成一个特殊的“掩码”（Mask）。

- **举个例子**：假设 `n = 16`，这是一个2的幂（2^4）。

  - `n - 1 = 15`，它的二进制表示为 `0000 1111`。
  - 现在有一个哈希值 `hash = 25`，其二进制为 `0001 1001`。

- **进行位与运算**：`(n-1) & hash = 15 & 25`

  ```
  0000 1111  (15)
  & 0001 1001  (25)
  ------------
    0000 1001  (9)
  ```

  这个操作的本质是**保留 `hash`值的低4位（因为15的低4位全是1），高位全部清零**。结果是 `9`。

- **进行取模运算**：`hash % n = 25 % 16`

  - 在数学上，一个数除以16的余数，恰恰就等于这个数的二进制表示的最低4位所代表的值。因为16是10000，从第5位开始每一位都代表16的倍数，除以16的余数必然由低4位决定。计算结果也是 `9`。

因此，当 `n`是2的幂时，两种操作的结果完全相同，都是获取 `hash`值对 `n`取模后的余数。

### ⚡ 为何位运算性能更高

性能差异源于计算机底层的硬件指令：

1. **硬件支持**：位运算（AND）是CPU最基础、最原始的操作之一，通常在单个时钟周期内就能完成，直接对寄存器中的二进制位进行操作。
2. **操作复杂度**：取模运算（%）在底层通常需要通过除法来实现，而除法是CPU中最为耗时的基本运算之一，可能需要数十个时钟周期。

这种性能差距在像 `HashMap`这样需要每秒进行数百万次索引计算的场景下，累积起来的性能提升是非常可观的。这就是为什么 `HashMap`在设计上强制要求容量（即 `n`）必须为2的幂次方，从而可以安全地使用这种高效的优化手段。

### 💡 实际应用与注意事项

- **主要应用场景**：这种优化最常见于**哈希表**（如Java的 `HashMap`、`ConcurrentHashMap`）的索引定位，以及**环形缓冲区**（Ring Buffer）的指针计算。在这些地方，计算频率极高，对性能有严苛要求。
- **关键前提**：必须保证 `n`是 **2 的幂次方**。如果 `n`不是2的幂，比如 `n=10`，那么 `n-1=9`（二进制1001）。此时 `(n-1) & hash`只能保留特定的位（如上述例子中的第0位和第3位），会导致很多哈希值被映射到同一个索引，造成严重的哈希碰撞，无法均匀分布。
- **留意负数**：需要特别注意，在Java中，`%`操作符对于负数的结果可能是负数，而 `&`运算的结果则永远是非负的。在应用时，要确保哈希值是经过处理的非负数，或者理解上下文对负数的处理逻辑。

希望这个解释能帮助您彻底理解这个精巧的优化技巧！如果您对哈希表内部的其他机制（比如哈希扰动、扩容策略等）也感兴趣，我们可以继续探讨。

