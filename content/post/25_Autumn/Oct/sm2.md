---
title: 【OpenSource】SM2 Cipher
date: 2025-10-04 00:00:00+0000
categories: [snow]
---

## JNI

JNI（Java Native Interface）在某些场景下能带来更好的性能，主要源于它允许Java代码直接调用由C/C++等语言编写的本地代码，从而绕过了Java虚拟机（JVM）的一些开销，并能够进行更底层的系统操作。为了让你能快速了解JNI性能优势的核心要点，我先用一个表格来汇总：

| 性能优势来源           | 核心原理说明                                                 | 典型应用场景                                             |
| ---------------------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| **直接执行本地代码**   | 本地代码（如C/C++）编译后直接运行在硬件上，避免了JVM解释执行或JIT编译的开销。 | 复杂的数学计算、图像处理、信号处理算法。                 |
| **高效的内存操作**     | 可以直接进行精细化的内存管理和指针操作，减少Java对象创建和垃圾回收（GC）的压力。 | 处理大规模数据（如大型数组、图像像素数据）。             |
| **访问系统资源与硬件** | 可以直接调用操作系统API或硬件驱动，实现Java本身不直接支持的低级操作。 | 设备驱动调用、特定系统功能的访问。                       |
| **复用高性能原生库**   | 可以直接集成并调用那些已经为性能进行过高度优化的现有C/C++库。 | 使用OpenCV进行计算机视觉处理，使用FFmpeg进行视频编解码。 |

### 💡 理解JNI的性能权衡与优化

虽然JNI有上述优势，但重要的是要认识到，**JNI的性能优势并非无条件存在的**。它本身也会引入额外的开销，如果使用不当，可能反而比纯Java实现更慢。

- **JNI调用开销**：每次从Java代码调用一个JNI方法，都需要在JVM和本地代码之间进行上下文切换。这个操作本身就有成本。有测试数据显示，即便是调用一个空的JNI方法，其开销也可能比调用一个空的Java方法高数倍。
- **数据转换开销**：在Java和本地代码之间传递数据时，需要进行类型转换（例如，将Java的`String`转换为C风格的`char*`）。对于复杂的数据结构（如数组和对象），这个转换过程可能非常耗时。

为了最大化JNI的性能收益，通常会采用以下关键优化策略：

- **缓存ID**：在本地代码中访问Java对象的字段或调用其方法时，需要先获取对应的字段ID（FieldID）或方法ID（MethodID）。这个查找过程比较耗时。最佳实践是在本地库初始化时（例如，在`JNI_OnLoad`函数中）或第一次使用时，就将这些ID查找出来并缓存起来，后续直接使用缓存的ID，避免重复查找。
- **减少跨界调用**：应避免在Java和本地代码之间进行频繁的、细粒度的调用。理想的做法是，**一次JNI调用完成尽可能多的工作**。例如，与其在循环中多次调用一个JNI方法来处理数组的每个元素，不如只调用一次JNI方法，将整个数组传入，由本地代码完成所有处理后再一次性传回。

### 💎 总结

总而言之，JNI的性能优势主要体现在它能够绕过JVM，直接执行优化过的本地代码、进行高效的内存管理以及利用现有的高性能库和系统资源。然而，这种优势是有条件的，必须谨慎处理JNI调用本身带来的开销。

因此，决策时请遵循一个基本原则：**只有当某个任务在Java中确实成为性能瓶颈，并且你有信心通过本地代码显著提升其效率时，才考虑使用JNI**。对于应用程序中的绝大多数常规逻辑，Java本身的性能已经非常优秀，盲目使用JNI反而会增加系统的复杂性和维护成本。

希望这些解释能帮助你更全面地理解JNI的性能特性。如果你对某个具体的应用场景有更深入的探讨需求，我们可以继续交流。

## jtreg

jtreg（Java Test Regression）是OpenJDK官方指定的回归测试框架，主要用于测试JDK本身，但也适用于其他Java项目的测试。为了让你快速把握jtreg的全貌，我先用一个表格来汇总它的核心特性：

| 特性类别           | 具体内容                                                     |
| ------------------ | ------------------------------------------------------------ |
| **主要用途**       | OpenJDK的回归测试、单元测试、功能测试                        |
| **诞生时间**       | 1997年（早于JUnit）                                          |
| **核心特点**       | 支持在独立JVM中运行测试、可测试Java Applet、能将shell脚本作为测试运行、支持GUI测试 |
| **测试类型支持**   | 纯Java类（含main方法）、TestNG测试、JUnit测试（有限支持）、Shell脚本测试 |
| **独特机制**       | 代理VM（AgentVM）模式、丰富的标签注解系统、详细的HTML报告生成 |
| **与现代框架区别** | 设计更侧重于测试基础设施（如JVM管理、报告生成），而非单纯的测试逻辑表达 |

### 🔄 jtreg的工作流程与核心机制

理解jtreg的核心工作机制，能帮助你更高效地使用它。

1. **测试执行流程**

   jtreg的测试执行通常包含三个阶段：

   - **编译阶段**：jtreg会编译测试源代码以及测试用例依赖的相关文件。
   - **运行阶段**：执行测试用例。在这个过程中，jtreg会根据预设的断言来判断测试结果是否符合预期。
   - **验证阶段**：将测试结果与预期输出进行对比，确认没有引入新的错误或回归问题。

2. **代理VM（AgentVM）模式**

   这是jtreg一个关键的性能优化特性。通过使用 `-agentvm`参数，jtreg会创建一个**可重用的JVM实例池**。当测试需要单独的JVM运行时，jtreg会从池中借用实例，而不是为每个测试都重新启动一个JVM。这能显著避免因反复创建JVM导致的测试速度下降。

### 🏷️ 关键测试标签与编写示例

jtreg通过源代码文件中的特定标签（Annotations）来识别测试和定义测试行为。以下是几个最常用的标签：

| 标签       | 用途                                              | 示例                                                  |
| ---------- | ------------------------------------------------- | ----------------------------------------------------- |
| `@test`    | **标识测试类**，没有它jtreg不会将其视为测试文件。 | `/* @test */`                                         |
| `@summary` | 提供测试的**简要描述**，会显示在日志和报告中。    | `@summary Test to ensure time is valid`               |
| `@compile` | 指定需要**编译的辅助文件**。                      | `@compile SampleTimeProvider.java`                    |
| `@run`     | 指定**测试的运行方式**，可多次定义。              | `@run main SampleTest` `@run main/othervm SampleTest` |

下面的代码展示了一个简单的jtreg测试例子：

```
/* 
 * @test
 * @summary Test to ensure that computer wasn't moved to the past
 * @compile SampleTimeProvider.java  // 编译所需的辅助类
 * @run main SampleTest  // 在同一JVM中运行
 * @run main/othervm SampleTest  // 在另一个新的JVM中运行
 */
public class SampleTest {
    public static void main(String[] args) {
        long currentTime = new SampleTimeProvider().getCurrentTime();
        if ( currentTime < 0 ) {
            throw new RuntimeException("It can't be 1969!"); // 测试失败通过抛出异常表示
        }
    }
}
```

### 📋 使用jtreg的典型步骤

通常，在OpenJDK项目中使用jtreg遵循以下步骤：

1. **获取jtreg**：从官方站点下载二进制包或从源代码构建。

2. **编写测试**：在OpenJDK源码树的`test`目录下创建Java测试文件，并使用上述标签进行标注。

3. **创建运行脚本**：创建一个shell脚本，设置环境变量（如`JT_JAVA`，指定运行测试的JDK）并执行jtreg命令。

   ```
   #!/bin/sh
   export JT_JAVA=/path/to/your/jdk
   /path/to/jtreg/bin/jtreg -jdk:$JT_JAVA -agentvm -verbose:summary -w build/work -r build/report YourTest.java
   ```

4. **查看报告**：测试完成后，在浏览器中打开`build/report/html/report.html`查看详细的HTML格式测试报告。

### 🖥️ GUI模式与其他测试框架支持

除了命令行，jtreg还提供了图形界面（GUI模式），可以通过添加 `-g`参数启动。在GUI中，你可以方便地查看测试结果、运行特定测试并监控进度。

此外，jtreg也支持集成其他流行的测试框架。你可以编写基于**TestNG**的测试，并且从jtreg 4.1版本开始，还提供了对**JUnit**测试的有限支持。

### 💎 总结

jtreg是一款为测试Java平台（尤其是OpenJDK）而生的强大、专业的回归测试工具。其独特的设计使其特别适合需要严格隔离、复杂测试环境或与JDK开发紧密相关的场景。

希望这些信息能帮助你更好地理解和使用jtreg。如果你对某个特定功能或使用场景有更深入的疑问，我们可以继续探讨。

## Jtreg 配置

你提供的这段代码确实是 `jtreg`测试用例的典型写法。它将测试的元数据（如 `@test`、`@run`等）以特殊格式的注释（Comment）形式编写，而不是使用 Java 语言标准的注解（Annotation）。这背后主要有历史兼容性和技术实现两方面的考量。

为了让你快速抓住核心区别，我先用一个表格来对比这两种方式：

| 特性对比     | Java 注解 (Annotation)                                       | jtreg 注释注解 (Comment Tags)                                |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **本质**     | Java 语言的一种类型，是代码的一部分，会被编译进 class 文件。 | 特殊的注释格式，是文本的一部分，编译器会忽略其内容。         |
| **处理时机** | 主要在编译时（如 `@Override`）或运行时（通过反射，如 `@Test`）。 | 在 **编译之前**，由 `jtreg`工具在扫描源代码文件时解析。      |
| **依赖关系** | 依赖特定的 Java 版本（JDK 5+）和特定的注解处理库。           | 与 Java 版本无关，甚至可以用类似方式测试非 Java 代码（如 Shell 脚本）。 |
| **灵活性**   | 语法严格，需要预定义，修改或扩展需重新编译。                 | 非常灵活，可以快速添加新的指令而无需修改编译器或工具本身。   |

### 🛠️ 核心原因解析

1. **历史与兼容性**

   `jtreg`的历史非常悠久，可以追溯到 **1997 年**，这远早于 Java 5（2004年发布）中引入注解（Annotation）特性的时间。在注解出现之前，`jtreg`就已经采用这种在注释中编写指令的方式来确定如何运行一个测试。为了保持对海量遗留测试用例的兼容性，这种设计被延续了下来。同时，这种做法也使得测试代码本身不依赖任何特定的 JDK 版本，你甚至可以用 JDK 1.4 来编译一个测试，然后用 `jtreg`驱动它在 JDK 24 上运行。

2. **技术实现与职责分离**

   `jtreg`的核心工作发生在 **编译之前**。它需要读取你的源代码文件，根据里面的指令（也就是这些注释标签）来决定：

   - 需要编译哪些文件（`@compile`）。

   - 如何运行测试（`@run main/othervm`）。

   - 需要哪些额外的库或模块（`@library`, `@modules`）。

   - 设置安全策略（`@run .../policy=test.policy`）等。

     这些信息是写给 `jtreg`**工具** 看的，而不是写给 Java **编译器** 看的。Java 编译器会完全忽略这些注释内容。这种设计实现了很好的职责分离：Java 编译器只关心语言本身的语法和语义，而 `jtreg`工具则负责解析和管理测试相关的元数据。

### 💎 总结

简单来说，`jtreg`将注解写在注释里，是其 **历史沿革** 和 **设计哲学** 共同作用的结果。这种看似“过时”的方式，反而提供了不依赖特定 Java 版本和编译器的 **极致灵活性** 和 **向后兼容性**，非常适合像 OpenJDK 这样需要测试庞大且历史悠久的代码库的场景。

希望这个解释能帮助你理解 `jtreg`的这一独特设计。如果你对 `jtreg`的其他标签或工作机制还有疑问，我们可以继续探讨。

## Jtreg & Junit

jtreg 和 JUnit 都是 Java 领域重要的测试工具，但它们的定位、设计目标和适用场景有显著区别。为了帮助你快速把握核心区别，我先用一个表格来汇总它们的对比，然后我们再深入细节。

| 特性维度             | jtreg                                                        | JUnit                                                        |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **核心定位与起源**   | OpenJDK 官方的**回归测试框架**，始于1997年，专为测试JDK本身及复杂环境设计。 | 通用的**单元测试框架**，是Java社区进行单元测试的事实标准，旨在简化测试编写。 |
| **测试范畴**         | **广泛**。支持单元测试、功能测试、集成测试，并能处理需多JVM、安全策略、GUI交互等复杂场景。 | **聚焦**。主要专注于单个代码单元（如方法、类）的隔离测试。   |
| **运行方式与隔离性** | 强调**严格隔离**。默认或通过`/othervm`参数为测试启动独立的JVM，避免相互干扰。 | 通常在同一JVM内快速顺序执行测试，追求**执行速度**。          |
| **测试定义方式**     | 使用特殊的**注释标签**（如 `@test`, `@run`），写在Java文件的注释中。 | 使用Java**注解**（如 `@Test`, `@BeforeEach`），是代码的一部分。 |
| **主要应用场景**     | OpenJDK 及其衍生项目的测试；需要模拟复杂运行时环境的测试。   | 绝大多数Java应用程序的日常单元测试、集成测试和TDD实践。      |

### 💡 深入理解差异点

#### 🧪 设计哲学与测试能力

jtreg 诞生于1997年，远早于JUnit。其设计初衷是确保像JDK这样庞大且基础的系统在变更后的稳定性，因此它必须具备处理各种“刁钻”测试场景的能力。例如，它可以测试Java Applet（尽管现在已过时），可以将Shell脚本作为测试运行，并且能够方便地配置不同的安全策略（如你之前例子中的 `@run main/othervm/policy=test.policy`)。这些能力在一般的应用开发中很少需要，但对于平台级的测试至关重要。

相比之下，JUnit 的设计哲学更侧重于提升开发者的效率，让编写和运行测试变得简单、快速。它通过丰富的注解（如 `@Nested`组织层级结构、`@ParameterizedTest`实现参数化测试）来优雅地表达各种测试意图，非常适合在应用开发的生命周期中使用。

#### ⚙️ 执行模型与开销

正是由于对稳定性和隔离性的极致追求，jtreg 的测试执行开销通常比 JUnit 大。为每个测试启动新JVM（`/othervm`模式）或甚至使用“代理VM”池（`-agentvm`参数）的机制，虽然保证了隔离，但也增加了时间和资源成本。

JUnit 则尽可能地在同一JVM内运行所有测试，速度更快，更适合需要频繁运行测试的快速开发迭代循环。

#### 🏷️ 语法与集成生态

jtreg 将指令写在注释中，这种做法与其历史兼容性有关，也使得它可以在编译前就由jtreg工具进行解析，不依赖特定的Java版本。而JUnit使用标准的Java注解，与现代Java开发工具链（如Maven、Gradle、IDE）的集成达到了天衣无缝的程度，报告和分析功能也非常强大。

### 💎 如何选择

简单来说，你的选择完全取决于测试的目标：

- **为 OpenJDK 或其衍生项目贡献代码、测试特定的JVM行为或系统级特性**？**jtreg** 是不二之选。
- **为绝大多数业务应用程序、库或框架编写单元测试、集成测试**？**JUnit**（结合TestNG等）是标准且高效的选择。

值得注意的是，jtreg 本身也支持运行JUnit测试，这体现了它在集成现代测试框架方面的灵活性。但在OpenJDK这样的特定生态中，其原生的测试标签方式依然是绝对的主流。

希望这些解释能帮助你清晰地把jtreg和JUnit区分开来。如果你有更具体的测试场景，我们可以继续深入探讨。

## Test policy

jtreg 和 JUnit 都是 Java 领域重要的测试工具，但它们的定位、设计目标和适用场景有显著区别。为了帮助你快速把握核心区别，我先用一个表格来汇总它们的对比，然后我们再深入细节。

| 特性维度             | jtreg                                                        | JUnit                                                        |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **核心定位与起源**   | OpenJDK 官方的**回归测试框架**，始于1997年，专为测试JDK本身及复杂环境设计。 | 通用的**单元测试框架**，是Java社区进行单元测试的事实标准，旨在简化测试编写。 |
| **测试范畴**         | **广泛**。支持单元测试、功能测试、集成测试，并能处理需多JVM、安全策略、GUI交互等复杂场景。 | **聚焦**。主要专注于单个代码单元（如方法、类）的隔离测试。   |
| **运行方式与隔离性** | 强调**严格隔离**。默认或通过`/othervm`参数为测试启动独立的JVM，避免相互干扰。 | 通常在同一JVM内快速顺序执行测试，追求**执行速度**。          |
| **测试定义方式**     | 使用特殊的**注释标签**（如 `@test`, `@run`），写在Java文件的注释中。 | 使用Java**注解**（如 `@Test`, `@BeforeEach`），是代码的一部分。 |
| **主要应用场景**     | OpenJDK 及其衍生项目的测试；需要模拟复杂运行时环境的测试。   | 绝大多数Java应用程序的日常单元测试、集成测试和TDD实践。      |

### 💡 深入理解差异点

#### 🧪 设计哲学与测试能力

jtreg 诞生于1997年，远早于JUnit。其设计初衷是确保像JDK这样庞大且基础的系统在变更后的稳定性，因此它必须具备处理各种“刁钻”测试场景的能力。例如，它可以测试Java Applet（尽管现在已过时），可以将Shell脚本作为测试运行，并且能够方便地配置不同的安全策略（如你之前例子中的 `@run main/othervm/policy=test.policy`)。这些能力在一般的应用开发中很少需要，但对于平台级的测试至关重要。

相比之下，JUnit 的设计哲学更侧重于提升开发者的效率，让编写和运行测试变得简单、快速。它通过丰富的注解（如 `@Nested`组织层级结构、`@ParameterizedTest`实现参数化测试）来优雅地表达各种测试意图，非常适合在应用开发的生命周期中使用。

#### ⚙️ 执行模型与开销

正是由于对稳定性和隔离性的极致追求，jtreg 的测试执行开销通常比 JUnit 大。为每个测试启动新JVM（`/othervm`模式）或甚至使用“代理VM”池（`-agentvm`参数）的机制，虽然保证了隔离，但也增加了时间和资源成本。

JUnit 则尽可能地在同一JVM内运行所有测试，速度更快，更适合需要频繁运行测试的快速开发迭代循环。

#### 🏷️ 语法与集成生态

jtreg 将指令写在注释中，这种做法与其历史兼容性有关，也使得它可以在编译前就由jtreg工具进行解析，不依赖特定的Java版本。而JUnit使用标准的Java注解，与现代Java开发工具链（如Maven、Gradle、IDE）的集成达到了天衣无缝的程度，报告和分析功能也非常强大。

### 💎 如何选择

简单来说，你的选择完全取决于测试的目标：

- **为 OpenJDK 或其衍生项目贡献代码、测试特定的JVM行为或系统级特性**？**jtreg** 是不二之选。
- **为绝大多数业务应用程序、库或框架编写单元测试、集成测试**？**JUnit**（结合TestNG等）是标准且高效的选择。

值得注意的是，jtreg 本身也支持运行JUnit测试，这体现了它在集成现代测试框架方面的灵活性。但在OpenJDK这样的特定生态中，其原生的测试标签方式依然是绝对的主流。

希望这些解释能帮助你清晰地把jtreg和JUnit区分开来。如果你有更具体的测试场景，我们可以继续深入探讨。

## test policy & jtreg

简单来说，`test.policy`文件为 jtreg 测试提供了**精细的权限控制**，使得测试可以在一个受控的安全沙箱中运行。这在测试涉及文件操作、网络连接或系统属性访问等需要特定权限的代码时至关重要。

为了让你快速把握核心联系，我先用一个表格来汇总：

| 关联环节     | 具体说明                                                     |
| ------------ | ------------------------------------------------------------ |
| **配置方式** | 在 jtreg 测试的 `@run`指令中，通过 `policy`参数直接指定 `test.policy`文件的路径。 |
| **作用时机** | 当 jtreg 启动一个测试 JVM 时，会根据 `@run`指令加载并应用指定的策略文件。 |
| **核心目的** | 为特定的测试用例授予其运行所必需的最小权限，确保测试在安全管理器的监控下不会因权限不足而失败。 |
| **典型场景** | 测试安全敏感代码（如加密模块）、文件 I/O、网络操作，或模拟权限不足的异常场景。 |

### 🛠️ 具体配置与工作流程

要将 `test.policy`与 jtreg 关联起来，你需要在测试源码的注释中使用特定的 `@run`标签。这正是你之前看到的 `@run main/othervm/policy=test.policy NativeSM2Test`这行配置的作用。

**1. 编写策略文件**

首先，你需要创建一个 `test.policy`文件，定义测试代码所需的权限。例如，以下内容授予了对 `/tmp`目录下所有文件的读写权限：

```
grant codeBase "file:path/to/your/test/classes/-" {
    permission java.io.FilePermission "/tmp/*", "read, write";
};
```

**2. 在测试中引用策略文件**

在你的 Java 测试类中，通过 jtreg 注解（注释形式）指定策略文件路径：

```
/*
 * @test
 * @summary Test to verify file operations with specific permissions
 * @run main/othervm/policy=test.policy MyFileOperationTest
 */
public class MyFileOperationTest {
    public static void main(String[] args) {
        // 你的测试代码，例如在 /tmp 目录下创建文件
    }
}
```

**3. jtreg 的执行流程**

当 jtreg 执行这个测试时，它会：

- 启动一个带有安全管理器的新 JVM（由 `@run main/othervm`触发）。
- 通过 `-Djava.security.policy=test.policy`参数将策略文件传递给该 JVM。
- JVM 会根据 `test.policy`中的规则运行测试。如果测试操作超出了授权范围，安全管理器会抛出 `AccessControlException`，导致测试失败。

### 🎯 主要应用场景

这种机制在 OpenJDK 测试中非常实用，主要体现在：

- **测试安全敏感代码**：例如，测试加解密模块（如你提到的 `NativeSM2Test`）或访问控制逻辑时，需要精确的权限配置。
- **确保测试隔离性**：通过为每个测试定义独立的权限策略，可以避免测试间相互干扰，提高测试的可靠性和可重复性。
- **模拟权限异常**：可以专门编写策略文件来模拟权限不足的场景，验证代码在安全限制下的健壮性。

### 💡 实用建议

- **最小权限原则**：策略文件应遵循最小权限原则，只授予测试运行所必需的最少权限，避免使用 `permission java.security.AllPermission;`这样的万能权限。
- **调试权限问题**：如果测试因权限问题失败，可以添加 JVM 参数 `-Djava.security.debug=access`来启用详细的安全调试日志，这有助于追踪是哪个权限检查失败了。

希望这些解释能帮助你清晰地理解 `test.policy`是如何与 jtreg 测试框架协同工作的。如果你对某个具体的使用场景有更深入的疑问，我们可以继续探讨。

## JMH

JMH（Java Microbenchmark Harness）是一款由 OpenJDK/Oracle 官方发布的，专门用于 **Java 代码微基准测试**（method 层面）的高精度工具套件，其测量精度可达**微秒级**。当你需要定量分析热点方法的性能、对比不同实现的优劣，或者验证优化措施的实际效果时，JMH 能提供科学、可靠的测试数据。

为了让你能快速把握 JMH 的全貌，我先用一个表格来汇总其核心特性：

| 特性维度         | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| **核心定位**     | Java 方法级别的微基准测试框架，精度可达微秒甚至纳秒级。      |
| **核心优势**     | 能有效规避 JVM 的 JIT 编译优化、预热等因素对测试结果的干扰，提供可靠的数据。 |
| **测试模式**     | 支持吞吐量 (`Throughput`)、平均时间 (`AverageTime`)、采样时间 (`SampleTime`)、单次执行时间 (`SingleShotTime`) 等。 |
| **关键特性**     | 提供预热（`Warmup`）、多进程隔离测试（`Fork`）、状态管理（`State`）、参数化测试（`Param`）等机制。 |
| **典型应用场景** | 优化热点方法、对比不同算法或实现的性能、评估第三方库的性能、分析性能损耗等。 |

### 🔧 工作原理与核心概念

JMH 的设计充分考虑到了 JVM 的运行机制（如 JIT 编译、垃圾回收），通过一系列机制确保测试结果的准确性：

- **预热 (Warmup)**：JVM 的 JIT 编译器会对热点代码进行动态编译优化，这会导致代码在运行初期和稳定后的性能表现差异很大。JMH 通过多次预热迭代，让 JVM 充分“热身的机制，使测试结果更接近稳定状态下的性能。
- **分叉 (Fork)**：JMH 可以**启动独立的 JVM 进程**来执行每个测试基准测试，以此隔离不同测试之间的相互影响（如类加载、JIT 编译等），并提供纯净的测试环境。
- **状态管理 (State)**：通过 `@State`注解，可以定义和管理测试方法间共享的“状态”数据，并精确控制其共享范围（线程独享 `Scope.Thread`、所有线程共享 `Scope.Benchmark`或线程组共享 `Scope.Group`），这对于多线程测试尤为重要。
- **黑洞 (Blackhole)**：JVM 的即时编译器 (JIT) 非常智能，它会尝试优化掉那些“没有实际作用”的代码（例如，计算结果未被使用）。为了防止这些“无用”的计算被优化掉而影响测试结果的准确性，JMH 提供了 `Blackhole`类。你可以将计算结果“消耗”到黑洞中，确保所有计算真实发生。

### 📝 如何使用 JMH

#### 1. 添加依赖

首先需要在项目中引入 JMH 的依赖（以 Maven 为例）：

```
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-core</artifactId>
    <version>1.36</version> <!-- 请检查最新版本 -->
</dependency>
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-generator-annprocess</artifactId>
    <version>1.36</version>
    <scope>provided</scope>
</dependency>
```

#### 2. 编写测试

创建一个基准测试类，使用 JMH 提供的注解来配置和标记测试方法：

```
import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.infra.Blackhole;
import java.util.concurrent.TimeUnit;

@BenchmarkMode(Mode.AverageTime) // 测试模式：平均执行时间
@OutputTimeUnit(TimeUnit.NANOSECONDS) // 输出时间单位：纳秒
@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS) // 预热：3轮，每轮1秒
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS) // 正式测量：5轮，每轮1秒
@Fork(1) // 启动1个进程进行测试
@State(Scope.Benchmark) // 状态共享范围：所有线程共享
public class MyBenchmark {

    @Param({"10", "100", "1000"}) // 参数化测试：测试不同规模下的性能
    private int size;

    private int[] data;

    @Setup // 初始化方法，会在每个批次测试前执行
    public void setup() {
        data = new int[size];
        for (int i = 0; i < size; i++) {
            data[i] = i;
        }
    }

    @Benchmark // 标记这是一个基准测试方法
    public int testSum() {
        int sum = 0;
        for (int value : data) {
            sum += value;
        }
        return sum;
    }

    @Benchmark
    public void testSumWithBlackhole(Blackhole bh) { // 使用Blackhole避免JIT优化
        int sum = 0;
        for (int value : data) {
            sum += value;
        }
        bh.consume(sum); // 将结果“喂”给黑洞，防止被优化掉
    }
}
```

#### 3. 运行测试

通常通过编写一个 `main`方法来配置和启动 JMH 测试：

```
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

public class Main {
    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(MyBenchmark.class.getSimpleName()) // 指定要运行的测试类
                .forks(1) // 进程数
                .warmupIterations(3) // 预热迭代次数
                .measurementIterations(5) // 正式测量迭代次数
                .output("jmh-result.log") // (可选)将结果输出到文件
                .build();

        new Runner(opt).run();
    }
}
```

也可以打包成 jar 包后在命令行运行。

#### 4. 解读结果

运行后，JMH 会输出详细的测试报告，格式通常类似：

```
Benchmark                 (size)  Mode  Cnt     Score     Error  Units
MyBenchmark.testSum         10    avgt    5    22.123 ±   1.456  ns/op
MyBenchmark.testSum        100    avgt    5   205.678 ±  12.345  ns/op
MyBenchmark.testSum       1000    avgt    5  1987.654 ± 987.654  ns/op
```

其中：

- **Benchmark**: 测试方法名及参数。
- **Mode**: 测试模式，如 `avgt`(平均时间)。
- **Cnt**: 迭代次数。
- **Score**: **主要性能指标**，本例中是平均每次操作耗时。
- **Error**: 误差范围（如标准差）。
- **Units**: 单位。

### ⚠️ 注意事项与最佳实践

1. **避免死代码消除 (Dead Code Elimination)**：确保测试方法的结果被实际使用（如返回、使用 `Blackhole`消耗），防止 JIT 编译器优化掉你的测试代码。
2. **关注误差范围**：结果的 `Error`项很重要。如果误差很大，说明测试可能不稳定，需要增加迭代次数或检查测试逻辑。
3. **保持测试环境稳定**：在**安静、空闲**的机器上进行测试，关闭其他不必要的应用程序，以减少干扰。
4. **遵循最小权限原则**：策略文件应遵循最小权限原则，只授予测试运行所必需的最少权限，避免使用 `permission java.security.AllPermission;`这样的万能权限。
5. **理解模式差异**：选择适合你目标的测试模式：
   - `Throughput`: 关心**单位时间内的操作次数**（例如，每秒多少次查询）。
   - `AverageTime`: 关心**单次操作的平均耗时**（例如，每次查询耗时多少毫秒）。
   - `SingleShotTime`: 关心**冷启动时间**（例如，方法第一次执行的耗时）。

### 💡 更多技巧

- **参数化测试**：使用 `@Param`注解可以非常方便地测试同一方法在不同输入规模或不同参数下的性能表现，从而更全面地了解其性能特性。
- **多线程测试**：使用 `@Threads`注解可以测试方法在并发环境下的性能表现，例如 `@Threads(4)`表示用 4 个线程并发执行该测试方法。
- **结果可视化**：JMH 支持将结果输出为 JSON 等格式，然后可以导入到其他工具（如 JMH Visualizer 等）进行可视化分析，更直观地对比性能差异。

JMH 是 Java 开发者进行性能调优和代码评估的利器。希望这些信息能帮助你更好地了解和使用 JMH。如果你有任何进一步的问题，欢迎随时提出。

## SM2

SM2算法是中国国家密码管理局于2010年12月发布的一种基于椭圆曲线密码学的公钥密码算法标准。作为中国商用密码体系的核心，它已被纳入ISO/IEC国际标准，主要用于数字签名、密钥交换和公钥加密等功能场景。

为了让你快速把握SM2算法的全貌，我先用一个表格来汇总其核心特性和与国际算法RSA的对比：

| 特性维度         | SM2 算法                                                     | 对比 RSA 算法 (相同安全强度下)         |
| ---------------- | ------------------------------------------------------------ | -------------------------------------- |
| **密码学基础**   | 椭圆曲线密码学 (ECC)，安全性基于椭圆曲线离散对数问题 (ECDLP) 的难解性 | 基于大整数分解问题的难解性             |
| **标准归属**     | 中国国家密码管理局 (国密算法)，GB/T 32918 标准               | 国际通用算法                           |
| **典型密钥长度** | 256 位                                                       | 2048-3072 位 (提供约128比特安全强度时) |
| **相对优势**     | **安全性高**：目前破解难度极大 **计算速度快，效率高** **密钥短，存储和传输占资源少** | 密钥长，计算效率相对较低               |
| **核心功能**     | 数字签名、密钥交换、公钥加密                                 | 加密、签名                             |

### 🔐 SM2算法的核心原理

SM2算法的安全性建立在**椭圆曲线离散对数问题（ECDLP）** 的数学难题之上。简单来说，在一条精心选择的椭圆曲线上，已知一个起点G（称为基点）和一个倍数点Q = d*G，想要反推出这个倍数d是极其困难的。这个d就是私钥，而Q则是公钥。

SM2标准使用一条特定的256位素数域椭圆曲线，其参数由国家密码管理局统一规定，确保了算法的安全性和互操作性。

### ⚙️ SM2算法的主要功能与流程

SM2算法主要包含三大功能：数字签名、密钥交换和公钥加密。

#### ✍️ 数字签名

用于验证消息的完整性和发送者的身份真实性。

- **签名生成**：
  1. 对待签名消息M计算SM3哈希值，得到e。
  2. 生成一个密码学安全的随机数k。
  3. 计算椭圆曲线点 (x1, y1) = k * G，G为基点。
  4. 计算 r = (e + x1) mod n，n为基点的阶。如果r为0或r+k=n，则更换k重试。
  5. 计算 s = ((1 + d)^(-1) * (k - r * d)) mod n，d为签名者私钥。如果s为0，则重试。
  6. 得到的签名对就是(r, s)。
- **签名验证**：
  1. 对接收到的消息M计算SM3哈希值e。
  2. 计算 t = (r + s) mod n。
  3. 计算椭圆曲线点 (x2, y2) = s * G + t * P，P为签名者公钥。
  4. 计算 R = (e + x2) mod n。
  5. 验证R是否等于收到的r。如果相等，则签名有效。

#### 🤝 密钥交换

允许通信双方在不安全的信道上，通过交换信息协商出一个只有双方知道的共享会话密钥（通常用于后续的对称加密）。

- 双方（例如Alice和Bob）各自生成一个临时的密钥对（私钥和对应的公钥）。
- 双方交换各自的公钥。
- 每一方结合自己的临时私钥和对方的临时公钥，通过特定的椭圆曲线点乘运算，可以独立地计算出相同的共享秘密点S。
- 将这个共享秘密点S的坐标等数据，通过SM3哈希算法和密钥派生函数（KDF）处理，最终生成相同的对称会话密钥。

#### 🔒 公钥加密

用于使用接收者的公钥对消息进行加密，只有拥有对应私钥的接收者才能解密。

- **加密过程**：
  1. 发送方获取接收方的公钥 P1。
  2. 生成一个随机数 k 作为发送方私钥。
  3. 计算发送方公钥 P2 = k * G，并将其作为密文的第一部分 C1。
  4. 计算点 S = k * P1，从而得到一个共享秘密点。
  5. 使用密钥派生函数（KDF）从点 S 的坐标中派生出一个对称密钥 t。
  6. 使用密钥 t 和对称加密算法（如SM4）加密明文 M，得到密文 C2。
  7. 计算 C3 = SM3( S 的 x 坐标 || M || S 的 y 坐标)，作为消息的验证码。
  8. 最终的密文由C1, C2, C3三部分组成。根据标准的不同，其排列顺序可能是C1||C2||C3或C1||C3||C2。
- **解密过程**：
  1. 接收方从密文中解析出 C1，并验证其是否为有效的椭圆曲线点。
  2. 使用自己的私钥 d 计算点S = d * C1。如果双方操作正确，发送方计算的k * P1 等于接收方计算的d * (k * G) = k * (d * G) = k * P1，从而得到相同的共享秘密点 S。
  3. 使用 KDF 从 S 的坐标中派生出相同的对称密钥 t。
  4. 用t解密密文 C2，得到明文 M。
  5. 重新计算 SM3(S 的 x 坐标 || M || S 的 y 坐标)，并与收到的 C3 比较。如果一致，则证明密文在传输过程中未被篡改。

### 💻 应用场景与开发实践

SM2算法凭借其安全性和效率，在诸多领域得到广泛应用：

- **数字证书与SSL/TLS连接**：用于实现国密SSL证书（例如网银、电子政务网站的安全连接），对通信双方进行身份认证和密钥交换。
- **区块链技术**：用于区块链中的身份认证和交易签名，例如Hyperledger Fabric的国密支持。
- **物联网（IoT）**：为资源受限的物联网设备提供轻量级且高强度的安全通信保障。
- **电子签章与电子合同**：确保电子文档的签署者身份真实、内容完整且不可否认。

在实际开发中，通常需要借助密码库来实现SM2算法，例如Java中的BouncyCastle库或Python中的`pycryptodome`库。使用时需注意选择经过国家密码管理局认证的合规实现，并妥善管理密钥（如使用硬件密码模块存储私钥），同时确保使用密码学安全的随机数生成器。

### 💎 总结

SM2算法作为一种自主可控、安全高效的国产密码算法标准，在保障我国各领域信息安全方面扮演着至关重要的角色。希望这份详细的介绍能帮助你全面了解SM2算法。如果你对某个具体技术细节或应用场景有进一步的疑问，我们可以继续深入探讨。

## 密文分解

了解SM2密文的结构和如何正确分解出`C1`、`C2`、`C3`组件，以及理解字符串连接的方式，对于正确实现加解密流程至关重要。下面这张流程图清晰地展示了根据新旧两种标准分解密文的核心步骤，你可以先通过它建立一个整体概念。

```
flowchart TD
    A[输入SM2密文] --> B{判断标准版本};
    B -- 旧标准 C1C2C3 --> C1C2C3;
    B -- 新标准 C1C3C2 --> C1C3C2;
    
    subgraph C1C2C3 [旧标准分解流程]
        D1[提取前65字节为C1] --> E1[剩余部分中<br>取最后32字节为C3];
        E1 --> F1[中间部分为C2];
    end
    
    subgraph C1C3C2 [新标准分解流程]
        D2[提取前65字节为C1] --> E2[紧接着的32字节为C3];
        E2 --> F2[剩余部分为C2];
    end
    
    F1 --> G[输出C1, C2, C3];
    F2 --> G;
```

### 🔍 分解密文的三要素

SM2加密后生成的密文是由`C1`、`C2`、`C3`三个部分拼接而成的比特串或字节串。分解的关键在于准确识别每个部分的**起始位置和长度**。

- **`C1`的识别**：`C1`是一个椭圆曲线点，通常由**65字节**组成。其第一个字节是**固定的标识符`0x04`**，表示这是一个未压缩的点格式。紧随其后的64字节分别是该点的x坐标（32字节）和y坐标（32字节）。因此，在任何版本的密文格式中，**密文最开始的65字节就是`C1`**。
- **`C3`的识别**：`C3`是使用SM3哈希算法计算出的摘要值，其长度是**固定的32字节**。
- **`C2`的识别**：`C2`是实际加密后的密文，其长度与原始明文**完全相同**。因此，`C2`的长度等于明文长度。

### 📏 新旧标准与分解策略

明确了`C1`、`C2`、`C3`的特征后，分解策略就取决于它们三者的拼接顺序。主要存在两种标准：

1. **旧标准（C1C2C3）**：
   - **顺序**：`C1`+ `C2`+ `C3`。
   - **分解方法**：
     - `C1`：取密文最开始的65字节。
     - `C3`：取密文最后32字节。
     - `C2`：**中间剩余的部分**，其长度等于总密文长度减去65字节再减去32字节。
2. **新标准（C1C3C2）**：
   - **顺序**：`C1`+ `C3`+ `C2`。
   - **分解方法**：
     - `C1`：取密文最开始的65字节。
     - `C3`：紧接着`C1`之后的32字节。
     - `C2`：**最后剩余的部分**，其长度等于总密文长度减去65字节再减去32字节。

在实际编程中，你需要根据你所遵循的规范或与通信方的约定，来确定使用哪种顺序进行组装和解析。

### 🔗 字符串连接标识

在SM2算法的描述中，符号`||`表示**简单的字节拼接（或比特串拼接）**。它**不代表任何分隔符**。例如，在计算`C3 = Hash(x2 || M || y2)`时，意味着需要将x2的坐标值、明文M、y2的坐标值这三个字节数组按顺序首尾相连，组成一个更长的字节数组，然后对这个拼接后的整体计算哈希值。

同样，在密钥派生函数（KDF）中，如`t = KDF(x2 || y2, klen)`，也是将x2和y2的坐标拼接起来作为输入。

### 💻 实践注意事项

- **字节序问题**：在具体编程实现时，需要注意处理大端序（Big-Endian）和小端序（Little-Endian）的问题，确保数字（如坐标值）到字节串的转换与标准一致。
- **兼容性**：由于存在两种密文格式，在实际系统中（尤其是在与外部系统交互时）必须明确约定和识别所使用的格式，否则会导致解密失败。有些库或平台可能会提供配置选项来指定格式。

希望这些详细的解释能帮助你彻底理解SM2密文的分解方法和连接标识的含义。如果你在具体的代码实现中遇到问题，我们可以继续探讨。

## 生成元

SM2算法中的基点G（也称生成元）是整个密码体系的基石，它的选择直接关系到系统的安全性和可靠性。为了让你快速把握全貌，我先用一个表格来汇总基点G的核心特性和选定要求。

| 特性维度         | SM2 标准基点的选定要求                                       |
| ---------------- | ------------------------------------------------------------ |
| **数学基础**     | 椭圆曲线密码学（ECC），基于椭圆曲线离散对数问题（ECDLP）的难解性 |
| **标准曲线**     | 国家密码管理局指定了一条固定的256位素数域椭圆曲线，其参数公开 |
| **基点G的性质**  | 是椭圆曲线上的一个点，且其阶n是一个大素数                    |
| **阶n的要求**    | 必须满足n > 4√p，以确保抵抗Pohlig-Hellman等攻击              |
| **核心安全原则** | 基点G的阶n必须足够大（通常n > 2^256），使得求解离散对数问题在计算上不可行 |
| **实现方式**     | **绝大多数情况下，直接采用国家密码管理局标准推荐的预设值和基点坐标** |

### 🔧 基点G的选定流程

虽然在实际应用中我们直接使用标准参数，但了解其背后的选定流程有助于深化理解。一个符合密码学安全要求的基点G，通常需要通过以下步骤产生：

1. **确定椭圆曲线参数**：首先需要确定椭圆曲线方程 `y^2 = x^3 + ax + b`中的系数 `a`, `b`，以及定义曲线所在的有限域的大小（一个素数 `p`）。这些参数共同定义了一条唯一的椭圆曲线。
2. **计算椭圆曲线的阶**：接下来需要计算这条椭圆曲线上所有点的个数，记为 `#E`。这个数字必须满足一定的条件才能保证安全，例如它应该等于一个大素数 `n`（此时 `n`就是基点G的阶），或者等于 `n * h`，其中 `n`是一个大素数，`h`是一个很小的整数（称为余因子，通常为1、2、3、4）。
3. **寻找生成元**：在曲线上随机选择一个点 `G`，验证其阶是否为 `n`。也就是说，需要验证 `[n]G = O`（`O`是无穷远点），且对于 `n`的任何真因子 `d`，`[d]G ≠ O`。这个过程可能需要多次尝试。

### 💡 为什么直接使用标准参数？

你可能会问，既然有选定的流程，为什么在实践中我们几乎总是直接使用标准参数呢？这主要基于以下三个关键原因：

- **保障安全**：自行生成一套安全且可靠的椭圆曲线参数是一项极具挑战性的工作。如果参数选择不当（例如曲线存在特殊结构），可能会存在未知的后门或漏洞，容易被攻击。使用经过广泛公开密码学家分析和验证的国家标准，可以最大限度地避免这类风险。
- **确保互操作性**：密码学算法需要在不同的系统、设备和软件之间进行通信。如果每个人都使用自己生成的曲线和基点，那么不同的系统之间将无法互相识别和验证。采用统一的标准参数确保了所有遵循SM2标准的实现可以无缝协作。
- **提升效率**：国家密码管理局已经提供了经过优化的标准参数，直接使用这些参数可以省去复杂的参数生成和验证过程，提高开发效率，并避免因自行实现不当而引入错误。

### 🔒 应用实例与注意事项

在实际开发中，例如使用BouncyCastle等密码库实现SM2算法时，你通常会看到代码直接引用了预定义的标准参数。

**至关重要的提醒**：除非你是密码学专家，并且有极其特殊的需求，否则**绝对不要**尝试自行生成SM2的曲线参数和基点G。务必使用国家密码管理局官方公布的标准参数。这是确保你的密码系统安全性的首要前提。

希望这些详细的解释能帮助你全面理解SM2算法中基点G的选定原则。如果你对SM2的其他方面还有疑问，我们可以继续探讨。