---
title:  【LeetCode-C】STL 容器对比
date: 2025-02-28 00:00:00+0000
categories: 
- pearl
- temple
tags:
- LeetCode-C
---

## 顺序容器
以下是C++ STL中主要顺序容器（Sequence Containers）的底层实现对比分析，结合其数据结构、内存管理策略和操作特性进行总结：
---

### **Vector（动态数组）**
- **底层结构**  
  基于**连续内存的动态数组**，维护三个核心指针：`_start`（首元素）、`_finish`（最后一个元素的下一位）、`_end_of_storage`（容量末尾）。
- **内存管理**  
  - 容量不足时按**指数增长（通常双倍扩容）**，需重新分配内存并拷贝旧数据。
  - 支持随机访问（`operator[]`时间复杂度为O(1)），但中间插入/删除需移动后续元素（时间复杂度O(n)）。
- **优势与局限**  
  - **优势**：尾部操作高效（O(1)）、缓存友好（内存连续）。
  - **局限**：扩容导致迭代器失效，频繁中间操作效率低。

---

### **Deque（双端队列）**
[C++ STL deque 容器底层实现原理（深度剖析）](https://mp.weixin.qq.com/s?__biz=MzIwNTIwMzAzNg==&mid=2654171934&idx=1&sn=3081d579df5f65110fb11f5e262504e5&chksm=8dfd8f9fb86f62b9bedc4eb538412b766a3eb7fd5a2c7e4a64cc092e3bea333db8915ac5b1c6#rd)
- **底层结构**  
  采用**分段连续存储**，由中控器（**存储着各个连续空间的首地址**的 `map` 数组）管理多个固定大小的缓冲区，维护`start`和`finish`迭代器指向首尾缓冲区。
  - 迭代器包含4个指针：`cur`（当前元素）、`first`/`last`（当前缓冲区首尾）、`node`（指向中控器中的缓冲区指针）。
- **内存管理**  
  - 中控器满时重新分配更大空间并拷贝指针，缓冲区按需动态分配。
  - 支持两端高效插入/删除（O(1)），随机访问需计算跨缓冲区偏移（O(1)，但比`vector`慢）。
- **优势与局限**  
  - **优势**：两端操作高效、无需整体扩容。
  - **局限**：迭代器实现复杂，中间插入/删除效率仍低于`list`。

---

### **List（双向链表）**
- **底层结构**  
  **非连续的双向链表**，每个节点包含数据、前驱和后继指针。
- **内存管理**  
  - 每个节点独立分配堆内存，插入/删除仅修改指针（O(1)）。
  - 不支持随机访问（访问需遍历，O(n)）。
- **优势与局限**  
  - **优势**：任意位置插入/删除高效，迭代器稳定（除非节点被删除）。
  - **局限**：内存占用高（每个节点需额外指针），缓存不友好。

---

### **Forward_list（单向链表）**
- **底层结构**  
  **单向链表**，每个节点仅含数据和后继指针，节省内存。
- **内存管理**  
  - 仅支持单向遍历，插入/删除需前驱节点指针（需遍历查找，O(n)）。
  - 无`size()`成员函数，需手动遍历计算长度。
- **优势与局限**  
  - **优势**：内存占用更小。
  - **局限**：功能受限，仅适合单向操作场景。

---

### **Array（固定数组）**
- **底层结构**  
  **固定大小的连续内存数组**，编译时确定容量，无动态扩容能力。
- **内存管理**  
  - 内存分配在栈或静态区，性能优于动态容器。
  - 支持随机访问，但无法插入/删除元素。
- **应用场景**  
  适用于已知固定大小且需STL接口的数组需求。

---

### **对比总结**
| **特性**          | Vector               | Deque                | List                 | Forward_list        | Array       |
|-------------------|----------------------|----------------------|----------------------|---------------------|-------------|
| **内存连续性**    | 连续                 | 分段连续             | 非连续               | 非连续              | 连续        |
| **随机访问**      | O(1)                | O(1)（跨段计算）     | O(n)                | O(n)               | O(1)       |
| **尾部插入/删除** | O(1)（可能触发扩容）| O(1)                | O(1)                | O(1)               | 不支持      |
| **头部插入/删除** | O(n)                | O(1)                | O(1)                | O(n)               | 不支持      |
| **中间插入/删除** | O(n)                | O(n)                | O(1)                | O(n)               | 不支持      |
| **迭代器稳定性**  | 扩容后失效          | 插入/删除可能失效    | 稳定（除非节点删除） | 稳定（除非节点删除）| 稳定        |
| **典型场景**      | 随机访问、尾部操作  | 两端高频操作         | 频繁任意位置修改     | 单向遍历、内存敏感  | 固定大小数组 |

---

### **选择建议**
- **优先`vector`**：需随机访问或尾部操作，且数据规模变化不大。
- **选`deque`**：需高效两端操作（如队列或栈），避免`vector`扩容开销。
- **用`list`/`forward_list`**：高频中间插入/删除，或需稳定迭代器。
- **固定大小用`array`**：已知容量且需STL接口。

通过理解底层实现差异，可针对性能、内存和操作需求选择最合适的容器。

以下是 C++ STL 中主要关联容器（Associative Containers）的底层实现对比分析，结合其数据结构、内存管理策略和操作特性进行总结：

---
## 关联容器
### **有序关联容器**
#### **1. `std::map` / `std::set`**
- **底层结构**：基于**红黑树（Red-Black Tree）**，一种自平衡二叉搜索树。
  - **红黑树特性**：通过节点颜色（红/黑）和旋转操作维护平衡，确保树的高度为 O(log n)。
  - **节点结构**：每个节点存储键（`map`）或值（`set`）、颜色标记、父指针及左右子指针。
- **内存管理**：
  - 动态分配节点内存，插入/删除时需调整树结构以维持平衡。
  - 默认按键的升序排列（可通过 `Compare` 模板参数自定义排序规则）。
- **核心特性**：
  - **键唯一性**：`map` 和 `set` 的键不可重复，插入重复键时会被忽略。
  - **时间复杂度**：查找、插入、删除均为 **O(log n)**。
  - **迭代器稳定性**：除被删除节点外，其他迭代器不受影响。

#### **2. `std::multimap` / `std::multiset`**
- **底层结构**：同样基于红黑树，但允许键重复。
  - 节点结构与 `map`/`set` 相同，但树中允许存在多个相同键值的节点。
- **核心特性**：
  - **键可重复**：通过调整红黑树的比较逻辑支持重复键。
  - **查找操作**：`equal_range` 方法可返回匹配键的所有元素范围。

---

### **无序关联容器（Unordered Associative Containers）**
#### **1. `std::unordered_map` / `std::unordered_set`**
- **底层结构**：基于**哈希表（Hash Table）**，采用链地址法（Separate Chaining）解决冲突。
  - **哈希桶**：动态数组存储桶（Bucket），每个桶指向链表或红黑树（C++11后优化为单链表）。
  - **哈希函数**：通过 `Hash` 模板参数计算键的哈希值。
- **内存管理**：
  - 自动扩容：当负载因子（元素数/桶数）超过阈值（默认 1.0）时，重新哈希并扩容桶数组（通常翻倍）。
  - 元素无序存储，但同一桶内元素按插入顺序排列。
- **核心特性**：
  - **时间复杂度**：平均 **O(1)**（最坏情况 O(n)，如哈希冲突严重）。
  - **键唯一性**：同 `map`/`set`，键不可重复。

#### **2. `std::unordered_multimap` / `std::unordered_multiset`**
- **底层结构**：哈希表，允许键重复。
  - 同一哈希桶内存储相同键值的多个元素，通过链表连接。
- **核心特性**：
  - **键可重复**：插入时允许重复键，查找返回所有匹配元素。
  - **性能优化**：C++11后单链表设计减少内存开销。

---

### **关键对比总结**
| **特性**              | 有序容器（`map`/`set`）        | 无序容器（`unordered_map`/`unordered_set`） |
|-----------------------|-------------------------------|--------------------------------------------|
| **底层数据结构**      | 红黑树                        | 哈希表                                     |
| **元素顺序**          | 按键排序                      | 无序（依赖哈希函数）                       |
| **时间复杂度**        | O(log n)（稳定）              | 平均 O(1)，最坏 O(n)                       |
| **内存开销**          | 较高（树节点需额外指针）      | 较低（链表或单链表结构）                   |
| **键重复支持**        | 仅 `multimap`/`multiset`      | 仅 `unordered_multimap`/`unordered_multiset` |
| **迭代器失效场景**    | 仅删除操作影响当前节点迭代器  | 扩容时所有迭代器可能失效                   |
| **适用场景**          | 需有序遍历或范围查询          | 高频查找、插入，无需顺序                   |

---

### **性能优化建议**
1. **选择有序容器**：  
   - 当需要按顺序遍历或范围查询（如 `lower_bound`/`upper_bound`）时优先使用 `map`/`set`。
2. **选择无序容器**：  
   - 高频查找场景（如缓存、字典）使用 `unordered_map`，避免红黑树的 O(log n) 开销。
3. **调整哈希参数**：  
   - 自定义哈希函数以减少冲突，或预分配桶数（`reserve`）避免频繁扩容。
4. **权衡内存与性能**：  
   - 红黑树内存开销大但稳定，哈希表内存紧凑但扩容代价高。

---

### **底层实现细节补充**
- **红黑树的自平衡**：  
  插入/删除时通过旋转和变色维持以下规则：  
  - 根节点为黑色；  
  - 红色节点的子节点必须为黑色；  
  - 任一节点到叶子的路径包含相同数量的黑色节点。
- **哈希表的负载因子**：  
  默认负载因子为 1.0，可通过 `max_load_factor` 调整以平衡空间与时间效率。

---

通过理解底层实现差异，开发者可根据实际需求（如数据规模、操作频率、内存限制）选择最优容器，从而提升程序性能。

## 容器适配器

C++ STL 中的容器适配器（Container Adaptors）基于不同的底层容器实现，通过封装和限制接口提供特定数据结构的行为。以下是各容器适配器的底层实现及关键特性总结：

### `std::stack`（栈）
- **底层容器**：默认基于 **`std::deque`**，但可替换为 **`std::vector`** 或 **`std::list`**。
- **选择原因**：
  - `deque` 支持两端快速插入/删除（`push_back`/`pop_back`），与栈的后进先出（LIFO）特性匹配；
  - `vector` 的连续内存特性适合高频尾部操作，但扩容时需拷贝数据，效率可能低于 `deque`；
  - `list` 支持任意位置操作，但内存碎片化可能影响缓存效率。
- **接口限制**：仅暴露 `push()`、`pop()`、`top()` 等栈专用接口，隐藏底层容器的其他功能。

---

### **`std::queue`（队列）**
- **底层容器**：默认基于 **`std::deque`**，也可使用 **`std::list`**。
- **选择原因**：
  - `deque` 支持头尾高效操作（`push_back`/`pop_front`），符合队列的先进先出（FIFO）特性；
  - `list` 的链表结构允许任意位置插入/删除，但随机访问效率低，适合队列的简单操作。
- **接口限制**：仅提供 `push()`、`pop()`、`front()`、`back()` 等队列相关接口。

---

### **`std::priority_queue`（优先队列）**
```cpp
template<
    class T,    class Container = std::vector<T>,    class Compare = std::less<typename Container::value_type>
> class priority_queue;
```
- **底层容器**：默认基于 **`std::vector`**，也可使用 **`std::deque`**。
- **选择原因**：
  - `vector` 的连续内存特性便于构建堆结构（通过 `std::make_heap` 等算法），支持快速插入和提取最大/最小元素；
  - `deque` 也可用于堆操作，但内存分段可能导致性能略低于 `vector`；
  - **不支持 `std::list`**：因链表无法直接支持堆算法所需的随机访问。
- **排序机制**：默认通过 `std::less` 实现大顶堆（**优先级最高元素在堆顶**），可自定义比较函数。

---

### **对比总结**
| **容器适配器**     | 默认底层容器 | 允许的其他底层容器 | 适用场景                     | 底层容器要求                |
|---------------------|--------------|---------------------|------------------------------|----------------------------|
| `std::stack`        | `deque`      | `vector`、`list`    | 后进先出操作（如撤销机制）   | 支持 `push_back`、`pop_back` |
| `std::queue`        | `deque`      | `list`              | 先进先出操作（如任务队列）   | 支持 `push_back`、`pop_front` |
| `std::priority_queue` | `vector`    | `deque`             | 按优先级处理元素（如调度器） | 支持随机访问，适配堆操作     |

---

### **底层容器的选择逻辑**
1. **性能与功能平衡**：  
   - `deque` 综合性能优秀，适合需要高效两端操作的 `stack` 和 `queue`；
   - `vector` 内存连续，适合 `priority_queue` 的堆操作。
2. **接口兼容性**：  
   - 替换底层容器时需确保其支持适配器所需的操作（如 `push_back` 对 `stack` 的必要性）。
3. **线程安全**：  
   - 容器适配器本身不保证线程安全，需手动同步底层容器的访问。

---

通过合理选择底层容器，开发者可优化适配器的性能与内存使用，同时保持代码的简洁性和可维护性。