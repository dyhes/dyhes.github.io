---
title: 【LeetCode-C】lambda
date: 2025-03-13 00:00:00+0000
categories: 
- pearl
- temple
tags:
- LeetCode-C
---
在C++中，匿名函数（Lambda表达式）是一种无需显式定义函数名的内联函数，常用于简化代码和增强灵活性。以下是其核心特性和应用解析：

---

### **基本语法结构**
C++中的Lambda表达式语法为：
```cpp
[capture](parameters) mutable -> return_type { body }
```
• **捕获列表 `[capture]`**：定义如何访问外部变量，支持多种捕获方式：
  • `[]`：不捕获任何外部变量。
  • `[=]`：以值捕获所有外部变量。
  • `[&]`：以引用捕获所有外部变量。
  • `[x, &y]`：混合捕获（值捕获`x`，引用捕获`y`）。
  • `[this]`：捕获当前类的`this`指针。
• **参数列表 `(parameters)`**：与普通函数类似，支持自动类型推导（C++14+）。
• **`mutable`**：允许修改值捕获的变量（默认情况下Lambda是`const`）。
• **返回类型 `-> return_type`**：可省略，编译器自动推导。

**示例**：
```cpp
auto sum = [](int a, int b) { return a + b; }; // 值相加
auto print = [&](int x) { std::cout << x; };   // 引用捕获外部变量
```

---

### **核心应用场景**
• **算法参数传递**：  
  常用于标准库算法（如`std::sort`、`std::for_each`）的回调函数。例如对字符串降序排序：
  ```cpp
  std::sort(text.begin(), text.end(), [](char x, char y) { return x > y; }); // 
  ```
• **替代函数对象（Functors）**：  
  避免定义单独的类或结构体，简化代码。
• **闭包与延迟执行**：  
  捕获外部变量后，Lambda可存储状态并在后续执行，例如事件处理。
• **异步编程**：  
  结合`std::async`或线程库实现异步任务。

---

### **与函数对象的对比**
| **特性**               | **Lambda表达式**                           | **函数对象**                          |
|------------------------|--------------------------------------------|---------------------------------------|
| **语法复杂度**         | 简洁，无需显式定义类或`operator()`         | 需定义类并重载`operator()`    |
| **状态管理**           | 通过捕获列表隐式管理                       | 显式通过类成员变量管理        |
| **可复用性**           | 适合一次性使用                             | 适合多次调用或复杂逻辑        |
| **性能**               | 通常与函数对象相当，但可能生成更多模板代码 | 可能更高效（编译器优化空间大）    |

---

### **注意事项**
• **悬挂引用问题**：  
  引用捕获外部变量时需确保变量生命周期（如避免捕获局部变量后返回Lambda）。
• **性能权衡**：  
  • 值捕获可能导致拷贝开销（尤其对大型对象）。
  • 引用捕获需注意线程安全问题。
• **捕获列表的显式声明**：  
  推荐显式指定捕获变量（如`[x, &y]`），而非默认的`[=]`或`[&]`，以提高可读性和安全性。

---

### **扩展功能**
• **泛型Lambda（C++14+）**：  
  支持`auto`参数，实现泛型操作：
  ```cpp
  auto generic = [](auto x, auto y) { return x + y; }; // 支持任意类型参数
  ```
• **捕获移动语义（C++14+）**：  
  通过`std::move`捕获仅移动类型（如`unique_ptr`）：
  ```cpp
  auto lambda = [data = std::move(unique_ptr)]() { /* 使用data */ };
  ```

---

### **总结**
C++的Lambda表达式通过捕获列表、参数传递和简洁语法，显著提升了代码的可维护性和灵活性。其适用于算法回调、闭包封装等场景，但在性能敏感或复杂状态管理时，函数对象可能更优。合理选择捕获方式并注意变量生命周期，可最大化Lambda的优势。