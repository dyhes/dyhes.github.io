---
title: 【Java】Composition
date: 2025-06-18 00:00:00+0000
categories: 
- temple
tags:
- Java
---

## 组合优于继承

组合优于继承（Composition over Inheritance）是面向对象编程中的核心设计原则，强调通过**组合对象**（has-a 关系）而非**继承类**（is-a 关系）实现代码复用和功能扩展。其核心思想是优先使用对象组合（将其他类的实例作为成员变量）而非类继承来构建系统，以提升灵活性、降低耦合度。以下是其核心要点：

------

### ⚙️ **核心概念与区别**

1. 组合（Composition）
   - **定义**：一个类通过持有其他类的实例（成员对象）来复用其功能，体现 **“has-a”** 关系（如汽车有发动机）。
   - **实现方式**：通过接口或类实例的委托调用（如 `car.engine.start()`）。
2. 继承（Inheritance）
   - **定义**：子类通过扩展父类获得属性和方法，体现 **“is-a”** 关系（如狗是动物）。
   - 问题：
     - 子类与父类强耦合，父类修改可能破坏子类逻辑；
     - 继承层次过深导致类爆炸（Class Explosion）；
     - 可能继承不必要的属性和方法。

------

### ⚖️ **为什么组合优于继承？**

| **特性**     | **组合**                         | **继承**                             |
| ------------ | -------------------------------- | ------------------------------------ |
| **耦合度**   | 低（通过接口交互，实现松耦合）   | 高（子类依赖父类实现细节）           |
| **灵活性**   | 高（运行时动态替换组件）         | 低（编译时确定，无法动态调整）       |
| **扩展性**   | 易扩展（新增功能只需添加新组件） | 难扩展（需创建新子类，易引发类爆炸） |
| **封装性**   | 高（内部细节隐藏，仅暴露接口）   | 低（父类实现暴露给子类）             |
| **复用粒度** | 细粒度（按需组合所需功能）       | 粗粒度（强制继承全部功能）           |

### 💡 **典型应用场景与案例**

#### **避免无效继承关系**

- **问题**：汽车不是发动机（`Car extends Engine`），但继承强制建立 is-a 关系。

- 组合方案：

  ```java
  class Engine { void start() { /* ... */ } }
  class Car {
      private Engine engine; // Car has-a Engine
      void start() { engine.start(); } // 委托调用
  }
  ```

  可动态更换引擎（如电动引擎），无需创建新子类。

#### **解决行为组合问题**

- **问题**：鸟类继承导致冗余（鸵鸟不应继承 `fly()` 方法）。

- 组合方案（接口 + 委托）：

  ```java
  interface Flyable { void fly(); }
  class FlyAbility implements Flyable { 
      public void fly() { /* 飞行实现 */ } 
  }
  class Sparrow {
      private FlyAbility flyer = new FlyAbility();
      public void fly() { flyer.fly(); } // 委托
  }
  class Ostrich { /* 无需实现 Flyable */ }
  ```

  仅需组合所需能力，避免方法冗余。

#### **动态扩展功能**

- 装饰器模式：通过组合嵌套对象动态添加功能（如为咖啡添加牛奶）。

  ```java
  interface Coffee { double cost(); }
  class MilkDecorator implements Coffee {
      private Coffee base;
      public MilkDecorator(Coffee base) { this.base = base; }
      public double cost() { return base.cost() + 0.5; }
  }
  ```

  比继承（如 

  ```
  MilkCoffee extends Coffee
  ```

  ）更灵活。

------

### ⚠️ **何时使用继承？**

尽管组合更灵活，**继承仍有适用场景**：

1. **稳定的 is-a 关系**（如 `Dog extends Animal`）；
2. **需利用多态特性**（如父类方法需被子类重写）；
3. **框架限制**（如某些 API 强制要求继承基类）。

------

### 💎 **实践建议**

1. **优先组合**：新功能通过组合现有组件实现。
2. **面向接口编程**：依赖抽象接口而非具体类，提升组件可替换性。
3. **控制继承层次**：继承层次 ≤ 2 层，避免复杂性和脆弱性。
4. 使用设计模式：
   - **策略模式**：通过组合不同策略对象动态改变行为；
   - **Mixin 模式**（Python/Rust）：水平混入功能，替代多重继承。

------

### **总结**

组合优于继承的核心价值在于**解耦与动态扩展**：

- 组合通过 **“黑盒复用”**（仅依赖接口）和 **“动态组装”** 解决了继承的强耦合与僵化问题；
- 继承适用于 **类型严格匹配** 的场景，但需警惕层次过深带来的维护成本。
  在现代语言（如 Go、Rust）中，组合已成为主流，而继承逐渐被接口和 Trait 替代。