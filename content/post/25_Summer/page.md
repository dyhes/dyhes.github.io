---
title: 【Postopia】page
date: 2025-07-02 00:00:00+0000
categories: [nutrition, willow, moon]
tags:
- Postopia
---

## 深度分页

在Spring Data JPA中，`Pageable`接口默认采用**基于Offset的分页机制**，但在深度分页（如查询第1000页）场景下，这种机制存在显著性能问题。开发者可通过游标分页（Cursor-based Pagination）优化性能。以下是具体分析及解决方案：

------

### ⚙️ 1. **默认机制：基于Offset的分页**

- 

  实现原理

  

  通过

  ```
  PageRequest.of(page, size)
  ```

  创建

  ```
  Pageable
  ```

  对象时，生成的SQL会使用

  ```
  LIMIT size OFFSET (page * size)
  ```

  （MySQL）或类似语法（如Oracle的

  ```
  ROWNUM
  ```

  ）。例如：

  ```
  SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 10000; -- 查询第1001页（每页10条）
  ```

  1,3,6

- 

  深度分页性能问题

  

  - **全表扫描风险**：数据库需先扫描`OFFSET + size`条记录（如`OFFSET 10000`需扫描前10000条），再返回目标数据，导致I/O和CPU资源消耗剧增[6](@ref)。
  - **延迟与资源浪费**：当`OFFSET`值超过10万时，查询响应时间可能从毫秒级升至秒级[6](@ref)。

- **适用场景**
  数据量较小（如总页数<100）或仅需前几页数据的场景。

------

### 🎯 2. **优化方案：游标分页（Cursor-based Pagination）**

- 

  核心思想

  

  不再依赖页码，而是基于

  最后一条记录的标识

  （如主键ID、时间戳）定位下一页数据：

  ```
  SELECT * FROM users WHERE id > last_id ORDER BY id LIMIT 10; -- 游标分页示例
  ```

  6,7

- 

  优势

  

  - **常数级性能**：无论深度如何，查询时间仅与`LIMIT size`相关，避免`OFFSET`的全表扫描[6](@ref)。
  - **数据一致性**：避免因分页期间数据增删导致的重复或遗漏（如使用自增ID或时间戳排序）[6](@ref)。

- 

  Spring Data JPA实现步骤

  

  1. 

     Repository层

     ：使用

     ```
     @Query
     ```

     定义游标查询：

     ```
     @Query("SELECT u FROM User u WHERE u.id > :cursorId ORDER BY u.id")
     List<User> findNextPage(@Param("cursorId") Long cursorId, Pageable pageable);
     ```

  2. 

     Service层

     ：传递游标参数：

     ```
     public Page<User> getUsers(Long cursorId, int size) {
         Pageable pageable = PageRequest.of(0, size); // 页码固定为0
         List<User> users = repository.findNextPage(cursorId, pageable);
         // 计算是否有下一页
         boolean hasNext = users.size() == size;
         return new PageImpl<>(users, pageable, hasNext ? users.size() : 0);
     }
     ```

  3. 

     返回结构

     ：响应中包含游标标识（如最后一条记录的ID）：

     ```
     {
       "content": [...],
       "nextCursor": 1024 // 下一页的起始游标
     }
     ```

  7,8

------

### ⚖️ 3. **两种分页方式对比**

| **特性**       | **Offset分页**                  | **游标分页**                     |
| -------------- | ------------------------------- | -------------------------------- |
| **性能**       | 深度分页时性能差（O(N)）        | 深度分页性能稳定（O(1)）         |
| **数据一致性** | 易受数据增删影响                | 稳定（基于排序字段）             |
| **实现复杂度** | 简单（Spring Data JPA原生支持） | 需手动处理游标传递               |
| **适用场景**   | 小数据量、随机访问页码          | 大数据量、连续翻页（如无限滚动） |

------

### 🛠️ 4. **实际选择建议**

- 

  优先游标分页的场景

  

  - 用户连续翻页（如无限滚动列表）[6,7](@ref)。
  - 单次查询数据量超过10万条，或需访问超过100页的深度[6](@ref)。

- 

  仍用Offset分页的场景

  

  - 后台管理系统（需精确统计总数、跳转任意页）[8](@ref)。
  - 数据量小于1万条，或仅需前几页数据[1](@ref)。

> 💡 **关键提示**：若必须使用Offset分页且需优化性能，可考虑：
>
> 1. **索引覆盖优化**：先通过子查询获取起始ID，再联表查询目标数据[6](@ref)。
> 2. **避免`COUNT(\*)**：大数据量表的总记录数查询可独立缓存[6](@ref)。

------

### 总结

Spring Data JPA的`Pageable`默认通过Offset分页实现，深度分页时需主动切换为游标机制。**游标分页是深度分页的性能首选**，尤其适合连续数据流场景；而Offset分页在需精确统计或跳转页码时仍有价值。开发者应根据数据规模与访问模式灵活选择[6,7,8](@ref)。

## 游标存储

在Spring Data JPA深度分页优化中使用游标时，游标的存储位置直接影响性能、一致性和实现复杂度。以下是不同方案的对比及Redis存储的适用性分析：

------

### 📍 **一、游标的本质与存储原则**

**游标本质**是**分页断点标识**（如最后一条记录的ID、时间戳或排序字段值），用于下一次查询的起始位置。其存储需满足：

- **轻量临时性**：通常无需长期存储，仅需在连续分页请求间传递。
- **低延迟访问**：需快速读写以支持高频分页。
- **客户端关联性**：游标与客户端的分页上下文绑定，不同客户端分页状态独立。

------

### 🔧 **二、主流存储方案对比**

#### 1️⃣ **客户端回传（首选方案）**

- **实现方式**：将游标（如`lastId`）作为响应返回客户端，客户端下次请求时通过参数（如`?cursor=1000&size=10`）回传[1,8](@ref)。

- 

  优点

  ：

  - **无状态服务**：服务端无需存储，天然支持分布式架构。
  - **低开销**：避免额外存储组件的网络和资源消耗。
  - **简单可靠**：适用于99%的连续分页场景（如无限滚动）。

- 

  缺点

  ：

  - 不支持跨设备或跳页（但游标分页本就不适合跳页）。

- 

  示例代码

  ：

  ```
  // 响应结构
  public class PageResult<T> {
      private List<T> content;
      private String nextCursor; // 如 "id:1000"
  }
  ```

#### 2️⃣ **Redis存储（特定场景使用）**

- 

  适用场景

  ：

  - **分页状态需跨设备共享**（如用户A在手机端分页到第5页，电脑端需自动续接）。
  - **分页会话需长期保留**（如分页导出任务可能中断后恢复）[6,7](@ref)。

- 

  实现要点

  ：

  - **键设计**：`cursor:{sessionId}:{queryId}`（如`cursor:user123:export-task-1`）。
  - **存储类型**：`String`（简单游标值）或 `Hash`（多字段游标）。
  - **过期时间**：设置TTL避免内存泄漏（如`EXPIRE cursor:user123:export-task-1 3600`）。

- 

  缺点

  ：

  - **增加复杂度**：需维护Redis连接、序列化、异常处理。
  - **性能损耗**：相比客户端回传，多一次网络请求（1~2ms延迟）[6](@ref)。

- 

  示例代码

  ：

  ```
  public String saveCursor(String sessionId, String queryId, String cursorValue) {
      String key = "cursor:" + sessionId + ":" + queryId;
      redisTemplate.opsForValue().set(key, cursorValue, Duration.ofHours(1));
      return key;
  }
  ```

#### 3️⃣ **数据库存储（不推荐）**

- **场景**：需持久化分页状态（如审计需求）。

- 

  问题

  ：

  - **性能差**：每次分页需读写数据库，拖慢响应。
  - **无必要**：游标是临时状态，数据库应存业务数据而非上下文[1,4](@ref)。

------

### ⚡ **三、Redis存储游标的实操建议**

若必须使用Redis，需注意：

1. **数据序列化**：游标值转为String（如`Jackson`序列化对象为JSON）。

2. **并发控制**：对同一分页会话加分布式锁（如Redisson），避免并发更新游标[6](@ref)。

3. 

   清理机制

   ：

   - 客户端主动通知结束时删除游标。
   - 设置TTL自动清理（如30分钟）。

4. **性能监控**：关注Redis内存和QPS，避免游标数据膨胀。

------

### 📊 **四、方案选型决策表**

| **场景**                 | **推荐方案**         | **理由**                                                     |
| ------------------------ | -------------------- | ------------------------------------------------------------ |
| 连续分页（如无限滚动）   | 客户端回传           | 简单高效，无额外开销[1,8](@ref)                              |
| 跨设备续接分页           | Redis存储            | 状态共享需求优先[6](@ref)                                    |
| 长时间任务（如数据导出） | Redis存储 + TTL      | 保留中断状态，避免重复计算                                   |
| 需要跳页或随机访问       | 非游标方案（Offset） | 游标分页不支持跳页，需改用Offset分页（需配合索引优化）[3](@ref) |

------

### 💎 **总结**

- **优先选择客户端回传**：游标通过请求参数传递，适用于绝大多数场景，简单高效 ✅。
- **谨慎使用Redis存储**：仅在需**跨设备同步分页状态**或**保留中断任务**时启用，并严格管理TTL和内存 ❗。
- **避免数据库存储**：游标是临时上下文，持久化到数据库得不偿失 ❌。

> **提示**：若使用Redis，建议封装游标管理工具类，统一处理存储、读取和清理逻辑，降低业务侵入性[6,7](@ref)。