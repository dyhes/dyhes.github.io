---
title: 【MongoDB】Fundamentals
date: 2025-08-06 00:00:00+0000
categories: [nutrition, willow]
tags: [DB]
---

## Introduction

A record in MongoDB is a document, which is a data structure composed of field and value pairs. MongoDB documents are similar to JSON objects. The values of fields may include other documents, arrays, and arrays of documents.

The advantages of using documents are:

- Documents correspond to **native data types** in many programming languages.
- Embedded documents and arrays **reduce need for expensive joins**.
- **Dynamic schema** supports fluent polymorphism.

MongoDB stores documents in [collections](https://www.mongodb.com/docs/manual/core/databases-and-collections/#std-label-collections). Collections are analogous to tables in relational databases.

### Query API

The MongoDB Query API supports [read and write operations (CRUD)](https://www.mongodb.com/docs/manual/crud/#std-label-crud) as well as:

- [Data Aggregation](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/#std-label-aggregation-pipeline)
- [Text Search](https://www.mongodb.com/docs/manual/text-search/#std-label-text-search) and [Geospatial Queries.](https://www.mongodb.com/docs/manual/tutorial/geospatial-tutorial/)

## 架构

MongoDB Atlas 是 MongoDB 公司推出的**全托管云数据库服务**，而 MongoDB 通常指开源、需自托管的数据库系统。两者核心区别在于**部署模式、运维复杂度及功能扩展性**。以下是详细对比：

------

### 🚀 **一、MongoDB Atlas 的核心特性**

1. **完全托管服务**
   - Atlas 自动处理数据库的部署、备份、监控、扩展、安全更新等运维任务，用户无需管理底层基础设施。
   - 支持多云部署（AWS/Azure/GCP），可跨区域复制数据，实现全球低延迟访问和高可用性。
2. **开箱即用的高级功能**
   - **内置向量搜索**：支持近似最近邻（ANN）搜索，适用于AI场景（如语义搜索、推荐系统）。
   - **自动化弹性扩展**：根据负载动态调整计算和存储资源，无需停机。
   - **企业级安全**：默认启用TLS加密、VPC网络隔离、RBAC权限控制，符合GDPR等合规要求。
3. **简化开发与运维**
   - 提供免费套餐和按需计费模式，降低初始成本。
   - 集成监控告警、自动化备份（支持时间点恢复）和查询分析工具。

------

### ⚙️ **二、MongoDB Atlas 与自托管 MongoDB 的关键区别**

| **维度**     | **MongoDB Atlas**                         | **自托管 MongoDB**                 |
| ------------ | ----------------------------------------- | ---------------------------------- |
| **运维管理** | 全自动运维（备份、监控、扩缩容）          | 需手动部署、升级、维护硬件与软件   |
| **高可用性** | 内置多区域副本集，自动故障转移            | 需手动配置副本集和分片集群         |
| **安全性**   | 默认TLS加密、IP白名单、VPC隔离            | 需自行配置网络防火墙和加密机制     |
| **扩展性**   | 一键横向分片/纵向扩展，支持全球分发       | 需手动分片，扩展过程复杂且可能停机 |
| **成本模型** | 按使用量付费（含免费套餐）                | 需采购硬件，长期运维成本较高       |
| **高级功能** | 原生支持向量搜索、Data Lake集成、AI工具链 | 需依赖第三方库或自建解决方案       |

------

### 💡 **三、典型使用场景对比**

- **适合 Atlas 的场景**
  - 快速原型开发：分钟级部署数据库，加速产品迭代。
  - 全球化应用：需跨区域低延迟访问（如电商、游戏）。
  - AI驱动型应用：直接调用内置向量搜索与LLM集成（如LangChain）。
- **适合自托管的场景**
  - 数据主权要求严格：需完全掌控本地硬件和网络。
  - 超低成本敏感场景：长期固定负载且具备专业运维团队。

------

### 🔌 **四、连接与开发差异**

- **连接方式**
  - Atlas：使用云服务专属URI（如 `mongodb+srv://`），需配置IP白名单和数据库用户。
  - 自托管：通过本地连接字符串（如 `mongodb://localhost:27017`）直接访问。
- **开发适配性**
  - Atlas 提供与开源MongoDB相同的驱动（Node.js/Python/Java等），但需调用云服务特定API（如向量搜索聚合管道）。

------

### 💎 **总结**

- **MongoDB Atlas** = **MongoDB 核心功能 + 全托管云服务 + 高级扩展能力**，适合追求效率、全球化部署及AI集成的团队。
- **自托管 MongoDB** 更适合需要完全控制基础设施或成本极度受限的场景，但需承担运维复杂性。

建议优先使用 Atlas 以聚焦业务开发，仅在特殊需求时选择自托管方案。

## B 树索引

MongoDB 选择 B 树而非 B+ 树作为索引结构，主要与其设计目标和应用场景相关，而“范围查询需求差异”只是原因之一。以下从多个维度分析其设计逻辑，并结合技术原理说明：

------

### 🧠 **一、核心设计理念差异**

1. **数据模型定位不同**
   - **MySQL（B+树）**：强调查询关联数据与范围遍历（如时间范围、外键关联查询），B+树的叶子节点链表结构天然支持高效顺序访问。
   - **MongoDB（B树）**：以文档为聚合单元，目标场景是**快速定位单个文档**（如通过 `_id` 获取用户完整信息），B树的非叶子节点直接存储数据可减少磁盘 I/O 次数，单点查询平均更快。
2. **查询模式优先级**
   - MongoDB 假设**单文档查询频率远高于范围遍历**。B 树在随机查询时可能仅需访问少数节点即可返回数据（最优 O(1)），而 B+树必须访问叶子节点（固定 O(log n)）。
   - *反例说明*：若集合设计未遵循文档聚合原则（如将评论独立存储并通过 `post_id` 关联查询），范围查询性能确实弱于 MySQL，但这是反模式设计，非 MongoDB 推荐用法。

------

### ⚙️ **二、B 树 vs B+ 树的技术权衡**

| **特性**         | **B 树（MongoDB）**             | **B+ 树（MySQL）**               |
| ---------------- | ------------------------------- | -------------------------------- |
| **节点数据存储** | 非叶节点存储键值+数据（Data域） | 非叶节点仅存索引键，数据在叶节点 |
| **单点查询性能** | 平均更优（可能中途命中数据）    | 稳定但需访问叶节点               |
| **范围查询性能** | 需多次回溯非叶节点，效率较低    | 叶节点链表直接顺序遍历，效率高   |
| **空间利用率**   | 非叶节点存储数据，索引体积较小  | 非叶节点冗余索引键，索引体积较大 |

------

### 🔍 **三、范围查询在 MongoDB 中的实际支持**

1. **MongoDB 仍支持范围查询**
   - 例如按时间戳或 `ObjectId` 范围过滤（如 `db.collection.find({_id: {$gt: startId}})`）。
   - 但性能弱于 MySQL：B 树需多次访问非连续节点，而 B+ 树通过叶节点链表顺序扫描。
2. **优化手段**
   - **复合索引设计**：将高区分度字段（如用户ID）置于索引左侧，缩小扫描范围。
   - **分片键策略**：哈希分片可避免热点，但牺牲范围查询；范围分片直接优化连续查询。
   - **聚合管道**：通过 `$match` 提前过滤数据，减少内存处理量。

------

### ⚖️ **四、其他影响因素**

1. **写入性能考量**
   - B 树的随机写性能优于 LSM 树（写放大低），且读取性能远胜 LSM 树（LSM 读需合并多层级文件）。MongoDB 的读多写少场景更倾向 B 树。
2. **存储引擎优化**
   - WiredTiger 引擎的**文档级锁**和 **MVCC** 机制弥补了 B 树并发短板，而压缩技术（Snappy/Zstd）缓解了 B 树空间问题。

------

### 💎 **总结：MongoDB 选择 B 树的本质原因**

1. **场景驱动**：文档型数据库的核心操作是**基于键的快速文档获取**，而非表关联遍历。
2. **性能折衷**：牺牲范围查询效率，换取更高的单点查询性能和更稳定的读写吞吐。
3. **生态适配**：通过聚合文档模型、分片策略和索引优化，规避 B 树在范围查询上的劣势。

> 若业务强依赖范围查询（如日志分析），建议：
> ✅ 使用范围分片键 + 复合索引（高区分度字段在前）
> ✅ 必要时改用 ClickHouse 或 Elasticsearch 等专用引擎。

## Change Stream

MongoDB Change Streams 是一种基于 **oplog（操作日志）** 的实时数据变更监听机制，自 3.6 版本引入，适用于副本集或分片集群环境。它通过推送模式将数据库的增量变更（如插入、更新、删除）以事件流的形式传递给应用程序，无需轮询查询。以下从核心机制、应用场景、技术实现及优化策略展开详解：

------

### 🔧 **一、核心机制与工作原理**

1. **依赖 Oplog 实现**

   - Change Streams 在 MongoDB 的 **oplog 集合**上开启一个可追加游标（tailable cursor），实时捕获所有副本集或分片集群的变更操作。
   - 变更事件包括：`insert`、`update`、`delete`、`drop`（集合删除）、`rename`（集合重命名）及 `invalidate`（集合失效事件）。

2. **数据一致性与可靠性**

   - 采用 **`readConcern: "majority"`** 级别，确保变更事件仅在数据写入多数节点后触发，避免回滚导致的数据不一致。
   - **断点恢复机制**：每个事件返回唯一的 `resumeToken`（存储在 `_id` 字段），支持通过 `resumeAfter` 参数从中断点恢复监听。

3. **事件过滤与定制**

   - 使用 **聚合管道** 过滤特定事件类型（如仅监听插入和删除）：

     ```
     db.collection.watch([{ $match: { operationType: { $in: ["insert", "delete"] } } }]);
     ```

   - 更新操作默认返回**增量字段**（仅变更部分），若需获取完整文档，需设置 `fullDocument: "updateLookup"`。

------

### ⚡ **二、适用场景与典型方案**

| **场景**           | **实现方案**                                            | **案例说明**                        |
| ------------------ | ------------------------------------------------------- | ----------------------------------- |
| **跨集群数据同步** | 订阅源集群变更流，实时写入目标集群                      | 异地容灾备份（如北京→上海集群同步） |
| **实时监控与审计** | 监听高风险操作（如 `dropDatabase`），触发告警或日志记录 | 审计删库行为，满足合规要求          |
| **事件驱动架构**   | 微服务间数据变更联动（如订单状态更新触发库存扣减）      | 电商系统中订单-库存服务解耦         |
| **实时分析计算**   | 将变更事件推送至 Flink/Spark 流处理平台                 | 用户行为实时分析（如点击流统计）    |
| **动态消息推送**   | 监听数据变更（如公交车 GPS 坐标），推送至客户端         | 公交到站实时提醒系统                |

------

### 🛠️ **三、技术实现与优化策略**

1. **基础代码示例（Node.js）**

   ```
   const changeStream = db.collection('users').watch();
   changeStream.on('change', (change) => {
     if (change.operationType === 'update') {
       console.log('更新后的完整文档：', change.fullDocument);
     }
   });
   ```

2. **Spring Boot 整合（Java）**

   - 配置

      

     ```
     MessageListenerContainer
     ```

      

     监听指定集合，过滤事件类型并启用全文档返回：

     ```
     ChangeStreamRequest.builder(listener)
       .collection("orders")
       .filter(Aggregation.match(Criteria.where("operationType").in("insert", "update")))
       .fullDocumentLookup(FullDocument.UPDATE_LOOKUP)
       .build();
     ```

3. **性能优化实践**

   - **资源控制**：通过 `maxAwaitTimeMS` 限制事件等待时间（如 `5000ms`），避免长连接阻塞。
   - **索引优化**：对高频查询的字段（如 `_id` 或分片键）创建索引，提升变更事件生成效率。
   - **网络带宽管理**：在跨数据中心场景中压缩事件数据（如使用 Snappy 算法）。

------

### ⚠️ **四、注意事项与限制**

1. **环境依赖**
   - 仅支持副本集或分片集群，单机 MongoDB 不可用。
   - Oplog 窗口限制：中断时间超过 oplog 保留周期（默认 24 小时）将导致数据丢失。
2. **事件特性**
   - 删除操作仅返回文档 `_id`，无法获取完整内容。
   - DDL 事件（如索引创建）仅 MongoDB 6.0+ 支持。
3. **资源消耗**
   - **高并发场景**：需监控 CPU/内存占用，建议分离监听节点与数据节点。
   - **网络压力**：海量变更事件可能占满带宽，需设计背压机制（如 Kafka 缓冲）。

------

### 💎 **总结**

Change Streams 是 MongoDB 实时数据生态的核心组件，通过 **oplog 监听 + 事件流推送** 机制，高效支撑了数据同步、微服务协作、实时分析等场景。开发中需注意：
✅ ​**优先使用聚合管道替代 MapReduce**，避免 JS 引擎性能瓶颈；
✅ ​**结合断点恢复与过滤机制**，提升事件处理可靠性；
✅ ​**生产环境部署分片集群**，保障高可用性与扩展性。

> 对于需要历史数据处理或复杂关联分析的场景，建议搭配 **CDC 工具（如 Debezium）** 或 **流式计算引擎（如 Flink）** 构建更健壮的流水线。

## Aggregation Pipeline

MongoDB 的聚合管道（Aggregation Pipeline）是一种基于**数据处理流水线模型**的框架，用于对集合中的文档进行多阶段转换、过滤、分组和计算，最终输出聚合结果。其核心设计思想是将数据像在管道中流动一样，依次经过多个处理阶段，每个阶段执行特定操作并传递给下一阶段。以下是详细解析：

------

### 🔧 **一、核心概念与工作机制**

1. **管道与阶段（Pipeline & Stage）**
   - **管道**：由多个**阶段（Stage）** 组成的序列，每个阶段接收上一阶段的输出文档，执行操作后输出新文档。
   - **阶段类型**：包括 `$match`（过滤）、`$project`（投影）、`$group`（分组）、`$sort`（排序）等，支持链式组合。
   - **执行顺序**：严格按定义顺序执行，例如先过滤再分组可显著提升性能。
2. **输入与输出**
   - **输入**：集合中的所有文档（或通过 `$match` 筛选的子集）。
   - **输出**：最终阶段的处理结果，可以是文档、统计值或写入新集合（通过 `$out` 或 `$merge`）。

------

### ⚙️ **二、核心阶段详解与示例**

以下是常用阶段的功能和语法示例：

| **阶段**       | **功能**                                       | **语法示例**                                                 | **应用场景**                    |
| -------------- | ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------- |
| **`$match`**   | 筛选符合条件的文档，类似 SQL 的 `WHERE`        | `{ $match: { status: "A", quantity: { $gt: 20 } } }`         | 提前过滤数据，减少后续计算量    |
| **`$project`** | 重命名、增删字段，或计算新字段                 | `{ $project: { name: 1, discount: { $multiply: ["$price", 0.9] } } }` | 数据格式转换或字段加工          |
| **`$group`**   | 按字段分组并计算聚合值（如求和、均值）         | `{ $group: { _id: "$category", total: { $sum: "$quantity" } } }` | 统计分类销售额或用户行为        |
| **`$unwind`**  | 将数组字段拆分为多条独立文档（每个元素一文档） | `{ $unwind: "$tags" }`                                       | 分析标签、评论等数组数据        |
| **`$sort`**    | 按字段排序                                     | `{ $sort: { total: -1 } }` （`-1` 降序，`1` 升序）           | 结果排序或分页预处理            |
| **`$lookup`**  | 跨集合左外连接（类似 SQL `LEFT JOIN`）         | `{ $lookup: { from: "orders", localField: "user_id", foreignField: "_id", as: "orders" } }` | 关联用户订单信息                |
| **`$facet`**   | 在同一阶段执行多个子管道，输出多维统计结果     | `{ $facet: { sales: [{ $group: { _id: null, total: { $sum: "$price" } }], topItems: [{ $limit: 5 }] } }` | 多维度分析（如销售额+热门商品） |

------

### ⚡ **三、高级功能与复杂操作**

1. **表达式操作符**

   - **数学计算**：`$add`、`$multiply`（例：`{ $multiply: ["$price", "$quantity"] }` 计算总价）。

   - 

     条件逻辑

     ：

     ```
     $cond
     ```

      

     实现

      

     ```
     IF-ELSE
     ```

     ，例如根据价格设置折扣：

     ```
     { $project: { discount: { $cond: { if: { $gt: ["$price", 100] }, then: 10, else: 0 } } } }
     ```

   - **日期/字符串处理**：`$dateFromString` 转换日期格式，`$substr` 截取字符串 。

2. **多阶段组合案例**
   ​**场景**​：统计 2024 年 Q1 各品类销售额 Top 3：

   ```
   db.sales.aggregate([
     { $match: { date: { $gte: "2024-01-01", $lt: "2024-04-01" } } },  // 过滤日期
     { $group: { _id: "$category", total: { $sum: { $multiply: ["$price", "$quantity"] } } } }, // 分组计算
     { $sort: { total: -1 } },  // 按销售额降序
     { $limit: 3 }               // 取前三
   ])
   ```

   **执行顺序**：`$match` → `$group` → `$sort` → `$limit`。

------

### 🛠️ **四、性能优化与注意事项**

1. **阶段顺序优化**
   - **前置过滤**：将 `$match` 和 `$project` 放在管道前端，减少后续处理的数据量。
   - **索引利用**：`$match` 和 `$sort` 若在管道开头，可命中索引加速查询。
2. **内存与资源管理**
   - **内存限制**：`$group` 和 `$sort` 默认内存上限 100MB，超限需启用 `allowDiskUse: true` 写入临时文件。
   - **分片集群优化**：在 `$group` 前使用 `$match` 减少跨分片数据传输。
3. **替代 MapReduce**
   - 聚合管道**原生使用 C++ 实现**，比基于 JavaScript 的 MapReduce **性能提升 10 倍以上**，MongoDB 5.0+ 已弃用 MapReduce。

------

### 💡 **五、典型应用场景**

| **场景**         | **实现方案**                                                 | **案例**           |
| ---------------- | ------------------------------------------------------------ | ------------------ |
| **实时报表**     | `$group` + `$project` 计算销售总额、均值等                   | 每日销售统计看板   |
| **数据清洗**     | `$project` 重命名字段 + `$unwind` 展开数组 + `$match` 过滤异常值 | 用户行为日志预处理 |
| **多表关联分析** | `$lookup` 连接订单表与用户表，`$group` 按用户分组统计        | 高价值用户识别     |
| **分页查询**     | `$skip` + `$limit` 组合实现（需配合 `$sort` 保证顺序）       | 商品列表分页展示   |

------

### ⚠️ **六、常见错误与规避措施**

1. **数组处理陷阱**

   - ```
     $unwind
     ```

      

     非数组字段会报错，需先用

      

     ```
     $ifNull
     ```

      

     设置默认值：

     ```
     { $project: { tags: { $ifNull: ["$tags", []] } } }, 
     { $unwind: "$tags" }
     ```

   - 空数组经 `$unwind` 后文档会被丢弃，需设 `preserveNullAndEmptyArrays: true` 保留。

2. **分组性能瓶颈**

   - 避免对高基数字段（如用户ID）直接 `$group`，改用 `$bucket` 分桶统计。
   - 分片集群中，确保 `$group` 的 `_id` 包含分片键以避免跨分片合并。

------

### 💎 **总结**

聚合管道是 MongoDB **最强大的数据分析工具**，通过灵活的阶段组合可实现：

- **高效数据转换**：`$project` 重塑结构，`$unwind` 解构数组；
- **复杂聚合计算**：`$group` 分组统计，`$facet` 多维度分析；
- **跨集合关联**：`$lookup` 替代关联查询；
- **资源可控性**：`allowDiskUse` 突破内存限制，分片集群优化分布式计算。

> **最佳实践**：始终将 `$match` 前置以减少数据量；避免 JavaScript 表达式；优先使用聚合管道而非已弃用的 MapReduce。 具体语法详见 [MongoDB 聚合管道文档](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/)。

## MapReduce

在 MongoDB 中，聚合管道（Aggregation Pipeline）和 MapReduce 是两种核心的数据处理模型，它们在性能上存在显著差异。以下从执行机制、资源消耗、扩展性等维度详细分析两者的具体差异：

------

### ⚙️ **一、执行机制与性能差异**

| **特性**         | **聚合管道**                                              | **MapReduce**                                                |
| ---------------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| **执行引擎**     | **原生 C++ 实现**，直接操作 BSON 数据，无解释器开销。     | **JavaScript 引擎执行**，需解析 JS 代码，性能损耗高。        |
| **数据处理方式** | **流式管道处理**，数据在内存中逐阶段传递，减少 I/O 开销。 | **分阶段读写磁盘**：Map 输出中间结果落盘，Reduce 阶段再读取，I/O 压力大。 |
| **内存限制**     | 单阶段默认 100MB 内存限制，可通过 `allowDiskUse` 突破。   | 无明确内存限制，但频繁磁盘溢写导致性能下降。                 |
| **索引支持**     | **强依赖索引**：`$match`、`$sort` 等阶段可命中索引加速。  | 仅输入阶段支持索引，Reduce 阶段无法利用索引。                |

> **性能实测对比**：相同聚合任务（如分组统计），聚合管道的速度通常比 MapReduce **快 5–10 倍**，尤其在 TB 级数据下差异更显著。

------

### 📊 **二、资源消耗对比**

1. **CPU 与内存**
   - **聚合管道**：CPU 开销低，内存占用可控（通过 `$project` 提前过滤字段）。
   - **MapReduce**：JS 引擎解析消耗大量 CPU，且 Map/Reduce 间数据交换易导致内存溢出。
2. **磁盘 I/O**
   - **聚合管道**：仅在 `allowDiskUse` 启用时写临时文件。
   - **MapReduce**：**强制写磁盘**：Map 输出、Reduce 输入/输出均需落盘，I/O 瓶颈明显。
3. **网络开销**
   - MapReduce 需跨分片传输大量中间数据，而聚合管道可通过分片键下推计算（如 `$match` 提前过滤）减少跨节点流量。

------

### 🔧 **三、扩展性与并发能力**

| **维度**         | **聚合管道**                                            | **MapReduce**                                             |
| ---------------- | ------------------------------------------------------- | --------------------------------------------------------- |
| **分片集群优化** | 支持**分片感知**：`$group` 自动并行化，均衡器分配任务。 | 需手动处理分片数据合并，易出现计算倾斜。                  |
| **锁机制**       | **文档级锁**，读写并发度高。                            | **全局写锁**：Reduce 输出阶段锁整个数据库，阻塞其他操作。 |
| **实时性**       | 适合**实时查询**（毫秒级响应）。                        | 仅适合**离线批处理**（分钟级延迟）。                      |

------

### ⚖️ **四、适用场景对比**

| **场景**           | **推荐方案**        | **原因**                                               |
| ------------------ | ------------------- | ------------------------------------------------------ |
| **实时数据分析**   | 聚合管道            | 低延迟响应，支持复杂流水线（如 `$facet` 多维度统计）。 |
| **大规模离线计算** | MapReduce           | 可处理超大数据集（PB 级），但需容忍高延迟。            |
| **自定义聚合逻辑** | MapReduce           | 支持 JavaScript 编写复杂业务逻辑（如迭代计算）。       |
| **高频增量更新**   | 聚合管道 + `$merge` | 支持结果集增量更新，避免全量重算。                     |

------

### 🛠️ **五、性能优化策略差异**

1. **聚合管道优化**
   - **阶段顺序**：`$match` → `$project` → `$sort`（利用 ESR 索引原则）。
   - **索引设计**：为 `$match` 字段创建复合索引（如 `status + created_at`）。
   - **分页技巧**：用 `$facet` 同时返回数据和总数，避免二次查询。
2. **MapReduce 优化**
   - **Combiner 预聚合**：在 Map 端局部合并数据，减少 Reduce 负载。
   - **输出定向**：结果写入分片集合，并行写入加速。

------

### 💎 **总结：核心差异与选型建议**

| **对比维度** | **聚合管道**       | **MapReduce**      |
| ------------ | ------------------ | ------------------ |
| **性能**     | ⭐⭐⭐⭐⭐（高效实时）  | ⭐⭐（高延迟离线）   |
| **开发效率** | ⭐⭐⭐⭐（声明式语法） | ⭐⭐（需写 JS 函数） |
| **资源消耗** | ⭐⭐⭐⭐（低 I/O）     | ⭐（高磁盘/CPU）    |
| **灵活性**   | ⭐⭐⭐（固定操作符）  | ⭐⭐⭐⭐（自定义逻辑） |

**选型建议**：
✅ ​**默认选择聚合管道**​：适用于 90% 的场景（实时统计、数据转换、关联分析）。
⚠️ ​**仅当以下情况用 MapReduce**​：

- 需自定义复杂算法（如机器学习特征工程）。
- 处理超大数据集且可接受小时级延迟。
- 历史系统兼容性要求。

> 可通过 `explain()` 分析执行计划，或使用 MongoDB Compass 可视化验证管道性能。

## Operations

[Learn MongoDB in 1 hour 🍃](https://www.youtube.com/watch?v=c2M-rlkkT5o)
