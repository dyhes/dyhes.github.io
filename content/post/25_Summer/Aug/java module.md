---
title: 【Java】Module
date: 2025-08-05 00:00:00+0000
categories: [temple]
tags: [Java]
---

## Module

Java模块系统（Java Platform Module System, JPMS），又称Project Jigsaw，是Java 9引入的核心特性，旨在解决传统Java开发中的依赖管理混乱、封装性不足及部署臃肿等问题。以下从核心概念、技术机制、工具链及实践场景展开详细说明：

------

### **一、模块系统的核心概念**

1. **模块（Module）**

   - **定义**：模块是代码和数据的命名集合，包含一组相关的包、资源及模块描述文件（`module-info.java`）。
   - **层级结构**：`JAR > Module > Package > Class/Interface`，实现更细粒度的代码组织。
   - **强封装性**：只有显式声明导出的包（`exports`）才能被外部访问，即使类为`public`，未导出的包对其他模块不可见。

2. **模块描述符（`module-info.java`）**
   位于模块根目录，声明模块元数据：

   ```
   module com.example.app {
       requires java.sql;          // 依赖其他模块
       exports com.example.api;    // 公开指定包
       provides Service with ServiceImpl; // 服务提供
       uses Service;               // 服务消费
   }
   ```

   - `requires`：声明依赖的模块（如`java.base`是隐式依赖的基础模块）。
   - `exports`：控制包的可见性，未导出的包内部使用。
   - 服务机制：通过`provides...with`和`uses`实现解耦的服务发现。

------

### **二、JDK自身的模块化**

Java 9将JDK拆分为约**94个核心模块**，例如：

| **模块名**     | **功能描述**                                             |
| -------------- | -------------------------------------------------------- |
| `java.base`    | 核心包（如`java.lang`、`java.util`），所有模块的隐式依赖 |
| `java.sql`     | JDBC数据库连接API                                        |
| `java.desktop` | AWT/Swing图形界面库                                      |
| `jdk.compiler` | Java编译器实现（`javac`）                                |

- **优势**：按需加载模块，减少运行时资源占用（如通过`jlink`生成最小化JRE）。

------

### **三、模块化核心机制**

1. **依赖解析与模块图**
   - 模块路径（`--module-path`）替代类路径，JVM基于`module-info.java`构建**有向模块图**，确保依赖关系无环且完整。
   - **循环依赖**：模块间禁止直接循环依赖，需通过接口或服务机制解耦。
2. **兼容性设计**
   - **自动模块**：传统JAR置于模块路径时，自动转换为模块（导出所有包，依赖所有模块）。
   - **未命名模块**：类路径中的JAR归入未命名模块，支持旧代码逐步迁移。

------

### **四、工具链与开发流程**

1. **关键工具**

   - **`jdeps`**：分析JAR的模块依赖，指导迁移策略。
   - **`jlink`**：创建定制化JRE镜像，仅包含指定模块（例：`jlink --add-modules java.base --output minimal-jre`）。
   - **`jmod`**：打包模块为JMOD格式（支持本地代码等资源）。

2. **编译与运行**

   ```
   # 编译模块
   javac -d out --module-source-path src -m com.example.app  
   # 运行模块
   java --module-path out -m com.example.app/com.example.Main
   ```

------

### **五、实际应用场景与挑战**

1. **典型用例**
   - **微服务与云部署**：通过`jlink`生成轻量级镜像（从300MB JDK缩减至30MB），优化容器化部署。
   - **大型系统解耦**：明确模块边界，避免类路径冲突（如不同库的同名类问题）。
2. **迁移挑战**
   - **框架兼容性**：Spring 5+部分支持模块化，但需处理自动模块的隐式依赖。
   - **模块粒度**：过度拆分增加管理成本，建议按功能高内聚原则设计。

------

### **六、与OSGi的对比**

| **特性**     | **JPMS**                | **OSGi**                   |
| ------------ | ----------------------- | -------------------------- |
| **定位**     | 语言级模块化（JDK集成） | 动态模块框架（第三方实现） |
| **热部署**   | 不支持                  | 支持动态加载/卸载模块      |
| **依赖解析** | 启动时静态验证          | 运行时动态解析             |

> JPMS适合基础架构封装与部署优化，OSGi适用于需运行时动态管理的场景。

------

### **总结**

Java模块系统通过**强封装**、**显式依赖**和**服务机制**，显著提升了代码安全性、可维护性和部署效率。尽管迁移过程需应对生态兼容性挑战（如Spring的渐进支持），但其在云原生与嵌入式领域的价值日益凸显。开发者可通过`module-info.java`定义模块、结合`jlink`定制运行时，逐步重构项目以发挥模块化优势。

