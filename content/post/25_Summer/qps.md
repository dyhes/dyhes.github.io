---
title: 【Postopia】QPS
date: 2025-07-02 00:00:00+0000
categories: [nutrition, willow, moon]
tags:
- Postopia
---

## QPS

测量后端服务的QPS（Queries Per Second，每秒查询率）是评估系统性能的关键指标，需结合工具使用、代码实现和统计分析。以下是系统化的测量方法，分为四大场景：

------

### 📊 **一、基础测量方法**

1. **离线日志统计**

   - **原理**：分析服务器日志（如Nginx、Tomcat访问日志），统计单位时间内的请求量。

   - 

     步骤

     ：

     - 提取日志中的请求时间戳（例如`grep 'GET /api' access.log | cut -d ' ' -f4 | uniq -c`）[2](@ref)；
     - 按秒/分钟聚合请求数，公式：`QPS = 总请求数 / 时间窗口（秒）`[1](@ref)；

   - **适用场景**：历史数据分析、非实时监控。

2. **压力测试工具**（推荐）

   - 

     工具选择

     ：

     - **JMeter**：通过`聚合报告（Aggregate Report）`的`Throughput`字段直接获取QPS[3,8](@ref)；
     - **wrk/ab**：命令行工具，结果中的`Requests/sec`即QPS（如`wrk -t12 -c400 -d30s http://api`）[6,4](@ref)。

   - 

     关键配置

     ：

     - 设置并发线程数（`-c`）、测试时长（`-d`）；
     - 使用**常量吞吐量定时器**（JMeter）控制请求速率[3](@ref)。

------

### ⏱️ **二、实时监控场景**

1. **代码埋点 + 时间窗口算法**

   - 

     滑动窗口实现

     ：

     - 用环形数组（Ring Buffer）分桶存储，每200ms一个桶，记录请求计数[5](@ref)；

     - 每秒聚合最近5个桶的数据（窗口=1秒），计算实时QPS：

       ```
       QPS = (桶ₜ计数总和) / 1.0
       ```

   - **开源组件**：阿里Sentinel、Google Guava RateLimiter均采用此算法[5,2](@ref)。

2. **监控系统集成**

   - 

     Prometheus + Grafana

     ：

     - 代码中调用`Counter.Inc()`打点；
     - PromQL查询：`rate(api_requests_total[1s])`[5](@ref)；

   - **优势**：动态可视化、告警联动。

------

### ⚙️ **三、分布式系统测量**

- 

  集群QPS计算

  ：

  ```
  \text{集群QPS} = \sum(\text{单实例QPS}) \times \text{负载均衡效率系数（通常0.8~0.95）}
  ```

- 

  注意事项

  ：

  - 需聚合所有节点日志（如ELK Stack）[2](@ref)；
  - 排除健康检查等非业务请求[4](@ref)。

------

### 🧪 **四、测量实践建议**

1. **参数配置原则**：

   - 测试时长≥5分钟，避免瞬时波动[4](@ref)；
   - 并发线程数逐步增加，观察吞吐量拐点（响应时间陡增时停止）[3](@ref)。

2. **典型QPS范围参考**：

   | 服务类型            | 单实例QPS范围  | 优化方向               |
   | ------------------- | -------------- | ---------------------- |
   | 数据库读写（MySQL） | 100~5,000      | 缓存/分库分表[7](@ref) |
   | 内存计算（Redis）   | 10,000~100,000 | 无锁结构[7](@ref)      |
   | API网关（Nginx）    | 100,000+       | 负载均衡[7](@ref)      |

3. **误差处理**：

   - 压力测试结果通常比理论值低20%~30%（因GC、线程切换）[2](@ref)；
   - 对比多工具结果（如JMeter vs. wrk）交叉验证[6,8](@ref)。

------

### 💎 **总结**

- **快速验证**：用`wrk/ab`压测，直接获取`Requests/sec`；
- **长期监控**：集成Prometheus，实时分析`rate()`曲线；
- **高精度要求**：实现滑动窗口算法（200ms分桶）或使用Sentinel等组件。

> 💡 提示：测量时需明确场景（单机/集群）、时间粒度（秒级/分钟级），并排除非业务流量。实际QPS受数据库、网络、代码逻辑影响，需结合瓶颈分析优化[4,7](@ref)。

## JMeter

JMeter 是由 Apache 软件基金会开发的开源性能测试工具，主要用于对 Web 应用、API、数据库、消息队列等系统进行压力测试、负载测试和功能测试。以下从核心功能、架构、使用流程、高级特性及最佳实践等方面详细介绍：

------

### ⚙️ **一、核心功能与特性**

1. **多协议支持**

   - **Web/API**：HTTP/HTTPS（REST、SOAP、GraphQL）[1,3](@ref)。
   - **数据库**：JDBC（MySQL、Oracle 等）[1,8](@ref)。
   - **消息中间件**：JMS、Kafka、MQTT[1,3](@ref)。
   - **其他**：FTP、TCP、SMTP、LDAP 等[3,8](@ref)。

2. **高并发模拟**

   - 

     线程组（Thread Group）

     ：定义虚拟用户数（线程数）、启动时间（Ramp-Up）、循环次数

     2,6

     。

     - *示例*：100 线程 + 10 秒 Ramp-Up = 每秒启动 10 个用户[6,10](@ref)。

   - **分布式测试**：通过 Master-Slave 架构联合多台机器突破单机并发限制[1,3](@ref)。

3. **测试元件丰富**

   - **取样器（Sampler）**：发送请求（如 HTTP Request）[3,8](@ref)。
   - **监听器（Listener）**：收集结果（聚合报告、响应时间图）[2,6](@ref)。
   - **逻辑控制器**：循环、条件判断（如 If Controller）[8](@ref)。
   - **断言（Assertion）**：验证响应（状态码、JSON 字段）[3,8](@ref)。

4. **动态数据处理**

   - **参数化**：CSV 文件、随机变量生成测试数据[3,7](@ref)。
   - **关联（Correlation）**：正则表达式/JSON 提取器从响应中提取动态值（如 Token）[3,8](@ref)。

------

### 🧱 **二、架构与核心组件**

| **组件**               | **作用**                   | **常用类型**                                              |
| ---------------------- | -------------------------- | --------------------------------------------------------- |
| 测试计划（Test Plan）  | 顶层容器，管理所有测试元件 | 全局变量配置[3,8](@ref)                                   |
| 线程组（Thread Group） | 定义并发用户行为           | 普通线程组、setUp/tearDown 线程组（预/后处理）[6,8](@ref) |
| 取样器（Sampler）      | 发送协议请求               | HTTP请求、JDBC请求、SOAP请求[3,8](@ref)                   |
| 监听器（Listener）     | 结果可视化                 | 聚合报告（Throughput、RT）、结果树（请求详情）[2,6](@ref) |
| 定时器（Timer）        | 控制请求间隔               | 固定定时器、同步定时器（模拟瞬时并发）[6,8](@ref)         |
| 前置/后置处理器        | 请求前后执行逻辑           | JSON提取器、BeanShell脚本（动态加密）[1,3](@ref)          |

------

### 🛠️ **三、安装与配置**

1. 

   环境要求

   

   - Java 8+ 环境，官网下载解压即用（无需安装）[5,7](@ref)。

2. 

   语言设置

   

   - 修改 `bin/jmeter.properties`：`language=zh_CN` 切换中文[7,10](@ref)。

3. 

   启动方式

   

   - **GUI模式**：调试脚本（双击 `jmeter.bat`）[5,7](@ref)。

   - 

     命令行模式

     ：正式压测（资源消耗低）：

     ```
     jmeter -n -t test.jmx -l result.jtl -e -o ./report
     ```[2,7](@ref)
     ```

------

### 📊 **四、测试设计与执行流程**

1. 

   创建测试计划

   

   - 右键测试计划 → 添加线程组 → 设置线程数、Ramp-Up、循环次数[9,10](@ref)。

2. 

   添加请求与配置

   

   - 线程组下添加 **HTTP 请求**：配置 URL、方法（GET/POST）、参数/消息体[9,10](@ref)。
   - 使用 **HTTP Cookie 管理器** 处理会话（如登录态）[2,8](@ref)。

3. 

   结果监听与断言

   

   - 添加 **聚合报告**：查看吞吐量（Throughput=QPS）、平均响应时间、错误率[6,9](@ref)。
   - 添加 **响应断言**：验证状态码是否为 200[3,8](@ref)。

4. 

   运行与分析

   

   - 命令行启动测试，生成 HTML 报告（包含响应时间分布、TPS 趋势）[2,7](@ref)。

------

### 🚀 **五、高级功能**

1. 

   分布式测试

   

   - 

     配置步骤

     ：

     1. 主控机（Master）修改 `jmeter.properties` 添加 Slave IP[1,3](@ref)。
     2. Slave 机启动 `jmeter-server`[1](@ref)。
     3. Master 选择 "Remote Start" 触发多机压测[3](@ref)。

2. 

   脚本扩展

   

   - 

     BeanShell/Groovy

     ：动态生成参数（如时间戳用户名）

     1,3

     ：

     ```
     vars.put("username", "user_" + System.currentTimeMillis());
     ```

3. 

   CI/CD 集成

   

   - 

     Jenkins 流水线

     ：自动化执行性能测试

     1,7

     ：

     ```
     jmeter(testPlan: 'test.jmx', generateReports: true)
     ```

------

### ⚠️ **六、优缺点与适用场景**

| **维度**     | **说明**                                                     |
| ------------ | ------------------------------------------------------------ |
| **优点**     | ✅ 开源免费、跨平台、多协议支持、插件生态丰富（如 WebSocket）[1,3](@ref)。 |
| **缺点**     | ❌ GUI 模式资源消耗大、学习曲线陡峭、实时监控弱（需整合 Prometheus）[1,3](@ref)。 |
| **典型场景** | - Web 高并发测试（电商秒杀） - API 吞吐量测量 - 数据库查询压测（JDBC） - 持续集成回归测试[1,3](@ref)。 |

------

### 💎 **七、最佳实践**

1. 

   避免 GUI 压测

   

   - 命令行执行减少资源占用，提升压测精度[1,7](@ref)。

2. 

   参数化与关联

   

   - 使用 CSV 文件分离测试数据，正则表达式提取动态 Token[3,7](@ref)。

3. 

   结果分析优化

   

   - **吞吐量瓶颈**：若 Throughput 不随线程数增长，需检查数据库/代码性能[6,9](@ref)。
   - **错误率阈值**：>1% 需定位原因（如超时、资源不足）[6](@ref)。

------

### 💎 **总结**

JMeter 是企业级性能测试的核心工具，尤其适合**复杂场景模拟**（如分布式压测、动态参数化）和**多协议覆盖**需求。对于轻量级 API 测试可选用 Locust/Gatling；若追求企业级支持，LoadRunner 是替代方案[1,3](@ref)。
​**学习建议**​：从基础线程组+HTTP请求入手，逐步进阶参数化、分布式和CI集成，结合聚合报告与HTML可视化精准定位性能瓶颈。

## Sentinel

是的，Sentinel **完全具备测量QPS（每秒查询率）的能力**，并且这是其流量控制的核心功能之一。以下是Sentinel实现QPS测量的原理、方式和应用场景的详细说明：

------

### ⚙️ **一、QPS测量原理：滑动时间窗口算法**

Sentinel 通过**滑动时间窗口算法**精确统计单位时间内的请求量，其核心设计如下：

1. **时间窗口划分**
   - 使用一个循环数组（如长度为2）表示时间窗口，每个窗口称为一个“桶”（Bucket），每个桶记录固定时长（如500ms）内的请求数据[2,6](@ref)。
   - 例如：统计1秒内的QPS时，窗口包含两个500ms的桶，通过滚动覆盖实现秒级统计。
2. **统计维度**
   - **毫秒级窗口**：用于实时限流判断（如快速失败规则）。
   - **秒级/分钟级窗口**：用于监控日志和仪表盘展示，例如每分钟60个1秒窗口[4,6](@ref)。
3. **数据记录**
   每个Bucket存储以下关键指标：
   - `passQps`：通过的请求数
   - `blockQps`：被限流的请求数
   - `successQps`：成功完成的请求数
   - `rt`（Response Time）：请求响应时间[6](@ref)。

------

### 📊 **二、如何获取QPS数据？**

1. **控制台实时监控**
   Sentinel Dashboard 直接展示每个资源的实时QPS、阻塞QPS、异常率等数据，支持动态刷新[1](@ref)。

2. **日志文件输出**
   Sentinel 会生成秒级监控日志（路径：`${user_home}/logs/csp/${app_name}-${pid}-metrics.log`），格式示例：

   ```
   时间戳|格式化时间|资源名|passQps|blockQps|successQps|异常数|平均RT  
   ```

   例如：`1568253804000|2019-09-12 10:03:24|orderService|15|2|15|0|5` 表示该秒内通过15次请求，阻塞2次[4](@ref)。

3. **API接口查询**
   通过 `ClusterNode` 对象可编程获取QPS：

   ```
   ClusterNode node = ClusterBuilderSlot.getClusterNode("资源名");
   long passQps = node.passQps(); // 当前秒通过QPS
   long blockQps = node.blockQps(); // 当前秒限流QPS
   ```

------

### ⚠️ **三、注意事项与常见问题**

1. **QPS统计误差问题**
   - 在高并发场景下，若请求跨越两个时间窗口（如1秒末尾的请求延迟到下一秒统计），可能导致日志中QPS未达阈值却被限流[4](@ref)。
   - **解决方案**：确保统计窗口对齐（如使用相同时间戳同步多维统计）。
2. **性能损耗**
   Sentinel 的QPS统计对性能影响极小，单机QPS低于25万时损耗可忽略（约5%~10%影响出现在超高并发场景）[3](@ref)。

------

### 🛠️ **四、扩展应用：基于QPS的流量控制**

Sentinel 不仅测量QPS，还能基于QPS实施动态控制：

1. **流量控制规则**

   - 设置QPS阈值（如20/s），超出时触发限流（快速失败、预热、排队）。

   - 示例规则配置：

     ```
     FlowRule rule = new FlowRule("orderService");
     rule.setCount(20); // QPS阈值=20
     rule.setGrade(RuleConstant.FLOW_GRADE_QPS);
     ```

2. **熔断降级**
   当QPS激增导致慢调用比例或异常率超标时，自动熔断服务[2](@ref)。

------

### 💎 **总结**

- **测量能力**：Sentinel 通过滑动窗口精确统计QPS，支持实时监控、日志输出和API查询。
- **核心价值**：不仅是测量工具，更是基于QPS实现流量控制、熔断降级的治理框架[1,2](@ref)。
- **适用场景**：微服务接口限流、网关层流量整形（如Nginx+Sentinel Sidecar）[1](@ref)、压测性能分析[3](@ref)。

如需深度集成，建议结合控制台和日志分析，并注意高并发下的窗口同步问题。

## 压力测试

Sentinel 和 JMeter 的核心定位存在本质差异：**Sentinel 无法直接替代 JMeter 进行流量模拟和压力测试**，但它能通过与压测工具结合，在压力测试中实现精准的流量治理与监控。以下是具体分析：

------

### ⚙️ **一、核心能力对比**

| **能力维度**     | **Sentinel**                                 | **JMeter**                                          |
| ---------------- | -------------------------------------------- | --------------------------------------------------- |
| **流量生成**     | ❌ 无法主动模拟请求                           | ✅ 通过线程组、定时器等模拟高并发流量                |
| **QPS压力测试**  | 仅被动统计实时QPS，不生成压力[1,5](@ref)     | ✅ 核心功能，可精确控制并发量、持续时间等[7,9](@ref) |
| **限流熔断控制** | ✅ 核心功能（如QPS阈值、熔断策略）[1,5](@ref) | ❌ 需依赖外部组件（如集成Sentinel）                  |
| **监控分析**     | ✅ 实时展示QPS、阻塞量、异常率等[1,2](@ref)   | ✅ 通过监听器收集吞吐量、响应时间等[7](@ref)         |

**结论**：

- **JMeter** 是专业的**压力测试工具**，用于模拟流量、制造系统压力。
- **Sentinel** 是**流量治理组件**，用于在真实流量或测试流量中实施防护策略（如限流熔断），并监控系统表现。

------

### 🔧 **二、Sentinel在压力测试中的辅助价值**

虽然无法主动生成流量，但Sentinel在压力测试中扮演关键角色：

1. **实时QPS监控与验证**
   - 在JMeter压测过程中，Sentinel可实时统计接口的**实际QPS**、**被限流请求数**、**熔断状态**等，帮助验证系统是否达到预期吞吐量[1,6](@ref)。
   - 例如：通过控制台查看 `orderService` 的QPS是否稳定在预设阈值（如1000/s）[2](@ref)。
2. **动态规则触发测试**
   - 结合JMeter的高并发请求，测试Sentinel的**限流规则**（如QPS阈值）和**熔断策略**（如慢调用比例）是否按预期生效[4,6](@ref)。
   - 示例：当JMeter发送2000 QPS时，观察Sentinel是否拦截超阈值的请求（返回429状态码）[2,5](@ref)。
3. **系统保护策略验证**
   - 通过压测触发Sentinel的**系统自适应规则**（如CPU >80%时自动限流），验证系统在资源瓶颈下的自我保护能力[5,6](@ref)。

------

### 🛠️ **三、联合使用方案：JMeter + Sentinel**

若需实现“模拟流量 + 精准防护”的完整测试流程，可组合使用：

1. **JMeter模拟流量**

   - 配置线程组、HTTP请求采样器，模拟目标QPS（如5000请求/秒）[7,9](@ref)。

   - 使用命令行模式执行压测，避免GUI资源消耗：

     ```
     jmeter -n -t test.jmx -l result.jtl -e -o ./report
     ```

2. **Sentinel监控与拦截**

   - 在应用中集成Sentinel，为接口配置规则（如QPS≤1000）[2,6](@ref)。
   - 通过控制台实时观察：
     - 实际QPS vs 限流阈值；
     - 被拒绝请求的比例；
     - 熔断器状态（OPEN/HALF_OPEN/CLOSED）[1,5](@ref)。

3. **结果综合分析**

   - 对比JMeter的聚合报告（吞吐量、错误率）与Sentinel的监控日志，定位性能瓶颈：
     - 若JMeter显示高错误率，而Sentinel显示限流触发 → 需调整QPS阈值；
     - 若Sentinel触发熔断但JMeter未报错 → 检查熔断策略是否过敏感[4,6](@ref)。

------

### ⚠️ **四、注意事项**

1. **Sentinel的被动性**
   Sentinel 的统计依赖于真实流量，若需测试冷启动场景（如系统空载时突发流量），仍需JMeter等工具模拟[1,5](@ref)。
2. **资源消耗**
   Sentinel的滑动窗口统计（如500ms分桶）会占用少量CPU，在超高性能测试中（如QPS>20万）需评估影响[5](@ref)。

------

### 💎 **总结**

- **🚫 不能替代**：Sentinel 无法像 JMeter 一样主动生成压力流量。
- **✅ 必须配合**：在压力测试中，**用JMeter制造压力**，**用Sentinel实施防护并监控效果**，两者互补可验证系统在高并发下的稳定性与韧性[3,4,6](@ref)。
- **进阶场景**：对于云原生架构，可结合 **Kubernetes + JMeter分布式压测 + Sentinel集群限流**，实现全链路压力测试与治理验证[5](@ref)。
