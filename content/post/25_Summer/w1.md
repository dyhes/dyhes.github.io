---
title: 【BE】Review Week1
date: 2025-07-03 00:00:00+0000
categories: 
- arts
- willow
---
## JUC

JUC 在 Java 领域通常指 **`java.util.concurrent` 并发工具包**（Java Utility Concurrency），而非其他含义（如某些搜索结果中提到的通信接口或扩展平台）。以下是其核心解析：


------
### ⚙️ JUC 的本质

JUC 是 Java 标准库中用于**简化多线程编程**的核心工具包，由 Doug Lea 设计并贡献。它从 **JDK 1.5** 开始引入，提供了高效、安全的并发控制机制，显著提升了多线程程序的性能和可靠性[1,5](@ref)。


------
### 🧩 核心组件与功能

JUC 包含五大类工具，覆盖并发编程的常见需求：
1. **🔒 锁机制（`java.util.concurrent.locks`）**
   - **功能**：替代传统的 `synchronized` 关键字，提供更灵活的锁控制。
   - 典型工具：
     - `ReentrantLock`：可重入锁，支持公平/非公平策略。
  - `ReadWriteLock`：读写分离锁，提升读多写少场景的性能[5](@ref)。
     - `StampedLock`：乐观读锁，减少读写冲突。
2. **⚛️ 原子操作类（`java.util.concurrent.atomic`）**
   - **功能**：通过 **CAS（Compare-And-Swap）** 指令实现无锁线程安全操作，避免阻塞开销。
   - 典型工具：
     - `AtomicInteger`、`AtomicLong`：基础数值的原子更新。
     - `LongAdder`：高并发下的累加器优化[1,5](@ref)。
3. **🚦 同步工具（`java.util.concurrent`）**
   - **功能**：协调多线程的执行顺序。
   - 典型工具：
     - `CountDownLatch`：等待指定数量任务完成（一次性）。
     - `CyclicBarrier`：多线程到达屏障后同步继续（可重用）。
     - `Semaphore`：控制并发资源访问数量[1,5](@ref)。
4. **📦 并发容器（`java.util.concurrent`）**
   - **功能**：替代传统集合（如 `HashMap`），提供线程安全的存储结构。
   - 典型工具：
     - `ConcurrentHashMap`：分段锁实现的线程安全 Map。
     - `CopyOnWriteArrayList`：写时复制 List，读操作无锁[5](@ref)。
5. **🧵 线程池框架（`java.util.concurrent`）**
   - **功能**：管理线程生命周期，避免频繁创建/销毁开销。
   - **核心接口**：`ExecutorService`、`ScheduledExecutorService`。
   - 实现类：
     - `ThreadPoolExecutor`：可定制核心参数（核心线程数、队列策略等）。
     - `ForkJoinPool`：分治算法专用池，支持工作窃取（Work-Stealing）[1,5](@ref)。


------
### 💡 解决的问题

JUC 主要应对多线程场景中的三类问题：
1. **线程安全**：通过原子类、锁、并发容器保证数据一致性。
2. **性能瓶颈**：减少锁竞争（如 CAS 替代阻塞锁）、优化资源利用（线程池复用）。
3. **协作控制**：同步工具协调任务执行顺序，避免复杂的手动等待/唤醒逻辑[1,5](@ref)。


------
### ⚡ 典型应用场景

| **场景**         | **JUC 工具**                         | **案例**                         |
| ---------------- | ------------------------------------ | -------------------------------- |
| 高并发计数器     | `AtomicInteger`、`LongAdder`         | 秒级请求量统计                   |
| 资源池管理       | `Semaphore`                          | 数据库连接池限流                 |
| 批量任务并行处理 | `CountDownLatch` + `ExecutorService` | 多接口数据聚合后返回             |
| 缓存更新         | `ConcurrentHashMap`                  | 热点数据缓存                     |
| CPU 密集型计算   | `ForkJoinPool`                       | 大规模数组排序/矩阵运算[5](@ref) |


------
### ⚠️ 澄清：与其他“JUC”术语的区别

部分搜索结果（如 `Java Uniform Classes` 或 `Java Extension Platform`）与 Java 并发工具包 **无关**，可能是特定领域术语或误解：
- **通信接口类定义**：用于跨平台通信（如[2,3](@ref)），与并发编程无关。
- **扩展平台**：指插件管理系统（如[4](@ref)），属于开发工具链范畴。
  ​**在 Java 开发中提及 JUC，默认指向 `java.util.concurrent` 包**。


------
### 💎 总结

JUC 是 Java 处理高并发的基石，通过原子操作、高效锁、线程池等工具，将开发者从复杂的线程同步问题中解放，同时兼顾性能与安全性。**对于 Java 工程师，掌握 JUC 是构建高性能服务的必备技能**。可通过官方文档或源码（如 `ReentrantLock` 的 CAS 实现）进一步深入[1,5](@ref)。
## git ammend

`git commit --amend` 是 Git 中用于修改最近一次提交的核心命令，它通过替换原提交而非创建新提交来保持版本历史的整洁性。以下从核心原理到进阶技巧的全面解析：


------
### 🔄 **核心原理与工作机制**

1. **修改机制**
   - `amend` 会生成一个**新的提交对象**（新哈希值），原提交被移除但暂存于 Git 的引用日志（`reflog`），默认保留 30 天，可通过 `git reflog` 查看历史操作记录[1,7,9](@ref)。
   - 工作流程：
     ```
     git add missed_file.txt       # 添加遗漏文件到暂存区
     git commit --amend --no-edit  # 合并到上一提交，不修改提交信息
     ```
2. **适用限制**
   - 仅作用于**最近一次提交**（`HEAD`），如需修改历史提交需结合 `rebase`[2,7](@ref)。


------
### ⚙️ **核心应用场景**

| **场景**         | **命令示例**                                     | **说明**                                  |
| ---------------- | ------------------------------------------------ | ----------------------------------------- |
| **修正提交信息** | `git commit --amend`                             | 打开编辑器修改拼写错误或描述[2,4](@ref)   |
| **添加遗漏文件** | `git add file.txt; git commit --amend --no-edit` | 将漏提交的文件合并到上一提交[1,3](@ref)   |
| **敏感数据撤回** | 删除文件后执行 `amend`                           | 清除误提交的密钥或配置文件[1](@ref)       |
| **合并零碎提交** | 配合 `git reset --soft HEAD~2` + `amend`         | 将多次小提交合并为完整功能单元[4,7](@ref) |


------
### 🛠️ **具体操作指南**

#### **基础操作流程**

1. **修改提交信息**
   ```
   git commit --amend  # 打开默认编辑器（如 Vim/Nano）修改信息
   ```
   **编辑器操作速查**：
   | 编辑器 | 保存命令       | 退出命令   | 强制退出             |
   | ------ | -------------- | ---------- | -------------------- |
   | Vim    | `:w`           | `:q`       | `:q!`                |
   | Nano   | `Ctrl+O`+Enter | `Ctrl+X`   | `Ctrl+C` → `y`       |
   | VSCode | `Ctrl+S`       | 关闭标签页 | 关闭窗口 [1,7](@ref) |
2. **添加文件到上一提交**
   ```
   git add forgotten.py   # 暂存遗漏文件
   git commit --amend      # 将文件合并到上一提交
   ```


------
### ⚡️ **高级使用技巧**

1. **修改历史提交**
   通过交互式变基（`rebase`）修改非最近提交：
   ```
   git rebase -i HEAD~3       # 选择要修改的提交，标记为 `edit`
   git commit --amend         # 修改提交内容或信息
   git rebase --continue      # 继续变基流程[1,7](@ref)
   ```
2. **修改元数据**
   - **更新作者信息**：`git commit --amend --author="New Name <email@example.com>"`
   - **重置提交时间**：`git commit --amend --date="2025-01-01T12:00:00"`[2,7](@ref)。
3. **自动化脚本**
   示例：自动修正提交信息中的日期格式：
   ```
   #!/bin/bash
   NEW_MSG=$(git log -1 --pretty=%B | sed 's/Date:/时间:/g')
   git commit --amend -m "$NEW_MSG"[7](@ref)
   ```


------
### ⚠️ **注意事项与最佳实践**

1. **强制推送风险**
   - 若已推送原提交，需强制覆盖远程：`git push --force-with-lease`（比 `-f` 更安全，避免覆盖他人提交）[1,4,7](@ref)。
   - 团队协作时
     ：必须同步仓库状态，并在主分支设置保护规则：
     ```
     git config receive.denyNonFastForwards true  # 禁止非快进式推送[1](@ref)
     ```
2. **灾难恢复**
   - 误操作后通过
     ```
     reflog
     ```
     恢复：
     ```
     git reflog                  # 查看操作历史，定位原提交哈希
     git reset --hard HEAD@{2}    # 回退到指定操作前状态[1,9](@ref)
     ```
3. **最佳实践**
   - **仅本地未推送提交使用 `amend`**，避免历史重写引发协作冲突[3,7](@ref)。
   - 重要修改前创建备份分支：`git branch backup-branch`[7](@ref)。


------
### 🖥️ **可视化工具支持**

- **VSCode + GitLens**：
  右键提交记录 → “Amend Commit”，图形化编辑文件与提交信息[1,7](@ref)。
- **GitKraken**：
  拖拽文件到指定提交区域，双击提交信息直接编辑[7](@ref)。


------
### 💎 **总结**

`git commit --amend` 是优化本地提交历史的利器，**适用于修正未推送的提交**。关键要点：
- **本地优先**：避免修改已推送提交，强制推送需团队协商。
- **灵活组合**：结合 `add`、`reset` 或 `rebase` 处理复杂场景。
- **安全兜底**：善用 `reflog` 和备份分支降低操作风险。
  通过规范使用，可显著提升版本管理的效率与整洁性！
## CAs

CAS（Compare-And-Swap）这一术语在计算机科学中通常指代 **“Compare and Swap”（比较并交换）**，这是其最本质的定义，描述了一种**硬件级别的原子操作机制**。而在Java编程语境下，开发者更常见到的是 **“Compare and Set”（比较并设置）**，这实际上是Java API对底层CAS操作的封装命名。以下是具体分析：


------
### 🔍 **本质概念：Compare and Swap（比较并交换）**

- 硬件级操作：
  CAS是CPU提供的一种原子指令（如x86架构的
  ```
  CMPXCHG
  ```
  指令），用于实现无锁并发。其操作包含三个参数：
  - **内存位置（V）**：需要修改的共享变量地址。
  - **预期原值（A）**：线程认为变量当前应有的值。
  - **新值（B）**：若变量值等于A，则更新为B。
    若`V == A`，则原子性地将`V`更新为`B`，否则不执行操作[1,3,7](@ref)。
- **核心目的**：
  在多线程环境下，无需加锁即可实现变量的原子更新，避免线程阻塞和上下文切换开销[4,9](@ref)。


------
### ☕ **Java实现：Compare and Set（比较并设置）**

- API层面的命名：
  在Java中，
  ```
  java.util.concurrent.atomic
  ```
  包下的原子类（如
  ```
  AtomicInteger
  ```
  ）提供了名为 **
  ```
  compareAndSet()
  ```
  ** 的方法。例如：
  ```
  AtomicInteger atomicInt = new AtomicInteger(0);
  boolean success = atomicInt.compareAndSet(0, 1); // 若当前值为0，则更新为1
  ```
  该方法底层调用
  ```
  Unsafe.compareAndSwapInt()
  ```
  ，映射到CPU的CAS指令
  5,10
  。
- **设计意图**：
  “Set”更贴近开发者视角，强调“设置新值”的动作，而“Swap”更侧重底层交换机制。Java的命名是为了更直观地表达其行为[8,10](@ref)。


------
### 🔧 **两者关系：同一机制的不同表述**

| **维度**     | **Compare and Swap**         | **Compare and Set**                   |
| ------------ | ---------------------------- | ------------------------------------- |
| **定义层级** | 硬件指令（如CPU的`CMPXCHG`） | Java API方法名（如`compareAndSet()`） |
| **核心动作** | 比较内存值并交换为新值       | 比较内存值并设置为新值                |
| **使用场景** | 描述通用计算机原理           | Java并发编程中的具体实现              |
| **代表实例** | CPU指令集、无锁算法设计      | `AtomicInteger.compareAndSet()`       |
**简言之**：
- **“Swap”是底层操作的本质**（如内存值的交换）[3,7](@ref)；
- **“Set”是Java对它的封装命名**，更符合开发者对“更新变量”的直觉[5,10](@ref)。


------
### ⚙️ **为何Java选择“Set”而非“Swap”？**

- **语义更明确**：
  Java的原子类方法（如`getAndSet()`、`compareAndSet()`）强调“设置值”的结果导向，而非底层交换细节[5,8](@ref)。
- **避免歧义**：
  “Swap”可能被误解为两个变量的互换（如`swap(a, b)`），而“Set”更清晰指向单变量更新[10](@ref)。


------
### 💎 总结

- **通用术语**：在计算机体系结构、操作系统和无锁算法中，**CAS始终指“Compare and Swap”**，描述硬件级原子操作[1,3,7](@ref)。
- **Java语境**：开发者实际调用的方法是 **`compareAndSet()`**，这是Java对CAS机制的API封装，两者本质相同但命名侧重不同[5,8,10](@ref)。
因此，若讨论底层原理，用 **Compare and Swap**；若写Java代码，用 **Compare and Set**，无需纠结术语差异。