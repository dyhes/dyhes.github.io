---
title: 【BE】Interview
date: 2025-07-09 00:00:00+0000
draft: true
categories: 
- arts
- willow
---
## 算力大陆

7.4 沟通
7.7 发送简历
### 9 一面 45min

1. 介绍
   产品实习？
2. 防止恶意攻击
3. JWT 源码
4. 前端服务
5. DNS
6. @Mapping 细节
7. AOP
8. 索引
9. 数据库操作
10. 数据库连接参数
11. 数据库模糊查询
12. 修改数据库表结构
13. 10亿个数找前20个
建议：
细节+源码
### 10 二面 30min

1. 介绍
   优化
2. 最有挑战性的点
3. 最大的挑战
4. 如何解决问题
5. 为什么使用 XXL-JOB
6. XXL-JOB 高可用原理
7. 高性能投票
8. Redis缓存
9. 缓存穿透和缓存雪崩
10. Redis一致性
11. 为什么使用 Spring Cloud
12. ES索引优化
13. 如何解决
14. AI的使用
15. 对于AI的看法
7.11 oc
## BDA China

7.10 沟通 + 发送简历 + 笔试
7.11 约面
### 14 一面

1

* 第K大的数
* 台阶 x 2
* 1-1亿素数
2
* 实习经历
* 项目经历
3
* 发展方向
* 实际工作内容介绍
* 对岗位的兴趣程度
* 优缺点
7.15 oc
## 字节飞书

7.10 投递
7.14 约面
### 15 一面

1. 最小路径和
2. 麻将胡牌
    当天约二面
### 21 二面

表达时避免「额...」

回避不擅长的领域

不要有杂音

1. 自我介绍
2. 博客网址
3. 百度实习经历（比较有挑战的事情）
   * 如流知识库文档智能导入解析
   * 业务结构（生成与文档层级结构对应的目录结构）
   * 为什么不直接通过代码（首先解决普及问题，代码是下一步的计划）
   * 怎么做的，难点（前后端联调，线上本地差异首先排查环境变量）
4. 前后端选择（学生时期试错成本低时，多尝试不同方向 + Vibe Coding 时代，掌握多方面的知识，能够把握 coding 方向也是一个重要技能）
5. 详细介绍论文
   * 出发点
   *  冷热数据工业界实践（时间） 
   * 学界思路
   *  为什么要这么做，动机（更加精确）
   * 验证（生成模拟数据）
6. 对 AI 的了解和尝试
   * 大模型的了解（开源大模型gemma）
   * CCF-A （稀疏矩阵优化 LightGBM）

算法题

* 回溯

## Shopee

7.15 投递约面
### 17 一面

1. 自我介绍
2. 实习介绍
3. 智能代码生成
4. 智能搜索如何实现
   * AI 智能总结
   * ES存储匹配
5. 活跃度程度
   * 前端埋点
   * 后端大数据 MapReduce
6. B+ 树索引
   * B 树索引
   * Hash 索引
7. TCP、UDP
   * 可靠如何保证
8. 服务注册发现
9. 负载均衡
10. ES的搜索
11. 为什么使用多级缓存
12. Redis 热点数据使用的数据结构
13. Java 
14. 线程池
15. 大数据了解
16. 实习收获

算法题

* 二分
  * 尝试用Java实现
* 数组中重复数字
反问
* 业务
* 建议、提升
### 18 二面

* equals & hashCode
* CSRF
* 自定义 AOP 注解
  * 延迟双删
* 如何保证系统高并发
  * 多级 cache
  * 计数字段
  * 用户行为聚合
* XXL-JOB注册
  * 自动配置
  算法
* LRU
  反问
* 团队规模
* 建议
### 22 三面（HR面？）

1. 自我介绍

2. 博客内容

   * 问题解决经验
   * 知识积累

3. 博客更新频率

4. 平衡写博客的精力

   本身总结也是学习的过程，每天十几二十分钟，当成日常去进行

5. 博客访问量

   自用为主，没有统计访问量

6. 百度实习经历

7. 长期职业规划

8. AI 对于研发过程的提效

9. 40亿数据1GB内存判断是否存在

   1. Bitmap
   2. Hyperloglog
   3. 布隆过滤器

10. sql并发、乐观锁

11. Java Web 掌握

12. 实习时间 出勤

反问

1. 工作内容

2. 建议

   多个解决方案

## 小红书

7.16 HR联系
7.17 约面
### 18 一面

1. 用户态 内核态
2. 共享内存
算法题
* 最长严格递增子序列
* 第K大的数
  * 排序 O(n*logn)
  * 快速选择 O(n) + O(logn)
  * 最小堆 O(n*logk)
  反问
* 团队规模
* 建议