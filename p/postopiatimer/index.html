<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='定时任务 以下是Java定时任务的常见解决方案，结合不同场景和需求从基础到高级进行分类说明：\n⏰ 基础原生方案 Timer + TimerTask\n特点：JDK自带，简单轻量，支持延迟/周期性任务。 缺陷：单线程执行，任务阻塞或异常会导致整个调度终止；系统时间修改影响调度准确性1,2,7。 示例： Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println("Task executed"); } }, 2000, 1000); // 延迟2秒，间隔1秒 ScheduledExecutorService\n特点：基于线程池（支持多任务并发），异常隔离（单任务失败不影响整体），提供scheduleAtFixedRate（固定速率）和scheduleWithFixedDelay（固定延迟）1,7,9。 优势：相比Timer更健壮，适合生产环境。 示例： ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); executor.scheduleAtFixedRate(() -> System.out.println("Task"), 2, 3, TimeUnit.SECONDS); 🔄 Spring生态方案 @Scheduled注解\n特点：Spring 3.0+内置，无需额外依赖，支持Cron表达式、固定速率（fixedRate）、固定延迟（fixedDelay）1,6,8。\n配置步骤：\n启动类加@EnableScheduling。 方法加@Scheduled(cron = "0/5 * * * * ?")。 线程池优化：\n@Bean public ThreadPoolTaskScheduler taskScheduler() { ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setPoolSize(10); // 避免单线程阻塞 return scheduler; } ScheduledExecutorFactoryBean\n'><title>【Postopia】timer</title><link rel=canonical href=https://dyhes.github.io/p/postopiatimer/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【Postopia】timer"><meta property='og:description' content='定时任务 以下是Java定时任务的常见解决方案，结合不同场景和需求从基础到高级进行分类说明：\n⏰ 基础原生方案 Timer + TimerTask\n特点：JDK自带，简单轻量，支持延迟/周期性任务。 缺陷：单线程执行，任务阻塞或异常会导致整个调度终止；系统时间修改影响调度准确性1,2,7。 示例： Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println("Task executed"); } }, 2000, 1000); // 延迟2秒，间隔1秒 ScheduledExecutorService\n特点：基于线程池（支持多任务并发），异常隔离（单任务失败不影响整体），提供scheduleAtFixedRate（固定速率）和scheduleWithFixedDelay（固定延迟）1,7,9。 优势：相比Timer更健壮，适合生产环境。 示例： ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); executor.scheduleAtFixedRate(() -> System.out.println("Task"), 2, 3, TimeUnit.SECONDS); 🔄 Spring生态方案 @Scheduled注解\n特点：Spring 3.0+内置，无需额外依赖，支持Cron表达式、固定速率（fixedRate）、固定延迟（fixedDelay）1,6,8。\n配置步骤：\n启动类加@EnableScheduling。 方法加@Scheduled(cron = "0/5 * * * * ?")。 线程池优化：\n@Bean public ThreadPoolTaskScheduler taskScheduler() { ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setPoolSize(10); // 避免单线程阻塞 return scheduler; } ScheduledExecutorFactoryBean\n'><meta property='og:url' content='https://dyhes.github.io/p/postopiatimer/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Postopia'><meta property='article:published_time' content='2025-07-02T00:00:00+00:00'><meta property='article:modified_time' content='2025-10-22T16:26:59+08:00'><meta name=twitter:title content="【Postopia】timer"><meta name=twitter:description content='定时任务 以下是Java定时任务的常见解决方案，结合不同场景和需求从基础到高级进行分类说明：\n⏰ 基础原生方案 Timer + TimerTask\n特点：JDK自带，简单轻量，支持延迟/周期性任务。 缺陷：单线程执行，任务阻塞或异常会导致整个调度终止；系统时间修改影响调度准确性1,2,7。 示例： Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { System.out.println("Task executed"); } }, 2000, 1000); // 延迟2秒，间隔1秒 ScheduledExecutorService\n特点：基于线程池（支持多任务并发），异常隔离（单任务失败不影响整体），提供scheduleAtFixedRate（固定速率）和scheduleWithFixedDelay（固定延迟）1,7,9。 优势：相比Timer更健壮，适合生产环境。 示例： ScheduledExecutorService executor = Executors.newScheduledThreadPool(2); executor.scheduleAtFixedRate(() -> System.out.println("Task"), 2, 3, TimeUnit.SECONDS); 🔄 Spring生态方案 @Scheduled注解\n特点：Spring 3.0+内置，无需额外依赖，支持Cron表达式、固定速率（fixedRate）、固定延迟（fixedDelay）1,6,8。\n配置步骤：\n启动类加@EnableScheduling。 方法加@Scheduled(cron = "0/5 * * * * ?")。 线程池优化：\n@Bean public ThreadPoolTaskScheduler taskScheduler() { ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setPoolSize(10); // 避免单线程阻塞 return scheduler; } ScheduledExecutorFactoryBean\n'><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#定时任务>定时任务</a><ol><li><a href=#-基础原生方案>⏰ 基础原生方案</a></li><li><a href=#-spring生态方案>🔄 Spring生态方案</a></li><li><a href=#-高级调度框架>⚙️ 高级调度框架</a></li><li><a href=#-方案选型建议>📊 方案选型建议</a></li><li><a href=#-避坑指南>⚠️ 避坑指南</a></li></ol></li><li><a href=#scheduledexecutorservice>ScheduledExecutorService</a><ol><li><a href=#-任务状态持久化>🛡️ <strong>任务状态持久化</strong></a></li><li><a href=#-分布式锁防重复执行>🔒 <strong>分布式锁防重复执行</strong></a></li><li><a href=#-主从节点故障切换>⚙️ <strong>主从节点故障切换</strong></a></li><li><a href=#-任务补偿与超时控制>⚠️ <strong>任务补偿与超时控制</strong></a></li><li><a href=#-方案对比与适用场景>📊 <strong>方案对比与适用场景</strong></a></li><li><a href=#-注意事项>⚠️ <strong>注意事项</strong></a></li><li><a href=#-总结>💎 <strong>总结</strong></a></li></ol></li><li><a href=#threadpooltaskscheduler>ThreadPoolTaskScheduler</a><ol><li><a href=#-框架依赖与来源>⚙️ <strong>框架依赖与来源</strong></a></li><li><a href=#-调度能力对比>⏱️ <strong>调度能力对比</strong></a></li><li><a href=#-线程池管理>🧵 <strong>线程池管理</strong></a></li><li><a href=#-异常处理与集成能力>🛠️ <strong>异常处理与集成能力</strong></a></li><li><a href=#-性能与适用场景>⚡ <strong>性能与适用场景</strong></a></li><li><a href=#-总结与选型建议>💎 <strong>总结与选型建议</strong></a></li></ol></li><li><a href=#quartz>Quartz</a><ol><li><a href=#-核心概念与组件>⚙️ **核心概念与组件</a></li><li><a href=#-架构设计>🏗️ <strong>架构设计</strong></a></li><li><a href=#-触发器与调度规则>⏱️ <strong>触发器与调度规则</strong></a><ol><li><a href=#simpletrigger><strong>SimpleTrigger</strong></a></li><li><a href=#crontrigger><strong>CronTrigger</strong></a></li></ol></li><li><a href=#-集群与高可用14>🌐 <strong>集群与高可用</strong>1,4</a></li><li><a href=#-企业级特性18>🧩 <strong>企业级特性</strong>1,8</a></li><li><a href=#-spring-boot-集成28>🌱 <strong>Spring Boot 集成</strong>2,8</a></li><li><a href=#-适用场景-vs-替代方案46>⚖️ <strong>适用场景 vs 替代方案</strong>4,6</a></li><li><a href=#-注意事项-1>⚠️ <strong>注意事项</strong></a></li><li><a href=#-总结-1>💎 <strong>总结</strong></a></li></ol></li><li><a href=#xxl-job>XXL-JOB</a><ol><li><a href=#-核心架构与设计思想>⚙️ <strong>核心架构与设计思想</strong></a></li><li><a href=#-核心功能与特性>🚀 <strong>核心功能与特性</strong></a></li><li><a href=#-部署与集成>🛠️ <strong>部署与集成</strong></a><ol><li><a href=#调度中心部署><strong>调度中心部署</strong></a></li><li><a href=#执行器集成spring-boot-项目><strong>执行器集成（Spring Boot 项目）</strong></a></li></ol></li><li><a href=#-适用场景与框架对比>⚖️ <strong>适用场景与框架对比</strong></a><ol><li><a href=#典型场景><strong>典型场景</strong></a></li><li><a href=#与其他框架对比><strong>与其他框架对比</strong></a></li></ol></li><li><a href=#-注意事项-2>⚠️ <strong>注意事项</strong></a></li><li><a href=#-总结-2>💎 <strong>总结</strong></a></li></ol></li><li><a href=#quartz--xxl-job>Quartz & XXL-JOB</a><ol><li><a href=#-核心架构对比>⚙️ <strong>核心架构对比</strong></a></li><li><a href=#-功能特性对比>🛠️ <strong>功能特性对比</strong></a></li><li><a href=#-适用场景对比>📊 <strong>适用场景对比</strong></a></li><li><a href=#-局限性对比>⚠️ <strong>局限性对比</strong></a></li><li><a href=#-选型建议>💎 <strong>选型建议</strong></a></li><li><a href=#-扩展能力补充>🔧 <strong>扩展能力补充</strong></a></li></ol></li><li><a href=#xxl-job-动态提交>XXL-JOB 动态提交</a><ol><li><a href=#-核心实现方式>⚙️ <strong>核心实现方式</strong></a><ol><li><a href=#通过管理界面手动创建适合临时任务><strong>通过管理界面手动创建</strong>（适合临时任务）</a></li><li><a href=#通过-api-动态提交适合程序触发><strong>通过 API 动态提交</strong>（适合程序触发）</a></li></ol></li><li><a href=#-执行器接收动态参数>🧩 <strong>执行器接收动态参数</strong></a><ol><li><a href=#bean-模式方法形式><strong>Bean 模式（方法形式）</strong></a></li><li><a href=#使用上下文对象高级><strong>使用上下文对象（高级）</strong></a></li></ol></li><li><a href=#-注意事项-3>⚠️ <strong>注意事项</strong></a></li><li><a href=#-扩展api-触发替代方案>🔧 <strong>扩展：API 触发替代方案</strong></a></li><li><a href=#-总结-3>💎 <strong>总结</strong></a></li></ol></li><li><a href=#scheduletype>scheduleType</a><ol><li><a href=#-核心调度类型scheduletype>⚙️ <strong>核心调度类型（scheduleType）</strong></a></li><li><a href=#-动态提交-api-示例>⚡ <strong>动态提交 API 示例</strong></a></li><li><a href=#-注意事项-4>⚠️ <strong>注意事项</strong></a></li><li><a href=#-总结-4>💎 <strong>总结</strong></a></li></ol></li><li><a href=#xxl-job-分布式调度>XXL-JOB 分布式调度</a><ol><li><a href=#-核心架构设计>⚙️ <strong>核心架构设计</strong></a><ol><li><a href=#调度中心admin><strong>调度中心（Admin）</strong></a></li><li><a href=#执行器executor><strong>执行器（Executor）</strong></a></li></ol></li><li><a href=#-分布式调度核心机制>🔧 <strong>分布式调度核心机制</strong></a><ol><li><a href=#任务路由与负载均衡><strong>任务路由与负载均衡</strong></a></li><li><a href=#分片任务处理><strong>分片任务处理</strong></a></li><li><a href=#高可用与容错><strong>高可用与容错</strong></a></li><li><a href=#时间轮调度算法><strong>时间轮调度算法</strong></a></li></ol></li><li><a href=#-任务执行流程>⚡ <strong>任务执行流程</strong></a></li><li><a href=#-关键优化设计>🧩 <strong>关键优化设计</strong></a></li><li><a href=#-总结-5>💎 <strong>总结</strong></a></li></ol></li><li><a href=#错误重试>错误重试</a><ol><li><a href=#-任务调度机制>⏱️ <strong>任务调度机制</strong></a><ol><li><a href=#调度中心admin的核心作用><strong>调度中心（Admin）的核心作用</strong></a></li><li><a href=#任务触发流程><strong>任务触发流程</strong></a></li><li><a href=#关键调度策略><strong>关键调度策略</strong></a></li></ol></li><li><a href=#-错误重试机制>🔁 <strong>错误重试机制</strong></a><ol><li><a href=#内置重试能力><strong>内置重试能力</strong></a></li><li><a href=#容错与故障转移><strong>容错与故障转移</strong></a></li><li><a href=#扩展重试策略结合第三方库><strong>扩展重试策略（结合第三方库）</strong></a></li><li><a href=#失败告警与日志><strong>失败告警与日志</strong></a></li></ol></li><li><a href=#-调度与重试的协同流程>⚡ <strong>调度与重试的协同流程</strong></a></li><li><a href=#-最佳实践建议>🧩 <strong>最佳实践建议</strong></a></li><li><a href=#-总结-6>💎 <strong>总结</strong></a></li></ol></li><li><a href=#执行器>执行器</a><ol><li><a href=#-添加依赖>🔧 添加依赖</a></li><li><a href=#-配置执行器参数>⚙️ 配置执行器参数</a></li><li><a href=#-注册执行器spring-bean>🧩 注册执行器Spring Bean</a></li><li><a href=#-定义任务处理器>🛠️ 定义任务处理器</a></li><li><a href=#-注意事项与高级配置>⚠️ 注意事项与高级配置</a></li><li><a href=#-执行器注册流程示意图>🔄 执行器注册流程示意图</a></li><li><a href=#-总结-7>💎 总结</a></li></ol></li><li><a href=#remove>remove</a><ol><li><a href=#-apijobinforemove-接口参数>⚙️ <code>/api/jobinfo/remove</code> 接口参数</a></li><li><a href=#-按已停止状态删除任务的步骤>🗑️ 按“已停止”状态删除任务的步骤</a></li><li><a href=#-注意事项-5>⚠️ 注意事项</a></li><li><a href=#-总结建议>💎 总结建议</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/nutrition/ style=background-color:#93b5cf;color:>积雪粮
</a><a href=/categories/willow/ style=background-color:#dc9123;color:>满城风絮
</a><a href=/categories/moon/ style=background-color:#b7ae8f;color:>月满西楼</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/postopiatimer/>【Postopia】timer</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jul 02, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>10 minute read</time></div></footer></div></header><section class=article-content><h2 id=定时任务>定时任务</h2><p>以下是Java定时任务的常见解决方案，结合不同场景和需求从基础到高级进行分类说明：</p><hr><h3 id=-基础原生方案>⏰ 基础原生方案</h3><ol><li><p><strong><code>Timer</code> + <code>TimerTask</code></strong></p><ul><li><strong>特点</strong>：JDK自带，简单轻量，支持延迟/周期性任务。</li><li><strong>缺陷</strong>：单线程执行，任务阻塞或异常会导致整个调度终止；系统时间修改影响调度准确性<a class=link href=@ref>1,2,7</a>。</li><li>示例：<pre tabindex=0><code>Timer timer = new Timer();
timer.schedule(new TimerTask() {
    @Override
    public void run() {
        System.out.println(&#34;Task executed&#34;);
    }
}, 2000, 1000); // 延迟2秒，间隔1秒
</code></pre></li></ul></li><li><p><strong><code>ScheduledExecutorService</code></strong></p><ul><li><strong>特点</strong>：基于线程池（支持多任务并发），异常隔离（单任务失败不影响整体），提供<code>scheduleAtFixedRate</code>（固定速率）和<code>scheduleWithFixedDelay</code>（固定延迟）<a class=link href=@ref>1,7,9</a>。</li><li><strong>优势</strong>：相比<code>Timer</code>更健壮，适合生产环境。</li><li>示例：<pre tabindex=0><code>ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
executor.scheduleAtFixedRate(() -&gt; System.out.println(&#34;Task&#34;), 2, 3, TimeUnit.SECONDS);
</code></pre></li></ul></li></ol><h3 id=-spring生态方案>🔄 Spring生态方案</h3><ol><li><p><strong><code>@Scheduled</code>注解</strong></p><ul><li><p><strong>特点</strong>：Spring 3.0+内置，无需额外依赖，支持Cron表达式、固定速率（<code>fixedRate</code>）、固定延迟（<code>fixedDelay</code>）<a class=link href=@ref>1,6,8</a>。</p></li><li><p>配置步骤：</p><ol><li>启动类加<code>@EnableScheduling</code>。</li><li>方法加<code>@Scheduled(cron = "0/5 * * * * ?")</code>。</li></ol></li><li><p>线程池优化：</p><pre tabindex=0><code>@Bean
public ThreadPoolTaskScheduler taskScheduler() {
    ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
    scheduler.setPoolSize(10); // 避免单线程阻塞
    return scheduler;
}
</code></pre></li></ul></li><li><p><strong><code>ScheduledExecutorFactoryBean</code></strong></p><ul><li><strong>特点</strong>：Spring对<code>ScheduledThreadPoolExecutor</code>的封装，支持XML配置线程池参数<a class=link href=@ref>1</a>。</li></ul></li></ol><hr><h3 id=-高级调度框架>⚙️ 高级调度框架</h3><ol><li><strong>Quartz</strong><ul><li><strong>特点</strong>：支持分布式调度、任务持久化（数据库存储）、动态配置（运行时修改触发规则）、集群容错<a class=link href=@ref>1,5,6</a>。</li><li>核心组件：<ul><li><code>Job</code>：任务接口。</li></ul></li><li><code>Trigger</code>：触发策略（如<code>CronTrigger</code>）。<ul><li><code>Scheduler</code>：调度控制器。</li></ul></li><li><strong>适用场景</strong>：高可靠、复杂调度（如跨节点任务分片）。</li></ul></li><li><strong>分布式调度框架</strong><ul><li><strong>XXL-JOB</strong>：开箱即用的管理界面、任务分片、失败告警；依赖MySQL，轻量级<a class=link href=@ref>5</a>。</li><li><strong>Elastic-Job</strong>：基于ZooKeeper协调，弹性扩容、作业治理；适合海量任务<a class=link href=@ref>5</a>。</li></ul></li></ol><hr><h3 id=-方案选型建议>📊 方案选型建议</h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方案</strong></th><th><strong>理由</strong></th></tr></thead><tbody><tr><td>单机简单任务</td><td><code>ScheduledExecutorService</code></td><td>轻量、线程安全，避免<code>Timer</code>单线程缺陷 <a class=link href=@ref>7</a>。</td></tr><tr><td>Spring Boot项目</td><td><code>@Scheduled</code> + 线程池配置</td><td>集成简便，Cron表达式灵活 <a class=link href=@ref>6,8</a>。</td></tr><tr><td>分布式环境/高可用</td><td>Quartz或XXL-JOB</td><td>支持任务持久化、集群调度 <a class=link href=@ref>5,6</a>。</td></tr><tr><td>秒级精度/海量任务</td><td>时间轮算法（Netty等实现）</td><td>时间复杂度O(1)，高性能 <a class=link href=@ref>2</a>。</td></tr></tbody></table></div><hr><h3 id=-避坑指南>⚠️ 避坑指南</h3><ul><li><strong>线程阻塞</strong>：避免单线程调度（如<code>Timer</code>），优先用线程池<a class=link href=@ref>7</a>。</li><li><strong>Cron语法</strong>：注意<code>?</code>（日/周互斥）和<code>L</code>（最后一天）等特殊字符<a class=link href=@ref>6</a>。</li><li><strong>分布式重复执行</strong>：通过Redis锁或框架（XXL-JOB）协调节点<a class=link href=@ref>5</a>。</li><li><strong>异常处理</strong>：任务内捕获异常，防止中断调度链<a class=link href=@ref>7</a>。
根据业务规模、可靠性要求及技术栈选择方案，轻量任务用原生或Spring，复杂分布式场景选Quartz或专用框架（如XXL-JOB）以提升可维护性<a class=link href=@ref>4,5</a>。</li></ul><h2 id=scheduledexecutorservice>ScheduledExecutorService</h2><p>在仅使用 <code>ScheduledExecutorService</code> 的前提下实现高可用（避免节点宕机导致任务丢失），需通过应用层设计弥补其单机内存调度的缺陷。以下是核心解决方案及实现要点：</p><hr><h3 id=-任务状态持久化>🛡️ <strong>任务状态持久化</strong></h3><p><strong>核心思路</strong>：将任务定义与状态存储到外部存储（如数据库、Redis），节点重启后重新加载任务。</p><ul><li>实现步骤：<ol><li><strong>任务定义存储</strong>：创建任务注册表（如MySQL表），记录任务ID、执行周期、上次执行时间、状态（未开始/执行中/已完成）<a class=link href=@ref>2,3</a>。</li><li><strong>宕机恢复</strong>：节点启动时扫描注册表，加载未完成的定时任务到 <code>ScheduledExecutorService</code><a class=link href=@ref>3</a>。</li><li>状态更新：<ul><li>任务开始前更新状态为“执行中”，并记录节点IP与时间戳；</li></ul></li></ol></li><li>任务完成后更新为“已完成”<a class=link href=@ref>7</a>。
<strong>示例代码（任务注册与加载）</strong>：</li></ul><pre tabindex=0><code>public class TaskRegistry {
    private ScheduledExecutorService scheduler;
    private Map&lt;String, ScheduledFuture&lt;?&gt;&gt; tasks = new ConcurrentHashMap&lt;&gt;();
    private TaskDao taskDao; // 数据库访问对象

    public void init() {
        List&lt;Task&gt; pendingTasks = taskDao.loadPendingTasks(); // 加载未完成任务
        pendingTasks.forEach(task -&gt; scheduleTask(task.getId(), task.getPeriod()));
    }

    public void scheduleTask(String taskId, long period) {
        Runnable task = () -&gt; {
            taskDao.markTaskRunning(taskId); // 标记为执行中
            try {
                executeBusinessLogic(); // 实际业务逻辑
                taskDao.markTaskCompleted(taskId); // 标记完成
            } catch (Exception e) {
                taskDao.resetTaskStatus(taskId); // 失败时重置状态
            }
        };
        ScheduledFuture&lt;?&gt; future = scheduler.scheduleAtFixedRate(task, 0, period, TimeUnit.SECONDS);
        tasks.put(taskId, future);
    }
}
</code></pre><hr><h3 id=-分布式锁防重复执行>🔒 <strong>分布式锁防重复执行</strong></h3><p><strong>核心思路</strong>：节点执行任务前获取分布式锁，确保集群中仅一个节点执行任务。</p><ul><li>实现方式：<ol><li><strong>Redis 锁</strong>：通过 <code>SET key value NX EX</code> 命令获取锁，设置超时时间（如30秒）<a class=link href=@ref>2,7</a>。</li><li><strong>ZooKeeper 锁</strong>：创建临时有序节点，最小节点获得锁<a class=link href=@ref>8</a>。</li></ol></li><li>执行流程：<pre tabindex=0><code>graph TD
  A[任务触发] --&gt; B{尝试获取分布式锁}
  B --&gt;|成功| C[执行业务逻辑]
  B --&gt;|失败| D[放弃执行]
  C --&gt; E[释放锁]
</code></pre></li></ul><hr><h3 id=-主从节点故障切换>⚙️ <strong>主从节点故障切换</strong></h3><p><strong>核心思路</strong>：设计主从架构，主节点宕机时从节点接管任务。</p><ul><li>实现步骤：<ol><li>主节点选举：<ul><li>使用 ZooKeeper 临时节点竞争主节点身份<a class=link href=@ref>8</a>；</li></ul></li></ol><ul><li>或通过 Redis 的 <code>SETNX</code> 抢主<a class=link href=@ref>7</a>。</li></ul></li></ul><ol start=2><li><strong>心跳检测</strong>：主节点定期更新DB/Redis中的心跳时间戳，从节点监控该时间戳，超时未更新则触发抢主<a class=link href=@ref>7</a>。</li><li><strong>任务接管</strong>：新主节点加载持久化的未完成任务并调度。
<strong>关键配置</strong>：</li></ol><ul><li>心跳间隔：≤ 任务周期的一半（如任务每分钟执行，心跳间隔设25秒）。</li></ul><hr><h3 id=-任务补偿与超时控制>⚠️ <strong>任务补偿与超时控制</strong></h3><p><strong>核心问题</strong>：任务执行中节点宕机导致状态卡在“执行中”。
​<strong>解决方案</strong>​：</p><ol><li>超时重置：<ul><li>为任务设置最大执行时长（如30分钟）；</li><li>若任务状态长期为“执行中”且超时，自动重置为“未开始”，允许其他节点重试<a class=link href=@ref>2,7</a>。</li></ul></li><li><strong>幂等性设计</strong>：业务逻辑需支持重复执行（如数据库操作加唯一索引）。</li></ol><hr><h3 id=-方案对比与适用场景>📊 <strong>方案对比与适用场景</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>方案</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>任务持久化 + 重启加载</td><td>实现简单，依赖少</td><td>宕机期间任务完全停滞</td><td>容忍分钟级延迟的任务</td></tr><tr><td>分布式锁</td><td>精确控制单节点执行</td><td>需维护锁超时，逻辑复杂</td><td>秒级任务，需严格防重</td></tr><tr><td>主从切换</td><td>故障转移快（秒级）</td><td>需实现心跳和选举机制</td><td>高可用要求严格的场景</td></tr></tbody></table></div><hr><h3 id=-注意事项>⚠️ <strong>注意事项</strong></h3><ol><li>时间精度：<ul><li><code>ScheduledExecutorService</code> 在节点时钟不同步时可能重复执行，需部署 NTP 服务同步时间<a class=link href=@ref>3</a>。</li></ul></li><li>资源隔离：<ul><li>CPU 密集型与 I/O 密集型任务使用独立线程池，避免相互阻塞<a class=link href=@ref>2</a>。</li></ul></li><li>监控告警：<ul><li>记录任务调度日志（节点IP、开始/结束时间），接入 Prometheus 监控执行成功率<a class=link href=@ref>6</a>。</li></ul></li></ol><hr><h3 id=-总结>💎 <strong>总结</strong></h3><p>仅凭 <code>ScheduledExecutorService</code> 无法原生支持高可用，需结合 <strong>持久化 + 分布式协调 + 故障转移</strong> 的混合方案：</p><ol><li><strong>轻量级场景</strong>：任务持久化到数据库 + 重启加载；</li><li><strong>严格防重场景</strong>：Redis 分布式锁 + 任务超时重置；</li><li><strong>生产高可用</strong>：主从切换（ZooKeeper/Redis 选主） + 心跳检测。</li></ol><blockquote><p>若业务规模扩大，建议迁移至 <strong>XXL-JOB</strong> 或 <strong>Quartz 集群</strong>（原生支持故障转移与持久化）<a class=link href=@ref>6,8</a>。</p></blockquote><h2 id=threadpooltaskscheduler>ThreadPoolTaskScheduler</h2><p>ThreadPoolTaskScheduler 和 ScheduledExecutorService 是 Java 中用于任务调度的两种核心工具，分别属于 <strong>Spring 框架</strong> 和 <strong>JDK 原生并发包</strong>。以下是两者的详细对比及选型建议：</p><hr><h3 id=-框架依赖与来源>⚙️ <strong>框架依赖与来源</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>ScheduledExecutorService</strong></th><th><strong>ThreadPoolTaskScheduler</strong></th></tr></thead><tbody><tr><td><strong>所属框架</strong></td><td>JDK 原生 (<code>java.util.concurrent</code>)</td><td>Spring 框架 (<code>org.springframework.scheduling</code>)</td></tr><tr><td><strong>依赖</strong></td><td>无需额外依赖</td><td>需集成 Spring 环境</td></tr><tr><td><strong>底层实现</strong></td><td><code>ScheduledThreadPoolExecutor</code> + <code>DelayedWorkQueue</code></td><td>封装 <code>ScheduledExecutorService</code>，扩展调度功能</td></tr></tbody></table></div><ul><li>说明：<ul><li><code>ScheduledExecutorService</code> 是 Java 标准库的一部分，适合非 Spring 项目<a class=link href=@ref>4,8,10</a>。</li><li><code>ThreadPoolTaskScheduler</code> 依赖 Spring 容器，提供更便捷的配置和集成能力<a class=link href=@ref>3,5,6</a>。</li></ul></li></ul><hr><h3 id=-调度能力对比>⏱️ <strong>调度能力对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>调度类型</strong></th><th><strong>ScheduledExecutorService</strong></th><th><strong>ThreadPoolTaskScheduler</strong></th></tr></thead><tbody><tr><td><strong>单次延迟任务</strong></td><td>✅ <code>schedule(task, delay, unit)</code></td><td>✅ <code>schedule(task, Date/Instant)</code></td></tr><tr><td><strong>固定速率任务</strong></td><td>✅ <code>scheduleAtFixedRate()</code></td><td>✅ <code>scheduleAtFixedRate()</code></td></tr><tr><td><strong>固定延迟任务</strong></td><td>✅ <code>scheduleWithFixedDelay()</code></td><td>✅ <code>scheduleWithFixedDelay()</code></td></tr><tr><td><strong>Cron 表达式</strong></td><td>❌ 不支持</td><td>✅ <code>schedule(task, CronTrigger)</code></td></tr><tr><td><strong>动态启停任务</strong></td><td>需手动管理 <code>ScheduledFuture</code></td><td>内置 <code>ScheduledFuture</code> 管理（支持 <code>cancel()</code>）</td></tr></tbody></table></div><ul><li>关键差异：<ul><li><strong>Cron 支持</strong>：<code>ThreadPoolTaskScheduler</code> 可直接解析 Cron 表达式，适用于复杂时间规则（如“每天 8:00 执行”）<a class=link href=@ref>3,6</a>。</li></ul></li><li><strong>动态控制</strong>：<code>ThreadPoolTaskScheduler</code> 提供更便捷的任务启停接口，适合需动态调整的场景（如数据库配置更新）<a class=link href=@ref>6</a>。</li></ul><hr><h3 id=-线程池管理>🧵 <strong>线程池管理</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>ScheduledExecutorService</strong></th><th><strong>ThreadPoolTaskScheduler</strong></th></tr></thead><tbody><tr><td><strong>线程池配置</strong></td><td>手动设置核心参数（核心线程数、队列等）</td><td>通过 Spring Bean 配置（支持依赖注入）</td></tr><tr><td><strong>线程命名</strong></td><td>需自定义 <code>ThreadFactory</code></td><td>内置 <code>setThreadNamePrefix()</code></td></tr><tr><td><strong>拒绝策略</strong></td><td>支持 <code>RejectedExecutionHandler</code></td><td>支持 Spring 任务拒绝策略（如 <code>CallerRunsPolicy</code>）</td></tr></tbody></table></div><ul><li>示例配置：ScheduledExecutorService：<pre tabindex=0><code>ScheduledExecutorService executor = new ScheduledThreadPoolExecutor(5);
</code></pre>ThreadPoolTaskScheduler（Spring 配置）：<pre tabindex=0><code>@Bean
public ThreadPoolTaskScheduler taskScheduler() {
  ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
    scheduler.setPoolSize(10);
    scheduler.setThreadNamePrefix(&#34;task-&#34;);
    return scheduler;
}
</code></pre></li></ul><h3 id=-异常处理与集成能力>🛠️ <strong>异常处理与集成能力</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>ScheduledExecutorService</strong></th><th><strong>ThreadPoolTaskScheduler</strong></th></tr></thead><tbody><tr><td><strong>异常处理</strong></td><td>任务异常仅终止当前任务，不影响线程池</td><td>支持 Spring 的 <code>ErrorHandler</code> 统一处理异常</td></tr><tr><td><strong>Spring 集成</strong></td><td>❌ 需手动整合</td><td>✅ 无缝兼容 <code>@Scheduled</code>、事件监听等机制</td></tr><tr><td><strong>任务上下文</strong></td><td>无</td><td>✅ 可访问 Spring 上下文（如 <code>@Autowired</code> 注入）</td></tr></tbody></table></div><ul><li>说明：<ul><li><code>ThreadPoolTaskScheduler</code> 在任务中可直接调用 Spring Bean，适合需要依赖注入的业务逻辑<a class=link href=@ref>3,6</a>。</li><li><code>ScheduledExecutorService</code> 需自行处理线程内 Spring 上下文（如通过 <code>ThreadLocal</code>）<a class=link href=@ref>4</a>。</li></ul></li></ul><hr><h3 id=-性能与适用场景>⚡ <strong>性能与适用场景</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐工具</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong>轻量级定时任务</strong></td><td><code>ScheduledExecutorService</code></td><td>无 Spring 依赖，资源占用低<a class=link href=@ref>8,10</a></td></tr><tr><td><strong>复杂调度（Cron）</strong></td><td><code>ThreadPoolTaskScheduler</code></td><td>原生支持 Cron 表达式，配置简洁<a class=link href=@ref>3,6</a></td></tr><tr><td><strong>动态任务管理</strong></td><td><code>ThreadPoolTaskScheduler</code></td><td>内置 <code>ScheduledFuture</code> 控制启停，适合重试机制、开关需求<a class=link href=@ref>6</a></td></tr><tr><td><strong>高并发任务</strong></td><td><code>ScheduledExecutorService</code></td><td>更底层，可精细优化线程池参数（如队列类型）<a class=link href=@ref>4,8</a></td></tr></tbody></table></div><hr><h3 id=-总结与选型建议>💎 <strong>总结与选型建议</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>维度</strong></th><th><strong>ScheduledExecutorService</strong></th><th><strong>ThreadPoolTaskScheduler</strong></th></tr></thead><tbody><tr><td><strong>灵活性</strong></td><td>⭐⭐⭐⭐（需手动实现高级调度）</td><td>⭐⭐⭐⭐⭐（开箱即用）</td></tr><tr><td><strong>Spring 集成</strong></td><td>⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>学习成本</strong></td><td>⭐⭐⭐（熟悉 JDK 并发）</td><td>⭐⭐（需 Spring 基础）</td></tr><tr><td><strong>适用项目</strong></td><td>非 Spring 应用、简单调度需求</td><td>Spring 项目、需动态任务或 Cron 的场景</td></tr><tr><td><strong>最终建议</strong>：</td><td></td><td></td></tr></tbody></table></div><ul><li><strong>非 Spring 环境</strong> ➜ 选择 <code>ScheduledExecutorService</code>，避免引入额外依赖。</li><li><strong>Spring 项目</strong> ➜ 优先使用 <code>ThreadPoolTaskScheduler</code>，尤其需动态任务或 Cron 表达式时<a class=link href=@ref>3,5,6</a>。</li><li><strong>高性能要求</strong> ➜ 两者均可优化线程池，但 <code>ScheduledExecutorService</code> 更易精细化调优<a class=link href=@ref>4,8</a>。</li></ul><h2 id=quartz>Quartz</h2><p>Quartz 是一个功能强大的开源 <strong>Java 作业调度框架</strong>，由 OpenSymphony 开源组织开发，广泛应用于 J2SE 和 J2EE 应用中。它支持从简单定时任务到复杂分布式调度的需求，适用于如定时报表生成、数据同步、系统监控等场景。以下是其核心特性和使用详解：</p><hr><h3 id=-核心概念与组件>⚙️ **核心概念与组件</h3><ol><li><strong>Job（任务）</strong><ul><li>需实现 <code>Job</code> 接口的 <code>execute()</code> 方法，定义具体任务逻辑。</li><li>每次执行时，Quartz 会创建新的 Job 实例，因此需保证线程安全。</li></ul></li><li><strong>JobDetail（任务详情）</strong><ul><li>封装 Job 的元数据（如任务名称、所属组、关联的 Job 类）。</li><li>通过 <code>JobBuilder</code> 构建，支持传递参数（如 <code>JobDataMap</code>）。</li></ul></li><li><strong>Trigger（触发器）</strong><ul><li>定义任务触发规则，分为两类：<ul><li><strong><code>SimpleTrigger</code></strong>：固定时间间隔执行（如每 10 秒一次），适合简单调度。</li><li><strong><code>CronTrigger</code></strong>：基于 Cron 表达式（如 <code>0 0 12 * * ?</code> 表示每天中午执行），支持复杂时间规则<a class=link href=@ref>3,5</a>。</li></ul></li></ul></li><li><strong>Scheduler（调度器）</strong><ul><li>核心控制器，注册 JobDetail 和 Trigger 并协调执行。</li><li>通过 <code>SchedulerFactory</code> 创建，支持启动、暂停、关闭等操作。</li></ul></li><li><strong>JobDataMap</strong><ul><li>用于在 Job 和 Trigger 间传递参数，可通过 <code>JobExecutionContext</code> 在 <code>execute()</code> 中获取<a class=link href=@ref>4,8</a>。</li></ul></li></ol><hr><h3 id=-架构设计>🏗️ <strong>架构设计</strong></h3><ul><li><strong>多线程架构</strong>：初始化 worker 线程池执行任务，支持高并发。</li><li>模块化设计：<ul><li><strong><code>ThreadPool</code></strong>：管理任务执行线程（默认大小 10，可配置）。</li><li><strong><code>JobStore</code></strong>：存储任务和触发器信息，支持内存（<code>RAMJobStore</code>）或数据库（<code>JDBCJobStore</code>）。</li></ul></li><li><strong>事件监听</strong>：提供 <code>SchedulerListener</code>、<code>JobListener</code> 等接口，支持任务执行前后的自定义逻辑（如日志、告警）<a class=link href=@ref>1</a>。</li></ul><hr><h3 id=-触发器与调度规则>⏱️ <strong>触发器与调度规则</strong></h3><h4 id=simpletrigger><strong>SimpleTrigger</strong></h4><ul><li>适用场景：单次执行或固定间隔重复（如每隔 5 分钟执行，共 10 次）。</li><li>示例代码：</li></ul><pre tabindex=0><code>  Trigger trigger = TriggerBuilder.newTrigger()
      .withSchedule(SimpleScheduleBuilder.simpleSchedule()
          .withIntervalInSeconds(10)
          .repeatForever())
      .build();
</code></pre><h4 id=crontrigger><strong>CronTrigger</strong></h4><ul><li>Cron 表达式：由 7 个字段组成（秒 分 时 日 月 周 年），支持特殊字符：<ul><li><code>*</code>：任意值</li><li><code>?</code>：忽略日/周字段冲突</li><li><code>L</code>：最后一天（如 <code>0 0 23 L * ?</code> 表示每月最后一天 23 点执行）</li><li><code>#</code>：第 N 个周几（如 <code>0 15 10 ? * 6#3</code> 表示每月第三个周五 10:15 执行）<a class=link href=@ref>3,5</a></li></ul></li><li>常用示例：<ul><li>每小时执行：<code>0 0 * * * ?</code></li><li>每周一 8 点：<code>0 0 8 ? * MON</code></li></ul></li></ul><hr><h3 id=-集群与高可用14>🌐 <strong>集群与高可用</strong><a class=link href=@ref>1,4</a></h3><ul><li>集群模式：<ul><li>通过数据库（如 MySQL）共享任务状态，避免单点故障。</li><li>支持故障切换和负载均衡，多个调度器节点协同工作。</li></ul></li><li>配置步骤：<ol><li>创建数据库表（使用 Quartz 提供的 SQL 脚本）。</li><li>修改 quartz.properties ：</li></ol></li></ul><pre tabindex=0><code>     org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTX
   org.quartz.jobStore.isClustered=true
     org.quartz.jobStore.dataSource=myDS  # 配置数据库连接
</code></pre><hr><h3 id=-企业级特性18>🧩 <strong>企业级特性</strong><a class=link href=@ref>1,8</a></h3><ol><li>持久化<ul><li>任务状态保存到数据库，重启后自动恢复未完成的任务。</li></ul></li><li>事务管理<ul><li>支持 JTA 事务，确保任务执行与业务逻辑的原子性。</li></ul></li><li>插件机制<ul><li>可扩展 <code>SchedulerPlugin</code> 等接口，自定义调度策略（如动态修改 Cron 表达式）。</li></ul></li></ol><hr><h3 id=-spring-boot-集成28>🌱 <strong>Spring Boot 集成</strong><a class=link href=@ref>2,8</a></h3><ol><li>依赖配置：<pre tabindex=0><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre></li><li>定义 Job 类：<pre tabindex=0><code>public class MyJob implements Job {
    @Override
    public void execute(JobExecutionContext context) {
        System.out.println(&#34;Job executed!&#34;);
    }
}
</code></pre></li><li>自动配置：<ul><li>Spring Boot 自动创建 <code>Scheduler</code>，通过 <code>application.yml</code> 配置线程池、存储方式等。</li></ul></li></ol><hr><h3 id=-适用场景-vs-替代方案46>⚖️ <strong>适用场景 vs 替代方案</strong><a class=link href=@ref>4,6</a></h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方案</strong></th><th><strong>理由</strong></th></tr></thead><tbody><tr><td>简单单机任务</td><td>Spring <code>@Scheduled</code></td><td>轻量级，注解即可使用。</td></tr><tr><td>复杂调度（分布式/持久化）</td><td>Quartz</td><td>支持集群、事务、灵活 Cron 规则。</td></tr><tr><td>大规模分布式任务</td><td>XXL-JOB/Elastic-Job</td><td>提供分片、动态扩容、管理界面等增强功能。</td></tr></tbody></table></div><hr><h3 id=-注意事项-1>⚠️ <strong>注意事项</strong></h3><ul><li><strong>线程阻塞</strong>：避免在 Job 中执行长时阻塞操作，需优化任务逻辑或异步处理。</li><li><strong>时间精度</strong>：Cron 表达式最小单位为分钟，秒级精度需用 <code>SimpleTrigger</code>。</li><li><strong>资源清理</strong>：应用关闭时调用 <code>scheduler.shutdown()</code> 释放线程池<a class=link href=@ref>4</a>。</li></ul><hr><h3 id=-总结-1>💎 <strong>总结</strong></h3><p>Quartz 是 Java 生态中最成熟的调度框架之一，<strong>适合需要高可靠性、复杂调度规则或分布式部署的企业应用</strong>。对于 Spring Boot 项目，可无缝集成并简化配置；若需更轻量级方案，可考虑 Spring 自带调度器或分布式框架如 XXL-JOB<a class=link href=@ref>2,4</a>。</p><h2 id=xxl-job>XXL-JOB</h2><p>XXL-JOB 是一个轻量级、易扩展的分布式任务调度平台，由许雪里开发，采用中心式调度与分布式执行架构，支持高可用、动态管理、任务分片等核心功能。以下从架构设计、核心功能、使用部署到适用场景进行系统介绍：</p><hr><h3 id=-核心架构与设计思想>⚙️ <strong>核心架构与设计思想</strong></h3><p>XXL-JOB 采用 <strong>“调度中心 + 执行器” 的分布式架构</strong>，实现调度与执行的解耦：</p><ol><li><strong>调度中心（Admin）</strong><ul><li><strong>功能</strong>：提供 Web 管理界面，负责任务配置、触发调度、监控日志等。</li><li><strong>高可用</strong>：支持集群部署，通过数据库（如 MySQL）维护任务状态，避免单点故障<a class=link href=@ref>1,4,7</a>。</li><li><strong>调度线程池</strong>：分快慢线程池，慢任务自动降级，避免阻塞调度<a class=link href=@ref>3</a>。</li></ul></li><li><strong>执行器（Executor）</strong><ul><li><strong>功能</strong>：接收调度请求，执行具体业务逻辑（通过 <code>JobHandler</code> 实现）。</li><li><strong>注册机制</strong>：周期性上报心跳至调度中心，动态维护在线节点列表<a class=link href=@ref>4,7</a>。</li><li><strong>集群支持</strong>：支持弹性扩容，新节点自动加入任务分配<a class=link href=@ref>2,6</a>。</li></ul></li><li><strong>通信协议</strong><ul><li>调度中心与执行器通过 <strong>RESTful API</strong> 交互，支持跨语言调用<a class=link href=@ref>1,6</a>。</li></ul></li></ol><hr><h3 id=-核心功能与特性>🚀 <strong>核心功能与特性</strong></h3><ol><li><strong>灵活的任务触发策略</strong><ul><li>支持 <strong>Cron 表达式</strong>、固定间隔、固定延时、API 触发、父子任务依赖等<a class=link href=@ref>1,3</a>。</li><li><strong>示例</strong>：<code>0 */10 * * * ?</code> 表示每 10 分钟执行一次。</li></ul></li><li><strong>分布式任务分片</strong><ul><li>将大任务拆分为多个子任务并行执行，显著提升处理效率。</li><li>代码示例：<pre tabindex=0><code>@XxlJob(&#34;shardingJob&#34;)  
public ReturnT&lt;String&gt; execute(String param) {  
    ShardingUtil.ShardingVO shard = ShardingUtil.getShardingVo();  
    int index = shard.getIndex(); // 当前分片索引  
    int total = shard.getTotal(); // 总分片数  
    // 根据分片处理数据（例如：i % total == index）  
    return ReturnT.SUCCESS;  
}  
</code></pre>路由策略支持故障转移、轮询、一致性 HASH 等。</li></ul></li><li><strong>高可用与容错机制</strong><ul><li><strong>故障转移</strong>：节点宕机时自动切换至健康节点<a class=link href=@ref>1,6</a>。</li><li><strong>失败重试</strong>：自定义重试次数（默认 3 次），支持分片级重试<a class=link href=@ref>2,3</a>。</li><li><strong>阻塞处理</strong>：提供单机串行、丢弃后续调度、覆盖之前调度等策略<a class=link href=@ref>3</a>。</li></ul></li><li><strong>运维监控能力</strong><ul><li><strong>实时日志</strong>：支持 Rolling 方式查看执行日志<a class=link href=@ref>3,4</a>。</li><li><strong>报警机制</strong>：任务失败时触发邮件、钉钉等告警（可扩展短信/Webhook）<a class=link href=@ref>1,6</a>。</li><li><strong>运行报表</strong>：统计任务执行成功率、调度分布等指标<a class=link href=@ref>3</a>。</li></ul></li><li><strong>动态管理</strong><ul><li>任务参数、Cron 表达式、启停状态可动态修改并实时生效<a class=link href=@ref>1,2</a>。</li></ul></li></ol><hr><h3 id=-部署与集成>🛠️ <strong>部署与集成</strong></h3><h4 id=调度中心部署><strong>调度中心部署</strong></h4><ul><li><strong>数据库初始化</strong>：执行 SQL 脚本 <code>tables_xxl_job.sql</code><a class=link href=@ref>4,7</a>。</li><li>启动方式：<ul><li>本地运行：<pre tabindex=0><code>java -jar xxl-job-admin.jar --spring.datasource.url=jdbc:mysql://localhost:3306/xxl_job  
</code></pre></li><li>Docker 部署：<pre tabindex=0><code>docker run -d -p 8080:8080 -e PARAMS=&#34;--spring.datasource.url=...&#34; xuxueli/xxl-job-admin:2.4.0  
</code></pre></li></ul></li><li><strong>访问管理台</strong>：<code>http://localhost:8080/xxl-job-admin</code>（默认账号 <code>admin/123456</code>）<a class=link href=@ref>4</a>。</li></ul><h4 id=执行器集成spring-boot-项目><strong>执行器集成（Spring Boot 项目）</strong></h4><ul><li><strong>依赖添加</strong>：<pre tabindex=0><code>&lt;dependency&gt;  
    &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;  
    &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;  
    &lt;version&gt;2.4.0&lt;/version&gt;  
&lt;/dependency&gt;  
</code></pre></li><li><strong>配置示例（application.yml）</strong>：<pre tabindex=0><code>xxl:  
  job:  
    admin:  
      addresses: http://localhost:8080/xxl-job-admin  
    executor:  
      appname: my-executor  
      port: 9999  
      logpath: /data/logs/xxl-job  
</code></pre></li><li><strong>定义任务处理器</strong>：<pre tabindex=0><code>@Component  
public class DemoJobHandler {  
    @XxlJob(&#34;demoJob&#34;)  
    public ReturnT&lt;String&gt; execute(String param) {  
        System.out.println(&#34;执行任务，参数：&#34; + param);  
        return ReturnT.SUCCESS;  
    }  
}  
</code></pre></li></ul><hr><h3 id=-适用场景与框架对比>⚖️ <strong>适用场景与框架对比</strong></h3><h4 id=典型场景><strong>典型场景</strong></h4><ul><li><strong>定时任务</strong>：每日凌晨数据统计、日志清理<a class=link href=@ref>1,6</a>。</li><li><strong>异步任务</strong>：用户注册后发送验证邮件、支付成功通知<a class=link href=@ref>2</a>。</li><li><strong>分布式计算</strong>：海量数据分片处理（如清洗 1TB 日志文件）<a class=link href=@ref>1,4</a>。</li></ul><h4 id=与其他框架对比><strong>与其他框架对比</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>Quartz</strong></th><th><strong>Elastic-Job</strong></th><th><strong>XXL-JOB</strong></th></tr></thead><tbody><tr><td><strong>分布式调度</strong></td><td>需自行配置</td><td>是（ZK）</td><td><strong>是（内置）</strong></td></tr><tr><td><strong>可视化界面</strong></td><td>无</td><td>无</td><td><strong>支持</strong></td></tr><tr><td><strong>动态管理</strong></td><td>部分支持</td><td>是</td><td><strong>实时生效</strong></td></tr><tr><td><strong>日志监控</strong></td><td>弱</td><td>有限</td><td><strong>实时日志 + 报表</strong></td></tr><tr><td><strong>学习成本</strong></td><td>高</td><td>中高</td><td><strong>低（Web 操作）</strong></td></tr></tbody></table></div><blockquote><p><strong>优势总结</strong>：开箱即用、运维友好、扩展性强，适合中小型至大型项目<a class=link href=@ref>4,6</a>。</p></blockquote><hr><h3 id=-注意事项-2>⚠️ <strong>注意事项</strong></h3><ol><li><strong>数据库性能</strong>：任务量极大时需优化数据库（如分表、索引）<a class=link href=@ref>2</a>。</li><li><strong>网络隔离</strong>：确保调度中心与执行器网络互通，防火墙开放端口<a class=link href=@ref>7</a>。</li><li><strong>幂等性设计</strong>：任务逻辑需支持重复执行（如 DB 操作加唯一约束）<a class=link href=@ref>4</a>。</li></ol><hr><h3 id=-总结-2>💎 <strong>总结</strong></h3><p>XXL-JOB 通过 <strong>解耦设计</strong> 与 <strong>全异步流程</strong> 解决了分布式任务的高可用、弹性扩展问题，其 <strong>开箱即用的管理台</strong> 大幅降低运维成本。对于 Java 生态中的定时任务需求，无论是简单调度还是大数据分片场景，XXL-JOB 均是比原生 <code>ScheduledExecutorService</code> 或 <code>Quartz</code> 更高效的解决方案<a class=link href=@ref>1,4,7</a>。
<strong>官方资源</strong>：</p><ul><li>源码地址：<a class=link href=https://gitee.com/xuxueli0323/xxl-job target=_blank rel=noopener>Gitee</a></li><li>文档：https://www.xuxueli.com/xxl-job/</li></ul><h2 id=quartz--xxl-job>Quartz & XXL-JOB</h2><p>以下是Quartz与XXL-JOB的详细对比，结合架构设计、功能特性、适用场景等维度进行系统分析：</p><hr><h3 id=-核心架构对比>⚙️ <strong>核心架构对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>Quartz</strong></th><th><strong>XXL-JOB</strong></th></tr></thead><tbody><tr><td><strong>架构模型</strong></td><td>无中心化调度</td><td>中心化调度（调度中心 + 执行器）</td></tr><tr><td><strong>分布式支持</strong></td><td>弱（依赖数据库锁竞争）<a class=link href=@ref>1,7</a></td><td>强（内置负载均衡 + 故障转移）<a class=link href=@ref>2,6</a></td></tr><tr><td><strong>任务分片</strong></td><td>不支持</td><td>支持静态分片（需手动编码）<a class=link href=@ref>3,8</a></td></tr><tr><td><strong>通信协议</strong></td><td>基于Java API</td><td>HTTP/RESTful（跨语言支持）<a class=link href=@ref>6,8</a></td></tr></tbody></table></div><hr><h3 id=-功能特性对比>🛠️ <strong>功能特性对比</strong></h3><ol><li><strong>任务调度能力</strong><ul><li>Quartz：<ul><li>支持Cron表达式、固定间隔等复杂调度策略<a class=link href=@ref>1,6</a>。</li><li>任务持久化到数据库，重启可恢复<a class=link href=@ref>2</a>。</li></ul></li><li>XXL-JOB：<ul><li>除Cron外，支持API触发、父子任务依赖、分片广播<a class=link href=@ref>4,8</a>。</li></ul></li><li><strong>动态生效</strong>：任务参数、状态修改实时生效<a class=link href=@ref>6,7</a>。</li></ul></li><li><strong>集群与高可用</strong><ul><li>Quartz：<ul><li>集群节点通过数据库行锁竞争任务，负载不均衡，存在单点瓶颈<a class=link href=@ref>2,7</a>。</li></ul></li><li>XXL-JOB：<ul><li>调度中心集群通过DB锁或ZK选主，执行器支持故障自动转移<a class=link href=@ref>3,8</a>。</li></ul></li><li>心跳检测机制（30秒/次），自动剔除宕机节点<a class=link href=@ref>8</a>。</li></ul></li><li><strong>运维监控</strong></li></ol><ul><li><strong>Quartz</strong>：无原生管理界面，需自行开发监控系统<a class=link href=@ref>1,7</a>。</li><li><strong>XXL-JOB</strong>：<ul><li>提供<strong>可视化控制台</strong>，实时查看任务日志、执行状态、成功率统计<a class=link href=@ref>3,6</a>。</li><li>支持邮件/钉钉告警，任务失败自动触发<a class=link href=@ref>4</a>。</li></ul></li></ul><ol start=4><li><strong>性能与扩展性</strong><ul><li><strong>Quartz</strong>：单机调度吞吐量约500任务/秒，集群扩展需手动分库分表<a class=link href=@ref>7,8</a>。</li><li><strong>XXL-JOB</strong>：<ul><li>异步调度设计，吞吐量达1200任务/秒<a class=link href=@ref>8</a>。</li><li>执行器动态注册，支持弹性扩容<a class=link href=@ref>4,6</a>。</li></ul></li></ul></li></ol><hr><h3 id=-适用场景对比>📊 <strong>适用场景对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐框架</strong></th><th><strong>理由</strong></th></tr></thead><tbody><tr><td><strong>单机/小规模集群</strong></td><td>Quartz</td><td>轻量级嵌入，无需复杂部署，适合传统单体应用<a class=link href=@ref>2,7</a>。</td></tr><tr><td><strong>分布式系统（中小型）</strong></td><td>XXL-JOB</td><td>开箱即用的运维界面、跨语言支持，快速搭建调度平台<a class=link href=@ref>3,6</a>。</td></tr><tr><td><strong>大数据分片任务</strong></td><td>不推荐二者</td><td>Elastic-Job更优（自动分片+ZK动态协调）<a class=link href=@ref>3,7</a>。</td></tr><tr><td><strong>需严格监控告警的场景</strong></td><td>XXL-JOB</td><td>内置日志追踪与报警机制，降低运维成本<a class=link href=@ref>4,8</a>。</td></tr></tbody></table></div><hr><h3 id=-局限性对比>⚠️ <strong>局限性对比</strong></h3><ul><li>Quartz：<ul><li><strong>代码侵入性强</strong>：调度逻辑与业务耦合，影响性能<a class=link href=@ref>4,7</a>。</li><li><strong>无分片机制</strong>：无法处理海量数据并行任务<a class=link href=@ref>7</a>。</li></ul></li><li>XXL-JOB：<ul><li><strong>分片功能较弱</strong>：需开发者手动实现分片逻辑（例：<code>ShardingUtil.getShardingVo()</code>）<a class=link href=@ref>8</a>。</li></ul></li><li><strong>中心化风险</strong>：调度中心若未集群部署，可能成为单点故障<a class=link href=@ref>3,7</a>。</li></ul><hr><h3 id=-选型建议>💎 <strong>选型建议</strong></h3><ol><li><strong>优先选择Quartz的场景</strong>：<ul><li>历史项目改造，已有Quartz集成；</li><li>简单定时任务（如每日报表），无需分布式支持<a class=link href=@ref>2,6</a>。</li></ul></li><li><strong>优先选择XXL-JOB的场景</strong>：<ul><li><strong>分布式微服务架构</strong>：需统一管理跨服务任务；</li><li><strong>可视化运维需求</strong>：非技术角色参与任务监控；</li><li><strong>快速迭代项目</strong>：动态调整任务参数无需重启<a class=link href=@ref>3,8</a>。</li></ul></li></ol><blockquote><p><strong>新项目趋势</strong>：超过70%的分布式系统选型XXL-JOB（数据来源：CSDN开发者调研<a class=link href=@ref>6</a>）。</p></blockquote><hr><h3 id=-扩展能力补充>🔧 <strong>扩展能力补充</strong></h3><ul><li>XXL-JOB：<ul><li>支持<strong>GLUE脚本任务</strong>（Java/Python/PHP等），动态更新代码<a class=link href=@ref>4</a>。</li><li>整合Spring Boot仅需3步：依赖 → 配置 → 注解<code>@XxlJob</code><a class=link href=@ref>6,8</a>。</li></ul></li><li>Quartz：<ul><li>可通过<strong>监听器</strong>（<code>JobListener</code>）扩展任务生命周期事件<a class=link href=@ref>1</a>。</li></ul></li></ul><hr><p><strong>总结</strong>：Quartz是<strong>稳健的单机调度基石</strong>，而XXL-JOB是<strong>分布式时代的调度平台</strong>。两者定位差异显著：</p><ul><li>追求<strong>轻量嵌入、复杂调度策略</strong> → Quartz；</li><li>追求<strong>开箱即用、运维友好、跨语言</strong> → XXL-JOB<a class=link href=@ref>3,6,7</a>。</li></ul><h2 id=xxl-job-动态提交>XXL-JOB 动态提交</h2><p>XXL-JOB 实现动态提交附带执行参数且仅执行一次的定时任务，主要通过其 <strong>API 触发机制</strong> 和 <strong>任务参数配置</strong> 实现。以下是具体步骤和实现方式：</p><hr><h3 id=-核心实现方式>⚙️ <strong>核心实现方式</strong></h3><h4 id=通过管理界面手动创建适合临时任务><strong>通过管理界面手动创建</strong>（适合临时任务）</h4><ul><li>步骤：<ol><li>登录 XXL-JOB 管理台，进入任务管理页面；</li><li>点击“新增任务”，填写任务信息：<ul><li><strong>执行器</strong>：选择目标执行器；</li><li><strong>任务描述</strong>：自定义名称；</li><li><strong>路由策略</strong>：默认或按需选择；</li><li><strong>调度类型</strong>：<strong>CRON</strong>，设置表达式为具体执行时间（如 <code>2025-07-03 15:30:00</code>）；</li><li><strong>运行模式</strong>：选择 <strong>BEAN模式</strong>；</li><li><strong>JobHandler</strong>：填写任务对应的注解名（如 <code>demoJobHandler</code>）；</li><li><strong>任务参数</strong>：填写 JSON 或键值对参数（如 <code>{"orderId":1001}</code>）；</li><li><strong>执行一次</strong>：调度类型选择一次任务后自动失效<a class=link href=@ref>1,6</a>。</li></ul></li><li>保存后任务会在指定时间触发一次，执行后自动停止。</li></ol></li><li><strong>优点</strong>：操作简单，无需编码。</li></ul><h4 id=通过-api-动态提交适合程序触发><strong>通过 API 动态提交</strong>（适合程序触发）</h4><ul><li>步骤：<ol><li><strong>调用调度中心 API</strong>：<pre tabindex=0><code>POST /api/jobinfo/add
</code></pre></li><li><strong>请求体示例</strong>：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=s>&#34;jobGroup&#34;</span><span class=p>:</span><span class=w> </span><span class=n>2</span><span class=p>,</span><span class=w>                </span><span class=c1>// 执行器ID</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=s>&#34;jobDesc&#34;</span><span class=p>:</span><span class=w> </span><span class=s>&#34;一次性订单任务&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=s>&#34;author&#34;</span><span class=p>:</span><span class=w> </span><span class=s>&#34;admin&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=s>&#34;scheduleType&#34;</span><span class=p>:</span><span class=w> </span><span class=s>&#34;CRON&#34;</span><span class=p>,</span><span class=w>        </span><span class=c1>// 调度类型</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=s>&#34;scheduleConf&#34;</span><span class=p>:</span><span class=w> </span><span class=s>&#34;0 30 15 3 7 ? 2025&#34;</span><span class=p>,</span><span class=w> </span><span class=c1>// 执行时间（2025-07-03 15:30:00）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=s>&#34;glueType&#34;</span><span class=p>:</span><span class=w> </span><span class=s>&#34;BEAN&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=s>&#34;executorHandler&#34;</span><span class=p>:</span><span class=w> </span><span class=s>&#34;orderJobHandler&#34;</span><span class=p>,</span><span class=w> </span><span class=c1>// JobHandler名称</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=s>&#34;executorParam&#34;</span><span class=p>:</span><span class=w> </span><span class=s>&#34;{\&#34;orderId\&#34;:1001}&#34;</span><span class=p>,</span><span class=w> </span><span class=c1>// 动态参数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=s>&#34;triggerNextTime&#34;</span><span class=p>:</span><span class=w> </span><span class=n>0</span><span class=w>           </span><span class=c1>// 立即生效</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><strong>鉴权</strong>：需在 Header 中添加 <code>XXL-JOB-ACCESS-TOKEN</code>（与调度中心配置一致）<a class=link href=@ref>4,6</a>。</li></ol></li><li>关键点：<ul><li><code>scheduleConf</code> 设置为精确到秒的 CRON 表达式；</li></ul></li><li>任务执行后自动归档，不会再次触发。</li></ul><hr><h3 id=-执行器接收动态参数>🧩 <strong>执行器接收动态参数</strong></h3><p>在任务逻辑中，通过以下方式获取参数：</p><h4 id=bean-模式方法形式><strong>Bean 模式（方法形式）</strong></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Component</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>OrderJobHandler</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@XxlJob</span><span class=p>(</span><span class=s>&#34;orderJobHandler&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>ReturnT</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=nf>execute</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>param</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 解析JSON参数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>JSONObject</span><span class=w> </span><span class=n>params</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>JSON</span><span class=p>.</span><span class=na>parseObject</span><span class=p>(</span><span class=n>param</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>orderId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>params</span><span class=p>.</span><span class=na>getString</span><span class=p>(</span><span class=s>&#34;orderId&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;处理订单ID：&#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>orderId</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>ReturnT</span><span class=p>.</span><span class=na>SUCCESS</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li><strong>说明</strong>：参数通过 <code>param</code> 字符串传入，需自行解析为 JSON 或 Map<a class=link href=@ref>1,6</a>。</li></ul><h4 id=使用上下文对象高级><strong>使用上下文对象（高级）</strong></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@XxlJob</span><span class=p>(</span><span class=s>&#34;orderJobHandler&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=n>ReturnT</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=nf>execute</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 获取任务上下文</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>String</span><span class=w> </span><span class=n>param</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>XxlJobHelper</span><span class=p>.</span><span class=na>getJobParam</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>JSONObject</span><span class=w> </span><span class=n>params</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>JSON</span><span class=p>.</span><span class=na>parseObject</span><span class=p>(</span><span class=n>param</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>ReturnT</span><span class=p>.</span><span class=na>SUCCESS</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li><strong>适用场景</strong>：需要获取任务 ID、分片信息等更多上下文时<a class=link href=@ref>6</a>。</li></ul><hr><h3 id=-注意事项-3>⚠️ <strong>注意事项</strong></h3><ol><li>参数安全性：<ul><li>避免传递敏感数据，或对参数加密；</li><li>执行器需校验参数合法性，防止注入攻击<a class=link href=@ref>6</a>。</li></ul></li><li>任务生命周期：<ul><li>单次任务执行后状态变为 <strong>已停止</strong>，需手动或调用 API 删除<a class=link href=@ref>4</a>。</li></ul></li><li>时间精度：<ul><li>CRON 表达式需精确到秒（如 <code>ss mm HH dd MM ? yyyy</code>），确保只触发一次。</li></ul></li><li>集群环境：<ul><li>调度中心需集群部署，避免单点故障导致任务丢失<a class=link href=@ref>5</a>。</li></ul></li></ol><hr><h3 id=-扩展api-触发替代方案>🔧 <strong>扩展：API 触发替代方案</strong></h3><p>若需更灵活触发（如事件驱动），可直接调用 <strong>任务触发 API</strong>：</p><pre tabindex=0><code>POST /api/jobinfo/trigger
Body: {&#34;id&#34;:任务ID, &#34;executorParam&#34;:&#34;{\&#34;key\&#34;:\&#34;value\&#34;}&#34;}
</code></pre><ul><li><strong>特点</strong>：绕过调度计划，立即执行一次任务，适合异步事件场景<a class=link href=@ref>6</a>。</li></ul><hr><h3 id=-总结-3>💎 <strong>总结</strong></h3><ul><li><strong>动态提交单次任务</strong>：通过管理台或 API 创建 CRON 调度任务，指定精确执行时间。</li><li><strong>参数传递</strong>：任务参数以 JSON 字符串传递，执行器解析后使用。</li><li><strong>适用场景</strong>：订单超时处理、临时数据修复等需精准控制执行时机的业务。</li></ul><blockquote><p>官方文档参考：<a class=link href=https://www.xuxueli.com/xxl-job/ target=_blank rel=noopener>XXL-JOB 任务管理</a>
完整 API 列表见调度中心 Swagger 页面（<code>/xxl-job-admin/swagger-ui.html</code>）<a class=link href=@ref>4</a>。</p></blockquote><h2 id=scheduletype>scheduleType</h2><p>XXL-JOB 支持多种调度类型（<code>scheduleType</code>），可通过 <strong>API 动态提交任务</strong> 时灵活配置。以下是所有支持的调度类型及其使用场景和配置方式：</p><hr><h3 id=-核心调度类型scheduletype>⚙️ <strong>核心调度类型（scheduleType）</strong></h3><p>XXL-JOB 的 <code>scheduleType</code> 定义了任务触发规则，动态提交任务时需在 API 请求中指定该参数。以下是全部类型：</p><ol><li><strong>CRON</strong><ul><li><strong>功能</strong>：基于 Cron 表达式触发任务，适用于复杂时间规则（如每天凌晨执行）。</li><li>API 参数示例：<pre tabindex=0><code>{
  &#34;scheduleType&#34;: &#34;CRON&#34;,
  &#34;scheduleConf&#34;: &#34;0 0 2 * * ?&#34;  // 每天凌晨2点执行
}
</code></pre></li><li><strong>场景</strong>：定期报表生成、定时数据清洗<a class=link href=@ref>1,7</a>。</li></ul></li><li><strong>FIX_RATE</strong>（固定速率）<ul><li><strong>功能</strong>：按固定间隔重复执行（从任务启动后开始计时）。</li><li>API 参数示例：<pre tabindex=0><code>{
  &#34;scheduleType&#34;: &#34;FIX_RATE&#34;,
  &#34;scheduleConf&#34;: &#34;30&#34;  // 单位：秒，每30秒执行一次
}
</code></pre></li><li><strong>场景</strong>：实时监控、心跳检测<a class=link href=@ref>5,7</a>。</li></ul></li><li><strong>FIX_DELAY</strong>（固定延时）<ul><li><strong>功能</strong>：任务执行完成后，延迟固定时间再次触发。</li><li>API 参数示例：<pre tabindex=0><code>{
  &#34;scheduleType&#34;: &#34;FIX_DELAY&#34;,
  &#34;scheduleConf&#34;: &#34;60&#34;  // 单位：秒，任务结束后延迟60秒执行下一次
}
</code></pre></li><li><strong>场景</strong>：避免任务重叠，如数据分批处理<a class=link href=@ref>5,7</a>。</li></ul></li><li><strong>API</strong>（事件触发）<ul><li><strong>功能</strong>：无内置调度规则，需通过外部 API 手动触发单次执行。</li><li>API 参数示例：<pre tabindex=0><code>{
  &#34;scheduleType&#34;: &#34;API&#34;,
  &#34;scheduleConf&#34;: &#34;&#34;  // 留空
}
</code></pre></li><li><strong>触发方式</strong>：调用 <code>/api/jobinfo/trigger</code> 接口主动触发任务<a class=link href=@ref>5,8</a>。</li></ul></li><li><strong>PARENT</strong>（父子任务依赖）<ul><li><strong>功能</strong>：依赖父任务执行成功后触发（需配置父任务ID）。</li><li>API 参数示例：<pre tabindex=0><code>{
  &#34;scheduleType&#34;: &#34;PARENT&#34;,
  &#34;scheduleConf&#34;: &#34;1001&#34;  // 父任务ID
}
</code></pre></li><li><strong>场景</strong>：任务流水线，如订单处理完成后触发通知任务<a class=link href=@ref>7</a>。</li></ul></li><li><strong>MANUAL</strong>（人工触发）<ul><li><strong>功能</strong>：仅在管理台手动点击“执行”按钮时触发。</li><li>API 参数示例：<pre tabindex=0><code>{
  &#34;scheduleType&#34;: &#34;MANUAL&#34;,
  &#34;scheduleConf&#34;: &#34;&#34;
}
</code></pre></li><li><strong>适用场景</strong>：临时调试或应急操作<a class=link href=@ref>7</a>。</li></ul></li></ol><hr><h3 id=-动态提交-api-示例>⚡ <strong>动态提交 API 示例</strong></h3><p>通过调度中心 RESTful API 提交任务（以创建任务接口为例）：</p><pre tabindex=0><code>POST /api/jobinfo/add
Headers: {&#34;XXL-JOB-ACCESS-TOKEN&#34;: &#34;your_token&#34;}
Body:
{
  &#34;jobGroup&#34;: 2,                 // 执行器ID
  &#34;jobDesc&#34;: &#34;动态任务示例&#34;,
  &#34;scheduleType&#34;: &#34;FIX_RATE&#34;,     // 调度类型
  &#34;scheduleConf&#34;: &#34;300&#34;,          // 间隔300秒
  &#34;executorHandler&#34;: &#34;demoJob&#34;,    // JobHandler名称
  &#34;executorParam&#34;: &#34;{\&#34;key\&#34;:\&#34;value\&#34;}&#34; // 任务参数
}
</code></pre><blockquote><p>💡 <strong>关键字段说明</strong>：</p><ul><li><code>scheduleType</code>：必须为上述六种类型之一。</li><li><code>scheduleConf</code>：根据类型填写 Cron 表达式、时间间隔或父任务ID。</li></ul></blockquote><hr><h3 id=-注意事项-4>⚠️ <strong>注意事项</strong></h3><ol><li>动态生效性</li></ol><ul><li>通过 API 提交的任务会<strong>实时生效</strong>，无需重启调度中心或执行器<a class=link href=@ref>5,8</a>。</li></ul><ol start=2><li>参数校验</li></ol><ul><li><code>scheduleConf</code> 需符合类型规则（如 CRON 需合法表达式，FIX_RATE 需正整数）<a class=link href=@ref>7</a>。</li></ul><ol start=3><li>任务生命周期</li></ol><ul><li><code>API</code> 和 <code>MANUAL</code> 类型任务需手动触发，不会自动调度；其他类型按规则自动执行<a class=link href=@ref>5</a>。</li></ul><ol start=4><li>集群兼容性</li></ol><ul><li>所有调度类型均支持分布式执行，依赖调度中心的集群协调能力<a class=link href=@ref>1,7</a>。</li></ul><hr><h3 id=-总结-4>💎 <strong>总结</strong></h3><p>XXL-JOB 的六种 <code>scheduleType</code> 覆盖了从 <strong>定时任务</strong> 到 <strong>事件驱动</strong> 的全场景：</p><ul><li><strong>周期任务</strong> → <code>CRON</code>、<code>FIX_RATE</code>、<code>FIX_DELAY</code></li><li><strong>被动触发</strong> → <code>API</code>、<code>MANUAL</code></li><li><strong>任务编排</strong> → <code>PARENT</code>
通过动态 API 提交任务时，结合 <code>executorParam</code> 传递参数，可灵活适配业务变化，显著提升调度系统的响应速度<a class=link href=@ref>5,7,8</a>。</li></ul><h2 id=xxl-job-分布式调度>XXL-JOB 分布式调度</h2><p>XXL-JOB 实现任务的分布式调度主要依赖其<strong>中心化调度 + 分布式执行</strong>的架构设计，通过调度中心（Admin）与执行器（Executor）的协同工作，结合多种核心机制保障任务在分布式环境下的高效、可靠执行。以下是具体实现原理及关键机制：</p><hr><h3 id=-核心架构设计>⚙️ <strong>核心架构设计</strong></h3><h4 id=调度中心admin><strong>调度中心（Admin）</strong></h4><ul><li><strong>统一调度中枢</strong>：负责管理任务配置、触发调度、监控状态，支持集群部署（多节点共享同一数据库），通过数据库锁（<code>xxl_job_lock</code>）保证分布式环境下任务调度的唯一性<a class=link href=@ref>3,8</a>。</li><li>功能模块：<ul><li><strong>任务管理</strong>：通过Web界面动态配置任务（CRON表达式、路由策略、重试机制等）。</li><li><strong>调度线程池</strong>：多线程触发任务，避免单点阻塞（快慢线程池隔离，慢任务自动降级）<a class=link href=@ref>1,8</a>。</li><li><strong>执行器发现</strong>：维护注册表（<code>xxl_job_registry</code>），动态感知在线执行器节点<a class=link href=@ref>3,8</a>。</li></ul></li></ul><h4 id=执行器executor><strong>执行器（Executor）</strong></h4><ul><li><strong>分布式任务执行</strong>：部署在业务服务节点，通过HTTP接收调度请求，执行具体业务逻辑。</li><li><strong>自动注册</strong>：启动时向调度中心注册，定期（30秒）发送心跳维持在线状态<a class=link href=@ref>3,8</a>。</li><li><strong>集群支持</strong>：同一执行器可多节点部署，调度中心根据路由策略分配任务。</li></ul><hr><h3 id=-分布式调度核心机制>🔧 <strong>分布式调度核心机制</strong></h3><h4 id=任务路由与负载均衡><strong>任务路由与负载均衡</strong></h4><p>调度中心根据配置的<strong>路由策略</strong>选择执行器节点，确保任务均匀分配：</p><ul><li>常用策略：<ul><li><strong>故障转移（FAILOVER）</strong>：优先选择上次成功的节点，失败自动切换<a class=link href=@ref>3,8</a>。</li><li><strong>忙碌转移（BUSY_OVER）</strong>：选择空闲节点执行，避免节点过载。</li><li><strong>分片广播（SHARDING_BROADCAST）</strong>：所有执行器并行执行同一任务，配合分片参数处理不同数据子集<a class=link href=@ref>6,7</a>。</li><li><strong>一致性HASH</strong>：任务固定分配到特定节点，减少节点变动的影响<a class=link href=@ref>8</a>。</li></ul></li></ul><h4 id=分片任务处理><strong>分片任务处理</strong></h4><ul><li>动态数据分片：<ul><li>调度中心广播任务时传递分片参数（当前分片索引 <code>index</code>、总分片数 <code>total</code>）。</li><li>执行器通过 <code>ShardingUtil.getShardingVo()</code> 获取参数，按分片处理数据（如按ID取模分片查询）<a class=link href=@ref>6,7</a>。</li><li>示例代码：<pre tabindex=0><code>@XxlJob(&#34;shardingJob&#34;)
public void shardingTask() {
  ShardingVO shard = ShardingUtil.getShardingVo();
    List&lt;Data&gt; dataSubset = fetchDataByShard(shard.getIndex(), shard.getTotal());
  process(dataSubset);
}
</code></pre></li></ul></li></ul><h4 id=高可用与容错><strong>高可用与容错</strong></h4><ul><li><strong>调度中心集群</strong>：多节点共享数据库，通过DB锁避免重复调度；配合Nginx实现负载均衡<a class=link href=@ref>3,4</a>。</li><li><strong>执行器故障转移</strong>：节点宕机后，调度中心自动剔除离线节点，将任务路由至健康节点<a class=link href=@ref>1,8</a>。</li><li><strong>失败重试与告警</strong>：任务失败自动重试（可配置次数），并通过邮件/钉钉通知负责人<a class=link href=@ref>1,3</a>。</li></ul><h4 id=时间轮调度算法><strong>时间轮调度算法</strong></h4><ul><li>高效触发任务：<ul><li><strong>ScheduleThread</strong>：预读未来5秒任务，加载至时间轮槽位。</li><li><strong>RingThread</strong>：每秒检测当前槽位任务并触发，减少数据库轮询压力<a class=link href=@ref>8</a>。</li></ul></li><li><strong>过期策略</strong>：若任务错过触发时间，可选择忽略或立即补偿执行一次（<code>FIRE_ONCE_NOW</code>）<a class=link href=@ref>1,3</a>。</li></ul><hr><h3 id=-任务执行流程>⚡ <strong>任务执行流程</strong></h3><ol><li><strong>调度触发</strong>：调度中心根据CRON或事件触发任务，生成调度记录。</li><li><strong>路由选择</strong>：按策略选取目标执行器节点，发送HTTP请求至其 <code>/run</code> 接口<a class=link href=@ref>3,8</a>。</li><li><strong>任务执行</strong>：执行器调用匹配的 <code>JobHandler</code>，执行业务逻辑。</li><li><strong>结果回调</strong>：执行器通过 <code>/callback</code> 接口返回结果，调度中心更新日志及状态<a class=link href=@ref>3</a>。</li><li><strong>日志监控</strong>：执行日志实时上报，支持Rolling方式查看实时输出<a class=link href=@ref>1,3</a>。</li></ol><hr><h3 id=-关键优化设计>🧩 <strong>关键优化设计</strong></h3><ol><li>弹性扩缩容<ul><li>新增执行器自动注册并参与任务分配；节点下线后，下次调度重新分配分片<a class=link href=@ref>1,8</a>。</li></ul></li><li>全异步流程<ul><li>调度触发、任务执行、结果回调全链路异步化，避免阻塞调度线程，支持长任务运行<a class=link href=@ref>1,8</a>。</li></ul></li><li>阻塞处理策略<ul><li>针对密集调度场景提供策略：</li></ul></li></ol><ul><li><strong>单机串行</strong>（默认）：任务排队执行。<ul><li><strong>丢弃后续调度</strong>：跳过新调度请求。</li></ul></li><li><strong>覆盖之前调度</strong>：终止运行中任务，执行新调度<a class=link href=@ref>1,3</a>。</li></ul><hr><h3 id=-总结-5>💎 <strong>总结</strong></h3><p>XXL-JOB 的分布式调度能力源于其<strong>解耦的架构设计</strong>与<strong>精细化策略控制</strong>：</p><ul><li><strong>调度中心</strong>：通过集群化与时间轮算法保障调度高可用与时效性。</li><li><strong>执行器</strong>：借助路由策略、分片机制实现负载均衡与水平扩展。</li><li><strong>全流程管控</strong>：从动态注册到失败重试，覆盖分布式任务的全生命周期管理。</li></ul><blockquote><p>实践建议：</p><ul><li><strong>调度中心</strong>：至少部署2节点 + Nginx负载均衡，数据库强制走主库<a class=link href=@ref>3,4</a>。</li><li><strong>执行器</strong>：与业务服务同机部署，通过唯一 <code>appname</code> 标识集群<a class=link href=@ref>3,6</a>。
官方文档：<a class=link href=https://github.com/xuxueli/xxl-job target=_blank rel=noopener>XXL-JOB GitHub</a>。</li></ul></blockquote><h2 id=错误重试>错误重试</h2><p>XXL-JOB 实现任务调度与错误重试的核心机制基于其<strong>中心化调度</strong>与<strong>分布式执行</strong>的架构设计，结合多种策略保障任务的可靠执行。以下是详细原理及实现方式：</p><hr><h3 id=-任务调度机制>⏱️ <strong>任务调度机制</strong></h3><h4 id=调度中心admin的核心作用><strong>调度中心（Admin）的核心作用</strong></h4><ul><li><strong>统一调度中枢</strong>：负责任务的触发、路由和状态监控，支持集群部署（多节点共享同一数据库），通过数据库锁（<code>xxl_job_lock</code>）保证分布式环境下调度唯一性<a class=link href=@ref>3,5</a>。</li><li>时间轮算法：<ul><li><strong>ScheduleThread</strong>：预读未来5秒内的任务，加载至时间轮的环形队列中，减少数据库轮询压力<a class=link href=@ref>3</a>。</li><li><strong>RingThread</strong>：每秒检测当前时间槽位任务并触发执行，避免任务堆积或遗漏<a class=link href=@ref>3</a>。</li></ul></li><li>调度线程池隔离：<ul><li><strong>快线程池</strong>：处理常规任务（如短时任务）。</li><li><strong>慢线程池</strong>：处理长耗时任务，避免阻塞调度线程<a class=link href=@ref>5</a>。</li></ul></li></ul><h4 id=任务触发流程><strong>任务触发流程</strong></h4><ol><li><strong>调度触发</strong>：根据任务配置的触发策略（如Cron表达式、固定间隔）生成调度请求<a class=link href=@ref>4</a>。</li><li><strong>路由选择</strong>：根据预设的路由策略（如轮询、故障转移、一致性HASH）选择目标执行器节点<a class=link href=@ref>3,6</a>。</li><li><strong>HTTP请求发送</strong>：调度中心向执行器的<code>/run</code>接口发送任务执行请求<a class=link href=@ref>3</a>。</li><li><strong>异步回调</strong>：执行器完成任务后，通过<code>/callback</code>接口返回结果，更新任务状态和日志<a class=link href=@ref>5</a>。</li></ol><h4 id=关键调度策略><strong>关键调度策略</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>策略类型</strong></th><th><strong>功能说明</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>调度过期策略</strong></td><td>错过触发时间时，选择忽略或立即补偿执行一次（<code>FIRE_ONCE_NOW</code>）<a class=link href=@ref>5</a></td><td>服务重启或线程阻塞后的任务恢复</td></tr><tr><td><strong>阻塞处理策略</strong></td><td>包括单机串行（默认）、丢弃后续调度、覆盖之前调度<a class=link href=@ref>5</a></td><td>高并发任务防堆积</td></tr><tr><td><strong>分片广播</strong></td><td>任务广播至所有执行器，配合分片参数（index/total）并行处理数据子集<a class=link href=@ref>3,6</a></td><td>大数据量处理（如ETL任务）</td></tr></tbody></table></div><hr><h3 id=-错误重试机制>🔁 <strong>错误重试机制</strong></h3><h4 id=内置重试能力><strong>内置重试能力</strong></h4><ul><li><strong>任务级重试</strong>：
在任务配置中设置<strong>失败重试次数</strong>​（如3次），任务执行失败后自动触发重试，间隔时间可配置<a class=link href=@ref>2,5</a>。</li><li><strong>分片任务重试</strong>：
支持分片粒度重试，仅重试失败的分片，而非整个任务<a class=link href=@ref>5</a>。</li></ul><h4 id=容错与故障转移><strong>容错与故障转移</strong></h4><ul><li><strong>故障转移（FAILOVER）</strong>：
若某执行器节点宕机，调度中心自动将任务路由至其他健康节点重新执行<a class=link href=@ref>3,6</a>。</li><li><strong>超时控制</strong>：
设置任务超时时间（如30分钟），超时后主动中断任务并触发重试或告警<a class=link href=@ref>5</a>。</li></ul><h4 id=扩展重试策略结合第三方库><strong>扩展重试策略（结合第三方库）</strong></h4><p>若需复杂重试逻辑（如指数退避），可集成<code>Spring Retry</code>或<code>Guava Retrying</code><a class=link href=@ref>1</a>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>org.springframework.retry.annotation.Backoff</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>org.springframework.retry.annotation.Retryable</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>OrderService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Retryable</span><span class=p>(</span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Exception</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>maxAttempts</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>5</span><span class=p>,</span><span class=w> </span><span class=n>backoff</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nd>@Backoff</span><span class=p>(</span><span class=n>delay</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>2000</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>syncOrderData</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 业务逻辑（失败时按2秒间隔重试5次）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=失败告警与日志><strong>失败告警与日志</strong></h4><ul><li><strong>告警机制</strong>：任务失败后自动发送邮件/钉钉通知，并支持扩展短信等渠道<a class=link href=@ref>5,6</a>。</li><li><strong>日志追踪</strong>：通过调度中心实时查看任务日志（包括重试记录），支持Rolling方式监控执行进度<a class=link href=@ref>4</a>。</li></ul><hr><h3 id=-调度与重试的协同流程>⚡ <strong>调度与重试的协同流程</strong></h3><ol><li><strong>任务触发</strong>：调度中心根据Cron规则触发任务，生成调度日志。</li><li><strong>执行失败</strong>：执行器返回失败状态（如网络超时、业务异常）。</li><li>自动重试：<ul><li>调度中心根据配置的重试次数，重新生成调度请求<a class=link href=@ref>5</a>。</li><li>若启用故障转移，自动切换至其他执行器节点。</li></ul></li><li>最终处理：<ul><li>重试成功：更新任务状态为成功，记录日志。</li><li>重试耗尽：标记任务失败，触发告警通知负责人<a class=link href=@ref>2,6</a>。</li></ul></li></ol><hr><h3 id=-最佳实践建议>🧩 <strong>最佳实践建议</strong></h3><ol><li>重试参数配置：<ul><li>短时任务：重试间隔建议1~5秒，避免堆积。</li><li>长时任务：设置较大超时时间（如小时级），重试间隔按分钟递增<a class=link href=@ref>1,5</a>。</li></ul></li><li><strong>幂等性设计</strong>：
在任务逻辑中保证<strong>幂等性</strong>​（如数据库唯一键、Redis锁），防止重试导致数据重复<a class=link href=@ref>3</a>。</li><li>集群部署优化：<ul><li>调度中心：至少2节点 + Nginx负载均衡，数据库强制走主库。</li><li>执行器：与业务服务同机部署，通过唯一<code>appname</code>标识集群<a class=link href=@ref>6</a>。</li></ul></li></ol><hr><h3 id=-总结-6>💎 <strong>总结</strong></h3><p>XXL-JOB 通过<strong>时间轮调度</strong>、<strong>路由策略</strong>和<strong>多级重试机制</strong>，实现了高可靠的任务调度：</p><ul><li><strong>调度高效性</strong>：预读任务 + 双线程协作减少数据库压力<a class=link href=@ref>3</a>。</li><li><strong>错误容忍度</strong>：内置重试 + 故障转移 + 超时控制保障任务最终成功<a class=link href=@ref>5,6</a>。</li><li><strong>扩展灵活性</strong>：支持第三方重试库集成，适应复杂业务场景<a class=link href=@ref>1</a>。</li></ul><blockquote><p>官方文档参考：<a class=link href=https://github.com/xuxueli/xxl-job target=_blank rel=noopener>XXL-JOB GitHub</a>。</p></blockquote><h2 id=执行器>执行器</h2><p>在Spring Cloud + Spring Boot环境中定义XXL-JOB执行器，需通过<strong>依赖配置、执行器参数定义、Spring Bean注册及任务处理器开发</strong>四步完成。以下是具体步骤和注意事项：</p><hr><h3 id=-添加依赖>🔧 添加依赖</h3><p>在项目的<code>pom.xml</code>中添加XXL-JOB核心依赖（版本需与调度中心一致）：</p><pre tabindex=0><code>&lt;dependency&gt;
    &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;
    &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;
    &lt;version&gt;2.4.2&lt;/version&gt; &lt;!-- 推荐使用2.4.x版本 --&gt;
&lt;/dependency&gt;
</code></pre><blockquote><p><strong>注</strong>：版本需与调度中心兼容，否则可能通信失败<a class=link href=@ref>2,5,6</a>。</p></blockquote><hr><h3 id=-配置执行器参数>⚙️ 配置执行器参数</h3><p>在<code>application.yml</code>或<code>application.properties</code>中配置执行器参数：</p><pre tabindex=0><code>xxl:
  job:
    admin:
      addresses: http://localhost:8080/xxl-job-admin  # 调度中心地址（集群用逗号分隔）
      accessToken: default_token                      # 与调度中心一致的Token[5,6](@ref)
    executor:
      appname: xxl-job-executor-sample               # 执行器名称（调度中心据此分组）
      port: 9999                                     # 执行器端口（单机多实例需不同端口）
      logpath: /data/applogs/xxl-job/jobhandler      # 任务日志存储路径
      logretentiondays: 30                           # 日志保留天数
</code></pre><blockquote><p><strong>关键配置说明</strong>：</p><ul><li><code>appname</code><strong>必须与调度中心执行器配置一致</strong>，否则注册失败<a class=link href=@ref>2,6</a>。</li><li><code>port</code><strong>避免冲突</strong>：单机部署多个执行器时需设置不同端口（如9999、10000）<a class=link href=@ref>6</a>。</li><li><code>accessToken</code><strong>必填</strong>：若调度中心启用Token校验，此处需保持一致<a class=link href=@ref>5,7</a>。</li></ul></blockquote><hr><h3 id=-注册执行器spring-bean>🧩 注册执行器Spring Bean</h3><p>创建配置类，将执行器注入Spring容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Configuration</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>XxlJobConfig</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Value</span><span class=p>(</span><span class=s>&#34;${xxl.job.admin.addresses}&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>adminAddresses</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Value</span><span class=p>(</span><span class=s>&#34;${xxl.job.executor.appname}&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>appname</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Value</span><span class=p>(</span><span class=s>&#34;${xxl.job.executor.port}&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>port</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Bean</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>XxlJobSpringExecutor</span><span class=w> </span><span class=nf>xxlJobExecutor</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>XxlJobSpringExecutor</span><span class=w> </span><span class=n>executor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>XxlJobSpringExecutor</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>executor</span><span class=p>.</span><span class=na>setAdminAddresses</span><span class=p>(</span><span class=n>adminAddresses</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>executor</span><span class=p>.</span><span class=na>setAppname</span><span class=p>(</span><span class=n>appname</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>executor</span><span class=p>.</span><span class=na>setPort</span><span class=p>(</span><span class=n>port</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>executor</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><blockquote><p><strong>作用</strong>：</p><ul><li>该Bean启动时<strong>自动向调度中心注册</strong>执行器<a class=link href=@ref>3,5</a>。</li><li>支持<strong>动态感知</strong>执行器上线/下线，实现高可用<a class=link href=@ref>2</a>。</li></ul></blockquote><hr><h3 id=-定义任务处理器>🛠️ 定义任务处理器</h3><p>使用<code>@XxlJob</code>注解开发任务逻辑：</p><pre tabindex=0><code>@Component
public class SampleJobHandler {
    
    // 1. 简单任务示例
    @XxlJob(&#34;demoJobHandler&#34;)
    public void demoJobHandler() {
        System.out.println(&#34;XXL-JOB任务执行成功, 时间: &#34; + new Date());
    }

    // 2. 分片任务示例
    @XxlJob(&#34;shardingJobHandler&#34;)
    public void shardingJobHandler() {
        int shardIndex = XxlJobHelper.getShardIndex();  // 当前分片索引
        int shardTotal = XxlJobHelper.getShardTotal();  // 总分片数
        System.out.printf(&#34;分片任务: %d/%d%n&#34;, shardIndex, shardTotal);
    }
}
</code></pre><blockquote><p><strong>注解说明</strong>：</p><ul><li><code>@XxlJob("demoJobHandler")</code>中<code>demoJobHandler</code>为<strong>JobHandler名称</strong>，需与调度中心任务配置一致<a class=link href=@ref>5,6</a>。</li><li>方法内可通过<code>XxlJobHelper</code><strong>获取任务参数</strong>、分片信息等上下文<a class=link href=@ref>3,7</a>。</li></ul></blockquote><hr><h3 id=-注意事项与高级配置>⚠️ 注意事项与高级配置</h3><ol><li><strong>执行器集群部署</strong><ul><li>相同<code>appname</code>的执行器自动组成集群，调度中心按<strong>路由策略</strong>（轮询、故障转移等）分发任务<a class=link href=@ref>2,6</a>。</li><li>每个执行器实例的<code>port</code>需唯一，避免端口冲突。</li></ul></li><li><strong>调度中心通信安全</strong><ul><li>生产环境建议配置<code>accessToken</code>，防止未授权访问<a class=link href=@ref>5,7</a>。</li></ul></li><li><strong>日志与监控</strong><ul><li>任务日志存储在<code>logpath</code>目录，可通过调度中心<strong>实时查看</strong><a class=link href=@ref>3</a>。</li><li>执行器异常时，调度中心自动触发<strong>失败重试</strong>或<strong>故障转移</strong><a class=link href=@ref>2</a>。</li></ul></li><li><strong>健康检查</strong>
执行器默认每30秒向调度中心发送<strong>心跳</strong>，离线节点会被自动剔除<a class=link href=@ref>3,6</a>。</li></ol><hr><h3 id=-执行器注册流程示意图>🔄 执行器注册流程示意图</h3><pre tabindex=0><code>graph LR
    A[Spring Boot启动] --&gt; B[加载XxlJobConfig配置]
    B --&gt; C[注册XxlJobSpringExecutor]
    C --&gt; D[向调度中心发送注册请求]
    D --&gt; E{注册成功？}
    E --&gt;|是| F[执行器状态在线]
    E --&gt;|否| G[检查配置后重试]
    F --&gt; H[等待调度任务]
</code></pre><hr><h3 id=-总结-7>💎 总结</h3><ul><li><strong>核心步骤</strong>：依赖 → 配置 → 注册Bean → 开发<code>@XxlJob</code>任务。</li><li>避坑点：<ul><li><code>appname</code>、<code>accessToken</code><strong>必须与调度中心一致</strong>；</li><li>集群环境下<strong>端口唯一</strong>。</li></ul></li><li><strong>扩展能力</strong>：结合分片参数实现<strong>大数据并行处理</strong>，通过<code>XxlJobHelper</code>动态控制任务逻辑<a class=link href=@ref>2,6</a>。</li></ul><blockquote><p>完成上述配置后，启动Spring Boot服务，执行器将自动注册至调度中心。在调度中心<strong>任务管理</strong>页面配置JobHandler名称（如<code>demoJobHandler</code>），即可触发任务执行。</p></blockquote><h2 id=remove>remove</h2><p>在 XXL-JOB 中，<code>/api/jobinfo/remove</code> 接口用于删除任务，其参数和按“已停止”状态删除的操作流程如下：</p><hr><h3 id=-apijobinforemove-接口参数>⚙️ <code>/api/jobinfo/remove</code> 接口参数</h3><div class=table-wrapper><table><thead><tr><th><strong>参数类型</strong></th><th><strong>参数名</strong></th><th><strong>是否必填</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>路径参数</strong></td><td><code>id</code></td><td>✅ 是</td><td>需要删除的任务 ID（唯一标识） 示例：<code>/api/jobinfo/remove/1001</code> 表示删除 ID=1001 的任务 <a class=link href=@ref>1,7</a></td></tr><tr><td><strong>Header</strong></td><td><code>XXL-JOB-ACCESS-TOKEN</code></td><td>✅ 是</td><td>调度中心配置的访问令牌（需与 <code>xxl.job.accessToken</code> 一致）<a class=link href=@ref>3,5</a></td></tr><tr><td><strong>调用示例</strong>：</td><td></td><td></td><td></td></tr></tbody></table></div><pre tabindex=0><code>curl -X DELETE http://localhost:8080/api/jobinfo/remove/1001 \
  -H &#34;XXL-JOB-ACCESS-TOKEN: default_token&#34;
</code></pre><hr><h3 id=-按已停止状态删除任务的步骤>🗑️ 按“已停止”状态删除任务的步骤</h3><p>XXL-JOB 未提供直接按状态删除的 API，需结合查询接口和删除接口实现：</p><ol><li><strong>查询所有任务</strong>
调用 <code>/jobinfo/pageList</code> 接口（GET 请求），获取任务列表，筛选 <code>trigger_status=0</code>（对应“已停止”状态）的任务：<pre tabindex=0><code>curl -X GET &#34;http://localhost:8080/jobinfo/pageList?triggerStatus=0&#34;
</code></pre>返回结果中的 <code>records</code> 数组包含所有已停止任务的信息（含任务 ID）<a class=link href=@ref>1,6</a>。</li><li><strong>批量删除任务</strong>
遍历上一步获取的任务 ID 列表，逐个调用 <code>/api/jobinfo/remove/{id}</code> 删除：<pre tabindex=0><code># 示例：删除 ID 为 1001 和 1002 的任务
curl -X DELETE http://localhost:8080/api/jobinfo/remove/1001 -H &#34;XXL-JOB-ACCESS-TOKEN: default_token&#34;
curl -X DELETE http://localhost:8080/api/jobinfo/remove/1002 -H &#34;XXL-JOB-ACCESS-TOKEN: default_token&#34;
</code></pre></li></ol><hr><h3 id=-注意事项-5>⚠️ 注意事项</h3><ol><li><strong>权限与安全</strong><ul><li>确保调用 API 时携带正确的 <code>XXL-JOB-ACCESS-TOKEN</code>，否则会返回 <code>401</code> 错误<a class=link href=@ref>3,5</a>。</li><li>生产环境建议通过服务端代理调用 API，避免令牌泄露。</li></ul></li><li><strong>状态与删除逻辑</strong><ul><li>“已停止”状态在数据库中对应 <code>xxl_job_info.trigger_status=0</code><a class=link href=@ref>6</a>。</li><li>删除操作是物理删除（直接从数据库移除记录），不可恢复<a class=link href=@ref>6</a>。</li></ul></li><li><strong>替代方案（控制台操作）</strong>
若无需自动化，可直接在 XXL-JOB 管理台操作：<ul><li><strong>步骤</strong>：
任务管理 → 筛选“已停止”状态 → 勾选任务 → 点击“删除”按钮<a class=link href=@ref>4,5</a>。</li></ul></li></ol><hr><h3 id=-总结建议>💎 总结建议</h3><div class=table-wrapper><table><thead><tr><th><strong>操作方式</strong></th><th><strong>适用场景</strong></th><th><strong>复杂度</strong></th></tr></thead><tbody><tr><td><strong>API 批量删除</strong></td><td>需清理大量任务或集成自动化脚本</td><td>中</td></tr><tr><td><strong>控制台手动删除</strong></td><td>临时清理少量任务或运维操作</td><td>低</td></tr></tbody></table></div><blockquote><p>推荐通过 API 删除时，先备份数据库表 <code>xxl_job_info</code>，避免误删重要任务配置<a class=link href=@ref>6</a>。
更多 API 细节参考官方文档：<a class=link href=https://github.com/xuxueli/xxl-job target=_blank rel=noopener>XXL-JOB GitHub</a>。</p></blockquote></section><footer class=article-footer><section class=article-tags><a href=/tags/postopia/>Postopia</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Oct 22, 2025 16:26 CST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/postopiaexactly-once/><div class=article-details><h2 class=article-title>【Postopia】Exactly Once</h2></div></a></article><article><a href=/p/postopiaqps/><div class=article-details><h2 class=article-title>【Postopia】QPS</h2></div></a></article><article><a href=/p/postopiacaffeine/><div class=article-details><h2 class=article-title>【Postopia】caffeine</h2></div></a></article><article><a href=/p/postopiapage/><div class=article-details><h2 class=article-title>【Postopia】page</h2></div></a></article><article><a href=/p/distributedxxl-job/><div class=article-details><h2 class=article-title>【Distributed】XXL-JOB</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>