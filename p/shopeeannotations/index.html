<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='GetMapping 根据 Spring 框架的设计规范，@GetMapping对所在类有明确要求，且类必须添加特定的注解才能使其生效。以下是核心规则和说明：\n⚙️ 1. 类必须声明为 Spring 控制器 @GetMapping所在类必须添加以下任一注解，否则 Spring 无法识别该类为控制器：\n@RestController：\n组合了 @Controller和 @ResponseBody，推荐用于 RESTful API 开发，方法返回值自动转换为 JSON/XML 等数据格式。\n示例：\n@RestController // ✅ 类必须添加此注解 public class UserController { @GetMapping("/user/{id}") public User getUser(@PathVariable Long id) { ... } } @Controller：\n传统 MVC 控制器，需配合 @ResponseBody返回数据（若需返回 JSON 而非视图）。\n示例：\n@Controller // ✅ 类声明为控制器 public class LegacyController { @GetMapping("/data") @ResponseBody // 需显式添加 public String getData() { ... } } 📌 2. @RequestMapping不是必需的，但常用于统一路径前缀 类上无需强制添加 @RequestMapping：\n'><title>【Shopee】Annotations</title><link rel=canonical href=https://dyhes.github.io/p/shopeeannotations/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【Shopee】Annotations"><meta property='og:description' content='GetMapping 根据 Spring 框架的设计规范，@GetMapping对所在类有明确要求，且类必须添加特定的注解才能使其生效。以下是核心规则和说明：\n⚙️ 1. 类必须声明为 Spring 控制器 @GetMapping所在类必须添加以下任一注解，否则 Spring 无法识别该类为控制器：\n@RestController：\n组合了 @Controller和 @ResponseBody，推荐用于 RESTful API 开发，方法返回值自动转换为 JSON/XML 等数据格式。\n示例：\n@RestController // ✅ 类必须添加此注解 public class UserController { @GetMapping("/user/{id}") public User getUser(@PathVariable Long id) { ... } } @Controller：\n传统 MVC 控制器，需配合 @ResponseBody返回数据（若需返回 JSON 而非视图）。\n示例：\n@Controller // ✅ 类声明为控制器 public class LegacyController { @GetMapping("/data") @ResponseBody // 需显式添加 public String getData() { ... } } 📌 2. @RequestMapping不是必需的，但常用于统一路径前缀 类上无需强制添加 @RequestMapping：\n'><meta property='og:url' content='https://dyhes.github.io/p/shopeeannotations/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Shopee'><meta property='article:published_time' content='2025-08-20T00:00:00+00:00'><meta property='article:modified_time' content='2025-08-29T20:44:23+08:00'><meta name=twitter:title content="【Shopee】Annotations"><meta name=twitter:description content='GetMapping 根据 Spring 框架的设计规范，@GetMapping对所在类有明确要求，且类必须添加特定的注解才能使其生效。以下是核心规则和说明：\n⚙️ 1. 类必须声明为 Spring 控制器 @GetMapping所在类必须添加以下任一注解，否则 Spring 无法识别该类为控制器：\n@RestController：\n组合了 @Controller和 @ResponseBody，推荐用于 RESTful API 开发，方法返回值自动转换为 JSON/XML 等数据格式。\n示例：\n@RestController // ✅ 类必须添加此注解 public class UserController { @GetMapping("/user/{id}") public User getUser(@PathVariable Long id) { ... } } @Controller：\n传统 MVC 控制器，需配合 @ResponseBody返回数据（若需返回 JSON 而非视图）。\n示例：\n@Controller // ✅ 类声明为控制器 public class LegacyController { @GetMapping("/data") @ResponseBody // 需显式添加 public String getData() { ... } } 📌 2. @RequestMapping不是必需的，但常用于统一路径前缀 类上无需强制添加 @RequestMapping：\n'><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#getmapping>GetMapping</a><ol><li><a href=#-1-类必须声明为-spring-控制器>⚙️ <strong>1. 类必须声明为 Spring 控制器</strong></a></li><li><a href=#-2>📌 <strong>2. <code>@RequestMapping</code>不是必需的，但常用于统一路径前缀</strong></a></li><li><a href=#-3-常见错误与注意事项>⚠️ <strong>3. 常见错误与注意事项</strong></a></li><li><a href=#-总结类注解的强制性与选择建议>💎 <strong>总结：类注解的强制性与选择建议</strong></a></li></ol></li><li><a href=#restcontroller>RestController</a><ol><li><a href=#-1-类必须声明为-spring-控制器-1>⚙️ <strong>1. 类必须声明为 Spring 控制器</strong></a></li><li><a href=#-2-1>📌 <strong>2. <code>@RequestMapping</code>不是必需的，但常用于统一路径前缀</strong></a></li><li><a href=#-3-常见错误与注意事项-1>⚠️ <strong>3. 常见错误与注意事项</strong></a></li><li><a href=#-总结类注解的强制性与选择建议-1>💎 <strong>总结：类注解的强制性与选择建议</strong></a></li></ol></li><li><a href=#requestmapping>@RequestMapping</a><ol><li><a href=#-1-同时定义多方法的语法>⚙️ <strong>1. 同时定义多方法的语法</strong></a></li><li><a href=#-2-未指定>⚠️ <strong>2. 未指定 <code>method</code>属性的默认行为</strong></a></li><li><a href=#-3-常见错误与注意事项-2>⚠️ <strong>3. 常见错误与注意事项</strong></a></li><li><a href=#-总结>💎 <strong>总结</strong></a></li></ol></li><li><a href=#table>@Table</a><ol><li><a href=#-1-直接通过>✅ <strong>1. 直接通过 <code>@Table.schema()</code>获取</strong></a></li><li><a href=#-2-注意事项>⚠️ <strong>2. 注意事项</strong></a></li><li><a href=#-3-扩展获取其他表信息>🔧 <strong>3. 扩展：获取其他表信息</strong></a></li><li><a href=#-总结-1>💎 <strong>总结</strong></a></li></ol></li><li><a href=#schema><strong>Schema</strong></a><ol><li><a href=#-核心区别>⚙️ <strong>核心区别</strong></a></li><li><a href=#-不同数据库的实现差异>🗂️ <strong>不同数据库的实现差异</strong></a></li><li><a href=#-关键结论>🔍 <strong>关键结论</strong></a></li><li><a href=#-一句话总结>💡 <strong>一句话总结</strong></a></li></ol></li><li><a href=#mybatis>MyBatis</a><ol><li><a href=#-核心结论>✅ <strong>核心结论</strong></a></li><li><a href=#-详细解析>⚙️ <strong>详细解析</strong></a><ol><li><a href=#1-mapper>1. <strong><code>@Mapper</code>和 <code>@MapperScan</code>的必要性</strong></a></li><li><a href=#2-repository>2. <strong><code>@Repository</code>的作用与可选性</strong></a></li></ol></li><li><a href=#-实际配置示例>💡 <strong>实际配置示例</strong></a><ol><li><a href=#场景spring-boot--mybatis-项目>场景：Spring Boot + MyBatis 项目</a></li><li><a href=#配置文件applicationproperties>配置文件（<code>application.properties</code>）</a></li></ol></li><li><a href=#-常见问题>⚠️ <strong>常见问题</strong></a></li><li><a href=#-总结建议>💎 <strong>总结建议</strong></a></li></ol></li><li><a href=#repository>@Repository</a><ol><li><a href=#-1-二者可以共存的原因>✅ 1. <strong>二者可以共存的原因</strong></a></li><li><a href=#-2-同时使用的好处>💡 2. <strong>同时使用的好处</strong></a></li><li><a href=#-3-注意事项>⚠️ 3. <strong>注意事项</strong></a></li><li><a href=#-4-代码示例>🛠️ 4. <strong>代码示例</strong></a></li><li><a href=#-5-替代方案对比>⚖️ 5. <strong>替代方案对比</strong></a></li><li><a href=#-总结建议-1>💎 <strong>总结建议</strong></a></li></ol></li><li><a href=#mybatis-plus>MyBatis Plus</a><ol><li><a href=#-1-mapper-层接口dao-层>🔧 <strong>1. Mapper 层接口（DAO 层）</strong></a></li><li><a href=#-2-service-层接口与实现类>⚙️ <strong>2. Service 层接口与实现类</strong></a></li><li><a href=#-3-基础-mybatis-框架的扩展>📍 <strong>3. 基础 MyBatis 框架的扩展</strong></a></li><li><a href=#-总结继承接口的核心场景>💎 <strong>总结：继承接口的核心场景</strong></a></li><li><a href=#-注意事项>⚠️ <strong>注意事项</strong></a></li></ol></li><li><a href=#select>@Select</a><ol><li><a href=#-1-注解来源>🧩 1. <strong>注解来源</strong></a></li><li><a href=#-2-功能定位>⚙️ 2. <strong>功能定位</strong></a></li><li><a href=#-3-协同使用场景>🔄 3. <strong>协同使用场景</strong></a></li><li><a href=#-4-动态-sql-支持>💎 4. <strong>动态 SQL 支持</strong></a></li><li><a href=#-核心总结>📊 核心总结</a></li></ol></li><li><a href=#全限定名>全限定名</a><ol><li><a href=#-一全限定名的定义与结构>📌 <strong>一、全限定名的定义与结构</strong></a></li><li><a href=#-二为什么需要全限定名>⚙️ <strong>二、为什么需要全限定名？</strong></a></li><li><a href=#-三全限定名的实际应用场景>💡 <strong>三、全限定名的实际应用场景</strong></a></li><li><a href=#-四注意事项>⚠️ <strong>四、注意事项</strong></a></li><li><a href=#-总结-2>💎 <strong>总结</strong></a></li></ol></li><li><a href=#mapper-xml>Mapper xml</a><ol><li><a href=#-一必备结构特征>🔍 <strong>一、必备结构特征</strong></a></li><li><a href=#-二辅助判断特征>🧩 <strong>二、辅助判断特征</strong></a></li><li><a href=#-三完整示例结构>📋 <strong>三、完整示例结构</strong></a></li><li><a href=#-四常见排查点>⚠️ <strong>四、常见排查点</strong></a></li></ol></li><li><a href=#mybatis-常用注解>MyBatis 常用注解</a><ol><li><a href=#-一基础-crud-注解>📌 <strong>一、基础 CRUD 注解</strong></a></li><li><a href=#-二参数与结果集处理注解>🧩 <strong>二、参数与结果集处理注解</strong></a></li><li><a href=#-三关联关系映射注解>🔗 <strong>三、关联关系映射注解</strong></a></li><li><a href=#-四动态-sql-提供者注解>⚙️ <strong>四、动态 SQL 提供者注解</strong></a></li><li><a href=#-五缓存管理注解>💾 <strong>五、缓存管理注解</strong></a></li><li><a href=#-六其他实用注解>⚡ <strong>六、其他实用注解</strong></a></li><li><a href=#-七注解-vs-xml-适用场景对比>📊 <strong>七、注解 vs. XML 适用场景对比</strong></a></li><li><a href=#-总结-3>💎 <strong>总结</strong></a></li></ol></li><li><a href=#kafkalistener>@KafkaListener</a><ol><li><a href=#-1-原生kafkaconsumer-api轮询模式>📦 <strong>1. 原生KafkaConsumer API轮询模式</strong></a></li><li><a href=#-2-动态消费者工厂模式>🧪 <strong>2. 动态消费者工厂模式</strong></a></li><li><a href=#-3-concurrentmessagelistenercontainer配置>⚙️ <strong>3. ConcurrentMessageListenerContainer配置</strong></a></li><li><a href=#-4-手动线程管理原生api--executorservice>🔧 <strong>4. 手动线程管理（原生API + ExecutorService）</strong></a></li><li><a href=#-方案对比与选型建议>💎 <strong>方案对比与选型建议</strong></a></li></ol></li><li><a href=#class-行为>Class 行为</a><ol><li><a href=#-核心原理>🔍 <strong>核心原理</strong></a></li><li><a href=#-与相关概念的对比>⚖️ <strong>与相关概念的对比</strong></a></li><li><a href=#-注意事项-1>⚠️ <strong>注意事项</strong></a></li><li><a href=#-总结-4>💎 <strong>总结</strong></a></li></ol></li><li><a href=#hashmap--reentrantlock>HashMap + ReentrantLock</a><ol><li><a href=#-1-技术可行性分析>⚙️ <strong>1. 技术可行性分析</strong></a></li><li><a href=#-2-性能对比>⚖️ <strong>2. 性能对比</strong></a></li><li><a href=#-3-适用场景与风险>⚠️ <strong>3. 适用场景与风险</strong></a></li><li><a href=#-4-实现方案示例>🛠️ <strong>4. 实现方案示例</strong></a><ol><li><a href=#1-hashmap--reentrantlock全局锁>(1) <code>HashMap + ReentrantLock</code>（全局锁）</a></li><li><a href=#2-concurrenthashmap推荐>(2) <code>ConcurrentHashMap</code>（推荐）</a></li></ol></li><li><a href=#-总结建议-2>💎 <strong>总结建议</strong></a></li></ol></li><li><a href=#reentrantlock-和-reentrantreadwritelock>ReentrantLock 和 ReentrantReadWriteLock</a><ol><li><a href=#-1-锁类型与并发性>🔒 <strong>1. 锁类型与并发性</strong></a></li><li><a href=#-2-性能对比-1>⚖️ <strong>2. 性能对比</strong></a></li><li><a href=#-3-功能特性>⚙️ <strong>3. 功能特性</strong></a></li><li><a href=#-4-典型应用场景>🧩 <strong>4. 典型应用场景</strong></a></li><li><a href=#-总结如何选择>💎 <strong>总结：如何选择？</strong></a></li></ol></li><li><a href=#value>@Value</a><ol><li><a href=#-为什么>⚠️ <strong>为什么 <code>@Value</code>注解必须在 Spring 管理的类中使用？</strong></a></li><li><a href=#-替代方案在非-spring-管理类中获取配置>🔧 <strong>替代方案：在非 Spring 管理类中获取配置</strong></a><ol><li><a href=#1-手动从-spring-环境获取属性值>1. <strong>手动从 Spring 环境获取属性值</strong></a></li><li><a href=#2-将类改为-spring-管理>2. <strong>将类改为 Spring 管理</strong></a></li><li><a href=#3-通过>3. <strong>通过 <code>@Bean</code>方法手动注入属性</strong></a></li><li><a href=#4-java-原生方式读取配置文件>4. <strong>Java 原生方式读取配置文件</strong></a></li></ol></li><li><a href=#-总结-5>💎 <strong>总结</strong></a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/snow/ style=background-color:#aa6a4c;color:>踏雪泥</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/shopeeannotations/>【Shopee】Annotations</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Aug 20, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>15 minute read</time></div></footer></div></header><section class=article-content><h2 id=getmapping>GetMapping</h2><p>根据 Spring 框架的设计规范，<code>@GetMapping</code>对所在类有明确要求，且类必须添加特定的注解才能使其生效。以下是核心规则和说明：</p><hr><h3 id=-1-类必须声明为-spring-控制器>⚙️ <strong>1. 类必须声明为 Spring 控制器</strong></h3><p><code>@GetMapping</code>所在类必须添加以下任一注解，否则 Spring 无法识别该类为控制器：</p><ul><li><p><strong><code>@RestController</code></strong>：</p><p>组合了 <code>@Controller</code>和 <code>@ResponseBody</code>，<strong>推荐用于 RESTful API 开发</strong>，方法返回值自动转换为 JSON/XML 等数据格式。</p><p>示例：</p><pre tabindex=0><code>@RestController // ✅ 类必须添加此注解
public class UserController {
    @GetMapping(&#34;/user/{id}&#34;)
    public User getUser(@PathVariable Long id) { ... }
}
</code></pre></li><li><p><strong><code>@Controller</code></strong>：</p><p>传统 MVC 控制器，需配合 <code>@ResponseBody</code>返回数据（若需返回 JSON 而非视图）。</p><p>示例：</p><pre tabindex=0><code>@Controller // ✅ 类声明为控制器
public class LegacyController {
    @GetMapping(&#34;/data&#34;)
    @ResponseBody // 需显式添加
    public String getData() { ... }
}
</code></pre></li></ul><hr><h3 id=-2>📌 <strong>2. <code>@RequestMapping</code>不是必需的，但常用于统一路径前缀</strong></h3><ul><li><p><strong>类上无需强制添加 <code>@RequestMapping</code></strong>：</p><p>若所有方法路径无公共前缀，可直接在方法上使用 <code>@GetMapping</code>定义完整路径。</p></li><li><p><strong>类级 <code>@RequestMapping</code>的作用</strong>：</p><p>为类中所有方法提供统一路径前缀，简化路径管理。</p><p>示例：</p><pre tabindex=0><code>@RestController
@RequestMapping(&#34;/api&#34;) // ✅ 非必需，但可统一路径
public class ApiController {
    @GetMapping(&#34;/users&#34;) // 完整路径：/api/users
    public List&lt;User&gt; getUsers() { ... }
}
</code></pre></li></ul><hr><h3 id=-3-常见错误与注意事项>⚠️ <strong>3. 常见错误与注意事项</strong></h3><ol><li><p><strong>缺少控制器注解</strong>：</p><p>若类未添加 <code>@RestController</code>或 <code>@Controller</code>，<code>@GetMapping</code>会完全失效，Spring 不会注册该方法的路由。</p></li><li><p><strong>混淆 <code>@RestController</code>与 <code>@Controller</code></strong>：</p><ul><li><code>@RestController</code>方法<strong>自动返回数据</strong>（无需 <code>@ResponseBody</code>）。</li><li><code>@Controller</code>方法默认返回视图名称，需额外添加 <code>@ResponseBody</code>返回数据。</li></ul></li><li><p><strong>路径冲突问题</strong>：</p><p>同类或不同类中定义重复路径的 <code>@GetMapping</code>，会导致 Spring 启动报错。</p></li></ol><hr><h3 id=-总结类注解的强制性与选择建议>💎 <strong>总结：类注解的强制性与选择建议</strong></h3><ol><li><p><strong>必须添加的类注解</strong>：</p><p><code>@RestController</code>或 <code>@Controller</code><strong>二选一</strong>，否则 <code>@GetMapping</code>无效。</p></li><li><p><strong><code>@RequestMapping</code>的作用</strong>：</p><p>非必需，但推荐在类上添加以统一路径前缀，提升代码可维护性。</p></li><li><p><strong>典型场景选择</strong>：</p><ul><li><strong>返回 JSON/XML 数据</strong> → 优先用 <code>@RestController</code>（简洁且避免重复注解）。</li><li><strong>返回 HTML 视图</strong> → 使用 <code>@Controller</code>+ 视图解析器。</li></ul></li></ol><blockquote><p>示例完整代码结构：</p><pre tabindex=0><code>@RestController // ✅ 必需：声明为 REST 控制器
@RequestMapping(&#34;/api&#34;) // 可选：统一路径前缀
public class DemoController {
    @GetMapping(&#34;/hello&#34;) // ✅ 方法级注解
    public String hello() {
        return &#34;Hello World&#34;;
    }
}
</code></pre></blockquote><h2 id=restcontroller>RestController</h2><p>根据 Spring 框架的设计规范，<code>@GetMapping</code>对所在类有明确要求，且类必须添加特定的注解才能使其生效。以下是核心规则和说明：</p><hr><h3 id=-1-类必须声明为-spring-控制器-1>⚙️ <strong>1. 类必须声明为 Spring 控制器</strong></h3><p><code>@GetMapping</code>所在类必须添加以下任一注解，否则 Spring 无法识别该类为控制器：</p><ul><li><p><strong><code>@RestController</code></strong>：</p><p>组合了 <code>@Controller</code>和 <code>@ResponseBody</code>，<strong>推荐用于 RESTful API 开发</strong>，方法返回值自动转换为 JSON/XML 等数据格式。</p><p>示例：</p><pre tabindex=0><code>@RestController // ✅ 类必须添加此注解
public class UserController {
    @GetMapping(&#34;/user/{id}&#34;)
    public User getUser(@PathVariable Long id) { ... }
}
</code></pre></li><li><p><strong><code>@Controller</code></strong>：</p><p>传统 MVC 控制器，需配合 <code>@ResponseBody</code>返回数据（若需返回 JSON 而非视图）。</p><p>示例：</p><pre tabindex=0><code>@Controller // ✅ 类声明为控制器
public class LegacyController {
    @GetMapping(&#34;/data&#34;)
    @ResponseBody // 需显式添加
    public String getData() { ... }
}
</code></pre></li></ul><hr><h3 id=-2-1>📌 <strong>2. <code>@RequestMapping</code>不是必需的，但常用于统一路径前缀</strong></h3><ul><li><p><strong>类上无需强制添加 <code>@RequestMapping</code></strong>：</p><p>若所有方法路径无公共前缀，可直接在方法上使用 <code>@GetMapping</code>定义完整路径。</p></li><li><p><strong>类级 <code>@RequestMapping</code>的作用</strong>：</p><p>为类中所有方法提供统一路径前缀，简化路径管理。</p><p>示例：</p><pre tabindex=0><code>@RestController
@RequestMapping(&#34;/api&#34;) // ✅ 非必需，但可统一路径
public class ApiController {
    @GetMapping(&#34;/users&#34;) // 完整路径：/api/users
    public List&lt;User&gt; getUsers() { ... }
}
</code></pre></li></ul><hr><h3 id=-3-常见错误与注意事项-1>⚠️ <strong>3. 常见错误与注意事项</strong></h3><ol><li><p><strong>缺少控制器注解</strong>：</p><p>若类未添加 <code>@RestController</code>或 <code>@Controller</code>，<code>@GetMapping</code>会完全失效，Spring 不会注册该方法的路由。</p></li><li><p><strong>混淆 <code>@RestController</code>与 <code>@Controller</code></strong>：</p><ul><li><code>@RestController</code>方法<strong>自动返回数据</strong>（无需 <code>@ResponseBody</code>）。</li><li><code>@Controller</code>方法默认返回视图名称，需额外添加 <code>@ResponseBody</code>返回数据。</li></ul></li><li><p><strong>路径冲突问题</strong>：</p><p>同类或不同类中定义重复路径的 <code>@GetMapping</code>，会导致 Spring 启动报错。</p></li></ol><hr><h3 id=-总结类注解的强制性与选择建议-1>💎 <strong>总结：类注解的强制性与选择建议</strong></h3><ol><li><p><strong>必须添加的类注解</strong>：</p><p><code>@RestController</code>或 <code>@Controller</code><strong>二选一</strong>，否则 <code>@GetMapping</code>无效。</p></li><li><p><strong><code>@RequestMapping</code>的作用</strong>：</p><p>非必需，但推荐在类上添加以统一路径前缀，提升代码可维护性。</p></li><li><p><strong>典型场景选择</strong>：</p><ul><li><strong>返回 JSON/XML 数据</strong> → 优先用 <code>@RestController</code>（简洁且避免重复注解）。</li><li><strong>返回 HTML 视图</strong> → 使用 <code>@Controller</code>+ 视图解析器。</li></ul></li></ol><blockquote><p>示例完整代码结构：</p><pre tabindex=0><code>@RestController // ✅ 必需：声明为 REST 控制器
@RequestMapping(&#34;/api&#34;) // 可选：统一路径前缀
public class DemoController {
    @GetMapping(&#34;/hello&#34;) // ✅ 方法级注解
    public String hello() {
        return &#34;Hello World&#34;;
    }
}
</code></pre></blockquote><h2 id=requestmapping>@RequestMapping</h2><p>在 Spring MVC 框架中，<strong><code>@RequestMapping</code>注解可以同时支持多个 HTTP 请求方法（如 GET 和 POST）</strong>，这是其核心设计特性之一。以下是具体规则和实现方式：</p><hr><h3 id=-1-同时定义多方法的语法>⚙️ <strong>1. 同时定义多方法的语法</strong></h3><p>通过 <code>method</code>属性指定多个 <code>RequestMethod</code>枚举值，以数组形式声明支持的请求方法：</p><pre tabindex=0><code>@RequestMapping(
    value = &#34;/api/data&#34;, 
    method = {RequestMethod.GET, RequestMethod.POST} // ✅ 同时支持 GET 和 POST
)
public String handleData() {
    return &#34;Processed for both GET and POST&#34;;
}
</code></pre><ul><li><strong>效果</strong>：<ul><li>当客户端发起 <strong>GET 请求</strong> <code>/api/data</code>时，该方法被触发。</li><li>当客户端发起 <strong>POST 请求</strong> <code>/api/data</code>时，该方法同样被触发。</li></ul></li></ul><hr><h3 id=-2-未指定>⚠️ <strong>2. 未指定 <code>method</code>属性的默认行为</strong></h3><p>若省略 <code>method</code>属性，则 <strong><code>@RequestMapping</code>默认支持所有 HTTP 请求方法</strong>（包括 GET、POST、PUT、DELETE 等）：</p><pre tabindex=0><code>@RequestMapping(&#34;/api/data&#34;) // ✅ 默认支持所有方法
public String defaultHandler() {
    return &#34;Supports any HTTP method&#34;;
}
</code></pre><p>此写法等同于显式声明 <code>method = {RequestMethod.GET, RequestMethod.POST, ...}</code>。</p><hr><h3 id=-3-常见错误与注意事项-2>⚠️ <strong>3. 常见错误与注意事项</strong></h3><ol><li><strong>衍生注解的限制</strong>：<ul><li><code>@GetMapping</code>、<code>@PostMapping</code>等衍生注解仅支持单一 HTTP 方法（如 <code>@GetMapping</code>仅支持 GET）。</li><li><strong>不可用于多方法支持</strong>，需直接使用 <code>@RequestMapping</code>。</li></ul></li><li><strong>路径冲突问题</strong>：<ul><li>若同一路径存在多个处理器方法（如一个用 <code>@GetMapping</code>，另一个用 <code>@PostMapping</code>），无冲突。</li><li>但若两个方法均用 <code>@RequestMapping</code>且路径相同但未区分 <code>method</code>，启动时会报 <code>Ambiguous mapping</code>错误。</li></ul></li><li><strong>不支持的请求方法处理</strong>：<ul><li>若客户端以未声明的方法请求（如对仅支持 GET/POST 的接口发起 PUT 请求），Spring 会返回 <strong><code>405 Method Not Allowed</code></strong> 错误。</li></ul></li></ol><hr><h3 id=-总结>💎 <strong>总结</strong></h3><ul><li><strong>支持多方法</strong>：<code>@RequestMapping</code>可通过 <code>method</code>属性数组（如 <code>{GET, POST}</code>）<strong>同时支持多个 HTTP 方法</strong>。</li><li><strong>默认行为</strong>：未指定 <code>method</code>时，<strong>默认支持所有方法</strong>。</li><li><strong>替代方案</strong>：需严格区分方法时，优先使用衍生注解（如 <code>@GetMapping</code>、<code>@PostMapping</code>）以提高可读性。</li></ul><blockquote><p><strong>示例完整代码</strong>：</p><pre tabindex=0><code>@RestController
public class MultiMethodController {
    // 同时支持 GET 和 POST
    @RequestMapping(value = &#34;/submit&#34;, method = {RequestMethod.GET, RequestMethod.POST})
    public String handleSubmit() {
        return &#34;Processed for GET or POST&#34;;
    }
}
</code></pre></blockquote><h2 id=table>@Table</h2><p>在 Java 持久化框架（如 JPA 或 Hibernate）中，<strong>可以通过 <code>@Table</code>注解直接获取 <code>schema</code>信息</strong>。以下是具体方法及注意事项：</p><hr><h3 id=-1-直接通过>✅ <strong>1. 直接通过 <code>@Table.schema()</code>获取</strong></h3><p><code>@Table</code>注解提供了 <code>schema</code>属性，用于显式指定数据库模式（Schema）。通过反射即可读取该值：</p><pre tabindex=0><code>import javax.persistence.Table;

public class SchemaUtils {
    public static String getSchemaName(Class&lt;?&gt; entityClass) {
        Table tableAnnotation = entityClass.getAnnotation(Table.class);
        if (tableAnnotation != null) {
            return tableAnnotation.schema(); // 直接返回 schema 属性值
        }
        return &#34;&#34;; // 未显式指定时返回空字符串
    }
}
</code></pre><p><strong>示例用法</strong>：</p><pre tabindex=0><code>// 实体类声明
@Entity
@Table(name = &#34;users&#34;, schema = &#34;public&#34;)
public class User { ... }

// 获取 schema
String schema = SchemaUtils.getSchemaName(User.class);
System.out.println(schema); // 输出: public
</code></pre><hr><h3 id=-2-注意事项>⚠️ <strong>2. 注意事项</strong></h3><ul><li><p><strong>显式声明才有效</strong>：</p><p>仅当实体类上明确配置了 <code>@Table(schema = "xxx")</code>时才能获取到值。若未指定，<code>schema()</code>返回空字符串（<code>""</code>）。</p></li><li><p><strong>默认行为</strong>：</p><p>若未配置 <code>schema</code>，JPA 会使用数据库默认模式（如 PostgreSQL 的 <code>public</code>、MySQL 的数据库名），但<strong>框架不会将默认值填充到注解属性中</strong>，因此反射无法捕获默认值。</p></li><li><p><strong>多租户场景</strong>：</p><p>在需要动态 Schema 的场景（如 SaaS 多租户），通常需结合 <code>Hibernate</code>的 <code>CurrentTenantIdentifierResolver</code>或 <code>Spring</code>的动态数据源路由实现，而非依赖注解值。</p></li></ul><hr><h3 id=-3-扩展获取其他表信息>🔧 <strong>3. 扩展：获取其他表信息</strong></h3><p><code>@Table</code>注解还支持以下属性，均可通过反射获取：</p><ul><li><p><strong><code>name</code></strong>：表名（最常用）</p></li><li><p><strong><code>catalog</code></strong>：数据库目录名（类似 Schema）</p></li><li><p><strong><code>uniqueConstraints</code></strong>：表级唯一约束</p><p>示例代码：</p></li></ul><pre tabindex=0><code>Table table = entityClass.getAnnotation(Table.class);
String tableName = table.name(); 
String catalog = table.catalog(); 
UniqueConstraint[] constraints = table.uniqueConstraints();
</code></pre><hr><h3 id=-总结-1>💎 <strong>总结</strong></h3><ul><li><p><strong>能否获取 Schema</strong>：✅ 能，但<strong>必须显式声明</strong>在 <code>@Table(schema = "...")</code>中。</p></li><li><p><strong>未声明时的返回值</strong>：空字符串（<code>""</code>），而非数据库实际默认模式。</p></li><li><p><strong>适用场景</strong>：</p><p>适合需要固定 Schema 的常规项目；动态 Schema 需通过 ORM 框架的租户隔离机制实现。</p></li></ul><h2 id=schema><strong>Schema</strong></h2><p>数据库中的 <strong>Schema（模式）</strong> 与 <strong>Database（数据库）</strong> 是不同层级的概念，<strong>Schema 并不是一个单独的数据库</strong>，而是数据库内部的逻辑组织单元。具体区别如下：</p><hr><h3 id=-核心区别>⚙️ <strong>核心区别</strong></h3><ol><li><strong>Database（数据库）</strong><ul><li>是<strong>物理或逻辑上的顶层容器</strong>，包含所有数据文件、用户权限、表空间等资源。</li><li>不同数据库之间<strong>物理隔离</strong>（如 PostgreSQL 中无法直接跨库查询）。</li><li><strong>示例</strong>：一个电商系统可能包含 <code>order_db</code>（订单库）、<code>user_db</code>（用户库）等独立数据库。</li></ul></li><li><strong>Schema（模式）</strong><ul><li>是数据库内部的<strong>逻辑分组工具</strong>，用于组织表、视图、索引等对象。</li><li>同一数据库下可包含<strong>多个 Schema</strong>，不同 Schema 可存在同名对象（需用 <code>schema_name.object_name</code>访问）。</li><li><strong>示例</strong>：在 <code>order_db</code>中可创建 <code>payment_schema</code>（支付模块）、<code>logistics_schema</code>（物流模块）等。</li></ul></li></ol><hr><h3 id=-不同数据库的实现差异>🗂️ <strong>不同数据库的实现差异</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>数据库类型</strong></th><th><strong>Schema 的本质</strong></th><th><strong>与 Database 的关系</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>MySQL</strong></td><td>Schema <strong>等同于 Database</strong></td><td><code>CREATE SCHEMA</code>= <code>CREATE DATABASE</code></td><td>每个 Schema 是一个独立的物理数据库，无法在库内再分 Schema 。</td></tr><tr><td><strong>PostgreSQL</strong></td><td>Database <strong>内部的命名空间</strong></td><td>一个 Database → 多个 Schema</td><td>通过 <code>search_path</code>设置默认 Schema，支持跨 Schema 查询 。</td></tr><tr><td><strong>Oracle</strong></td><td><strong>用户即 Schema</strong></td><td>创建用户时自动生成同名 Schema</td><td>用户 <code>scott</code>的 Schema 名为 <code>scott</code>，访问其他 Schema 需授权 。</td></tr><tr><td><strong>SQL Server</strong></td><td><strong>权限容器 & 命名空间</strong></td><td>一个 Database → 多个 Schema</td><td>权限可授予整个 Schema（如 <code>GRANT SELECT ON SCHEMA::sales</code>）。</td></tr></tbody></table></div><hr><h3 id=-关键结论>🔍 <strong>关键结论</strong></h3><ol><li><strong>Schema ≠ 数据库</strong><ul><li>Schema 是<strong>逻辑结构</strong>，用于组织对象；Database 是<strong>物理/逻辑容器</strong>，包含所有资源 。</li></ul></li><li><strong>隔离性不同</strong><ul><li>Database 提供<strong>物理隔离</strong>（如独立存储文件）；Schema 提供<strong>逻辑隔离</strong>（如权限控制、命名空间）。</li></ul></li><li><strong>应用场景</strong><ul><li><strong>多租户系统</strong>：用 PostgreSQL/SQL Server 的 Schema 隔离租户数据（一租户一 Schema）。</li><li><strong>微服务架构</strong>：MySQL 中每个服务使用独立 Database（因 Schema 无法再分组）。</li><li><strong>权限管理</strong>：SQL Server 的 Schema 级授权简化批量权限分配 。</li></ul></li></ol><hr><h3 id=-一句话总结>💡 <strong>一句话总结</strong></h3><blockquote><p>Schema 是数据库的“子文件夹”，用于逻辑分组；Database 是“总仓库”，提供物理存储和全局管理。<strong>Schema 不是独立数据库，而是数据库内部的高效管理工具</strong>。</p></blockquote><h2 id=mybatis>MyBatis</h2><p>在 MyBatis 中，Mapper 接口是否需要标记为 <code>@Mapper</code>或 <code>@Repository</code>，取决于项目配置和需求。以下是核心结论及详细解析：</p><hr><h3 id=-核心结论>✅ <strong>核心结论</strong></h3><ol><li><strong><code>@Mapper</code>或 <code>@MapperScan</code>必须二选一</strong><ul><li>两者都不加时，MyBatis 无法识别 Mapper 接口，导致启动报错。</li><li><strong><code>@Mapper</code></strong>：需标注在每个 Mapper 接口上（适用于接口数量少的场景）。</li><li><strong><code>@MapperScan</code></strong>：在启动类或配置类上标注，指定 Mapper 接口的包路径（<strong>推荐</strong>，避免重复注解）。</li></ul></li><li><strong><code>@Repository</code>是可选的</strong><ul><li>主要作用：解决 IDE 的注入警告（如 “Could not autowire”），不影响实际运行。</li><li>若需显式声明 DAO 层组件或统一异常处理（将原生异常转为 Spring <code>DataAccessException</code>），可添加此注解。</li></ul></li></ol><hr><h3 id=-详细解析>⚙️ <strong>详细解析</strong></h3><h4 id=1-mapper>1. <strong><code>@Mapper</code>和 <code>@MapperScan</code>的必要性</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>注解</strong></th><th><strong>作用</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td><strong><code>@Mapper</code></strong></td><td>MyBatis 注解，标记接口为 Mapper，运行时动态生成代理类执行 SQL。</td><td>需在每个 Mapper 接口上单独标注，适合小型项目。</td></tr><tr><td><strong><code>@MapperScan</code></strong></td><td>Spring 注解，扫描指定包下所有接口并注册为 Mapper Bean（自动应用 <code>@Mapper</code>逻辑）。</td><td>在启动类添加（如 <code>@MapperScan("com.mapper")</code>），适合中大型项目。</td></tr></tbody></table></div><p><strong>注意</strong>：两者必须至少使用一个，否则 MyBatis 无法创建 Mapper 代理对象，导致依赖注入失败。</p><hr><h4 id=2-repository>2. <strong><code>@Repository</code>的作用与可选性</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>功能</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>消除 IDE 警告</strong></td><td>单独使用 <code>@Mapper</code>时，Spring 无法直接识别 MyBatis 代理 Bean，导致 IDE 提示注入错误（实际运行正常）。添加 <code>@Repository</code>（Spring 注解）可显式注册 Bean，消除警告。</td></tr><tr><td><strong>异常转换</strong></td><td>将 JDBC、MyBatis 等原生异常统一转换为 Spring <code>DataAccessException</code>，提升异常处理一致性。</td></tr><tr><td><strong>明确分层职责</strong></td><td>符合 Spring 架构规范，明确标识该类为数据访问层（DAO）组件。</td></tr></tbody></table></div><p><strong>最佳实践</strong>：</p><ul><li><p><strong>推荐组合</strong>：<code>@MapperScan</code>+ <code>@Repository</code></p><p>同时解决 Bean 注册、异常转换和 IDE 警告问题，代码更规范。</p></li><li><p><strong>简化方案</strong>：仅用 <code>@MapperScan</code></p><p>接受 IDE 警告（可通过设置忽略），减少注解冗余。</p></li></ul><hr><h3 id=-实际配置示例>💡 <strong>实际配置示例</strong></h3><h4 id=场景spring-boot--mybatis-项目>场景：Spring Boot + MyBatis 项目</h4><pre tabindex=0><code>// 启动类：批量扫描 Mapper 包
@SpringBootApplication
@MapperScan(&#34;com.example.mapper&#34;) // 必须二选一
public class App { ... }

// Mapper 接口：可选添加 @Repository
@Repository // 消除警告 + 异常转换（可选）
public interface UserMapper {
    @Select(&#34;SELECT * FROM user WHERE id = #{id}&#34;)
    User getUserById(int id);
}
</code></pre><h4 id=配置文件applicationproperties>配置文件（<code>application.properties</code>）</h4><pre tabindex=0><code># 指定 XML 文件位置（若使用 XML 而非注解）
mybatis.mapper-locations=classpath:mapper/*.xml
</code></pre><hr><h3 id=-常见问题>⚠️ <strong>常见问题</strong></h3><ol><li><strong>为什么 <code>@Autowired</code>注入 Mapper 会报红？</strong><ul><li>未添加 <code>@Repository</code>时，Spring 无法在编译期识别 MyBatis 动态代理生成的 Bean（运行时正常）。</li></ul></li><li><strong><code>@Repository</code>是否影响 MyBatis 代理？</strong><ul><li>不会。MyBatis 优先通过 <code>@Mapper</code>/<code>@MapperScan</code>生成代理，<code>@Repository</code>仅作为 Spring Bean 标识。</li></ul></li><li><strong>纯 MyBatis 项目（无 Spring）如何配置？</strong><ul><li>只需用 <code>@Mapper</code>，无需 <code>@Repository</code>（后者是 Spring 特有）。</li></ul></li></ol><hr><h3 id=-总结建议>💎 <strong>总结建议</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方案</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td>Spring Boot + MyBatis</td><td><code>@MapperScan</code>+ <code>@Repository</code></td><td>避免警告、统一异常处理、符合分层规范。</td></tr><tr><td>小型项目/简化配置</td><td>仅 <code>@MapperScan</code></td><td>减少注解冗余，接受 IDE 警告。</td></tr><tr><td>非 Spring 项目（纯 MyBatis）</td><td>仅 <code>@Mapper</code></td><td>无 Spring 依赖，轻量。</td></tr></tbody></table></div><p>合理选择注解组合，既能提升开发体验，又能确保项目规范性与可维护性。</p><h2 id=repository>@Repository</h2><p>在 MyBatis 与 Spring/Spring Boot 整合的项目中，<strong>可以同时使用 <code>@Mapper</code>和 <code>@Repository</code>注解</strong>，且这种组合是常见且推荐的实践。以下是具体分析和使用建议：</p><hr><h3 id=-1-二者可以共存的原因>✅ 1. <strong>二者可以共存的原因</strong></h3><ul><li><p><strong>职责互补</strong>：</p><ul><li><code>@Mapper</code>（MyBatis 提供）：标识接口为 MyBatis Mapper，<strong>动态生成代理实现类</strong>，执行 SQL 映射逻辑。</li><li><code>@Repository</code>（Spring 提供）：将接口声明为 Spring Bean，<strong>解决 IDE 的依赖注入警告</strong>，并启用 Spring 的<strong>统一异常转换机制</strong>（将 JDBC、MyBatis 等原生异常转为 <code>DataAccessException</code>）。</li></ul></li><li><p><strong>无冲突</strong>：</p><p>MyBatis 优先通过 <code>@Mapper</code>生成代理对象，<code>@Repository</code>仅作为 Spring Bean 的标识，二者协同工作。</p></li></ul><hr><h3 id=-2-同时使用的好处>💡 2. <strong>同时使用的好处</strong></h3><ol><li><p><strong>消除 IDE 警告</strong>：</p><p>仅用 <code>@Mapper</code>时，Spring 在编译期无法识别动态代理生成的 Bean，导致 IDE 提示“无法注入”的红色警告（如 <code>Could not autowire</code>），但实际运行正常。添加 <code>@Repository</code>可显式声明 Bean，消除警告。</p></li><li><p><strong>启用异常统一处理</strong>：</p><p><code>@Repository</code>触发 Spring 的异常转换机制，避免业务层直接处理底层数据库异常（如 SQLException），提升代码健壮性。</p></li><li><p><strong>明确分层职责</strong>：</p><p>符合分层架构规范（Controller → Service → Repository），增强代码可读性。</p></li></ol><hr><h3 id=-3-注意事项>⚠️ 3. <strong>注意事项</strong></h3><ol><li><p><strong><code>@Mapper</code>是必需的</strong>：</p><ul><li>若省略 <code>@Mapper</code>，MyBatis 无法识别接口，导致 SQL 映射失效。</li><li>替代方案：使用 <code>@MapperScan</code>批量扫描包路径，避免在每个接口上单独添加 <code>@Mapper</code>。</li></ul></li><li><p><strong><code>@Repository</code>需配合组件扫描</strong>：</p><p>确保 Spring 扫描到 Mapper 接口所在包（如启动类添加 <code>@ComponentScan</code>或 <code>@SpringBootApplication</code>默认扫描当前包）。</p></li><li><p><strong>避免用于实现类</strong>：</p><p><code>@Repository</code>应标注在 <strong>Mapper 接口</strong>上，而非实现类（MyBatis 动态代理生成实现类，手动实现类会导致冲突）。</p></li></ol><hr><h3 id=-4-代码示例>🛠️ 4. <strong>代码示例</strong></h3><pre tabindex=0><code>// Mapper 接口：同时使用 @Mapper + @Repository
@Repository
@Mapper
public interface UserMapper {
    @Select(&#34;SELECT * FROM user WHERE id = #{id}&#34;)
    User findById(int id);
}

// Service 层：注入 Mapper
@Service
public class UserService {
    @Autowired
    private UserMapper userMapper; // 无 IDE 警告，且支持异常转换
}
</code></pre><hr><h3 id=-5-替代方案对比>⚖️ 5. <strong>替代方案对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>方案</strong></th><th>是否必需</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong><code>@Mapper</code>+ <code>@Repository</code></strong></td><td>否</td><td>消除警告、异常转换、分层明确</td><td>需每个接口标注</td></tr><tr><td><strong>仅 <code>@Mapper</code></strong></td><td>是</td><td>最小化配置</td><td>IDE 警告（运行正常）</td></tr><tr><td><strong><code>@MapperScan</code></strong></td><td>是</td><td>批量扫描，避免重复注解</td><td>仍可能需 <code>@Repository</code>消警告</td></tr></tbody></table></div><hr><h3 id=-总结建议-1>💎 <strong>总结建议</strong></h3><ul><li><p><strong>推荐组合</strong>：<code>@Mapper</code>+ <code>@Repository</code></p><p>适用于所有 Spring + MyBatis 项目，兼顾功能性与开发体验。</p></li><li><p><strong>简化方案</strong>：</p><ul><li>小型项目：仅用 <code>@Mapper</code>（接受 IDE 警告）。</li><li>中大型项目：<code>@MapperScan</code>+ <code>@Repository</code>（批量扫描 + 消除警告）。</li></ul></li></ul><blockquote><p><strong>关键点</strong>：<code>@Mapper</code>确保 MyBatis 功能，<code>@Repository</code>优化 Spring 整合体验，二者协同无冲突且提升代码质量。</p></blockquote><h2 id=mybatis-plus>MyBatis Plus</h2><p>在 MyBatis（尤其是其增强框架 MyBatis-Plus）中，不同层级的类需要继承特定接口以实现基础功能。以下是核心接口的继承规则及作用：</p><hr><h3 id=-1-mapper-层接口dao-层>🔧 <strong>1. Mapper 层接口（DAO 层）</strong></h3><ul><li><p><strong>继承 <code>BaseMapper&lt;T></code></strong></p><p>例如：<code>UserMapper extends BaseMapper&lt;User></code></p><ul><li><p><strong>功能</strong>：自动获得单表 CRUD 方法（如 <code>selectById</code>、<code>insert</code>、<code>update</code>等），无需编写 SQL 或 XML 映射。</p></li><li><p><strong>注意</strong>：泛型 <code>T</code>需指定对应的实体类（如 <code>User</code>）。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Mapper
public interface UserMapper extends BaseMapper&lt;User&gt; {
    // 可添加自定义查询方法
    List&lt;User&gt; selectByName(String name);
}
</code></pre></li></ul></li></ul><hr><h3 id=-2-service-层接口与实现类>⚙️ <strong>2. Service 层接口与实现类</strong></h3><ul><li><p><strong>Service 接口</strong>：<strong>继承 <code>IService&lt;T></code></strong></p><p>例如：<code>UserService extends IService&lt;User></code></p><ul><li><strong>功能</strong>：定义业务逻辑方法（如批量操作、事务管理），提供更语义化的 API（如 <code>saveBatch</code>、<code>removeById</code>）。</li></ul></li><li><p><strong>ServiceImpl 实现类</strong>：<strong>继承 <code>ServiceImpl&lt;M, T></code>并实现 Service 接口</strong></p><p>例如：<code>UserServiceImpl extends ServiceImpl&lt;UserMapper, User> implements UserService</code></p><ul><li><strong>关键点</strong>：<ul><li><code>M</code>需传入继承 <code>BaseMapper&lt;T></code>的 Mapper 接口（如 <code>UserMapper</code>）。</li><li><code>T</code>为实体类（如 <code>User</code>）。</li></ul></li><li><strong>作用</strong>：通过 <code>ServiceImpl</code>自动实现 <code>IService</code>中的方法（如 <code>save()</code>内部调用 <code>baseMapper.insert()</code>）。</li></ul></li></ul><hr><h3 id=-3-基础-mybatis-框架的扩展>📍 <strong>3. 基础 MyBatis 框架的扩展</strong></h3><ul><li>若不使用 MyBatis-Plus，Mapper 接口<strong>无需强制继承接口</strong>，但需遵循规范：<ul><li>XML 文件的 <code>namespace</code>需与 Mapper 接口全限定名一致。</li><li>方法名与 XML 中 SQL 语句的 <code>id</code>匹配。</li></ul></li><li>可自定义基础接口（如 <code>BaseMapper</code>）复用通用方法，但需手动实现 SQL 映射。</li></ul><hr><h3 id=-总结继承接口的核心场景>💎 <strong>总结：继承接口的核心场景</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>层级</strong></th><th><strong>需继承的接口/类</strong></th><th><strong>作用</strong></th><th>示例</th></tr></thead><tbody><tr><td>Mapper 接口</td><td><code>BaseMapper&lt;T></code></td><td>自动生成单表 CRUD SQL</td><td><code>UserMapper extends BaseMapper&lt;User></code></td></tr><tr><td>Service 接口</td><td><code>IService&lt;T></code></td><td>定义业务方法（批量、事务）</td><td><code>UserService extends IService&lt;User></code></td></tr><tr><td>Service 实现类</td><td><code>ServiceImpl&lt;M, T></code></td><td>实现 <code>IService</code>并代理 Mapper 操作</td><td><code>UserServiceImpl extends ServiceImpl&lt;UserMapper, User></code></td></tr></tbody></table></div><hr><h3 id=-注意事项>⚠️ <strong>注意事项</strong></h3><ul><li><strong>避免跨层调用</strong>：Service 层应封装业务逻辑，Controller 层不应直接调用 <code>BaseMapper</code>。</li><li><strong>自定义扩展</strong>：若需多表联查或复杂 SQL，可在 Mapper 接口中定义方法并配合 XML/注解实现。</li><li><strong>事务管理</strong>：涉及多表操作时，在 Service 层使用 <code>@Transactional</code>注解。</li></ul><p>通过继承上述接口，MyBatis-Plus 可大幅减少重复代码，而原生 MyBatis 需更多手动配置，但灵活性更高。</p><h2 id=select>@Select</h2><p><code>@Select</code>、<code>@Insert</code>、<code>@Update</code>、<code>@Delete</code>等注解是 <strong>MyBatis 原生提供的注解</strong>，并非 MyBatis-Plus 的扩展功能。以下是关键区分点：</p><hr><h3 id=-1-注解来源>🧩 1. <strong>注解来源</strong></h3><ul><li><p><strong>MyBatis 原生注解</strong>：</p><p><code>@Select</code>、<code>@Insert</code>、<code>@Update</code>、<code>Delete</code>、<code>@Results</code>、<code>@Result</code>、<code>@Param</code>、<code>@Options</code>等均属于 MyBatis 核心包 <code>org.apache.ibatis.annotations</code>中定义的注解。</p><p><strong>作用</strong>：用于直接在 Mapper 接口方法上编写 SQL，替代 XML 配置。</p></li><li><p><strong>MyBatis-Plus 扩展注解</strong>：</p><p><code>@TableName</code>、<code>@TableId</code>、<code>@TableField</code>、<code>@TableLogic</code>、<code>@Version</code>等是 MyBatis-Plus 特有的注解，用于增强实体类与数据库表的映射、主键策略、逻辑删除等功能。</p></li></ul><hr><h3 id=-2-功能定位>⚙️ 2. <strong>功能定位</strong></h3><ul><li><p><strong>MyBatis 原生注解</strong>：</p><p>提供基础的 SQL 操作能力，支持自定义 SQL 语句（静态或动态），但需手动编写完整 SQL。</p><p>例如：</p><pre tabindex=0><code>@Select(&#34;SELECT * FROM user WHERE name = #{name}&#34;)
User findByName(@Param(&#34;name&#34;) String name);
</code></pre></li><li><p><strong>MyBatis-Plus 注解</strong>：</p><p>专注于简化开发：</p><ul><li><code>@TableName</code>：实体类与表名映射；</li><li><code>@TableId</code>：主键策略（如自增、雪花算法）；</li><li><code>@TableField</code>：字段映射与非表字段排除（<code>exist = false</code>）；</li><li><code>@TableLogic</code>：逻辑删除标记。</li></ul></li></ul><hr><h3 id=-3-协同使用场景>🔄 3. <strong>协同使用场景</strong></h3><p>MyBatis-Plus 兼容 MyBatis 原生注解，实践中常<strong>组合使用</strong>：</p><ul><li><p><strong>示例</strong>：Mapper 接口继承 <code>BaseMapper</code>（MyBatis-Plus）的同时，用 <code>@Select</code>编写复杂查询：</p><pre tabindex=0><code>public interface UserMapper extends BaseMapper&lt;User&gt; {
    @Select(&#34;SELECT * FROM user WHERE age &gt; #{age}&#34;)
    List&lt;User&gt; selectByAge(@Param(&#34;age&#34;) int age);
}
</code></pre><p>此处 <code>BaseMapper</code>提供通用 CRUD 方法，<code>@Select</code>补充自定义 SQL。</p></li></ul><hr><h3 id=-4-动态-sql-支持>💎 4. <strong>动态 SQL 支持</strong></h3><ul><li><p><strong>MyBatis 原生方案</strong>：</p><p>通过 <code>@SelectProvider</code>、<code>@UpdateProvider</code>等实现动态 SQL（需配合工具类）。</p></li><li><p><strong>MyBatis-Plus 方案</strong>：</p><p>提供 <code>QueryWrapper</code>/<code>LambdaQueryWrapper</code>链式构造条件，无需手写 SQL。</p></li></ul><hr><h3 id=-核心总结>📊 核心总结</h3><div class=table-wrapper><table><thead><tr><th><strong>注解类型</strong></th><th>代表注解</th><th>归属框架</th><th>主要作用</th></tr></thead><tbody><tr><td><strong>MyBatis 原生</strong></td><td><code>@Select</code>, <code>@Insert</code>, <code>@Results</code></td><td>MyBatis</td><td>自定义 SQL 与结果映射</td></tr><tr><td><strong>MyBatis-Plus 扩展</strong></td><td><code>@TableName</code>, <code>@TableId</code></td><td>MyBatis-Plus</td><td>表/字段映射、主键策略、逻辑删除等</td></tr></tbody></table></div><blockquote><p>✅ <strong>结论</strong>：</p><p><code>@Select</code>等 SQL 操作注解属于 <strong>MyBatis</strong>，而 MyBatis-Plus 在其基础上扩展了实体映射与自动化功能。两者可无缝协作，兼顾灵活性与开发效率。</p></blockquote><h2 id=全限定名>全限定名</h2><p>在Java中，<strong>类的全限定名（Fully Qualified Name）</strong> 是唯一标识一个类的完整名称，由包名（Package Name）和类名（Class Name）组成，中间用点号<code>.</code>分隔。其核心作用是<strong>避免命名冲突</strong>，确保在复杂项目中准确引用特定类。以下是详细解析：</p><hr><h3 id=-一全限定名的定义与结构>📌 <strong>一、全限定名的定义与结构</strong></h3><ul><li><p><strong>格式</strong>：<code>包名.类名</code></p><p>示例：</p><ul><li><code>java.lang.String</code>（Java核心字符串类）</li><li><code>com.example.model.User</code>（自定义用户类）</li></ul></li><li><p><strong>包名的作用</strong>：</p><p>包名本质是命名空间，通常按<strong>域名反写</strong>（如<code>com.example</code>）组织，防止不同组织或项目的类名冲突。</p></li><li><p><strong>与简单类名的区别</strong>：</p><p>简单类名（如<code>String</code>）仅包含类本身名称，而全限定名包含完整路径，确保全局唯一性。</p></li></ul><hr><h3 id=-二为什么需要全限定名>⚙️ <strong>二、为什么需要全限定名？</strong></h3><ol><li><p><strong>解决命名冲突</strong></p><ul><li><p>当不同包中存在同名类时（如<code>java.util.Date</code>与<code>java.sql.Date</code>），全限定名可明确指定具体类，避免歧义。</p></li><li><p>示例：</p><pre tabindex=0><code>java.util.Date utilDate = new java.util.Date();  // 明确使用java.util包的Date类
java.sql.Date sqlDate = new java.sql.Date();     // 明确使用java.sql包的Date类
</code></pre></li></ul></li><li><p><strong>支持跨模块引用</strong></p><ul><li>在大型项目中，全限定名允许不同模块直接引用外部类，无需担心包结构重叠。</li></ul></li><li><p><strong>类加载器的依赖</strong></p><ul><li>JVM通过全限定名定位<code>.class</code>文件。类加载器（ClassLoader）根据全限定名在类路径中搜索并加载类。</li></ul></li></ol><hr><h3 id=-三全限定名的实际应用场景>💡 <strong>三、全限定名的实际应用场景</strong></h3><ol><li><p><strong>显式引用类（无import语句）</strong></p><p>直接使用全限定名实例化对象或调用静态方法：</p><pre tabindex=0><code>com.example.Utils.doSomething();  // 直接通过全限定名调用工具类方法
</code></pre></li><li><p><strong>反射机制</strong></p><p>反射API（如<code>Class.forName()</code>）必须使用全限定名加载类：</p><pre tabindex=0><code>Class&lt;?&gt; clazz = Class.forName(&#34;com.example.model.User&#34;); // 根据全限定名加载类
</code></pre></li><li><p><strong>配置文件与框架</strong></p><ul><li><p><strong>Spring/MyBatis</strong>：在XML配置中通过全限定名声明Bean或映射类：</p><pre tabindex=0><code>&lt;bean class=&#34;com.example.service.UserService&#34;/&gt; &lt;!-- Spring Bean配置 --&gt;
</code></pre></li><li><p><strong>JDBC驱动注册</strong>：早期JDBC需用<code>Class.forName("com.mysql.jdbc.Driver")</code>加载驱动。</p></li></ul></li><li><p><strong>避免import冲突</strong></p><p>当两个类同名且均被<code>import</code>时，编译器会报错。此时需用全限定名显式指定：</p><pre tabindex=0><code>import com.library1.Utility;
import com.library2.Utility;  // 编译错误！类名冲突

// 解决方案：改用全限定名
com.library1.Utility.runTask(); 
com.library2.Utility.runTask();
</code></pre></li></ol><hr><h3 id=-四注意事项>⚠️ <strong>四、注意事项</strong></h3><ol><li><p><strong>内部类的全限定名</strong></p><p>内部类的全限定名需包含外部类名，格式为<code>外部类全限定名$内部类名</code>：</p><pre tabindex=0><code>com.example.Outer$Inner  // 内部类Inner的全限定名
</code></pre></li><li><p><strong>与文件路径的关联</strong></p><p>类文件在项目中的物理路径需与全限定名匹配：</p><ul><li>全限定名：<code>com.example.MyClass</code></li><li>文件路径：<code>src/main/java/com/example/MyClass.java</code>（Maven标准目录）。</li></ul></li><li><p><strong>IDE与构建工具的简化</strong></p><ul><li><strong>IDE</strong>：自动管理<code>import</code>语句，开发者通常只需写简单类名。</li><li><strong>Maven/Gradle</strong>：依赖管理自动处理类路径，无需手动配置全限定名。</li></ul></li></ol><hr><h3 id=-总结-2>💎 <strong>总结</strong></h3><p>类的全限定名是Java包机制的核心设计，通过**“包名+类名”** 的结构确保类全局唯一。它在解决命名冲突、支持反射、框架配置等场景中不可或缺。实际开发中，尽管IDE和构建工具简化了使用，<strong>深入理解全限定名仍有助于调试类加载问题与跨模块协作</strong>。例如，当遇到<code>ClassNotFoundException</code>时，优先检查全限定名是否与类路径匹配。</p><h2 id=mapper-xml>Mapper xml</h2><p>要判断一个 XML 文件是否是 MyBatis Mapper 文件，需检查其是否符合以下核心特征和规范（按重要性排序）：</p><hr><h3 id=-一必备结构特征>🔍 <strong>一、必备结构特征</strong></h3><ol><li><p><strong>根标签 <code>&lt;mapper></code></strong></p><ul><li>文件必须包含 <code>&lt;mapper></code>作为根标签，且其 <code>namespace</code>属性需指向一个 Java Mapper 接口的<strong>全限定类名</strong>（如 <code>namespace="com.example.UserMapper"</code>）。这是 MyBatis 绑定接口与 XML 的关键标识。</li><li><em>示例</em>：<code>&lt;mapper namespace="com.example.mapper.UserMapper"></code></li></ul></li><li><p><strong>SQL 操作标签</strong></p><ul><li>文件内需包含至少一个 SQL 操作标签（<code>&lt;select></code>、<code>&lt;insert></code>、<code>&lt;update></code>、<code>&lt;delete></code>），且每个标签必须包含 <strong><code>id</code>属性</strong>，其值需与 Mapper 接口中的<strong>方法名完全一致</strong>。</li><li><em>示例</em>：<code>&lt;select id="getUserById" resultType="User"> ... &lt;/select></code></li></ul></li><li><p><strong>DOCTYPE 声明</strong></p><ul><li><p>文件头部需包含 MyBatis 专用的文档类型声明，指向官方 DTD 或 XSD：</p><pre tabindex=0><code>&lt;!DOCTYPE mapper PUBLIC &#34;-//mybatis.org//DTD Mapper 3.0//EN&#34; 
&#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd&#34;&gt;
</code></pre><p>此声明是 MyBatis Mapper 文件的<strong>标准身份标识</strong>。</p></li></ul></li></ol><hr><h3 id=-二辅助判断特征>🧩 <strong>二、辅助判断特征</strong></h3><ol><li><strong>参数与结果绑定语法</strong><ul><li>SQL 语句中应使用 MyBatis 特有的参数占位符（如 <code>#{id}</code>或动态 <code>${field}</code>）。</li><li>结果映射可能通过 <code>resultType</code>（简单类型）或 <code>resultMap</code>（复杂对象）定义。</li></ul></li><li><strong>动态 SQL 标签</strong><ul><li>若包含复杂逻辑，文件可能使用 MyBatis 动态 SQL 标签（如 <code>&lt;if></code>、<code>&lt;foreach></code>、<code>&lt;choose></code>），用于条件分支或循环查询。</li></ul></li><li><strong>文件命名与路径规范</strong><ul><li>文件名通常与 Mapper 接口同名（如 <code>UserMapper.java</code>对应 <code>UserMapper.xml</code>）。</li><li>在 Maven/Gradle 项目中，文件需位于 <code>src/main/resources</code>下，且路径与接口包名一致（如 <code>com/example/mapper/UserMapper.xml</code>）。</li></ul></li><li><strong>结果映射定义（<code>&lt;resultMap></code>）</strong><ul><li>复杂查询可能包含 <code>&lt;resultMap></code>标签，定义数据库列与 Java 对象属性的映射关系，尤其涉及关联对象（<code>&lt;association></code>）或集合（<code>&lt;collection></code>）时。</li></ul></li></ol><hr><h3 id=-三完整示例结构>📋 <strong>三、完整示例结构</strong></h3><pre tabindex=0><code>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
&lt;!DOCTYPE mapper PUBLIC &#34;-//mybatis.org//DTD Mapper 3.0//EN&#34; 
&#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd&#34;&gt;
&lt;mapper namespace=&#34;com.example.mapper.UserMapper&#34;&gt;
  &lt;!-- 简单查询 --&gt;
  &lt;select id=&#34;getUserById&#34; resultType=&#34;User&#34;&gt;
    SELECT * FROM user WHERE id = #{id}
  &lt;/select&gt;
  
  &lt;!-- 动态SQL --&gt;
  &lt;select id=&#34;findUsers&#34; resultMap=&#34;UserResultMap&#34;&gt;
    SELECT * FROM user 
    &lt;where&gt;
      &lt;if test=&#34;name != null&#34;&gt;AND name LIKE #{name}&lt;/if&gt;
      &lt;if test=&#34;role != null&#34;&gt;AND role = #{role}&lt;/if&gt;
    &lt;/where&gt;
  &lt;/select&gt;
  
  &lt;!-- 结果映射 --&gt;
  &lt;resultMap id=&#34;UserResultMap&#34; type=&#34;User&#34;&gt;
    &lt;id property=&#34;id&#34; column=&#34;id&#34;/&gt;
    &lt;result property=&#34;name&#34; column=&#34;name&#34;/&gt;
    &lt;collection property=&#34;orders&#34; ofType=&#34;Order&#34; select=&#34;getOrdersByUserId&#34;/&gt;
  &lt;/resultMap&gt;
&lt;/mapper&gt;
</code></pre><hr><h3 id=-四常见排查点>⚠️ <strong>四、常见排查点</strong></h3><p>若文件符合上述特征但未被识别，需检查：</p><ul><li><strong>XML 语法错误</strong>：如标签未闭合、特殊符号未转义。</li><li><strong>路径或命名不一致</strong>：确保 XML 文件与接口的<strong>包路径、文件名、namespace</strong> 完全匹配。</li><li><strong>配置未加载</strong>：在 Spring Boot 中需验证 <code>mybatis.mapper-locations</code>是否包含该文件路径。</li></ul><p>通过以上特征综合判断，可明确识别 MyBatis Mapper XML 文件。实际开发中，建议使用 <strong>MyBatisX 插件</strong>（IDEA），通过 🐦 图标跳转接口与 XML，进一步验证关联性。</p><h2 id=mybatis-常用注解>MyBatis 常用注解</h2><p>MyBatis 支持通过注解方式替代 XML 配置，简化 SQL 映射的开发。以下是所有支持的注解分类及详细说明，结合功能、使用场景和示例：</p><hr><h3 id=-一基础-crud-注解>📌 <strong>一、基础 CRUD 注解</strong></h3><ol><li><p><strong><code>@Select</code></strong></p><ul><li><p><strong>功能</strong>：定义查询 SQL。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Select(&#34;SELECT * FROM users WHERE id = #{id}&#34;)
User getUserById(@Param(&#34;id&#34;) Long id);
</code></pre></li></ul></li><li><p><strong><code>@Insert</code></strong></p><ul><li><p><strong>功能</strong>：定义插入 SQL，支持主键回填。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Insert(&#34;INSERT INTO users(name, age) VALUES(#{name}, #{age})&#34;)
@Options(useGeneratedKeys = true, keyProperty = &#34;id&#34;)
int insertUser(User user);
</code></pre></li></ul></li><li><p><strong><code>@Update</code></strong></p><ul><li><p><strong>功能</strong>：定义更新 SQL。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Update(&#34;UPDATE users SET name = #{name} WHERE id = #{id}&#34;)
int updateUser(User user);
</code></pre></li></ul></li><li><p><strong><code>@Delete</code></strong></p><ul><li><p><strong>功能</strong>：定义删除 SQL。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Delete(&#34;DELETE FROM users WHERE id = #{id}&#34;)
int deleteUserById(@Param(&#34;id&#34;) Long id);
</code></pre></li></ul></li></ol><hr><h3 id=-二参数与结果集处理注解>🧩 <strong>二、参数与结果集处理注解</strong></h3><ol><li><p><strong><code>@Param</code></strong></p><ul><li><p><strong>功能</strong>：为方法参数命名，用于多参数绑定。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Select(&#34;SELECT * FROM users WHERE name = #{name} AND age = #{age}&#34;)
User findUser(@Param(&#34;name&#34;) String name, @Param(&#34;age&#34;) int age);
</code></pre></li></ul></li><li><p><strong><code>@Results</code>+ <code>@Result</code></strong></p><ul><li><p><strong>功能</strong>：自定义结果集映射（字段名与属性名不一致时）。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Select(&#34;SELECT user_id, user_name FROM t_user&#34;)
@Results(id = &#34;userMap&#34;, value = {
    @Result(property = &#34;id&#34;, column = &#34;user_id&#34;, id = true),
    @Result(property = &#34;name&#34;, column = &#34;user_name&#34;)
})
List&lt;User&gt; getAllUsers();
</code></pre></li></ul></li><li><p><strong><code>@ResultMap</code></strong></p><ul><li><p><strong>功能</strong>：引用已定义的 <code>@Results</code>映射。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Select(&#34;SELECT * FROM t_user WHERE id = #{id}&#34;)
@ResultMap(&#34;userMap&#34;)
User getUserById(Long id);
</code></pre></li></ul></li><li><p><strong><code>@ConstructorArgs</code>+ <code>@Arg</code></strong></p><ul><li><p><strong>功能</strong>：通过构造方法映射结果集。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Select(&#34;SELECT name, age FROM users WHERE id = #{id}&#34;)
@ConstructorArgs({
    @Arg(column = &#34;name&#34;, javaType = String.class),
    @Arg(column = &#34;age&#34;, javaType = Integer.class)
})
User getUserById(Long id);
</code></pre></li></ul></li></ol><hr><h3 id=-三关联关系映射注解>🔗 <strong>三、关联关系映射注解</strong></h3><ol><li><p><strong><code>@One</code></strong></p><ul><li><p><strong>功能</strong>：一对一关联查询（嵌套子查询）。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Select(&#34;SELECT * FROM orders WHERE id = #{id}&#34;)
@Results({
    @Result(property = &#34;user&#34;, column = &#34;user_id&#34;, 
            one = @One(select = &#34;com.example.mapper.UserMapper.getUserById&#34;))
})
Order getOrderWithUser(Long id);
</code></pre></li></ul></li><li><p><strong><code>@Many</code></strong></p><ul><li><p><strong>功能</strong>：一对多关联查询。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Select(&#34;SELECT * FROM users WHERE id = #{id}&#34;)
@Results({
    @Result(property = &#34;orders&#34;, column = &#34;id&#34;, 
            many = @Many(select = &#34;com.example.mapper.OrderMapper.getOrdersByUserId&#34;))
})
User getUserWithOrders(Long id);
</code></pre></li></ul></li></ol><hr><h3 id=-四动态-sql-提供者注解>⚙️ <strong>四、动态 SQL 提供者注解</strong></h3><ol><li><p><strong><code>@SelectProvider</code>/ <code>@InsertProvider</code>/ <code>@UpdateProvider</code>/ <code>@DeleteProvider</code></strong></p><ul><li><p><strong>功能</strong>：通过 Java 类动态生成 SQL。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>public class UserSqlProvider {
    public String getUserByName(String name) {
        return &#34;SELECT * FROM users WHERE name = #{name}&#34;;
    }
}

public interface UserMapper {
    @SelectProvider(type = UserSqlProvider.class, method = &#34;getUserByName&#34;)
    User findUserByName(String name);
}
</code></pre></li></ul></li></ol><hr><h3 id=-五缓存管理注解>💾 <strong>五、缓存管理注解</strong></h3><ol><li><p><strong><code>@CacheNamespace</code></strong></p><ul><li><p><strong>功能</strong>：在 Mapper 接口启用二级缓存。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@CacheNamespace(implementation = PerpetualCache.class, size = 1024)
public interface UserMapper {
    @Select(&#34;SELECT * FROM users WHERE id = #{id}&#34;)
    User getUserById(Long id);
}
</code></pre></li></ul></li><li><p><strong><code>@CacheNamespaceRef</code></strong></p><ul><li><p><strong>功能</strong>：引用其他 Mapper 的缓存配置。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@CacheNamespaceRef(UserMapper.class)
public interface OrderMapper { ... }
</code></pre></li></ul></li></ol><hr><h3 id=-六其他实用注解>⚡ <strong>六、其他实用注解</strong></h3><ol><li><p><strong><code>@Options</code></strong></p><ul><li><p><strong>功能</strong>：配置 SQL 执行选项（如主键回填、超时时间）。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Insert(&#34;INSERT INTO users(name) VALUES(#{name})&#34;)
@Options(useGeneratedKeys = true, keyProperty = &#34;id&#34;, timeout = 10)
int insertUser(User user);
</code></pre></li></ul></li><li><p><strong><code>@SelectKey</code></strong></p><ul><li><p><strong>功能</strong>：自定义主键生成策略（如数据库序列）。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Insert(&#34;INSERT INTO users(name) VALUES(#{name})&#34;)
@SelectKey(statement = &#34;SELECT LAST_INSERT_ID()&#34;, keyProperty = &#34;id&#34;, 
           before = false, resultType = Long.class)
int insertUser(User user);
</code></pre></li></ul></li><li><p><strong><code>@MapKey</code></strong></p><ul><li><p><strong>功能</strong>：将查询结果转为 Map，指定 Key 字段。</p></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Select(&#34;SELECT id, name FROM users&#34;)
@MapKey(&#34;id&#34;)
Map&lt;Integer, User&gt; getUserMap();
</code></pre></li></ul></li></ol><hr><h3 id=-七注解-vs-xml-适用场景对比>📊 <strong>七、注解 vs. XML 适用场景对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方式</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td>简单 CRUD 操作</td><td>注解</td><td>代码简洁，减少 XML 配置量</td></tr><tr><td>复杂动态 SQL（多条件）</td><td>XML</td><td>支持 <code>&lt;if></code>/<code>&lt;foreach></code>等标签，可读性更强</td></tr><tr><td>结果集复用（如 ResultMap）</td><td>XML</td><td>全局复用，避免注解中重复定义</td></tr><tr><td>关联查询（嵌套结果）</td><td>注解 + XML</td><td>简单关联用 <code>@One</code>/<code>@Many</code>，复杂嵌套用 XML</td></tr></tbody></table></div><hr><h3 id=-总结-3>💎 <strong>总结</strong></h3><ul><li><strong>优先使用注解的场景</strong>：单表 CRUD、简单关联查询、小型项目。</li><li><strong>优先使用 XML 的场景</strong>：复杂动态 SQL、需要复用 SQL 片段或结果映射、大型项目协作。</li><li><strong>混合使用建议</strong>：核心业务用 XML 维护复杂 SQL，辅助功能用注解提升效率 。</li></ul><blockquote><p>完整注解列表可参考 <a class=link href=https://mybatis.org/mybatis-3/zh/java-api.html target=_blank rel=noopener>MyBatis 官方文档</a>或 <a class=link href=https://github.com/mybatis/mybatis-3/tree/master/src/main/java/org/apache/ibatis/annotations target=_blank rel=noopener>MyBatis 注解源码</a>。</p></blockquote><h2 id=kafkalistener>@KafkaListener</h2><p>在Spring Kafka中，除了主流的<code>@KafkaListener</code>注解，开发者还可以根据场景需求选择其他灵活定义消费者的方式。以下是四种常见的替代方案及其适用场景：</p><hr><h3 id=-1-原生kafkaconsumer-api轮询模式>📦 <strong>1. 原生KafkaConsumer API轮询模式</strong></h3><p>通过<code>KafkaConsumer</code>类手动实现消息拉取循环，适用于需精细控制消费逻辑或与Spring版本冲突的场景：</p><ul><li><p><strong>实现方式</strong>：</p><ul><li>初始化<code>KafkaConsumer</code>实例，配置服务器地址、反序列化器等参数；</li><li>使用<code>while(true)</code>循环调用<code>poll(Duration)</code>拉取消息，遍历处理<code>ConsumerRecords</code>；</li><li>手动管理偏移量提交（如<code>commitSync()</code>）与资源关闭。</li></ul></li><li><p><strong>代码片段示例</strong>：</p><pre tabindex=0><code>KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props);
consumer.subscribe(Arrays.asList(&#34;topic&#34;));
while (true) {
    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(1000));
    for (ConsumerRecord&lt;String, String&gt; record : records) {
        System.out.println(&#34;Received: &#34; + record.value());
    }
    consumer.commitSync(); // 手动提交偏移量
}
</code></pre></li><li><p><strong>适用场景</strong>：脱离Spring框架约束、需自定义消费线程或批处理逻辑。</p></li></ul><hr><h3 id=-2-动态消费者工厂模式>🧪 <strong>2. 动态消费者工厂模式</strong></h3><p>结合<code>KafkaConsumer</code>与定时任务，支持运行时动态创建/销毁消费者，适合发布-订阅模型中消费者数量不固定的需求：</p><ul><li><strong>核心组件</strong>：<ul><li><strong>工厂类</strong>：封装<code>KafkaConsumer</code>创建逻辑，注入组ID与主题；</li><li><strong>上下文管理器</strong>：通过<code>ScheduledExecutorService</code>定时调度<code>poll</code>任务，存储消费者与任务句柄。</li></ul></li><li><strong>动态控制</strong>：<ul><li>调用<code>addConsumerTask()</code>启动新消费者；</li><li>通过<code>removeConsumerTask()</code>关闭指定消费者并释放资源。</li></ul></li><li><strong>优势</strong>：避免<code>@KafkaListener</code>的静态绑定，实现按需扩缩容。</li></ul><hr><h3 id=-3-concurrentmessagelistenercontainer配置>⚙️ <strong>3. ConcurrentMessageListenerContainer配置</strong></h3><p>使用Spring Kafka的低阶API构建监听容器，需配合<code>MessageListener</code>接口实现：</p><ul><li><p><strong>配置步骤</strong>：</p><ul><li>定义<code>ConcurrentMessageListenerContainer</code>实例，关联<code>ConsumerFactory</code>；</li><li>实现<code>MessageListener</code>接口的<code>onMessage()</code>方法处理单条消息；</li><li>设置并发线程数（如<code>concurrency=3</code>）以匹配分区数。</li></ul></li><li><p><strong>代码关键点</strong>：</p><pre tabindex=0><code>@Bean
public ConcurrentMessageListenerContainer&lt;String, String&gt; container() {
    ContainerProperties props = new ContainerProperties(&#34;topic&#34;);
    props.setMessageListener((MessageListener&lt;String, String&gt;) record -&gt; {
        System.out.println(&#34;Handled: &#34; + record.value());
    });
    return new ConcurrentMessageListenerContainer&lt;&gt;(consumerFactory(), props);
}
</code></pre></li><li><p><strong>适用场景</strong>：需直接管理监听容器生命周期或整合非注解式监听器。</p></li></ul><hr><h3 id=-4-手动线程管理原生api--executorservice>🔧 <strong>4. 手动线程管理（原生API + ExecutorService）</strong></h3><p>自主创建消费者线程池，实现高并发消费或复杂流处理：</p><ul><li><strong>流程</strong>：<ul><li>创建多个<code>KafkaConsumer</code>实例，每个绑定独立线程；</li><li>通过<code>ExecutorService</code>提交消费者任务，并行执行<code>poll</code>循环；</li><li>协调线程间偏移量提交与错误恢复。</li></ul></li><li><strong>注意事项</strong>：<ul><li>需确保线程安全，避免偏移量提交冲突；</li><li>消费者数量不应超过分区数，否则线程闲置。</li></ul></li></ul><hr><h3 id=-方案对比与选型建议>💎 <strong>方案对比与选型建议</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>方式</strong></th><th><strong>控制粒度</strong></th><th><strong>动态性</strong></th><th><strong>适用场景</strong></th><th><strong>复杂度</strong></th></tr></thead><tbody><tr><td>原生<code>KafkaConsumer</code>轮询</td><td>⭐⭐⭐⭐</td><td>⭐⭐</td><td>精细控制、脱离Spring依赖</td><td>高</td></tr><tr><td>动态消费者工厂</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>运行时动态增删消费者</td><td>中高</td></tr><tr><td><code>ConcurrentMessageListenerContainer</code></td><td>⭐⭐⭐</td><td>⭐⭐</td><td>Spring容器管理、非注解监听</td><td>中</td></tr><tr><td>手动线程管理</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐</td><td>高并发、自定义流处理架构</td><td>极高</td></tr></tbody></table></div><blockquote><p>💡 <strong>实践建议</strong>：</p><ul><li><p>优先选择<code>@KafkaListener</code>简化开发；</p></li><li><p>需要动态扩展时采用<strong>动态工厂模式</strong>；</p></li><li><p>对性能或控制有极致要求时使用<strong>原生API轮询或线程管理</strong>。</p><p>更多配置细节可参考各方案来源文档。</p></li></ul></blockquote><h2 id=class-行为>Class 行为</h2><p>在 Java 中，当通过<strong>基类引用（实际指向子类对象）调用 <code>getClass()</code>方法时，返回的是子类的 <code>Class</code>对象</strong>，而非基类的 <code>Class</code>对象。这是由 <code>getClass()</code>的<strong>运行时类型识别</strong>特性决定的。以下是详细分析：</p><hr><h3 id=-核心原理>🔍 <strong>核心原理</strong></h3><ol><li><p><strong><code>getClass()</code>的运行时特性</strong></p><p><code>getClass()</code>是 <code>Object</code>类中定义的 <code>final</code>方法，其返回值取决于对象在堆内存中的<strong>实际类型</strong>（即运行时类型），与编译时的声明类型无关。</p><ul><li><p><strong>示例</strong>：</p><pre tabindex=0><code>class Animal {}
class Dog extends Animal {}

Animal animal = new Dog(); // 基类引用指向子类对象
Class&lt;?&gt; clazz = animal.getClass(); // 返回 Dog.class
</code></pre><p>此时 <code>clazz == Dog.class</code>为 <code>true</code>，而非 <code>Animal.class</code>。</p></li></ul></li><li><p><strong>多态场景下的行为</strong></p><p>即使方法在基类中被调用（如基类构造函数或普通方法），<code>this.getClass()</code>仍返回<strong>实际子类的 <code>Class</code>对象</strong>：</p><pre tabindex=0><code>class Art {
    Art() {
        System.out.println(this.getClass().getName()); // 输出子类类名
    }
}
class Cartoon extends Art {
    public static void main(String[] args) {
        new Cartoon(); // 输出：Art → &#34;Cartoon&#34;；Cartoon → &#34;Cartoon&#34;
    }
}
</code></pre><p>在 <code>Art</code>的构造函数中，<code>this.getClass()</code>返回 <code>Cartoon.class</code>，而非 <code>Art.class</code>。</p></li></ol><hr><h3 id=-与相关概念的对比>⚖️ <strong>与相关概念的对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong><code>getClass()</code></strong></th><th><strong><code>类名.class</code></strong></th><th><strong><code>instanceof</code></strong></th></tr></thead><tbody><tr><td><strong>判断依据</strong></td><td>运行时实际类型</td><td>编译时声明类型</td><td>是否属于类/接口或其子类</td></tr><tr><td><strong>多态场景结果</strong></td><td>返回子类 <code>Class</code></td><td>返回基类 <code>Class</code></td><td><code>true</code>（若为子类实例）</td></tr><tr><td><strong>示例</strong></td><td><code>animal.getClass() → Dog.class</code></td><td><code>Animal.class → Animal.class</code></td><td><code>animal instanceof Dog → true</code></td></tr></tbody></table></div><blockquote><p>📌 <strong>关键区别</strong>：</p><ul><li><code>getClass()</code><strong>严格匹配运行时类型</strong>，不认可继承关系（如 <code>Dog.class ≠ Animal.class</code>）。</li><li><code>instanceof</code><strong>认可继承关系</strong>（如 <code>animal instanceof Animal</code>对子类对象返回 <code>true</code>）。</li></ul></blockquote><hr><h3 id=-注意事项-1>⚠️ <strong>注意事项</strong></h3><ol><li><p><strong>代理对象的影响</strong></p><p>若对象是动态代理（如 Spring AOP 生成），<code>getClass()</code>返回代理类的 <code>Class</code>对象，而非原始子类。需通过工具类（如 <code>AopUtils.getTargetClass()</code>）获取原始类型。</p></li><li><p><strong>与 <code>.class</code>语法区别</strong></p><ul><li><code>类名.class</code>是<strong>静态获取</strong>的编译时常量，始终返回声明类型的 <code>Class</code>对象。</li><li><code>getClass()</code><strong>动态获取</strong>运行时类型。</li></ul></li></ol><hr><h3 id=-总结-4>💎 <strong>总结</strong></h3><blockquote><p>基类引用调用 <code>getClass()</code><strong>一定返回子类的 <code>Class</code>对象</strong>，这是由 Java 运行时类型识别机制决定的。若需判断对象是否属于某类或其子类，应使用 <code>instanceof</code>；若需精确匹配类型，则用 <code>getClass()</code>。</p></blockquote><h2 id=hashmap--reentrantlock>HashMap + ReentrantLock</h2><p>在并发编程中，使用 <strong><code>HashMap + ReentrantLock</code>可以替代 <code>ConcurrentHashMap</code>实现线程安全</strong>，但其适用性需结合具体场景评估。以下是关键对比与分析：</p><hr><h3 id=-1-技术可行性分析>⚙️ <strong>1. 技术可行性分析</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>方案</strong></th><th><strong>实现方式</strong></th><th><strong>线程安全性</strong></th><th><strong>锁粒度</strong></th></tr></thead><tbody><tr><td><code>HashMap + ReentrantLock</code></td><td>手动控制锁（如全局锁或分段锁）</td><td>✅ 可达到</td><td>粗粒度（全局锁）或细粒度（分段锁）</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>内置分段锁（JDK7）或 CAS+synchronized（JDK8+）</td><td>✅ 原生保证</td><td>桶级锁（JDK8+，锁定单个哈希桶）</td></tr></tbody></table></div><ul><li><strong><code>HashMap + ReentrantLock</code>的局限性</strong>：<ul><li><strong>全局锁方案</strong>：若使用单一把锁保护整个 <code>HashMap</code>，所有操作（如 <code>put</code>、<code>get</code>）需串行执行，<strong>并发性能差</strong>，退化近似 <code>Hashtable</code>。</li><li><strong>分段锁方案</strong>：需手动实现分段策略（如按哈希值分桶），但实现复杂且易出错（如死锁风险），且内存占用高于 <code>ConcurrentHashMap</code>。</li></ul></li><li><strong><code>ConcurrentHashMap</code>的优势</strong>：<ul><li><strong>锁粒度细化</strong>：JDK8+ 仅锁定单个哈希桶（桶头节点），不同桶的操作可并行执行。</li><li><strong>无锁读优化</strong>：读操作无需加锁，依赖 <code>volatile</code>变量保证可见性。</li><li><strong>内置原子操作</strong>：如 <code>computeIfAbsent()</code>、<code>putIfAbsent()</code>等，避免手动同步逻辑。</li></ul></li></ul><hr><h3 id=-2-性能对比>⚖️ <strong>2. 性能对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><code>HashMap + ReentrantLock</code>（全局锁）</th><th><code>ConcurrentHashMap</code>（JDK8+）</th></tr></thead><tbody><tr><td><strong>高并发写</strong></td><td>差（所有写操作串行）</td><td>优（桶级锁支持并行写）</td></tr><tr><td><strong>高并发读</strong></td><td>中（读操作需抢锁）</td><td>优（读无锁）</td></tr><tr><td><strong>读写混合</strong></td><td>差（读写互斥）</td><td>优（读写分离）</td></tr></tbody></table></div><blockquote><p>💎 <strong>关键结论</strong>：在<strong>高并发场景</strong>下，<code>ConcurrentHashMap</code>的吞吐量显著高于手动锁方案，尤其在读写混合操作中。</p></blockquote><hr><h3 id=-3-适用场景与风险>⚠️ <strong>3. 适用场景与风险</strong></h3><ul><li><strong>适合 <code>HashMap + ReentrantLock</code>的场景</strong>：<ul><li><strong>低并发环境</strong>：线程竞争少，锁争用不激烈。</li><li><strong>需定制锁逻辑</strong>：如跨多个数据结构需原子更新（如同时操作 <code>HashMap</code>和 <code>List</code>）。</li></ul></li><li><strong>适合 <code>ConcurrentHashMap</code>的场景</strong>：<ul><li><strong>高并发读写</strong>：如缓存、实时计数器等。</li><li><strong>简化代码</strong>：避免手动管理锁，减少 <code>try-finally</code>模板代码。</li></ul></li><li><strong>风险提示</strong>：<ul><li><strong>死锁风险</strong>：手动分段锁若未按固定顺序加锁，可能死锁（<code>ConcurrentHashMap</code>内部通过数组顺序避免）。</li><li><strong>内存一致性</strong>：手动锁需确保 <code>happens-before</code>规则（如锁释放前写入对所有线程可见），而 <code>ConcurrentHashMap</code>通过 <code>volatile</code>和 <code>CAS</code>自动保障。</li></ul></li></ul><hr><h3 id=-4-实现方案示例>🛠️ <strong>4. 实现方案示例</strong></h3><h4 id=1-hashmap--reentrantlock全局锁>(1) <code>HashMap + ReentrantLock</code>（全局锁）</h4><pre tabindex=0><code>public class LockedHashMap&lt;K, V&gt; {
    private final Map&lt;K, V&gt; map = new HashMap&lt;&gt;();
    private final ReentrantLock lock = new ReentrantLock();

    public void put(K key, V value) {
        lock.lock();
        try {
            map.put(key, value);
        } finally {
            lock.unlock();
        }
    }
    // 其他方法需类似加锁
}
</code></pre><p><strong>缺点</strong>：所有操作串行化，性能瓶颈明显。</p><h4 id=2-concurrenthashmap推荐>(2) <code>ConcurrentHashMap</code>（推荐）</h4><pre tabindex=0><code>ConcurrentHashMap&lt;String, Integer&gt; safeMap = new ConcurrentHashMap&lt;&gt;();
safeMap.put(&#34;key&#34;, 1); // 无需手动同步
safeMap.computeIfAbsent(&#34;key&#34;, k -&gt; 2); // 原子操作
</code></pre><hr><h3 id=-总结建议-2>💎 <strong>总结建议</strong></h3><ul><li><p><strong>优先选择 <code>ConcurrentHashMap</code></strong>：</p><p>在绝大多数并发场景下，其<strong>内置的细粒度锁机制和原子操作</strong>更高效、安全，且代码简洁。</p></li><li><p><strong>仅考虑 <code>HashMap + ReentrantLock</code>当</strong>：</p><p>① 需跨多个结构原子更新；</p><p>② 并发极低且追求代码轻量。</p></li></ul><blockquote><p>⚠️ <strong>避免重复造轮子</strong>：<code>ConcurrentHashMap</code>由 Java 并发专家深度优化（如红黑树抗哈希攻击、扩容协作等），手动实现同等性能与稳定性成本极高。</p></blockquote><h2 id=reentrantlock-和-reentrantreadwritelock>ReentrantLock 和 ReentrantReadWriteLock</h2><p>ReentrantLock 和 ReentrantReadWriteLock 是 Java 并发包中两种不同的锁机制，核心区别在于<strong>锁的粒度和适用场景</strong>。以下是详细对比：</p><hr><h3 id=-1-锁类型与并发性>🔒 <strong>1. 锁类型与并发性</strong></h3><ul><li><strong><code>ReentrantLock</code></strong><ul><li><strong>独占锁（互斥锁）</strong>：同一时间仅允许一个线程（读或写）访问资源，其他线程必须等待。</li><li><strong>适用场景</strong>：读写操作频率接近，或需要严格原子性的场景（如账户转账、订单支付）。</li></ul></li><li><strong><code>ReentrantReadWriteLock</code></strong><ul><li><strong>读写分离锁</strong>：<ul><li><strong>读锁（共享锁）</strong>：允许多个线程并发读取资源（读读不互斥）。</li><li><strong>写锁（独占锁）</strong>：仅允许一个线程写入，且与读锁/其他写锁互斥（读写、写写互斥）。</li></ul></li><li><strong>适用场景</strong>：读操作远多于写操作的场景（如缓存、配置管理、统计报表），典型读写比例建议 ≥ 9:1。</li></ul></li></ul><hr><h3 id=-2-性能对比-1>⚖️ <strong>2. 性能对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><code>ReentrantLock</code></th><th><code>ReentrantReadWriteLock</code></th></tr></thead><tbody><tr><td><strong>高并发读</strong></td><td>❌ 所有读操作串行化</td><td>✅ 读操作可并行（吞吐量高）</td></tr><tr><td><strong>高并发写</strong></td><td>✅ 写操作竞争可控</td><td>⚠️ 写操作竞争激烈时性能下降</td></tr><tr><td><strong>读写混合</strong></td><td>❌ 读写互斥导致阻塞</td><td>✅ 读操作不阻塞写操作等待</td></tr></tbody></table></div><blockquote><p>📌 <strong>关键结论</strong>：</p><ul><li><strong>读多写少</strong>（如缓存）：<code>ReentrantReadWriteLock</code>的并发性能显著优于 <code>ReentrantLock</code>。</li><li><strong>写多读少</strong>：<code>ReentrantLock</code>更高效（避免读写锁的维护开销）。</li></ul></blockquote><hr><h3 id=-3-功能特性>⚙️ <strong>3. 功能特性</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><code>ReentrantLock</code></th><th><code>ReentrantReadWriteLock</code></th></tr></thead><tbody><tr><td><strong>可重入性</strong></td><td>✅ 支持</td><td>✅ 读锁/写锁均支持重入</td></tr><tr><td><strong>公平性</strong></td><td>✅ 可配置公平/非公平</td><td>✅ 可配置公平/非公平</td></tr><tr><td><strong>锁降级</strong></td><td>❌ 不支持</td><td>✅ 写锁可降级为读锁（保证数据一致性）</td></tr><tr><td><strong>条件变量</strong></td><td>✅ 支持多个 <code>Condition</code></td><td>❌ 仅支持一个等待队列</td></tr><tr><td><strong>超时/中断</strong></td><td>✅ 支持 <code>tryLock()</code>、<code>lockInterruptibly()</code></td><td>✅ 读锁/写锁均支持超时与中断</td></tr></tbody></table></div><blockquote><p>⚠️ <strong>锁降级示例</strong>：</p><p>先获取写锁 → 修改数据 → 获取读锁 → 释放写锁 → 继续读操作（避免其他写线程干扰）。</p></blockquote><hr><h3 id=-4-典型应用场景>🧩 <strong>4. 典型应用场景</strong></h3><ul><li><strong><code>ReentrantLock</code>适用</strong>：<ul><li>写操作频繁（如库存扣减、支付交易）。</li><li>需要精细控制同步（如跨多个资源的原子操作）。</li></ul></li><li><strong><code>ReentrantReadWriteLock</code>适用</strong>：<ul><li><strong>缓存系统</strong>：高频读取配置或热点数据。</li><li><strong>共享文档</strong>：多人协同编辑（多数人读，少数人写）。</li><li><strong>统计数据</strong>：定时更新报表，多线程并发读取分析。</li></ul></li></ul><hr><h3 id=-总结如何选择>💎 <strong>总结：如何选择？</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>场景特征</strong></th><th><strong>推荐锁类型</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td>读写操作均衡或写多读少</td><td><code>ReentrantLock</code></td><td>避免读写锁的额外开销，简化同步逻辑。</td></tr><tr><td>读操作占比 ≥ 90%</td><td><code>ReentrantReadWriteLock</code></td><td>读并发性能提升显著，且支持锁降级保证一致性。</td></tr><tr><td>需锁降级（写后立即读）</td><td><code>ReentrantReadWriteLock</code></td><td>唯一支持写锁降级为读锁的机制。</td></tr><tr><td>需多个条件变量控制线程协作</td><td><code>ReentrantLock</code></td><td>可创建多个 <code>Condition</code>实现精细等待/唤醒。</td></tr></tbody></table></div><blockquote><p><strong>⚠️ 注意事项</strong>：</p><ul><li><strong>避免滥用读写锁</strong>：若写操作频繁，读写锁的维护开销（如读锁计数）可能抵消并发优势。</li><li><strong>替代方案</strong>：极高并发场景可考虑 <code>StampedLock</code>（乐观读锁）或 <code>ConcurrentHashMap</code>（内置分段锁）。</li></ul></blockquote><h2 id=value>@Value</h2><p>在 Spring Boot 中，<strong><code>@Value</code>注解不能直接在非 <code>@Component</code>类（即未被 Spring 容器管理的类）中生效</strong>。以下是详细分析和替代方案：</p><hr><h3 id=-为什么>⚠️ <strong>为什么 <code>@Value</code>注解必须在 Spring 管理的类中使用？</strong></h3><p><code>@Value</code>的依赖注入机制依赖于 Spring 容器。当类未被 Spring 管理（即未添加 <code>@Component</code>、<code>@Service</code>等注解）时：</p><ol><li><strong>注入失败</strong>：<code>@Value</code>标注的字段会保持默认值（如 <code>null</code>）。</li><li><strong>原理限制</strong>：Spring 通过 Bean 后置处理器处理 <code>@Value</code>注解，而普通 Java 类不会经过此流程。</li></ol><p><strong>错误示例</strong>：</p><pre tabindex=0><code>public class NonSpringClass {
    @Value(&#34;${app.name}&#34;) 
    private String appName; // 值始终为 null
}
</code></pre><hr><h3 id=-替代方案在非-spring-管理类中获取配置>🔧 <strong>替代方案：在非 Spring 管理类中获取配置</strong></h3><p>若需在普通类中读取配置，可通过以下方式实现：</p><h4 id=1-手动从-spring-环境获取属性值>1. <strong>手动从 Spring 环境获取属性值</strong></h4><ul><li><p><strong>步骤</strong>：</p><ol><li>创建一个 Spring 管理的工具类（如 <code>SpringContextHolder</code>），用于保存 <code>ApplicationContext</code>。</li><li>通过 <code>ApplicationContext</code>的 <code>Environment</code>获取属性值。</li></ol></li><li><p><strong>代码示例</strong>：</p><pre tabindex=0><code>@Component
public class SpringContextHolder implements ApplicationContextAware {
    private static ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext ctx) {
        context = ctx;
    }

    public static String getProperty(String key) {
        return context.getEnvironment().getProperty(key);
    }
}

// 在普通类中使用
public class NonSpringClass {
    private String appName = SpringContextHolder.getProperty(&#34;app.name&#34;);
}
</code></pre></li></ul><h4 id=2-将类改为-spring-管理>2. <strong>将类改为 Spring 管理</strong></h4><ul><li>直接添加 <code>@Component</code>等注解，使类由 Spring 容器管理，从而支持 <code>@Value</code>注入。</li><li><strong>适用场景</strong>：对原有代码改造影响较小的情况。</li></ul><h4 id=3-通过>3. <strong>通过 <code>@Bean</code>方法手动注入属性</strong></h4><ul><li><p><strong>步骤</strong>：</p><ol><li>在配置类中定义 <code>@Bean</code>方法。</li><li>在 <code>@Bean</code>方法中使用 <code>@Value</code>获取配置值，再传递给普通类的实例。</li></ol></li><li><p><strong>示例</strong>：</p><pre tabindex=0><code>@Configuration
public class AppConfig {
    @Value(&#34;${app.name}&#34;)
    private String appName;

    @Bean
    public NonSpringClass nonSpringClass() {
        return new NonSpringClass(appName); // 通过构造器传参
    }
}

public class NonSpringClass {
    private String appName;
    public NonSpringClass(String appName) {
        this.appName = appName;
    }
}
</code></pre></li></ul><h4 id=4-java-原生方式读取配置文件>4. <strong>Java 原生方式读取配置文件</strong></h4><ul><li><p>绕过 Spring 机制，直接通过 <code>Properties</code>类或 <code>Yaml</code>解析工具读取配置文件：</p><pre tabindex=0><code>public class ConfigReader {
    public static String getProperty(String key) {
        Properties props = new Properties();
        try (InputStream input = ConfigReader.class.getResourceAsStream(&#34;/application.properties&#34;)) {
            props.load(input);
            return props.getProperty(key);
        } catch (IOException e) {
            throw new RuntimeException(&#34;Failed to read config&#34;, e);
        }
    }
}
</code></pre></li></ul><hr><h3 id=-总结-5>💎 <strong>总结</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>方案</strong></th><th><strong>适用场景</strong></th><th><strong>优势</strong></th></tr></thead><tbody><tr><td>手动获取环境属性（方案1）</td><td>需在非托管类中动态获取配置</td><td>无需改造类结构</td></tr><tr><td>改为 Spring 管理（方案2）</td><td>允许代码改造</td><td>原生支持 <code>@Value</code>，简单直接</td></tr><tr><td><code>@Bean</code>方法注入（方案3）</td><td>需解耦配置与业务逻辑</td><td>集中管理配置，灵活性高</td></tr><tr><td>Java 原生读取（方案4）</td><td>不依赖 Spring 的独立应用</td><td>完全脱离框架</td></tr></tbody></table></div><p><strong>推荐实践</strong>：</p><ul><li>优先考虑<strong>将类纳入 Spring 管理</strong>（方案2），确保代码符合依赖注入规范。</li><li>若无法修改类结构，使用 <strong><code>SpringContextHolder</code>工具类</strong>（方案1）是最常见的解决方案。</li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/shopee/>Shopee</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Aug 29, 2025 20:44 CST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/shopeethread/><div class=article-details><h2 class=article-title>【Shopee】Thread</h2></div></a></article><article><a href=/p/shopeejava-parser/><div class=article-details><h2 class=article-title>【Shopee】Java Parser</h2></div></a></article><article><a href=/p/shopeeconcurrent-java/><div class=article-details><h2 class=article-title>【Shopee】Concurrent Java</h2></div></a></article><article><a href=/p/shopeeinsight-hub/><div class=article-details><h2 class=article-title>【Shopee】Insight Hub</h2></div></a></article><article><a href=/p/shopeelocal-llm/><div class=article-details><h2 class=article-title>【Shopee】Local LLM</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>