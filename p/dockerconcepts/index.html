<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Docker 以下是对Docker的详细介绍，从核心概念到技术原理、应用场景及生态系统，结合多维度信息综合整理：\n🐳 Docker的定义与核心概念 基本定义 Docker是一个开源的应用容器引擎，基于Go语言开发，允许开发者将应用及其依赖打包成轻量级、可移植的容器。容器共享宿主机操作系统内核，但通过隔离技术保证独立性，实现“一次构建，到处运行”1,4,5。 核心组件 镜像（Image）：只读模板，包含应用运行所需的所有文件（代码、库、环境变量等）。采用分层存储结构（Union FS），每一层可复用，节省存储空间2,4。 容器（Container）：镜像的运行实例，拥有独立的文件系统、网络和进程空间。通过写时复制（Copy-on-Write）技术，修改仅作用于容器层，不改变镜像本身2,6。 仓库（Registry）：集中存储和分发镜像的平台。公有仓库如Docker Hub，私有仓库如Harbor3,6。 Dockerfile：文本文件定义镜像构建步骤（如FROM指定基础镜像、RUN执行命令），实现自动化构建4,6。 ⚙️ 技术原理与架构设计 底层技术 Namespace：提供资源隔离，分为6类： 类型 功能 PID Namespace 隔离进程ID Net Namespace 隔离网络接口与端口 MNT Namespace 隔离文件系统挂载点 IPC Namespace 隔离进程间通信 UTS Namespace 隔离主机名与域名 User Namespace 隔离用户与用户组 2,3。 Cgroups：限制资源使用（CPU、内存、磁盘I/O等），防止单个容器耗尽宿主机资源3,6。 Union File System（Union FS）：支持分层镜像存储，多个容器共享基础镜像层，减少冗余2,4。 架构设计 客户端-服务器模型：用户通过Docker客户端发送命令，由守护进程（Dockerd）执行操作（构建、运行容器等）4,6。 容器运行时：早期使用LXC，后改为自研的runc（符合OCI标准），实现跨平台兼容3,6。 🔄 工作流程与核心组件 典型工作流： graph LR A[编写Dockerfile] --> B[构建镜像] --> C[推送至仓库] --> D[拉取镜像并运行容器] 构建：docker build -t my-image:tag . 运行：docker run -d --name my-container my-image:tag4,6。 容器管理工具 Docker Compose：通过YAML文件定义多容器应用（如Web服务+数据库），一键启动/停止6。 Docker Swarm/Kubernetes：用于容器编排，支持集群管理、自动扩缩容3,6。 💡 应用场景与优势分析 核心应用场景 环境一致性：解决开发、测试、生产环境差异问题（如依赖库版本冲突）4,5。 微服务部署：每个微服务独立容器化，便于扩展和维护6。 CI/CD流水线：与Jenkins/GitLab集成，实现自动化构建和测试5。 相比虚拟机的优势 特性 Docker容器 传统虚拟机 启动速度 秒级（共享内核） 分钟级（需启动完整OS） 资源占用 低（无Guest OS开销） 高（每个VM需独立OS资源） 隔离性 进程级（通过Namespace） 硬件级（更强隔离） 可移植性 高（镜像跨平台一致） 低（依赖Hypervisor兼容） 3,4,6。 局限性 隔离性较弱：共享内核导致安全风险高于虚拟机，不适合强隔离需求场景3,5。 仅支持Linux应用：Windows/macOS需通过虚拟化层（如Hyper-V）运行1,4。 📈 发展历程与生态系统 关键版本演进 2013年：DotCloud开源Docker，基于LXC技术1。 2014年（1.0版）：生产环境可用，引入核心命令（docker run、docker build）1。 2017年：分拆为社区版（CE）和企业版（EE）5。 2020年后：强化安全（Rootless模式）、优化ARM/M1支持、集成Kubernetes1,4。 相关工具与竞品 镜像仓库：Docker Hub（公有）、Harbor（私有）3,6。 容器运行时：rkt（CoreOS）、CRI-O（Kubernetes专用）3。 编排工具：Kubernetes（主流替代Swarm）3,6。 💎 总结 Docker通过操作系统级虚拟化技术，以容器为载体解决了环境不一致和资源效率问题，成为DevOps和云原生技术的基石。其轻量化、标准化特性在微服务、CI/CD中表现突出，但需结合业务需求权衡隔离性与安全性。未来随着容器生态（如Kubernetes、服务网格）的演进，Docker将继续在应用现代化中扮演核心角色。 如需进一步了解安装配置（如或教程）或命令详解（如），可参考具体章节。\n"><title>【Docker】Concepts</title><link rel=canonical href=https://dyhes.github.io/p/dockerconcepts/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【Docker】Concepts"><meta property='og:description' content="Docker 以下是对Docker的详细介绍，从核心概念到技术原理、应用场景及生态系统，结合多维度信息综合整理：\n🐳 Docker的定义与核心概念 基本定义 Docker是一个开源的应用容器引擎，基于Go语言开发，允许开发者将应用及其依赖打包成轻量级、可移植的容器。容器共享宿主机操作系统内核，但通过隔离技术保证独立性，实现“一次构建，到处运行”1,4,5。 核心组件 镜像（Image）：只读模板，包含应用运行所需的所有文件（代码、库、环境变量等）。采用分层存储结构（Union FS），每一层可复用，节省存储空间2,4。 容器（Container）：镜像的运行实例，拥有独立的文件系统、网络和进程空间。通过写时复制（Copy-on-Write）技术，修改仅作用于容器层，不改变镜像本身2,6。 仓库（Registry）：集中存储和分发镜像的平台。公有仓库如Docker Hub，私有仓库如Harbor3,6。 Dockerfile：文本文件定义镜像构建步骤（如FROM指定基础镜像、RUN执行命令），实现自动化构建4,6。 ⚙️ 技术原理与架构设计 底层技术 Namespace：提供资源隔离，分为6类： 类型 功能 PID Namespace 隔离进程ID Net Namespace 隔离网络接口与端口 MNT Namespace 隔离文件系统挂载点 IPC Namespace 隔离进程间通信 UTS Namespace 隔离主机名与域名 User Namespace 隔离用户与用户组 2,3。 Cgroups：限制资源使用（CPU、内存、磁盘I/O等），防止单个容器耗尽宿主机资源3,6。 Union File System（Union FS）：支持分层镜像存储，多个容器共享基础镜像层，减少冗余2,4。 架构设计 客户端-服务器模型：用户通过Docker客户端发送命令，由守护进程（Dockerd）执行操作（构建、运行容器等）4,6。 容器运行时：早期使用LXC，后改为自研的runc（符合OCI标准），实现跨平台兼容3,6。 🔄 工作流程与核心组件 典型工作流： graph LR A[编写Dockerfile] --> B[构建镜像] --> C[推送至仓库] --> D[拉取镜像并运行容器] 构建：docker build -t my-image:tag . 运行：docker run -d --name my-container my-image:tag4,6。 容器管理工具 Docker Compose：通过YAML文件定义多容器应用（如Web服务+数据库），一键启动/停止6。 Docker Swarm/Kubernetes：用于容器编排，支持集群管理、自动扩缩容3,6。 💡 应用场景与优势分析 核心应用场景 环境一致性：解决开发、测试、生产环境差异问题（如依赖库版本冲突）4,5。 微服务部署：每个微服务独立容器化，便于扩展和维护6。 CI/CD流水线：与Jenkins/GitLab集成，实现自动化构建和测试5。 相比虚拟机的优势 特性 Docker容器 传统虚拟机 启动速度 秒级（共享内核） 分钟级（需启动完整OS） 资源占用 低（无Guest OS开销） 高（每个VM需独立OS资源） 隔离性 进程级（通过Namespace） 硬件级（更强隔离） 可移植性 高（镜像跨平台一致） 低（依赖Hypervisor兼容） 3,4,6。 局限性 隔离性较弱：共享内核导致安全风险高于虚拟机，不适合强隔离需求场景3,5。 仅支持Linux应用：Windows/macOS需通过虚拟化层（如Hyper-V）运行1,4。 📈 发展历程与生态系统 关键版本演进 2013年：DotCloud开源Docker，基于LXC技术1。 2014年（1.0版）：生产环境可用，引入核心命令（docker run、docker build）1。 2017年：分拆为社区版（CE）和企业版（EE）5。 2020年后：强化安全（Rootless模式）、优化ARM/M1支持、集成Kubernetes1,4。 相关工具与竞品 镜像仓库：Docker Hub（公有）、Harbor（私有）3,6。 容器运行时：rkt（CoreOS）、CRI-O（Kubernetes专用）3。 编排工具：Kubernetes（主流替代Swarm）3,6。 💎 总结 Docker通过操作系统级虚拟化技术，以容器为载体解决了环境不一致和资源效率问题，成为DevOps和云原生技术的基石。其轻量化、标准化特性在微服务、CI/CD中表现突出，但需结合业务需求权衡隔离性与安全性。未来随着容器生态（如Kubernetes、服务网格）的演进，Docker将继续在应用现代化中扮演核心角色。 如需进一步了解安装配置（如或教程）或命令详解（如），可参考具体章节。\n"><meta property='og:url' content='https://dyhes.github.io/p/dockerconcepts/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Docker'><meta property='article:published_time' content='2025-06-30T00:00:00+00:00'><meta property='article:modified_time' content='2025-10-20T22:07:04+08:00'><meta name=twitter:title content="【Docker】Concepts"><meta name=twitter:description content="Docker 以下是对Docker的详细介绍，从核心概念到技术原理、应用场景及生态系统，结合多维度信息综合整理：\n🐳 Docker的定义与核心概念 基本定义 Docker是一个开源的应用容器引擎，基于Go语言开发，允许开发者将应用及其依赖打包成轻量级、可移植的容器。容器共享宿主机操作系统内核，但通过隔离技术保证独立性，实现“一次构建，到处运行”1,4,5。 核心组件 镜像（Image）：只读模板，包含应用运行所需的所有文件（代码、库、环境变量等）。采用分层存储结构（Union FS），每一层可复用，节省存储空间2,4。 容器（Container）：镜像的运行实例，拥有独立的文件系统、网络和进程空间。通过写时复制（Copy-on-Write）技术，修改仅作用于容器层，不改变镜像本身2,6。 仓库（Registry）：集中存储和分发镜像的平台。公有仓库如Docker Hub，私有仓库如Harbor3,6。 Dockerfile：文本文件定义镜像构建步骤（如FROM指定基础镜像、RUN执行命令），实现自动化构建4,6。 ⚙️ 技术原理与架构设计 底层技术 Namespace：提供资源隔离，分为6类： 类型 功能 PID Namespace 隔离进程ID Net Namespace 隔离网络接口与端口 MNT Namespace 隔离文件系统挂载点 IPC Namespace 隔离进程间通信 UTS Namespace 隔离主机名与域名 User Namespace 隔离用户与用户组 2,3。 Cgroups：限制资源使用（CPU、内存、磁盘I/O等），防止单个容器耗尽宿主机资源3,6。 Union File System（Union FS）：支持分层镜像存储，多个容器共享基础镜像层，减少冗余2,4。 架构设计 客户端-服务器模型：用户通过Docker客户端发送命令，由守护进程（Dockerd）执行操作（构建、运行容器等）4,6。 容器运行时：早期使用LXC，后改为自研的runc（符合OCI标准），实现跨平台兼容3,6。 🔄 工作流程与核心组件 典型工作流： graph LR A[编写Dockerfile] --> B[构建镜像] --> C[推送至仓库] --> D[拉取镜像并运行容器] 构建：docker build -t my-image:tag . 运行：docker run -d --name my-container my-image:tag4,6。 容器管理工具 Docker Compose：通过YAML文件定义多容器应用（如Web服务+数据库），一键启动/停止6。 Docker Swarm/Kubernetes：用于容器编排，支持集群管理、自动扩缩容3,6。 💡 应用场景与优势分析 核心应用场景 环境一致性：解决开发、测试、生产环境差异问题（如依赖库版本冲突）4,5。 微服务部署：每个微服务独立容器化，便于扩展和维护6。 CI/CD流水线：与Jenkins/GitLab集成，实现自动化构建和测试5。 相比虚拟机的优势 特性 Docker容器 传统虚拟机 启动速度 秒级（共享内核） 分钟级（需启动完整OS） 资源占用 低（无Guest OS开销） 高（每个VM需独立OS资源） 隔离性 进程级（通过Namespace） 硬件级（更强隔离） 可移植性 高（镜像跨平台一致） 低（依赖Hypervisor兼容） 3,4,6。 局限性 隔离性较弱：共享内核导致安全风险高于虚拟机，不适合强隔离需求场景3,5。 仅支持Linux应用：Windows/macOS需通过虚拟化层（如Hyper-V）运行1,4。 📈 发展历程与生态系统 关键版本演进 2013年：DotCloud开源Docker，基于LXC技术1。 2014年（1.0版）：生产环境可用，引入核心命令（docker run、docker build）1。 2017年：分拆为社区版（CE）和企业版（EE）5。 2020年后：强化安全（Rootless模式）、优化ARM/M1支持、集成Kubernetes1,4。 相关工具与竞品 镜像仓库：Docker Hub（公有）、Harbor（私有）3,6。 容器运行时：rkt（CoreOS）、CRI-O（Kubernetes专用）3。 编排工具：Kubernetes（主流替代Swarm）3,6。 💎 总结 Docker通过操作系统级虚拟化技术，以容器为载体解决了环境不一致和资源效率问题，成为DevOps和云原生技术的基石。其轻量化、标准化特性在微服务、CI/CD中表现突出，但需结合业务需求权衡隔离性与安全性。未来随着容器生态（如Kubernetes、服务网格）的演进，Docker将继续在应用现代化中扮演核心角色。 如需进一步了解安装配置（如或教程）或命令详解（如），可参考具体章节。\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#docker>Docker</a><ol><li><a href=#-docker的定义与核心概念>🐳 <strong>Docker的定义与核心概念</strong></a></li><li><a href=#-技术原理与架构设计>⚙️ <strong>技术原理与架构设计</strong></a></li><li><a href=#-工作流程与核心组件>🔄 <strong>工作流程与核心组件</strong></a></li><li><a href=#-应用场景与优势分析>💡 <strong>应用场景与优势分析</strong></a></li><li><a href=#-发展历程与生态系统>📈 <strong>发展历程与生态系统</strong></a></li><li><a href=#-总结>💎 <strong>总结</strong></a></li></ol></li><li><a href=#vs-虚拟机>vs. 虚拟机</a><ol><li><a href=#-架构与工作原理>⚙️ <strong>架构与工作原理</strong></a></li><li><a href=#-性能与资源效率>⚡ <strong>性能与资源效率</strong></a></li><li><a href=#-隔离性与安全性>🔒 <strong>隔离性与安全性</strong></a></li><li><a href=#-适用场景对比>🎯 <strong>适用场景对比</strong></a></li><li><a href=#-生态系统与管理工具>🌐 <strong>生态系统与管理工具</strong></a></li><li><a href=#-总结如何选择>💎 <strong>总结：如何选择？</strong></a></li></ol></li><li><a href=#虚拟化技术>虚拟化技术</a><ol><li><a href=#-服务器虚拟化>🖥️ <strong>服务器虚拟化</strong></a></li><li><a href=#-容器虚拟化操作系统级虚拟化>📦 <strong>容器虚拟化（操作系统级虚拟化）</strong></a></li><li><a href=#-存储虚拟化>💾 <strong>存储虚拟化</strong></a></li><li><a href=#-网络虚拟化>🌐 <strong>网络虚拟化</strong></a></li><li><a href=#-应用与桌面虚拟化>🖱️ <strong>应用与桌面虚拟化</strong></a></li><li><a href=#-新兴虚拟化技术>⚙️ <strong>新兴虚拟化技术</strong></a></li><li><a href=#-总结技术选型建议>💎 <strong>总结：技术选型建议</strong></a></li></ol></li><li><a href=#network>Network</a><ol><li><a href=#-docker-网络架构核心概念>🏗️ <strong>Docker 网络架构核心概念</strong></a></li><li><a href=#-六大网络模式详解>🔧 <strong>六大网络模式详解</strong></a><ol><li><a href=#bridge-模式默认><strong>Bridge 模式（默认）</strong></a></li><li><a href=#host-模式><strong>Host 模式</strong></a></li><li><a href=#container-模式><strong>Container 模式</strong></a></li><li><a href=#none-模式><strong>None 模式</strong></a></li><li><a href=#overlay-模式><strong>Overlay 模式</strong></a></li><li><a href=#macvlan-模式><strong>Macvlan 模式</strong></a></li></ol></li><li><a href=#-网络模式对比与选型指南>⚡ <strong>网络模式对比与选型指南</strong></a></li><li><a href=#-高级网络配置技巧>🛠️ <strong>高级网络配置技巧</strong></a></li><li><a href=#-总结-1>💎 <strong>总结</strong></a></li></ol></li><li><a href=#volume>Volume</a><ol><li><a href=#-volume-的核心概念>🗂️ <strong>Volume 的核心概念</strong></a></li><li><a href=#-volume-的类型与对比>🔧 <strong>Volume 的类型与对比</strong></a></li><li><a href=#-volume-操作全指南>⚙️ <strong>Volume 操作全指南</strong></a></li><li><a href=#-高级应用技巧>🔄 <strong>高级应用技巧</strong></a></li><li><a href=#-最佳实践总结>💎 <strong>最佳实践总结</strong></a></li><li><a href=#-实战案例>💡 <strong>实战案例</strong></a></li></ol></li><li><a href=#管理卷--绑定卷>管理卷 & 绑定卷</a><ol><li><a href=#-核心特性对比>⚙️ <strong>核心特性对比</strong></a></li><li><a href=#-性能与安全对比>⚡ <strong>性能与安全对比</strong></a></li><li><a href=#-操作方式对比>🛠️ <strong>操作方式对比</strong></a><ol><li><a href=#创建与挂载命令><strong>创建与挂载命令</strong></a></li><li><a href=#关键差异点><strong>关键差异点</strong></a></li></ol></li><li><a href=#-适用场景对比-1>🎯 <strong>适用场景对比</strong></a></li><li><a href=#-常见问题与避坑指南>⚠️ <strong>常见问题与避坑指南</strong></a></li><li><a href=#-总结选型建议>💎 <strong>总结：选型建议</strong></a></li></ol></li><li><a href=#重启策略>重启策略</a><ol><li><a href=#-重启策略类型与原理>🔧 <strong>重启策略类型与原理</strong></a></li><li><a href=#-关键注意事项>⚠️ <strong>关键注意事项</strong></a></li><li><a href=#-配置方法>⚙️ <strong>配置方法</strong></a><ol><li><a href=#命令行配置><strong>命令行配置</strong></a></li></ol></li></ol></li><li><a href=#docker-logs-nginx---定位错误日志>docker ps -a # 查看 Exited 状态码2,6 docker logs nginx # 定位错误日志</a><ol><li><a href=#-总结-2>💎 <strong>总结</strong></a></li></ol></li><li><a href=#多阶段构建>多阶段构建</a><ol><li><a href=#-核心原理>⚙️ <strong>核心原理</strong></a></li><li><a href=#-核心优势>🚀 <strong>核心优势</strong></a></li><li><a href=#-典型应用场景>🛠️ <strong>典型应用场景</strong></a><ol><li><a href=#编译型语言gojava><strong>编译型语言（Go、Java）</strong></a></li><li><a href=#前端应用reactvue><strong>前端应用（React、Vue）</strong></a></li><li><a href=#java-spring-boot><strong>Java Spring Boot</strong></a></li></ol></li><li><a href=#-高级技巧>🔧 <strong>高级技巧</strong></a></li><li><a href=#-最佳实践>⚠️ <strong>最佳实践</strong></a></li><li><a href=#-总结-3>💎 <strong>总结</strong></a></li></ol></li><li><a href=#容器隔离>容器隔离</a><ol><li><a href=#-隔离机制分类与实现技术>⚙️ <strong>隔离机制分类与实现技术</strong></a><ol><li><a href=#命名空间namespaces-资源视图隔离-2348><strong>命名空间（Namespaces）—— 资源视图隔离</strong> 2,3,4,8</a></li><li><a href=#控制组cgroups-资源限制-348><strong>控制组（Cgroups）—— 资源限制</strong> 3,4,8</a></li><li><a href=#联合文件系统unionfs-文件隔离-378><strong>联合文件系统（UnionFS）—— 文件隔离</strong> 3,7,8</a></li><li><a href=#安全机制权限隔离-38><strong>安全机制——权限隔离</strong> 3,8</a></li><li><a href=#网络隔离虚拟网络栈-68><strong>网络隔离——虚拟网络栈</strong> 6,8</a></li></ol></li><li><a href=#-与传统虚拟机的对比-89>⚖️ <strong>与传统虚拟机的对比</strong> 8,9</a></li><li><a href=#-安全性与局限性>🛡️ <strong>安全性与局限性</strong></a><ol><li><a href=#安全加固实践-78><strong>安全加固实践</strong> 7,8</a></li><li><a href=#固有局限性-38><strong>固有局限性</strong> 3,8</a></li></ol></li><li><a href=#-隔离效果验证示例>🔍 <strong>隔离效果验证示例</strong></a></li><li><a href=#-总结-4>💎 <strong>总结</strong></a></li></ol></li><li><a href=#cgroup>CGroup</a><ol><li><a href=#-cgroup-的核心概念>⚙️ <strong>CGroup 的核心概念</strong></a></li><li><a href=#-cgroup-的核心功能>🛠️ <strong>CGroup 的核心功能</strong></a></li><li><a href=#-cgroup-与容器技术的结合>🌐 <strong>CGroup 与容器技术的结合</strong></a></li><li><a href=#-配置与实践>⚠️ <strong>配置与实践</strong></a><ol><li><a href=#通过文件系统操作><strong>通过文件系统操作</strong></a></li></ol></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/nutrition/ style=background-color:#93b5cf;color:>积雪粮
</a><a href=/categories/willow/ style=background-color:#dc9123;color:>满城风絮</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/dockerconcepts/>【Docker】Concepts</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 30, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>13 minute read</time></div></footer></div></header><section class=article-content><h2 id=docker>Docker</h2><p>以下是对Docker的详细介绍，从核心概念到技术原理、应用场景及生态系统，结合多维度信息综合整理：</p><hr><h3 id=-docker的定义与核心概念>🐳 <strong>Docker的定义与核心概念</strong></h3><ol><li><strong>基本定义</strong>
Docker是一个开源的<strong>应用容器引擎</strong>，基于Go语言开发，允许开发者将应用及其依赖打包成轻量级、可移植的容器。容器共享宿主机操作系统内核，但通过隔离技术保证独立性，实现“一次构建，到处运行”<a class=link href=@ref>1,4,5</a>。</li><li><strong>核心组件</strong><ul><li><strong>镜像（Image）</strong>：只读模板，包含应用运行所需的所有文件（代码、库、环境变量等）。采用分层存储结构（Union FS），每一层可复用，节省存储空间<a class=link href=@ref>2,4</a>。</li><li><strong>容器（Container）</strong>：镜像的运行实例，拥有独立的文件系统、网络和进程空间。通过写时复制（Copy-on-Write）技术，修改仅作用于容器层，不改变镜像本身<a class=link href=@ref>2,6</a>。</li><li><strong>仓库（Registry）</strong>：集中存储和分发镜像的平台。公有仓库如Docker Hub，私有仓库如Harbor<a class=link href=@ref>3,6</a>。</li><li><strong>Dockerfile</strong>：文本文件定义镜像构建步骤（如<code>FROM</code>指定基础镜像、<code>RUN</code>执行命令），实现自动化构建<a class=link href=@ref>4,6</a>。</li></ul></li></ol><hr><h3 id=-技术原理与架构设计>⚙️ <strong>技术原理与架构设计</strong></h3><ol><li><strong>底层技术</strong><ul><li><strong>Namespace</strong>：提供资源隔离，分为6类：<div class=table-wrapper><table><thead><tr><th><strong>类型</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>PID Namespace</td><td>隔离进程ID</td></tr><tr><td>Net Namespace</td><td>隔离网络接口与端口</td></tr><tr><td>MNT Namespace</td><td>隔离文件系统挂载点</td></tr><tr><td>IPC Namespace</td><td>隔离进程间通信</td></tr><tr><td>UTS Namespace</td><td>隔离主机名与域名</td></tr><tr><td>User Namespace</td><td>隔离用户与用户组 <a class=link href=@ref>2,3</a>。</td></tr></tbody></table></div></li><li><strong>Cgroups</strong>：限制资源使用（CPU、内存、磁盘I/O等），防止单个容器耗尽宿主机资源<a class=link href=@ref>3,6</a>。</li><li><strong>Union File System（Union FS）</strong>：支持分层镜像存储，多个容器共享基础镜像层，减少冗余<a class=link href=@ref>2,4</a>。</li></ul></li><li><strong>架构设计</strong><ul><li><strong>客户端-服务器模型</strong>：用户通过Docker客户端发送命令，由守护进程（Dockerd）执行操作（构建、运行容器等）<a class=link href=@ref>4,6</a>。</li><li><strong>容器运行时</strong>：早期使用LXC，后改为自研的<code>runc</code>（符合OCI标准），实现跨平台兼容<a class=link href=@ref>3,6</a>。</li></ul></li></ol><hr><h3 id=-工作流程与核心组件>🔄 <strong>工作流程与核心组件</strong></h3><ol><li><strong>典型工作流</strong>：<pre tabindex=0><code>graph LR  
A[编写Dockerfile] --&gt; B[构建镜像] --&gt; C[推送至仓库] --&gt; D[拉取镜像并运行容器]  
</code></pre><ul><li><strong>构建</strong>：<code>docker build -t my-image:tag .</code></li><li><strong>运行</strong>：<code>docker run -d --name my-container my-image:tag</code><a class=link href=@ref>4,6</a>。</li></ul></li><li><strong>容器管理工具</strong><ul><li><strong>Docker Compose</strong>：通过YAML文件定义多容器应用（如Web服务+数据库），一键启动/停止<a class=link href=@ref>6</a>。</li><li><strong>Docker Swarm/Kubernetes</strong>：用于容器编排，支持集群管理、自动扩缩容<a class=link href=@ref>3,6</a>。</li></ul></li></ol><hr><h3 id=-应用场景与优势分析>💡 <strong>应用场景与优势分析</strong></h3><ol><li><strong>核心应用场景</strong><ul><li><strong>环境一致性</strong>：解决开发、测试、生产环境差异问题（如依赖库版本冲突）<a class=link href=@ref>4,5</a>。</li><li><strong>微服务部署</strong>：每个微服务独立容器化，便于扩展和维护<a class=link href=@ref>6</a>。</li><li><strong>CI/CD流水线</strong>：与Jenkins/GitLab集成，实现自动化构建和测试<a class=link href=@ref>5</a>。</li></ul></li><li><strong>相比虚拟机的优势</strong><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>Docker容器</strong></th><th><strong>传统虚拟机</strong></th></tr></thead><tbody><tr><td><strong>启动速度</strong></td><td>秒级（共享内核）</td><td>分钟级（需启动完整OS）</td></tr><tr><td><strong>资源占用</strong></td><td>低（无Guest OS开销）</td><td>高（每个VM需独立OS资源）</td></tr><tr><td><strong>隔离性</strong></td><td>进程级（通过Namespace）</td><td>硬件级（更强隔离）</td></tr><tr><td><strong>可移植性</strong></td><td>高（镜像跨平台一致）</td><td>低（依赖Hypervisor兼容） <a class=link href=@ref>3,4,6</a>。</td></tr></tbody></table></div></li><li><strong>局限性</strong><ul><li><strong>隔离性较弱</strong>：共享内核导致安全风险高于虚拟机，不适合强隔离需求场景<a class=link href=@ref>3,5</a>。</li><li><strong>仅支持Linux应用</strong>：Windows/macOS需通过虚拟化层（如Hyper-V）运行<a class=link href=@ref>1,4</a>。</li></ul></li></ol><hr><h3 id=-发展历程与生态系统>📈 <strong>发展历程与生态系统</strong></h3><ol><li><strong>关键版本演进</strong><ul><li><strong>2013年</strong>：DotCloud开源Docker，基于LXC技术<a class=link href=@ref>1</a>。</li><li><strong>2014年（1.0版）</strong>：生产环境可用，引入核心命令（<code>docker run</code>、<code>docker build</code>）<a class=link href=@ref>1</a>。</li><li><strong>2017年</strong>：分拆为社区版（CE）和企业版（EE）<a class=link href=@ref>5</a>。</li><li><strong>2020年后</strong>：强化安全（Rootless模式）、优化ARM/M1支持、集成Kubernetes<a class=link href=@ref>1,4</a>。</li></ul></li><li><strong>相关工具与竞品</strong><ul><li><strong>镜像仓库</strong>：Docker Hub（公有）、Harbor（私有）<a class=link href=@ref>3,6</a>。</li><li><strong>容器运行时</strong>：rkt（CoreOS）、CRI-O（Kubernetes专用）<a class=link href=@ref>3</a>。</li><li><strong>编排工具</strong>：Kubernetes（主流替代Swarm）<a class=link href=@ref>3,6</a>。</li></ul></li></ol><hr><h3 id=-总结>💎 <strong>总结</strong></h3><p>Docker通过<strong>操作系统级虚拟化</strong>技术，以容器为载体解决了环境不一致和资源效率问题，成为DevOps和云原生技术的基石。其轻量化、标准化特性在微服务、CI/CD中表现突出，但需结合业务需求权衡隔离性与安全性。未来随着容器生态（如Kubernetes、服务网格）的演进，Docker将继续在应用现代化中扮演核心角色。
如需进一步了解安装配置（如或教程）或命令详解（如），可参考具体章节。</p><h2 id=vs-虚拟机>vs. 虚拟机</h2><p>以下是 Docker 与虚拟机的详细对比，从架构原理、性能、隔离性、适用场景等维度综合分析，结合多源信息整合：</p><hr><h3 id=-架构与工作原理>⚙️ <strong>架构与工作原理</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>Docker（容器）</strong></th><th><strong>虚拟机（VM）</strong></th></tr></thead><tbody><tr><td><strong>虚拟化类型</strong></td><td>操作系统级虚拟化（共享宿主机内核）<a class=link href=@ref>1,3,9</a></td><td>硬件级虚拟化（通过 Hypervisor 模拟硬件）<a class=link href=@ref>3,6</a></td></tr><tr><td><strong>核心组件</strong></td><td>Docker 引擎、容器运行时（如 runc）、镜像分层存储 <a class=link href=@ref>7,8</a></td><td>Hypervisor（如 VMware ESXi、KVM）、Guest OS、虚拟硬件 <a class=link href=@ref>1,10</a></td></tr><tr><td><strong>资源占用</strong></td><td><strong>MB 级</strong>（仅包含应用及依赖）<a class=link href=@ref>3,4</a></td><td><strong>GB 级</strong>（需完整操作系统）<a class=link href=@ref>3,9</a></td></tr><tr><td><strong>启动速度</strong></td><td><strong>秒级启动</strong>（无操作系统加载）<a class=link href=@ref>2,6</a></td><td><strong>分钟级启动</strong>（需启动完整 OS）<a class=link href=@ref>1,10</a></td></tr></tbody></table></div><hr><h3 id=-性能与资源效率>⚡ <strong>性能与资源效率</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>指标</strong></th><th><strong>Docker</strong></th><th><strong>虚拟机</strong></th></tr></thead><tbody><tr><td><strong>CPU/内存开销</strong></td><td>极低（直接使用宿主机资源）<a class=link href=@ref>3,9</a></td><td>较高（Hypervisor 层 + Guest OS 开销）<a class=link href=@ref>6,10</a></td></tr><tr><td><strong>运行密度</strong></td><td>单宿主机可运行 <strong>上千容器</strong><a class=link href=@ref>2,10</a></td><td>单宿主机仅支持 <strong>几十个 VM</strong><a class=link href=@ref>2,9</a></td></tr><tr><td><strong>I/O 性能</strong></td><td>接近宿主机本地进程（无虚拟化层）<a class=link href=@ref>5,8</a></td><td>因虚拟化层存在 <strong>性能损耗</strong>（约 5-20%）<a class=link href=@ref>9</a></td></tr></tbody></table></div><hr><h3 id=-隔离性与安全性>🔒 <strong>隔离性与安全性</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>方面</strong></th><th><strong>Docker</strong></th><th><strong>虚拟机</strong></th></tr></thead><tbody><tr><td><strong>隔离级别</strong></td><td>进程级隔离（Linux Namespace/Cgroups）<a class=link href=@ref>7,9</a></td><td><strong>系统级隔离</strong>（独立内核+虚拟硬件）<a class=link href=@ref>1,10</a></td></tr><tr><td><strong>安全性</strong></td><td>较弱（共享内核，容器逃逸风险）<a class=link href=@ref>5,9</a></td><td>极强（硬件级隔离，攻击难扩散）<a class=link href=@ref>2,10</a></td></tr><tr><td><strong>root 权限风险</strong></td><td>容器内 root 等同宿主机 root（权限未分离）<a class=link href=@ref>5</a></td><td>虚拟机 root 与宿主机 root 权限分离<a class=link href=@ref>9</a></td></tr></tbody></table></div><hr><h3 id=-适用场景对比>🎯 <strong>适用场景对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>Docker 优势</strong></th><th><strong>虚拟机 优势</strong></th></tr></thead><tbody><tr><td><strong>微服务/云原生</strong></td><td>✅ 快速部署、弹性扩缩容 <a class=link href=@ref>1,5</a></td><td>❌ 资源开销大，启动慢</td></tr><tr><td><strong>CI/CD 流水线</strong></td><td>✅ 环境一致性（开发→测试→生产）<a class=link href=@ref>1,4</a></td><td>❌ 环境配置复杂</td></tr><tr><td><strong>多操作系统需求</strong></td><td>❌ 仅支持与宿主机同内核的系统（如 Linux 容器）<a class=link href=@ref>9</a></td><td>✅ 可同时运行 Windows/Linux 等异构系统 <a class=link href=@ref>1,10</a></td></tr><tr><td><strong>高安全隔离场景</strong></td><td>❌ 不适用（如金融核心系统、多租户环境）<a class=link href=@ref>2</a></td><td>✅ 强隔离保障（如 VDI、敏感数据处理）<a class=link href=@ref>1,9</a></td></tr><tr><td><strong>遗留系统兼容性</strong></td><td>❌ 依赖旧版库/硬件的应用难容器化<a class=link href=@ref>1</a></td><td>✅ 直接运行未改造的遗留应用<a class=link href=@ref>10</a></td></tr></tbody></table></div><hr><h3 id=-生态系统与管理工具>🌐 <strong>生态系统与管理工具</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>能力</strong></th><th><strong>Docker</strong></th><th><strong>虚拟机</strong></th></tr></thead><tbody><tr><td><strong>编排工具</strong></td><td>Kubernetes（主流）、Docker Swarm<a class=link href=@ref>5,10</a></td><td>VMware vSphere、OpenStack<a class=link href=@ref>2,9</a></td></tr><tr><td><strong>镜像/模板管理</strong></td><td>Docker Hub（公有仓库）、Harbor（私有）<a class=link href=@ref>7</a></td><td>OVF 模板、VM 快照<a class=link href=@ref>6</a></td></tr><tr><td><strong>高可用机制</strong></td><td>依赖编排工具（如 K8s 自动重启容器）<a class=link href=@ref>5</a></td><td>成熟（VMware HA 承诺 99.999% 可用性）<a class=link href=@ref>5,9</a></td></tr></tbody></table></div><hr><h3 id=-总结如何选择>💎 <strong>总结：如何选择？</strong></h3><ol><li><strong>选 Docker 的场景</strong>：<ul><li>追求 <strong>极致资源利用</strong>（云原生、微服务）<a class=link href=@ref>1,5</a></li><li>需 <strong>快速迭代</strong>（CI/CD、DevOps）<a class=link href=@ref>4,10</a></li><li>环境一致性要求高（跨平台开发测试）<a class=link href=@ref>1,6</a></li></ul></li><li><strong>选虚拟机的场景</strong>：<ul><li><strong>强隔离刚性需求</strong>（安全合规、多租户）<a class=link href=@ref>2,9</a></li><li><strong>运行异构 OS</strong>（如 Windows 应用）<a class=link href=@ref>3,10</a></li><li><strong>传统应用兼容</strong>（无需改造的遗留系统）<a class=link href=@ref>1,6</a></li></ul></li><li><strong>混合架构趋势</strong>：
虚拟机中部署 Docker 集群（如 VMware + Kubernetes），兼顾隔离性与容器效率<a class=link href=@ref>5,10</a>。</li></ol><blockquote><p>更深入的技术细节（如 Docker 的 Union FS、虚拟机的 VT-x 硬件加速）或具体场景方案，可进一步探讨！</p></blockquote><h2 id=虚拟化技术>虚拟化技术</h2><p>以下是除Docker容器外的其他主流虚拟化技术分类详解，涵盖原理、代表技术与应用场景：</p><hr><h3 id=-服务器虚拟化>🖥️ <strong>服务器虚拟化</strong></h3><p><strong>1. 全虚拟化（Full Virtualization）</strong></p><ul><li><strong>原理</strong>：通过Hypervisor（如VMware ESXi）在物理硬件上创建完全隔离的虚拟机，每个虚拟机运行独立操作系统。Hypervisor模拟完整硬件环境，无需修改客户机操作系统<a class=link href=@ref>3,5</a>。</li><li>代表技术：<ul><li><strong>VMware ESXi</strong>：企业级虚拟化平台，支持动态资源分配、实时迁移（vMotion），广泛用于数据中心整合<a class=link href=@ref>5,8</a>。</li><li><strong>Microsoft Hyper-V</strong>：集成于Windows Server，支持嵌套虚拟化，适用于混合云环境<a class=link href=@ref>5</a>。</li></ul></li><li><strong>优势</strong>：兼容性强，支持异构操作系统（Windows/Linux）。</li><li><strong>局限</strong>：Hypervisor层引入性能开销（约5-20%）<a class=link href=@ref>5</a>。
<strong>2. 半虚拟化（Paravirtualization）</strong></li><li><strong>原理</strong>：需修改客户机操作系统内核，使其感知虚拟化环境，直接与Hypervisor协作（如Xen），减少模拟开销<a class=link href=@ref>3,6</a>。</li><li><strong>代表技术</strong>：<strong>Xen</strong>：开源虚拟化平台，由剑桥大学开发，早期用于公有云（如AWS EC2），需定制化操作系统支持<a class=link href=@ref>3,6</a>。</li><li><strong>适用场景</strong>：对I/O性能要求高的场景（如数据库集群）<a class=link href=@ref>6</a>。
<strong>3. 硬件辅助虚拟化（Hardware-Assisted Virtualization）</strong></li><li><strong>原理</strong>：依赖CPU指令集（Intel VT-x / AMD-V）直接处理虚拟化操作，减少软件层开销。关键技术包括内存虚拟化（EPT/NPT）和I/O虚拟化（VT-d/SR-IOV）<a class=link href=@ref>6,7</a>。</li><li><strong>代表技术</strong>：<strong>KVM（Kernel-based Virtual Machine）</strong>：Linux内核模块，将Linux转化为Hypervisor，结合QEMU模拟硬件，成为OpenStack默认虚拟化方案<a class=link href=@ref>3,7</a>。</li><li><strong>性能</strong>：虚拟机性能达物理机95%以上，适用于高密度云环境<a class=link href=@ref>7</a>。</li></ul><hr><h3 id=-容器虚拟化操作系统级虚拟化>📦 <strong>容器虚拟化（操作系统级虚拟化）</strong></h3><p><strong>1. 轻量级容器技术</strong></p><ul><li><strong>原理</strong>：共享宿主机内核，通过Namespace和Cgroups实现进程隔离，无需独立操作系统<a class=link href=@ref>3,5</a>。</li><li>代表技术：<ul><li><strong>LXC（Linux Containers）</strong>：早期Linux容器引擎，Docker的前身基础<a class=link href=@ref>3</a>。</li><li><strong>OpenVZ</strong>：基于Linux内核的OS级虚拟化，支持资源隔离但需定制内核<a class=link href=@ref>3</a>。</li></ul></li><li><strong>对比Docker</strong>：更接近系统底层，适合需要直接管理内核资源的场景。
<strong>2. 容器编排生态</strong></li><li><strong>Kubernetes</strong>：容器编排标杆，支持自动化部署、扩缩容，与KVM、VMware集成实现混合虚拟化管理<a class=link href=@ref>5,8</a>。</li></ul><hr><h3 id=-存储虚拟化>💾 <strong>存储虚拟化</strong></h3><ul><li><strong>原理</strong>：整合物理存储设备（SAN/NAS）为统一“存储池”，实现动态分配与数据迁移<a class=link href=@ref>3,6</a>。</li><li>技术方案：<ul><li><strong>硬件方案</strong>：存储阵列（如EMC VMAX）提供卷管理。</li><li><strong>软件方案</strong>：分布式存储（如Ceph）、虚拟SAN（如VMware vSAN）<a class=link href=@ref>6</a>。</li></ul></li><li>核心功能：<ul><li>精简配置（Thin Provisioning）</li></ul></li><li>快照与克隆<ul><li>异地数据复制（容灾）</li></ul></li><li><strong>应用场景</strong>：云存储、备份恢复系统<a class=link href=@ref>4</a>。</li></ul><hr><h3 id=-网络虚拟化>🌐 <strong>网络虚拟化</strong></h3><p><strong>1. SDN（软件定义网络）</strong></p><ul><li><strong>原理</strong>：分离控制平面与数据平面，通过控制器（如OpenDaylight）集中管理网络流量<a class=link href=@ref>3,6</a>。</li><li><strong>应用</strong>：动态配置VLAN、负载均衡，支持多租户网络隔离（如云服务商）。
<strong>2. NFV（网络功能虚拟化）</strong></li><li><strong>原理</strong>：将防火墙、路由器等网络功能从专用硬件解耦，以软件形式运行于虚拟机<a class=link href=@ref>3,6</a>。</li><li><strong>案例</strong>：5G核心网UPF（用户面功能）虚拟化，降低运营商设备成本<a class=link href=@ref>6</a>。</li></ul><hr><h3 id=-应用与桌面虚拟化>🖱️ <strong>应用与桌面虚拟化</strong></h3><p><strong>1. 应用虚拟化</strong></p><ul><li><strong>原理</strong>：应用与操作系统解耦，通过流式传输（如Microsoft App-V）或容器（如Singularity）交付，避免本地安装冲突<a class=link href=@ref>3,4</a>。</li><li><strong>场景</strong>：企业统一发布软件，跨平台兼容（Windows/Linux应用混用）。
<strong>2. 桌面虚拟化（VDI）</strong></li><li><strong>原理</strong>：桌面操作系统运行于数据中心虚拟机，用户通过瘦客户端（如Citrix Receiver）远程访问<a class=link href=@ref>4,6</a>。</li><li><strong>优势</strong>：数据不落地、支持移动办公，典型方案包括VMware Horizon、Citrix XenDesktop。</li></ul><hr><h3 id=-新兴虚拟化技术>⚙️ <strong>新兴虚拟化技术</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>技术方向</strong></th><th><strong>核心突破</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>GPU虚拟化</strong></td><td>vGPU分片（NVIDIA GRID）支持AI训练并行加速</td><td>深度学习、实时渲染<a class=link href=@ref>6</a></td></tr><tr><td><strong>嵌套虚拟化</strong></td><td>虚拟机内再运行Hypervisor（如KVM on ESXi）</td><td>开发测试、云服务嵌套部署<a class=link href=@ref>6</a></td></tr><tr><td><strong>无服务器虚拟化</strong></td><td>事件驱动按需分配资源（AWS Lambda）</td><td>微服务、间歇性任务处理<a class=link href=@ref>4</a></td></tr></tbody></table></div><hr><h3 id=-总结技术选型建议>💎 <strong>总结：技术选型建议</strong></h3><ul><li><strong>追求轻量快速</strong>：选容器（Docker/LXC）<a class=link href=@ref>3</a>。</li><li><strong>强隔离与多OS</strong>：选全虚拟化（VMware/KVM）<a class=link href=@ref>5,8</a>。</li><li><strong>网络/存储优化</strong>：SDN/NFV或存储虚拟化<a class=link href=@ref>6</a>。</li><li><strong>桌面交付与安全</strong>：VDI方案（Citrix/VMware）<a class=link href=@ref>4</a>。</li><li><strong>未来趋势</strong>：硬件辅助虚拟化+容器化融合（如vSphere with Tanzu）<a class=link href=@ref>8</a>。</li></ul><blockquote><p>更深入的技术实现细节（如Intel VT-x指令集工作流程）或行业案例（金融/电信虚拟化架构），可进一步探讨！</p></blockquote><h2 id=network>Network</h2><p>以下是 Docker 网络模式的全面解析，涵盖核心原理、配置方法、适用场景及优化策略，结合技术细节与实践案例综合整理：</p><hr><h3 id=-docker-网络架构核心概念>🏗️ <strong>Docker 网络架构核心概念</strong></h3><ol><li><strong>Network Namespace</strong><ul><li>每个容器拥有独立的网络栈（网卡、IP、路由表），实现网络隔离<a class=link href=@ref>1,4</a>。</li><li>通过 <code>ip netns</code> 命令可查看不同容器的命名空间。</li></ul></li><li><strong>虚拟网桥（docker0）</strong><ul><li>默认创建的虚拟交换机（IP 通常为 <code>172.17.0.1/16</code>），容器通过 <code>veth pair</code> 设备连接到网桥<a class=link href=@ref>4,6</a>。</li><li><strong>veth pair</strong>：一端在容器内（<code>eth0</code>），一端在宿主机（<code>vethxxx</code>），实现容器与宿主机通信<a class=link href=@ref>4</a>。</li></ul></li><li><strong>网络驱动（Driver）</strong>
Docker 通过不同驱动实现多样化的网络模式：<ul><li><code>bridge</code>：默认驱动，适用于单机容器互联。</li><li><code>overlay</code>：支持跨主机通信（如 Swarm/Kubernetes）。</li><li><code>macvlan</code>：容器直接绑定物理网卡，获得独立 MAC 地址<a class=link href=@ref>9</a>。</li><li><code>none</code>：无网络功能，需手动配置。</li></ul></li></ol><hr><h3 id=-六大网络模式详解>🔧 <strong>六大网络模式详解</strong></h3><h4 id=bridge-模式默认><strong>Bridge 模式（默认）</strong></h4><ul><li><strong>原理</strong>：
容器通过 <code>docker0</code> 网桥互联，IP 由 DHCP 分配（如 <code>172.17.0.0/16</code>）。外部访问需端口映射（<code>-p 80:80</code>），本质是 iptables DNAT 规则<a class=link href=@ref>4,7</a>。</li><li>特点：<ul><li>✅ 容器间通过 IP 或容器名通信（需自定义网络）。</li><li>❌ 外部访问需显式端口映射。</li></ul></li><li>命令示例：<pre tabindex=0><code>docker run -d --name web nginx  # 默认使用 bridge
docker network create my-bridge  # 创建自定义桥接网络[7](@ref)
</code></pre></li></ul><h4 id=host-模式><strong>Host 模式</strong></h4><ul><li><p><strong>原理</strong>：
容器共享宿主机 Network Namespace，直接使用主机 IP 和端口，无虚拟网卡<a class=link href=@ref>1,3</a>。</p></li><li><p>适用场景：</p><ul><li>高性能需求（如网络监控工具），避免 NAT 开销。</li><li>需直接暴露服务的场景（如 Prometheus 抓取节点数据）。</li></ul></li><li><p>限制：</p><ul><li>❌ 端口冲突风险（容器与宿主机端口共用）。</li><li>❌ 无网络隔离，安全性低。</li></ul></li><li><p>命令示例：</p><pre tabindex=0><code>docker run -d --net=host --name nginx-host nginx
</code></pre></li></ul><h4 id=container-模式><strong>Container 模式</strong></h4><ul><li><p><strong>原理</strong>：
新容器共享指定容器的 Network Namespace（同 IP、端口）<a class=link href=@ref>1,5</a>。</p></li><li><p><strong>典型用例</strong>：</p><ul><li>Kubernetes Pod 内容器互通（通过 <code>localhost</code> 直接通信）。</li><li>Sidecar 模式（日志收集器共享业务容器的网络）。</li></ul></li><li><p><strong>命令示例</strong>：</p></li></ul><pre tabindex=0><code>docker run -d --name base-container alpine sleep 3600
docker run -d --net=container:base-container --name sidecar nginx
</code></pre><h4 id=none-模式><strong>None 模式</strong></h4><ul><li><p><strong>原理</strong>：
容器仅有 <code>lo</code> 回环接口，无外部网络连接<a class=link href=@ref>2,6</a>。</p></li><li><p>使用场景：</p><ul><li>离线数据处理（如安全审计）。</li><li>需完全自定义网络的场景（手动配置 veth 或 VPN）。</li></ul></li><li><p>命令示例：</p><pre tabindex=0><code>docker run -d --net=none --name isolated-container alpine
</code></pre></li></ul><h4 id=overlay-模式><strong>Overlay 模式</strong></h4><ul><li><p><strong>原理</strong>：
基于 VXLAN 隧道实现跨主机容器通信，用于 Docker Swarm/Kubernetes 集群<a class=link href=@ref>1,8</a>。</p></li><li><p>核心优势：</p><ul><li>✅ 自动服务发现（DNS 解析服务名）。</li><li>✅ 内置负载均衡（VIP 分发流量到多个副本）。</li></ul></li><li><p>命令示例：</p><pre tabindex=0><code>docker network create -d overlay my-overlay  # Swarm 模式下有效
</code></pre></li></ul><h4 id=macvlan-模式><strong>Macvlan 模式</strong></h4><ul><li><p><strong>原理</strong>：
容器直接绑定物理网卡（如 <code>eth0</code>），拥有独立 MAC 和 IP，像物理设备一样接入局域网<a class=link href=@ref>9</a>。</p></li><li><p>适用场景：</p><ul><li>IoT 设备模拟（每个容器代表一个设备）。</li><li>需固定 IP 的传统应用迁移。</li></ul></li><li><p>配置示例：</p><pre tabindex=0><code>docker network create -d macvlan \
  --subnet=192.168.1.0/24 \
  --gateway=192.168.1.1 \
  -o parent=eth0 \
  my-macvlan
</code></pre></li></ul><hr><h3 id=-网络模式对比与选型指南>⚡ <strong>网络模式对比与选型指南</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>模式</strong></th><th><strong>隔离性</strong></th><th><strong>性能</strong></th><th><strong>配置复杂度</strong></th><th><strong>典型场景</strong></th></tr></thead><tbody><tr><td><strong>Bridge</strong></td><td>中</td><td>中</td><td>低</td><td>开发测试、单机多容器</td></tr><tr><td><strong>Host</strong></td><td>低</td><td>★★★</td><td>低</td><td>网络监控、高性能服务</td></tr><tr><td><strong>Container</strong></td><td>低</td><td>高</td><td>中</td><td>Pod 内容器互通、Sidecar</td></tr><tr><td><strong>None</strong></td><td>★★★</td><td>-</td><td>高</td><td>安全敏感型离线任务</td></tr><tr><td><strong>Overlay</strong></td><td>高</td><td>中</td><td>高</td><td>集群跨主机通信（Swarm/K8s）</td></tr><tr><td><strong>Macvlan</strong></td><td>高</td><td>★★★</td><td>中</td><td>直接接入物理网络、IoT</td></tr></tbody></table></div><hr><h3 id=-高级网络配置技巧>🛠️ <strong>高级网络配置技巧</strong></h3><ol><li><p><strong>自定义 DNS 与服务发现</strong></p><ul><li>自定义网络中容器可通过<strong>容器名</strong>自动解析 IP（无需 <code>--link</code>）<a class=link href=@ref>7</a>。</li><li>覆盖网络内置 DNS 轮询，实现负载均衡。</li></ul></li><li><p><strong>网络隔离与安全</strong></p><ul><li>使用 <code>--internal</code> 创建仅内部通信的网络（禁止外部访问）<a class=link href=@ref>4</a>。</li><li>通过 <code>iptables</code> 限制容器间流量（如仅允许特定端口）。</li></ul></li><li><p><strong>多网卡绑定</strong></p><ul><li><p>容器可连接多个网络（如业务网+监控网）：</p><pre tabindex=0><code>docker network connect monitoring-net my-container
</code></pre></li></ul></li><li><p><strong>IPv6 支持</strong></p><ul><li><p>创建网络时添加</p><pre tabindex=0><code>--ipv6
</code></pre><p>参数，并配置子网：</p><pre tabindex=0><code>docker network create --ipv6 --subnet=2001:db8::/64 ipv6-net
</code></pre></li></ul></li></ol><hr><h3 id=-总结-1>💎 <strong>总结</strong></h3><ul><li><p><strong>基础场景</strong>：单机容器互联首选 <strong>Bridge 模式</strong>（自定义网络提升灵活性与 DNS 解析）。</p></li><li><p><strong>性能优先</strong>：<strong>Host 模式</strong>适合高频 I/O 应用，但牺牲隔离性。</p></li><li><p><strong>集群架构</strong>：<strong>Overlay 模式</strong>是跨主机通信的基石，集成于 Swarm/Kubernetes。</p></li><li><p>特殊需求：</p><ul><li>物理网络直通 → <strong>Macvlan</strong></li></ul></li><li><p>绝对网络隔离 → <strong>None 模式</strong> + 手动配置。</p></li></ul><blockquote><p>可通过 <code>docker network inspect [网络名]</code> 查看详细配置<a class=link href=@ref>4,7</a>。生产环境建议避免默认网桥，优先使用自定义网络以增强可控性与安全性。</p></blockquote><h2 id=volume>Volume</h2><p>以下是对 <strong>Docker Volume（存储卷）</strong> 的全面解析，结合核心概念、类型对比、操作指南及最佳实践，综合多源信息整理而成：</p><hr><h3 id=-volume-的核心概念>🗂️ <strong>Volume 的核心概念</strong></h3><ol><li><strong>定义</strong><ul><li>Volume 是 Docker 用于<strong>持久化存储容器数据</strong>的机制，本质是宿主机文件系统中的目录（如 <code>/var/lib/docker/volumes/</code>），与容器内目录建立绑定关系，实现双向数据同步<a class=link href=@ref>1,5</a>。</li><li>独立于容器生命周期，容器删除后数据仍保留，支持多容器共享<a class=link href=@ref>3,6</a>。</li></ul></li><li><strong>核心价值</strong><ul><li><strong>数据持久化</strong>：解决容器删除导致数据丢失的问题（如 MySQL 数据库文件）<a class=link href=@ref>1,4</a>。</li><li><strong>性能优化</strong>：绕过联合文件系统（Union FS），直接读写宿主机磁盘，I/O 效率提升 30% 以上<a class=link href=@ref>2,7</a>。</li><li><strong>共享与隔离</strong>：多个容器可挂载同一 Volume 共享数据（如日志目录），同时通过 Namespace 隔离操作<a class=link href=@ref>5,6</a>。</li></ul></li></ol><hr><h3 id=-volume-的类型与对比>🔧 <strong>Volume 的类型与对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>类型</strong></th><th><strong>管理方</strong></th><th><strong>存储位置</strong></th><th><strong>适用场景</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>管理卷 (Volume)</strong></td><td>Docker 引擎</td><td><code>/var/lib/docker/volumes/卷名</code></td><td>生产环境数据库（如 MySQL）</td><td>自动创建、安全隔离、易备份<a class=link href=@ref>1,4</a></td></tr><tr><td><strong>绑定卷 (Bind Mount)</strong></td><td>用户手动指定</td><td>宿主机任意路径（如 <code>/home/data</code>）</td><td>开发调试（挂载代码或配置）</td><td>需绝对路径，覆盖容器目录内容<a class=link href=@ref>5,7</a></td></tr><tr><td><strong>临时卷 (tmpfs)</strong></td><td>宿主机内存</td><td>内存中</td><td>敏感临时数据（如 SSL 证书）</td><td>容器停止即消失，高性能但易失<a class=link href=@ref>1,3</a></td></tr></tbody></table></div><blockquote><p>⚠️ <strong>关键区别</strong>：</p><ul><li>绑定卷会<strong>覆盖容器内目录原有内容</strong>，而管理卷会<strong>保留镜像初始数据</strong><a class=link href=@ref>5,7</a>。</li><li>临时卷仅限 Linux 宿主机使用，不支持共享<a class=link href=@ref>7</a>。</li></ul></blockquote><hr><h3 id=-volume-操作全指南>⚙️ <strong>Volume 操作全指南</strong></h3><ol><li><p><strong>管理卷操作</strong></p><ul><li><p>创建与查看：</p><pre tabindex=0><code>docker volume create my-vol  # 创建命名卷
docker volume ls             # 列出所有卷
docker volume inspect my-vol # 查看卷详情（含宿主机存储路径）[1,3](@ref)
</code></pre></li><li><p>挂载到容器：</p><pre tabindex=0><code># 方式1：-v 参数
docker run -d -v my-vol:/app/data nginx:latest
# 方式2：--mount 参数（更推荐，语法明确）
docker run -d --mount type=volume,source=my-vol,target=/app/data nginx:latest
</code></pre></li><li><p>删除清理：</p><pre tabindex=0><code></code></pre></li></ul><p>docker volume rm my-vol # 删除指定卷（需无容器使用）
docker volume prune # 清理所有未使用卷<a class=link href=@ref>1,3</a></p><pre tabindex=0><code></code></pre></li><li><p><strong>绑定卷操作</strong></p><pre tabindex=0><code># 将宿主机 /home/user/config 挂载到容器 /app/config（可读写）
docker run -d -v /home/user/config:/app/config nginx:latest
# 只读挂载（容器无法修改宿主机文件）
docker run -d -v /home/user/config:/app/config:ro nginx:latest[5,7](@ref)
</code></pre></li><li><p><strong>临时卷操作</strong></p><pre tabindex=0><code># 内存挂载（限制大小 128MB）
docker run -d --tmpfs /app/cache:rw,size=128m nginx:latest
# 或使用 --mount
docker run -d --mount type=tmpfs,destination=/app/cache,tmpfs-size=128m nginx:latest[1,3](@ref)
</code></pre></li></ol><hr><h3 id=-高级应用技巧>🔄 <strong>高级应用技巧</strong></h3><ol><li><p><strong>多容器共享数据</strong></p><ul><li><p>方案1：多个容器挂载同一 Volume</p><pre tabindex=0><code>docker run -d -v shared-data:/app/logs container1
docker run -d -v shared-data:/app/logs container2
</code></pre></li><li><p>方案2：通过 &ndash;volumes-from 继承挂载（适合 Sidecar 日志收集）</p><pre tabindex=0><code> docker run -d --name logger -v /logs busybox
 docker run -d --volumes-from logger app-server
</code></pre></li></ul></li><li><p><strong>数据备份与恢复</strong></p><pre tabindex=0><code># 备份 Volume 到宿主机
docker run --rm -v my-vol:/data -v $(pwd):/backup alpine \
  tar -czf /backup/my-vol-backup.tar.gz /data
# 从备份恢复
docker run --rm -v my-vol:/data -v $(pwd):/backup alpine \
  sh -c &#34;rm -rf /data/* &amp;&amp; tar -xzf /backup/my-vol-backup.tar.gz -C /data&#34;[3,6](@ref)
</code></pre></li><li><p><strong>远程存储驱动</strong>
对接 NFS、AWS EBS 等分布式存储：</p><pre tabindex=0><code>docker volume create \
  --driver local \
  --opt type=nfs \
  --opt o=addr=192.168.1.100,rw \
  --opt device=:/nfs/data \
  nfs-volume[3,4](@ref)
</code></pre></li></ol><hr><h3 id=-最佳实践总结>💎 <strong>最佳实践总结</strong></h3><ol><li><strong>选型建议</strong>：<ul><li>✅ <strong>生产环境</strong>：优先使用<strong>管理卷</strong>（安全隔离、易维护）<a class=link href=@ref>4,6</a>。</li><li>✅ <strong>开发调试</strong>：用<strong>绑定卷</strong>快速挂载代码或配置<a class=link href=@ref>7</a>。</li><li>⚠️ <strong>敏感数据</strong>：用 <strong>tmpfs</strong> 避免磁盘残留<a class=link href=@ref>3</a>。</li></ul></li><li><strong>避坑指南</strong>：<ul><li>避免匿名卷（难以追踪管理），始终命名 Volume（如 <code>mysql-data</code>）<a class=link href=@ref>6</a>。</li><li>绑定卷时确保宿主机目录存在，否则 <code>--mount</code> 会报错（<code>-v</code> 会自动创建但可能导致权限问题）<a class=link href=@ref>5,7</a>。</li><li>跨平台场景用 Volume 而非绑定卷（Windows/macOS 路径兼容性问题）<a class=link href=@ref>6</a>。</li></ul></li><li><strong>运维策略</strong>：<ul><li>监控宿主机磁盘空间（<code>df -h /var/lib/docker/volumes</code>）。</li><li>定期备份关键 Volume（如数据库卷）<a class=link href=@ref>3,6</a>。</li></ul></li></ol><hr><h3 id=-实战案例>💡 <strong>实战案例</strong></h3><p><strong>MySQL 数据持久化</strong>：</p><pre tabindex=0><code># 创建专用于数据库的 Volume
docker volume create mysql-data
# 运行容器并挂载
docker run -d \
  --name mysql-server \
  -e MYSQL_ROOT_PASSWORD=123456 \
  -v mysql-data:/var/lib/mysql \  # 数据目录持久化
  mysql:8.0
</code></pre><blockquote><p>即使删除容器，数据仍可通过新容器挂载 <code>mysql-data</code> 恢复<a class=link href=@ref>3,4</a>。</p></blockquote><hr><p>通过 Volume 机制，Docker 有效平衡了容器轻量化与数据持久化的矛盾，成为有状态服务的核心支撑。合理选型与规范操作，可显著提升系统可靠性（参考：<a class=link href=https://docs.docker.com/storage/volumes/ target=_blank rel=noopener>Docker 官方文档</a>）。</p><h2 id=管理卷--绑定卷>管理卷 & 绑定卷</h2><p>以下是 Docker 中**管理卷（Volume）<strong>与</strong>绑定卷（Bind Mount）**的详细对比，结合核心特性、适用场景及操作差异，整理自多源技术文档与实践分析：</p><hr><h3 id=-核心特性对比>⚙️ <strong>核心特性对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>管理卷 (Volume)</strong></th><th><strong>绑定卷 (Bind Mount)</strong></th></tr></thead><tbody><tr><td><strong>管理方</strong></td><td>Docker 引擎自动管理</td><td>用户手动管理宿主机路径</td></tr><tr><td><strong>存储位置</strong></td><td><code>/var/lib/docker/volumes/卷名/_data</code> <a class=link href=@ref>2,7</a></td><td>用户指定的宿主机任意路径（如 <code>/home/data</code>）<a class=link href=@ref>3,9</a></td></tr><tr><td><strong>初始化行为</strong></td><td>自动创建空目录，<strong>保留容器内原内容</strong></td><td>直接覆盖容器内目录的原有内容<a class=link href=@ref>6,9</a></td></tr><tr><td><strong>可移植性</strong></td><td>✅ 高（路径由 Docker 统一管理）</td><td>❌ 低（依赖宿主机特定路径）</td></tr><tr><td><strong>权限控制</strong></td><td>默认容器内用户权限隔离</td><td>依赖宿主机文件权限，需手动设置<a class=link href=@ref>9</a></td></tr><tr><td><strong>共享便捷性</strong></td><td>支持多容器共享同一命名卷</td><td>需手动确保多个容器挂载相同宿主机路径</td></tr></tbody></table></div><hr><h3 id=-性能与安全对比>⚡ <strong>性能与安全对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>维度</strong></th><th><strong>管理卷</strong></th><th><strong>绑定卷</strong></th></tr></thead><tbody><tr><td><strong>I/O 性能</strong></td><td>更优（尤其小文件读写）<a class=link href=@ref>1</a></td><td>可能因跨文件系统（如 ext4 → overlay2）产生额外开销<a class=link href=@ref>1</a></td></tr><tr><td><strong>元数据操作</strong></td><td>高效（大量文件创建/删除场景）</td><td>性能较低（依赖宿主机文件系统）<a class=link href=@ref>1</a></td></tr><tr><td><strong>安全性</strong></td><td>✅ 隔离性强（仅 Docker 可访问）</td><td>❌ 风险高（容器直接读写宿主机敏感路径）<a class=link href=@ref>8</a></td></tr><tr><td><strong>数据持久性</strong></td><td>独立于容器生命周期</td><td>依赖宿主机目录维护</td></tr></tbody></table></div><hr><h3 id=-操作方式对比>🛠️ <strong>操作方式对比</strong></h3><h4 id=创建与挂载命令><strong>创建与挂载命令</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>方式</strong></th><th><strong>管理卷</strong></th><th><strong>绑定卷</strong></th></tr></thead><tbody><tr><td><strong>命令行创建</strong></td><td><code>docker volume create db-data</code></td><td>无需创建，直接指定路径</td></tr><tr><td><strong>运行容器</strong></td><td><code>bash docker run -v db-data:/var/lib/mysql</code></td><td><code>bash docker run -v /host/mysql:/var/lib/mysql</code></td></tr><tr><td><strong><code>--mount</code></strong></td><td><code>bash --mount type=volume,src=db-data,target=/data</code></td><td><code>bash --mount type=bind,src=/host/data,target=/app</code></td></tr></tbody></table></div><h4 id=关键差异点><strong>关键差异点</strong></h4><ul><li><p><strong>路径存在性检查</strong></p></li><li><p><strong>绑定卷</strong>：宿主机路径不存在时，<code>--mount</code> 会报错，<code>-v</code> 会自动创建（可能导致权限问题）<a class=link href=@ref>9</a>。</p><ul><li>管理卷：自动创建目录，无需手动干预。</li></ul></li><li><p><strong>只读控制</strong>
两者均支持 <code>:ro</code> 或 <code>readonly</code> 参数（如 <code>-v db-data:/data:ro</code>）<a class=link href=@ref>6,7</a>。</p></li></ul><hr><h3 id=-适用场景对比-1>🎯 <strong>适用场景对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方案</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td><strong>生产环境数据库持久化</strong></td><td>✅ 管理卷</td><td>数据安全隔离、易备份迁移（如 MySQL 的 <code>/var/lib/mysql</code>）<a class=link href=@ref>6,9</a></td></tr><tr><td><strong>开发环境代码热更新</strong></td><td>✅ 绑定卷</td><td>直接修改宿主机代码，容器实时生效<a class=link href=@ref>1,8</a></td></tr><tr><td><strong>多容器共享配置（如日志）</strong></td><td>⚖️ 管理卷更安全</td><td>避免暴露宿主机敏感路径<a class=link href=@ref>7</a></td></tr><tr><td><strong>宿主机文件直接访问</strong></td><td>✅ 绑定卷</td><td>需读取宿主机特定文件（如 <code>/etc/resolv.conf</code>）<a class=link href=@ref>9</a></td></tr></tbody></table></div><hr><h3 id=-常见问题与避坑指南>⚠️ <strong>常见问题与避坑指南</strong></h3><ol><li><strong>数据覆盖风险</strong><ul><li>绑定卷会清空容器内目标目录原有文件（如挂载空目录到 Nginx 的 <code>/usr/share/nginx/html</code> 会导致默认页面消失）<a class=link href=@ref>6,9</a>。</li><li><strong>规避方案</strong>：预填充宿主机目录或使用管理卷保留初始内容。</li></ul></li><li><strong>权限冲突</strong><ul><li>绑定卷若宿主机目录属主为 root，容器非 root 用户运行时可能无写权限。</li><li><strong>解决</strong>：启动容器时指定用户 <code>-u</code> 或调整宿主机目录权限<a class=link href=@ref>9</a>。</li></ul></li><li><strong>匿名卷管理混乱</strong><ul><li>匿名管理卷（如 <code>-v /data</code>）难以追踪，<strong>建议始终使用命名卷</strong>（如 <code>-v named-vol:/data</code>）<a class=link href=@ref>5,7</a>。</li></ul></li></ol><hr><h3 id=-总结选型建议>💎 <strong>总结：选型建议</strong></h3><ul><li><strong>优先选择管理卷的场景</strong>：
✅ 生产环境数据持久化
✅ 需跨主机迁移或备份的数据
✅ 对安全隔离性要求高</li><li><strong>优先选择绑定卷的场景</strong>：
✅ 开发调试需实时同步代码
✅ 直接集成宿主机现有文件（如配置文件）
✅ 对宿主机路径有精准控制需求</li></ul><blockquote><p><strong>混合架构示例</strong>：
开发环境用绑定卷快速迭代，生产环境替换为管理卷：
<code>bash # 开发命令 docker run -v /path/to/code:/app my-image # 生产命令 docker run -v prod-code:/app my-image</code></p></blockquote><p>通过合理选型，可平衡开发效率与运维可靠性。更深入的性能调优（如 NFS 远程卷）或权限方案，可参考 <a class=link href=https://docs.docker.com/storage/volumes/ target=_blank rel=noopener>Docker 官方文档</a><a class=link href=@ref>9</a>。</p><h2 id=重启策略>重启策略</h2><p>Docker 的重启策略（Restart Policies）是确保容器在退出后自动恢复运行的核心机制，适用于生产环境中保障服务的高可用性。以下详细解析其原理、策略类型、配置方法及最佳实践：</p><hr><h3 id=-重启策略类型与原理>🔧 <strong>重启策略类型与原理</strong></h3><p>Docker 提供四种重启策略，通过 <code>--restart</code> 参数指定，由 Docker 守护进程执行<a class=link href=@ref>1,3,6</a>：</p><ol><li><p><strong><code>no</code>（默认策略）</strong></p><ul><li><strong>行为</strong>：容器退出后不自动重启。</li><li><strong>场景</strong>：临时任务、测试环境或由外部编排工具（如 Kubernetes）管理生命周期<a class=link href=@ref>1,3</a>。</li></ul></li><li><p><strong><code>always</code></strong></p><ul><li><strong>行为</strong>：无论退出状态（正常或异常），均自动重启容器。
​<strong>注意</strong>​：若容器被手动停止（<code>docker stop</code>），Docker 守护进程重启后该容器仍会自动启动<a class=link href=@ref>3,4</a>。</li><li><strong>场景</strong>：需绝对持续运行的服务（如监控代理），但需警惕无限重启循环<a class=link href=@ref>3,6</a>。</li></ul></li><li><p><strong><code>on-failure[:max-retries]</code></strong></p><ul><li><p>行为：仅当容器异常退出（退出状态码非</p><pre tabindex=0><code>0
</code></pre><p>）时重启。</p><ul><li>可指定最大重启次数（如 <code>on-failure:3</code>），超限后放弃重启。</li><li>若不设上限（<code>on-failure</code>），会无限重试<a class=link href=@ref>2,3,5</a>。</li></ul></li><li><p><strong>场景</strong>：批处理任务或可能偶发故障的服务，避免正常退出后无意义重启<a class=link href=@ref>3,6</a>。</p></li></ul></li><li><p><strong><code>unless-stopped</code></strong></p><ul><li><strong>行为</strong>：容器退出时自动重启，<strong>除非被手动停止</strong>（<code>docker stop</code>）。
​<strong>关键区别</strong>​：若容器手动停止，即使 Docker 守护进程重启，该容器也保持停止状态<a class=link href=@ref>3,4,6</a>。</li><li><strong>场景</strong>：<strong>生产环境首选</strong>，兼顾高可用（异常崩溃时恢复）与运维可控性（如维护时手动停止）<a class=link href=@ref>3,6</a>。</li></ul></li></ol><hr><h3 id=-关键注意事项>⚠️ <strong>关键注意事项</strong></h3><ol><li><p><strong>避免无限重启循环</strong></p><ul><li><p>若容器因配置错误持续崩溃（如应用启动即失败），<code>always</code> 或 <code>on-failure</code> 可能导致频繁重启，消耗资源。</p></li><li><p>解决方案：</p><ul><li>为 <code>on-failure</code> 设置最大重试次数（如 <code>on-failure:5</code>）<a class=link href=@ref>1,6</a>。</li></ul></li><li><p>通过日志诊断问题：<code>docker logs &lt;容器名></code><a class=link href=@ref>1</a>。</p></li></ul></li><li><p><strong>依赖服务启动顺序</strong></p><ul><li><p>容器重启时若依赖服务（如数据库）未就绪，可能导致启动失败。</p></li><li><p>解决方案：</p><ul><li>在启动脚本中添加重试逻辑（如 <code>wait-for-it.sh</code>）。</li></ul></li><li><p>使用 Docker Compose 的 <code>depends_on</code> 控制启动顺序<a class=link href=@ref>1</a>。</p></li></ul></li><li><p><strong>数据持久化</strong></p><ul><li><p>容器重启时，临时文件系统会被重置，关键数据需通过卷（Volume）或绑定挂载（Bind Mount）持久化：</p><pre tabindex=0><code> docker run -d --restart always -v /host/data:/container/data my-app
</code></pre></li></ul></li><li><p><strong>策略生效条件</strong></p><ul><li><p><strong>仅后台容器</strong>：<code>--restart</code> 仅适用于 <code>-d</code> 模式（后台运行），不可与 <code>--rm</code>（退出后删除）共用<a class=link href=@ref>5,6</a>。</p></li><li><p>Docker 服务自启：需确保 Docker 守护进程随系统启动：</p><pre tabindex=0><code>systemctl enable docker  # 启用开机自启[1](@ref)
</code></pre></li></ul></li></ol><hr><h3 id=-配置方法>⚙️ <strong>配置方法</strong></h3><h4 id=命令行配置><strong>命令行配置</strong></h4><ul><li><p>创建容器时指定：</p><pre tabindex=0><code></code></pre></li></ul><p>docker run -d &ndash;name nginx &ndash;restart unless-stopped nginx</p><pre tabindex=0><code>
- 修改已有容器：
</code></pre><p>docker update &ndash;restart unless-stopped nginx # 更新策略<a class=link href=@ref>2,6</a></p><pre tabindex=0><code>
#### **Docker Compose 配置**
</code></pre><p>version: &lsquo;3.8&rsquo;
services:
web:
image: nginx
restart: unless-stopped # 策略类型
ports:
- &ldquo;80:80&rdquo;
db:
image: mysql
restart: on-failure:5 # 限制最大重启次数
environment:
MYSQL_ROOT_PASSWORD: password
volumes:
- db_data:/var/lib/mysql
volumes:
db_data:</p><pre tabindex=0><code>
#### **手动修改容器配置**

编辑容器配置文件（需停止容器）：
</code></pre><p>vim /var/lib/docker/containers/&lt;容器ID>/hostconfig.json</p><pre tabindex=0><code>
修改 `RestartPolicy` 字段：
</code></pre><p>{&ldquo;Name&rdquo;: &ldquo;unless-stopped&rdquo;, &ldquo;MaximumRetryCount&rdquo;: 0} # 原值为 &ldquo;no&rdquo;<a class=link href=@ref>6</a></p><pre tabindex=0><code>
------

### 📊 **策略对比与选型建议**

| **策略**         | **自动重启触发条件**      | **手动停止后是否随 Docker 重启** | **适用场景**                     |
| ---------------- | ------------------------- | -------------------------------- | -------------------------------- |
| `no`             | 永不重启                  | 否                               | 临时任务、测试环境               |
| `always`         | **任何退出**              | **是**                           | 极少使用（可能引发循环重启）     |
| `on-failure[:N]` | **异常退出**（非0状态码） | 否                               | 批处理任务、可故障恢复的服务     |
| `unless-stopped` | **任何退出**              | **否**                           | **生产环境长期服务（推荐首选）** |

&gt; 💡 **状态码参考**：
&gt;
&gt; - `0`：正常退出（如 `docker stop`）。
&gt; - `非0`：异常退出（如应用崩溃）。
&gt; - `125+`：Docker 自身错误（如命令无法执行）[2,6](@ref)。

------

### 🔍 **调试与监控**

- 查看重启策略：
</code></pre><p>docker inspect nginx &ndash;format &lsquo;{{.HostConfig.RestartPolicy.Name}}&rsquo;</p><pre tabindex=0><code>
- 检查重启次数：
</code></pre><p>docker inspect nginx &ndash;format &lsquo;{{.RestartCount}}&rsquo; # 显示已重启次数<a class=link href=@ref>6</a></p><pre tabindex=0><code>
- 分析退出原因：
</code></pre><h2 id=docker-logs-nginx---定位错误日志>docker ps -a # 查看 Exited 状态码<a class=link href=@ref>2,6</a>
docker logs nginx # 定位错误日志</h2><h3 id=-总结-2>💎 <strong>总结</strong></h3><p>Docker 重启策略是保障服务韧性的关键工具：</p><ul><li><strong>生产首选 <code>unless-stopped</code></strong>：异常崩溃时自愈，同时尊重手动维护操作<a class=link href=@ref>3,6</a>。</li><li><strong>任务型服务用 <code>on-failure</code></strong>：限制重试次数，避免资源耗尽<a class=link href=@ref>1,5</a>。</li><li><strong>务必结合数据卷</strong>：确保重启后数据不丢失<a class=link href=@ref>1</a>。</li><li><strong>监控重启次数</strong>：频繁重启往往是应用故障的信号，需及时排查<a class=link href=@ref>6</a>。</li></ul><p>通过合理配置策略，可显著提升容器化服务的可用性，减少运维干预成本。</p><h2 id=多阶段构建>多阶段构建</h2><p>Docker 多阶段构建（Multi-stage Build）是 Docker 17.05 版本引入的核心特性，用于<strong>优化镜像体积、提升安全性和简化构建流程</strong>。它允许在单个 Dockerfile 中定义多个构建阶段（Stage），每个阶段使用独立的基础镜像，最终仅将必要的产物复制到最终镜像中。以下是其核心原理、优势及实践指南：</p><hr><h3 id=-核心原理>⚙️ <strong>核心原理</strong></h3><ol><li><p><strong>阶段分离</strong></p><ul><li>在单个 Dockerfile 中使用多个 <code>FROM</code> 指令，每个 <code>FROM</code> 开启一个新阶段，各阶段相互隔离。</li><li><strong>构建阶段（Builder Stage）</strong>：使用完整 SDK 镜像（如 <code>golang</code>、<code>maven</code>），安装编译工具并生成二进制文件。</li><li><strong>运行阶段（Runtime Stage）</strong>：使用轻量级基础镜像（如 <code>alpine</code>、<code>slim</code>），仅复制构建阶段的产物（如二进制文件、静态资源）<a class=link href=@ref>1,3,5</a>。</li></ul></li><li><p><strong>产物复制机制</strong></p><ul><li><p>通过 <code>COPY --from=&lt;stage-name></code> 将前一阶段的文件复制到当前阶段，其他中间文件（如编译器、源码）被丢弃。</p></li><li><p>示例：</p><p>FROM golang:1.20 AS builder # 构建阶段
WORKDIR /app
COPY . .
RUN go build -o myapp # 生成二进制文件
FROM alpine:3.18 # 运行阶段
COPY &ndash;from=builder /app/myapp . # 仅复制二进制文件
CMD ["./myapp"]</p><pre tabindex=0><code></code></pre></li></ul></li></ol><hr><h3 id=-核心优势>🚀 <strong>核心优势</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>维度</strong></th><th><strong>多阶段构建</strong></th><th><strong>传统单阶段构建</strong></th></tr></thead><tbody><tr><td><strong>镜像体积</strong></td><td>✅ <strong>减少 60%-90%</strong>（仅保留运行时文件）</td><td>❌ 包含构建工具、源码、临时文件，体积大</td></tr><tr><td><strong>安全性</strong></td><td>✅ 无编译工具和源码，攻击面小</td><td>❌ 构建工具可能含漏洞，源码易泄露</td></tr><tr><td><strong>构建效率</strong></td><td>⚡️ 利用缓存优化，仅重建变更阶段</td><td>⚠️ 全量重建，缓存利用率低</td></tr><tr><td><strong>维护成本</strong></td><td>📝 单 Dockerfile 管理，无需额外脚本</td><td>❌ 需维护构建脚本和多个 Dockerfile</td></tr></tbody></table></div><blockquote><p>💡 <strong>案例</strong>：</p><ul><li>Node.js React 应用：单阶段镜像 420MB → 多阶段镜像 43.2MB（缩小 90%）<a class=link href=@ref>8</a>。</li><li>Nginx 应用：从 172MB 优化至 24.1MB<a class=link href=@ref>1</a>。</li></ul></blockquote><hr><h3 id=-典型应用场景>🛠️ <strong>典型应用场景</strong></h3><h4 id=编译型语言gojava><strong>编译型语言（Go、Java）</strong></h4><pre tabindex=0><code># Go 应用
FROM golang:1.20 AS builder
WORKDIR /app
COPY . .
RUN go build -o app .   # 编译
FROM alpine:latest
COPY --from=builder /app/app .
CMD [&#34;./app&#34;]
</code></pre><h4 id=前端应用reactvue><strong>前端应用（React、Vue）</strong></h4><pre tabindex=0><code># React + Nginx
FROM node:18 AS build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build      # 生成静态文件
FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html  # 仅复制构建结果
</code></pre><h4 id=java-spring-boot><strong>Java Spring Boot</strong></h4><pre tabindex=0><code>FROM maven:3.8-openjdk-17 AS builder
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package        # 生成 JAR 包
FROM openjdk:17-alpine
COPY --from=builder /app/target/app.jar .
CMD [&#34;java&#34;, &#34;-jar&#34;, &#34;app.jar&#34;]
</code></pre><hr><h3 id=-高级技巧>🔧 <strong>高级技巧</strong></h3><ol><li><p><strong>阶段命名与引用</strong></p><ul><li>使用 <code>AS</code> 命名阶段（如 <code>FROM node:18 AS build</code>），提升可读性并避免依赖整数索引<a class=link href=@ref>3,6</a>。</li><li>示例：<code>COPY --from=build /app/dist ./dist</code></li></ul></li><li><p><strong>部分构建与调试</strong></p><ul><li>通过</li></ul></li></ol><pre tabindex=0><code>     --target
</code></pre><p>仅构建特定阶段，用于调试或测试：</p><pre><code> ```
 docker build --target builder -t app:debug .
 ```
</code></pre><ol start=3><li><p><strong>复用外部镜像文件</strong></p><ul><li><p>直接从其他镜像复制文件（如 Nginx 配置）：</p><pre tabindex=0><code>COPY --from=nginx:latest /etc/nginx/nginx.conf /app/nginx.conf
</code></pre></li></ul></li><li><p><strong>依赖缓存优化</strong></p><ul><li>优先复制依赖声明文件（如</li></ul></li></ol><pre tabindex=0><code>     package.json
</code></pre><pre><code> 、

 ```
 pom.xml
 ```

 ），再复制源码，最大化利用构建缓存：

 ```
 COPY package*.json ./   # 先复制依赖文件
 RUN npm install
 COPY . .                # 后复制源码
 ```
</code></pre><hr><h3 id=-最佳实践>⚠️ <strong>最佳实践</strong></h3><ol><li><p><strong>基础镜像选择</strong></p><ul><li>构建阶段：使用完整 SDK 镜像（如 <code>golang</code>、<code>maven</code>）。</li><li>运行阶段：使用最小化镜像（如 <code>alpine</code>、<code>distroless</code>）<a class=link href=@ref>4,7</a>。</li></ul></li><li><p><strong>清理无用文件</strong></p><ul><li><p>在构建阶段结束时删除缓存和临时文件：</p><pre tabindex=0><code>RUN npm install &amp;&amp; npm run build &amp;&amp; rm -rf /tmp/*
</code></pre></li></ul></li><li><p><strong>多阶段复用</strong></p><ul><li><p>多个运行阶段可复用同一构建阶段，避免重复编译：</p><pre tabindex=0><code>FROM builder AS prod
COPY --from=builder /app/bin .
FROM builder AS test
COPY --from=builder /app/bin .
RUN ./test-suite
</code></pre></li></ul></li><li><p><strong>安全加固</strong></p><ul><li><p>运行阶段使用非 root 用户：</p><pre tabindex=0><code>RUN adduser -D appuser &amp;&amp; chown -R appuser /app
USER appuser
</code></pre></li></ul></li></ol><hr><h3 id=-总结-3>💎 <strong>总结</strong></h3><p>Docker 多阶段构建通过<strong>分离构建与运行环境</strong>，解决了传统单阶段构建的三大痛点：<strong>镜像臃肿、安全风险、流程复杂</strong>。其核心价值在于：
✅ ​<strong>极简镜像</strong>​：仅包含运行时必要文件，提升部署效率。
✅ ​<strong>生产安全</strong>​：剔除编译工具和源码，降低攻击面。
✅ ​<strong>开发友好</strong>​：单 Dockerfile 管理全流程，无需外部脚本<a class=link href=@ref>3,5,8</a>。</p><blockquote><p>可通过 <code>docker build --target</code> 分步调试，结合轻量级基础镜像（如 Alpine）进一步优化。<strong>企业级应用</strong>（微服务、云原生场景）强烈推荐采用此方案。</p></blockquote><h2 id=容器隔离>容器隔离</h2><p>Docker 容器的隔离性是其核心价值之一，依赖于 <strong>Linux 内核的多项技术</strong>实现资源与环境的隔离，确保容器间互不干扰。以下是其隔离机制的详细解析：</p><hr><h3 id=-隔离机制分类与实现技术>⚙️ <strong>隔离机制分类与实现技术</strong></h3><h4 id=命名空间namespaces-资源视图隔离-2348><strong>命名空间（Namespaces）—— 资源视图隔离</strong> <a class=link href=@ref>2,3,4,8</a></h4><p>命名空间为容器提供独立的系统资源视图，包括：</p><ul><li><strong>PID 命名空间</strong>：隔离进程 ID，容器内进程从 PID 1 开始编号，无法看到宿主机或其他容器的进程。</li><li><strong>Network 命名空间</strong>：每个容器拥有独立的网络栈（IP、端口、路由表、防火墙规则）。</li><li><strong>Mount 命名空间</strong>：隔离文件系统挂载点，容器内文件操作不影响宿主机（如 <code>/app/data</code> 仅对当前容器可见）。</li><li><strong>UTS 命名空间</strong>：隔离主机名与域名（如容器可自定义 <code>hostname</code>）。</li><li><strong>IPC 命名空间</strong>：隔离进程间通信（信号量、消息队列）。</li><li><strong>User 命名空间</strong>：映射容器内 root 用户到宿主机非特权用户，提升安全性。</li></ul><h4 id=控制组cgroups-资源限制-348><strong>控制组（Cgroups）—— 资源限制</strong> <a class=link href=@ref>3,4,8</a></h4><p>Cgroups 限制容器对物理资源的占用：</p><ul><li><strong>CPU</strong>：通过 <code>--cpus</code> 限制核心数或时间片份额（如 <code>docker run --cpus=0.5</code> 限制 50% CPU）。</li><li><strong>内存</strong>：通过 <code>-m</code> 设置内存上限（如 <code>-m 512m</code>）。</li><li><strong>磁盘 I/O</strong>：限制读写带宽（如 <code>--device-write-bps</code>）。</li><li><strong>设备访问</strong>：控制容器对 <code>/dev</code> 目录下设备的访问权限。</li></ul><h4 id=联合文件系统unionfs-文件隔离-378><strong>联合文件系统（UnionFS）—— 文件隔离</strong> <a class=link href=@ref>3,7,8</a></h4><ul><li><strong>分层存储</strong>：镜像由多个只读层叠加，容器运行时添加可写层（OverlayFS/AUFS）。</li><li><strong>写时复制（CoW）</strong>：修改文件时复制到可写层，避免污染基础镜像。</li><li><strong>独立视图</strong>：每个容器仅看到自己的文件系统，无法直接访问其他容器或宿主机的文件。</li></ul><h4 id=安全机制权限隔离-38><strong>安全机制——权限隔离</strong> <a class=link href=@ref>3,8</a></h4><ul><li><strong>Capabilities</strong>：限制容器内 root 用户的权限（如禁止加载内核模块）。</li><li><strong>Seccomp</strong>：过滤危险系统调用（如禁止 <code>mount()</code> 或 <code>reboot()</code>）。</li><li><strong>AppArmor/SELinux</strong>：强制访问控制（MAC），限制进程行为（如禁止写入敏感目录）。</li></ul><h4 id=网络隔离虚拟网络栈-68><strong>网络隔离——虚拟网络栈</strong> <a class=link href=@ref>6,8</a></h4><ul><li><p><strong>veth pair + 网桥</strong>：容器通过虚拟网卡（veth）连接到宿主机网桥（如 <code>docker0</code>），实现独立 IP 和端口分配。</p></li><li><p>网络模式：</p><ul><li><code>bridge</code>（默认）：容器通过 NAT 与外部通信。</li><li><code>host</code>：共享宿主机网络栈（牺牲隔离性换取性能）。</li><li><code>none</code>：无网络接口，适用于无需网络的批处理任务。</li></ul></li></ul><hr><h3 id=-与传统虚拟机的对比-89>⚖️ <strong>与传统虚拟机的对比</strong> <a class=link href=@ref>8,9</a></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>Docker 容器</strong></th><th><strong>传统虚拟机</strong></th></tr></thead><tbody><tr><td><strong>隔离级别</strong></td><td>进程级（轻量）</td><td>硬件级（重量）</td></tr><tr><td><strong>性能开销</strong></td><td>低（直接调用宿主机内核）</td><td>高（需 Hypervisor 虚拟化层）</td></tr><tr><td><strong>启动速度</strong></td><td>秒级</td><td>分钟级</td></tr><tr><td><strong>镜像大小</strong></td><td>MB 级（共享内核）</td><td>GB 级（含完整 OS）</td></tr><tr><td><strong>安全性</strong></td><td>依赖内核隔离（需加固）</td><td>硬件级隔离（更强）</td></tr></tbody></table></div><blockquote><p>💡 <strong>适用场景</strong>：</p><ul><li><strong>容器</strong>：微服务、CI/CD、开发测试环境（轻量快速）。</li><li><strong>虚拟机</strong>：多租户隔离、强安全需求（如金融系统）。</li></ul></blockquote><hr><h3 id=-安全性与局限性>🛡️ <strong>安全性与局限性</strong></h3><h4 id=安全加固实践-78><strong>安全加固实践</strong> <a class=link href=@ref>7,8</a></h4><ul><li><strong>非 root 用户运行</strong>：<code>docker run -u 1000:1000</code> 避免特权提升。</li><li><strong>只读文件系统</strong>：<code>--read-only</code> 禁止容器写入（日志可挂载卷）。</li><li><strong>资源限制</strong>：严格配置 Cgroups 防止资源耗尽（如内存溢出导致 OOM Kill）。</li></ul><h4 id=固有局限性-38><strong>固有局限性</strong> <a class=link href=@ref>3,8</a></h4><ul><li><strong>内核共享</strong>：所有容器共享宿主机内核，内核漏洞可能影响所有容器。</li><li><strong>逃逸风险</strong>：配置不当可能导致容器突破隔离（如未启用 User Namespace）。</li><li><strong>多租户场景</strong>：生产环境需结合 Kubernetes Namespace 或 Kata Containers（基于虚拟化的容器运行时）。</li></ul><hr><h3 id=-隔离效果验证示例>🔍 <strong>隔离效果验证示例</strong></h3><pre tabindex=0><code># 查看容器进程隔离
docker run -it alpine sh
ps aux  # 仅显示容器内进程（PID 1 为容器初始化进程）
# 检查资源限制
docker run -m 100m --cpus=0.5 stress-ng --vm 1 --vm-bytes 150M
# 容器因内存超限被强制终止（OOM Killer）

# 网络隔离测试
docker run -d --name web nginx
docker exec web ip addr  # 显示容器内独立网卡（eth0）
</code></pre><hr><h3 id=-总结-4>💎 <strong>总结</strong></h3><p>Docker 通过 <strong>Namespaces（视图隔离）、Cgroups（资源限制）、UnionFS（文件隔离）及安全模块</strong>的组合，实现了轻量级但高效的容器隔离。其优势在于<strong>低开销、快速启动和易移植性</strong>，适用于云原生和微服务架构<a class=link href=@ref>4,7,9</a>。然而，在<strong>强安全隔离</strong>场景下，需结合虚拟化技术（如 gVisor）或硬件辅助方案（如 Intel VT-x）弥补内核共享的固有缺陷<a class=link href=@ref>8</a>。</p><h2 id=cgroup>CGroup</h2><p>CGroup（Control Groups）是 Linux 内核提供的资源管理机制，用于限制、隔离和监控进程组（process groups）的系统资源（如 CPU、内存、磁盘 I/O、网络等）。它是容器技术（如 Docker、Kubernetes）实现资源隔离的核心基础之一。以下是其核心原理和功能的详细解析：</p><hr><h3 id=-cgroup-的核心概念>⚙️ <strong>CGroup 的核心概念</strong></h3><ol><li><strong>任务（Task）</strong>
即系统中的进程（Process），是资源控制的基本单位<a class=link href=@ref>1,4</a>。</li><li><strong>控制组（Control Group）</strong>
一组进程的集合，资源限制以控制组为单位生效。进程可动态加入或迁移到不同控制组<a class=link href=@ref>1,6</a>。</li><li><strong>层级（Hierarchy）</strong>
控制组以树形结构组织，子组继承父组的资源属性。每个层级可附加多个子系统（Subsystem）<a class=link href=@ref>4,8</a>。</li><li><strong>子系统（Subsystem）</strong>
资源控制器，每个子系统负责一类资源的限制或监控。常见子系统包括：<ul><li><strong>CPU</strong>：限制 CPU 使用时间<a class=link href=@ref>3,6</a>。</li><li><strong>Memory</strong>：限制内存用量并统计使用情况<a class=link href=@ref>1,4</a>。</li><li><strong>Blkio</strong>：限制块设备 I/O 带宽（如磁盘读写）<a class=link href=@ref>3,8</a>。</li><li><strong>Cpuset</strong>：绑定进程到指定 CPU 核或内存节点<a class=link href=@ref>4,6</a>。</li><li><strong>Devices</strong>：控制设备访问权限（如禁止读写特定设备）<a class=link href=@ref>8</a>。</li></ul></li></ol><hr><h3 id=-cgroup-的核心功能>🛠️ <strong>CGroup 的核心功能</strong></h3><ol><li><p><strong>资源限制（Limiting）</strong></p><ul><li>CPU：通过</li></ul></li></ol><pre tabindex=0><code>     cpu.cfs_quota_us
</code></pre><pre><code> （周期内可用时间）和
</code></pre><pre tabindex=0><code>     cpu.cfs_period_us
</code></pre><pre><code> （周期长度）限制 CPU 时间片

 3,6

 。

 示例

 ：设置进程组最多使用 50% CPU：

 ```
 echo 50000 &gt; /sys/fs/cgroup/cpu/group1/cpu.cfs_quota_us  # 50ms/100ms
 echo 100000 &gt; /sys/fs/cgroup/cpu/group1/cpu.cfs_period_us
 ```
</code></pre><ul><li></li></ul><pre><code> 内存

 ：通过
</code></pre><pre tabindex=0><code>     memory.limit_in_bytes
</code></pre><p>设置内存上限，超限触发 OOM（Out-of-Memory）终止进程</p><pre><code> 4,7

 。

 示例

 ：限制内存为 100MB：

 ```
 echo 100M &gt; /sys/fs/cgroup/memory/group1/memory.limit_in_bytes
 ```
</code></pre><ul><li></li></ul><pre><code> I/O

 ：通过
</code></pre><pre tabindex=0><code>     blkio.throttle.read_bps_device
</code></pre><p>限制磁盘读写速率</p><pre><code> 1,8

 。

 示例

 ：限制磁盘读速率为 1MB/s：

 ```
 echo &quot;8:0 1048576&quot; &gt; /sys/fs/cgroup/blkio/group1/blkio.throttle.read_bps_device
 ```
</code></pre><ol start=2><li><p><strong>优先级控制（Prioritization）</strong></p><ul><li><strong>CPU 权重</strong>：通过 <code>cpu.shares</code> 分配相对权重（如 1000 vs 500 表示 2:1 的 CPU 竞争比例）<a class=link href=@ref>3,6</a>。</li><li><strong>I/O 权重</strong>：通过 <code>blkio.weight</code> 设置块设备 I/O 优先级<a class=link href=@ref>8</a>。</li></ul></li><li><p><strong>资源审计（Accounting）</strong>
子系统自动统计资源使用量：</p><ul><li><strong>CPUacct</strong>：记录 CPU 时间（<code>cpuacct.usage</code>）<a class=link href=@ref>3,6</a>。</li><li><strong>Memory</strong>：统计内存用量（<code>memory.usage_in_bytes</code>）<a class=link href=@ref>4</a>。</li></ul></li><li><p><strong>进程控制（Control）</strong></p><ul><li><strong>Freezer</strong>：暂停（<code>FROZEN</code>）或恢复（<code>THAWED</code>）进程组<a class=link href=@ref>8</a>。</li></ul></li></ol><hr><h3 id=-cgroup-与容器技术的结合>🌐 <strong>CGroup 与容器技术的结合</strong></h3><p>在 Docker/Kubernetes 中，CGroup 为每个容器创建独立的控制组，实现：</p><ol><li><strong>资源隔离</strong>：限制容器 CPU、内存等资源，避免互相争抢<a class=link href=@ref>7,8</a>。</li><li><strong>安全隔离</strong>：通过 <code>devices</code> 子系统禁止容器访问宿主机设备<a class=link href=@ref>8</a>。</li><li><strong>动态调整</strong>：运行时修改资源参数（如 <code>docker update --cpus=2</code> 实时调整 CPU 配额）<a class=link href=@ref>7</a>。</li></ol><hr><h3 id=-配置与实践>⚠️ <strong>配置与实践</strong></h3><h4 id=通过文件系统操作><strong>通过文件系统操作</strong></h4><ul><li><p>挂载子系统：</p><pre tabindex=0><code></code></pre></li></ul><p>mount -t cgroup -o cpu,memory cgroup /sys/fs/cgroup</p><pre tabindex=0><code>
- 创建控制组：
</code></pre><p>mkdir /sys/fs/cgroup/cpu/group1
echo 50000 > /sys/fs/cgroup/cpu/group1/cpu.cfs_quota_us</p><pre tabindex=0><code>
- 添加进程：
</code></pre><p>echo $$ > /sys/fs/cgroup/cpu/group1/tasks # 将当前进程加入 group1</p><pre tabindex=0><code>
#### **通过配置文件（/etc/cgconfig.conf）**
</code></pre><p>group mysql_group {
cpu {
cpu.cfs_quota_us = 50000; # 限制 50% CPU
}
memory {
memory.limit_in_bytes = 100M; # 限制 100MB 内存
}
}</p><pre tabindex=0><code>
重启服务生效：`service cgconfig restart`[3,4](@ref)。



------

### 💡 **常见问题与解决**

1. **Cgroup 挂载失败**
   检查内核支持：`grep CGROUP /boot/config-$(uname -r)`[1](@ref)。

2. **资源超限导致 OOM**
   调整 `memory.oom_control` 禁用 OOM Killer，或增加内存上限[4](@ref)。

3. **多核 CPU 绑定使用**
</code></pre><p>cpuset</p><pre tabindex=0><code>
子系统绑定进程到指定核心：
</code></pre><p>echo &ldquo;0-1&rdquo; > /sys/fs/cgroup/cpuset/group1/cpuset.cpus # 绑定到 CPU0-1</p><pre tabindex=0><code>


------

### 💎 **总结**

CGroup 是 Linux 资源管理的基石，通过**层级化的控制组**和**多样化的子系统**实现了对进程组资源的精细控制。其与 Namespace（环境隔离）的结合，构成了现代容器技术的核心架构[7,8](@ref)。在生产环境中，合理配置 CGroup 可显著提升系统稳定性和资源利用率，避免单点故障引发的资源雪崩。

&gt; 更多实践案例可参考：[CGroup 官方文档](https://www.kernel.org/doc/Documentation/cgroup-v1/)及 Docker 资源限制配置。

## -it

`docker exec -it` 中的 **`-it`** 是 Docker 命令中两个常用选项的组合：**`-i`**（`--interactive`）和 **`-t`**（`--tty`）。它们共同作用，使得用户能够以**交互式终端**的方式进入容器内部执行命令。以下是详细解析：



------

### 🔧 **`-i` 和 `-t` 的作用**

| **选项** | **含义**                                                     | **使用场景**                                                 |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **`-i`** | 保持标准输入（`STDIN`）打开，允许用户向容器内发送输入（如键盘输入）[1,3,5](@ref)。 | 需要与容器交互（如输入命令、编辑文件）时必选。               |
| **`-t`** | 分配一个伪终端（`pseudo-TTY`），模拟真实的终端环境（支持命令行格式、光标控制等）[1,6,8](@ref)。 | 需获得类似本地终端的操作体验（如彩色输出、命令补全）时必选。 |

&gt; 💡 **组合效果**：`-it` 使容器启动一个**可交互的终端会话**（如 Bash），用户可以直接在容器内执行命令并查看格式化输出。



------

### ⚙️ **为何需要 `-it`？**

1. **避免命令阻塞**
无 `-i` 时，容器可能因等待输入而阻塞（如 `docker exec` 执行 `bash` 后无法输入命令）[3](@ref)。
2. **解决终端格式混乱**
无 `-t` 时，终端无法正确解析换行、颜色等控制字符，输出可能错乱（如 `ls` 命令结果挤在一行）[6,8](@ref)。
3. **支持交互式工具**
需在容器内使用 `vi`、`top` 等交互式工具时，必须启用 `-it`[3,7](@ref)。



------

### 🛠️ **典型使用场景**

#### **进入容器的 Bash 终端**
</code></pre><p>docker exec -it nginx /bin/bash # 进入名为 nginx 容器的 Bash 终端<a class=link href=@ref>1,6</a></p><pre tabindex=0><code>
- 若容器无 Bash（如 Alpine 镜像），改用
</code></pre><p>/bin/sh</p><pre tabindex=0><code>
  ：
</code></pre><p>docker exec -it alpine_container /bin/sh <a class=link href=@ref>7,8</a></p><pre tabindex=0><code>
#### **在容器内执行交互命令**
</code></pre><p>docker exec -it mysql mysql -u root -p # 进入 MySQL 交互命令行<a class=link href=@ref>3,8</a></p><pre tabindex=0><code>
&gt; 输入密码后可直接执行 SQL 语句。

#### **调试容器（查看日志、进程）**
</code></pre><p>docker exec -it web_server tail -f /var/log/nginx/access.log # 实时查看日志<a class=link href=@ref>3</a>
docker exec -it web_server ps aux # 查看容器内进程<a class=link href=@ref>3</a></p><pre tabindex=0><code>


------

### ⚠️ **注意事项**

1. **容器必须处于运行状态**
   `docker exec` 仅对运行中的容器生效（需先通过 `docker start` 启动停止的容器）[3,8](@ref)。

2. 

   与 `docker attach` 的区别

- `docker attach`：直接附加到容器主进程，**退出可能导致容器停止**[7,8](@ref)。
   - `docker exec -it`：启动新进程（如 Bash），**退出不影响主进程**（更安全）[3,7](@ref)。

3. 

   权限问题

若提示权限不足，可添加
</code></pre><p>-u root</p><pre tabindex=0><code>
以 root 用户执行：
</code></pre><p>docker exec -it -u root my_container /bin/bash <a class=link href=@ref>2,3</a></p><pre tabindex=0><code>


------

### 💎 **总结**

- **`-it` = `-i` + `-t`**：缺一不可，共同实现**交互式终端操作**。
- **核心价值**：让用户像操作本地终端一样**安全调试容器**（查看、修改、运维）。
- **替代方案**：非交互命令（如 `docker exec nginx ls /app`）无需 `-it`[6](@ref)。

&gt; 可通过 `docker exec --help` 查看完整选项说明[3](@ref)。掌握 `-it` 是高效使用 Docker 的必备技能！

## TTY

TTY（Teletypewriter，电传打字机）是计算机系统中**终端设备的统称**，起源于早期的物理电传打字设备，用于通过串行通信传输文本。在现代操作系统中（尤其是Linux/Unix），TTY已演变为**管理用户与系统交互的抽象接口**，核心功能是处理输入（键盘）和输出（显示）。以下是其核心要点：



------

### 📜 **定义与历史演变**

1. **起源**
- TTY最初指物理电传打字机（Teletype），通过串口与计算机通信，用于远程传输文本[1,6](@ref)。
- 在计算机系统中，TTY成为**终端设备的软件抽象**，负责管理用户命令输入和系统输出（如显示文本或打印内容）[4,6](@ref)。
2. **核心功能**
- **输入处理**：将键盘信号转换为系统可读数据，存储到输入缓冲区。
- **输出处理**：将系统返回的数据发送到显示器或打印机。
- **回显控制**：用户输入时实时显示字符（如密码输入隐藏）[6](@ref)。



------

### ⚙️ **TTY的类型与设备路径**

现代系统主要分为三类TTY设备：

| **类型**          | **设备路径**                 | **应用场景**                           | **特点**                                                    |
| ----------------- | ---------------------------- | -------------------------------------- | ----------------------------------------------------------- |
| **物理TTY**       | `/dev/ttyS0`、`/dev/ttyUSB0` | 串口设备调试（如嵌入式开发板）         | 直接连接物理硬件，需配置波特率等参数 [3,4](@ref)            |
| **虚拟TTY**       | `/dev/tty1`~`/dev/tty6`      | 本地控制台（通过`Ctrl+Alt+F1~F6`切换） | 系统启动时预分配，严格权限控制（如限制root登录）[2,4](@ref) |
| **伪终端（PTS）** | `/dev/pts/0`、`/dev/pts/1`   | SSH远程连接、图形界面终端模拟器        | 动态创建，支持网络传输，用户权限灵活[4,10](@ref)            |

&gt; 💡 **伪终端（PTS）的工作流程**：
&gt;
&gt; 1. 终端模拟器（如SSHD）创建一对设备：**主设备（ptmx）** 和 **从设备（PTS）**。
&gt; 2. 用户输入 → ptmx → PTS → Shell进程 → 处理结果反向输出到终端[4,10](@ref)。



------

### 🔧 **TTY在Linux系统中的关键作用**

1. **多用户支持**
允许多个用户同时通过不同TTY登录系统，每个会话独立隔离（如用户A在`tty1`操作，用户B在`pts/0`通过SSH连接）[1,9](@ref)。
2. **会话管理**
TTY绑定Shell进程（如Bash），用户命令通过Shell解释后由内核执行，结果返回TTY显示[9,10](@ref)。
3. **系统调试与维护**
- 系统故障时可通过虚拟TTY（如`tty1`）直接操作，避免图形界面崩溃的影响[2,7](@ref)。
- 守护进程（如日志服务）通过TTY输出调试信息[6](@ref)。



------

### ⚠️ **常见问题与解决**

1. **TTY权限错误**
- **问题**：普通用户无法访问`/dev/tty1`。
- **解决**：修改`/etc/securetty`文件，添加允许登录的设备名[4](@ref)。
2. **伪终端连接断开**
- **问题**：SSH会话因网络波动中断。
- **解决**：客户端设置`ServerAliveInterval`保活参数，或服务端调整超时时间[1](@ref)。
3. **输入/输出异常**
- **问题**：TTY中键盘输入无响应或显示乱码。
- **解决**：检查终端属性配置（如波特率、数据位），使用`stty`命令重置设置[3,7](@ref)。



------

### 💎 **总结**

TTY是贯穿计算机历史的**交互接口基石**，从物理电传打字机到现代伪终端（PTS），始终承担着**用户与系统间文本通信的桥梁作用**。理解其类型差异（物理/Virtual/PTS）和工作原理（如ptmx-PTS数据流），对系统管理、远程运维和调试至关重要[4,6,10](@ref)。
</code></pre></section><footer class=article-footer><section class=article-tags><a href=/tags/docker/>Docker</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Oct 20, 2025 22:07 CST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/docker-composenotes/><div class=article-details><h2 class=article-title>【Docker Compose】Notes</h2></div></a></article><article><a href=/p/milvusfundamentals/><div class=article-details><h2 class=article-title>【Milvus】Fundamentals</h2></div></a></article><article><a href=/p/mongodbfundamentals/><div class=article-details><h2 class=article-title>【MongoDB】Fundamentals</h2></div></a></article><article><a href=/p/nebulafundamentals/><div class=article-details><h2 class=article-title>【Nebula】Fundamentals</h2></div></a></article><article><a href=/p/distributedlock/><div class=article-details><h2 class=article-title>【Distributed】Lock</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>