<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="基本类型 T 与 T& 在 C++ 中，char 和 char& 的性能差异主要体现在内存访问方式和编译器优化策略上。以下是综合分析：\n内存访问与间接寻址 • char：作为基本数据类型，直接存储值本身（1 字节）。对 char 的操作是直接访问内存中的字符值，无需额外寻址步骤。 • char&：作为引用类型，本质是变量的别名（底层通常通过指针实现）。每次访问 char& 需要一次间接寻址（解引用指针），理论上多一步内存访问操作。 • 性能影响：在频繁访问的场景下（如循环中），char 的直接访问可能比 char& 的间接寻址更快，但现代编译器通常会优化掉这种差异。\n函数参数传递 • 传值（char）：会复制字符值到函数栈，适合小数据量的场景。对于单个 char，复制的开销可以忽略不计。 • 传引用（char&）：传递的是变量的地址，避免了复制，适合需要修改原变量或传递大型对象的场景。但单个 char 的引用传递可能反而因间接寻址导致性能损失。 • 总结：对于单个 char，传值通常更高效；若需修改原值或传递复杂对象，引用更合适。\n编译器优化 • 内联优化：编译器可能将 char& 的间接寻址优化为直接操作原变量，消除性能差异。 • 寄存器分配：char 可能更容易被分配到寄存器中（尤其是临时变量），而引用可能因别名分析（Alias Analysis）的限制导致优化难度增加。\n内存占用 • char：占用 1 字节内存。 • char&：引用的内存占用与指针相同（如 4 字节或 8 字节，取决于系统），但编译器可能优化掉引用的实际存储。 • 应用场景：在需要节省内存的结构体或数组中，优先使用 char；引用更适合作为函数参数或返回值。\n实例对比 • 示例 1（循环操作）： ```cpp // 直接操作 char for (char c : str) { /* 操作 c */ } // 每次迭代复制字符值\n"><title>【LeetCode-C】Performance</title><link rel=canonical href=https://dyhes.github.io/p/leetcode-cperformance/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【LeetCode-C】Performance"><meta property='og:description' content="基本类型 T 与 T& 在 C++ 中，char 和 char& 的性能差异主要体现在内存访问方式和编译器优化策略上。以下是综合分析：\n内存访问与间接寻址 • char：作为基本数据类型，直接存储值本身（1 字节）。对 char 的操作是直接访问内存中的字符值，无需额外寻址步骤。 • char&：作为引用类型，本质是变量的别名（底层通常通过指针实现）。每次访问 char& 需要一次间接寻址（解引用指针），理论上多一步内存访问操作。 • 性能影响：在频繁访问的场景下（如循环中），char 的直接访问可能比 char& 的间接寻址更快，但现代编译器通常会优化掉这种差异。\n函数参数传递 • 传值（char）：会复制字符值到函数栈，适合小数据量的场景。对于单个 char，复制的开销可以忽略不计。 • 传引用（char&）：传递的是变量的地址，避免了复制，适合需要修改原变量或传递大型对象的场景。但单个 char 的引用传递可能反而因间接寻址导致性能损失。 • 总结：对于单个 char，传值通常更高效；若需修改原值或传递复杂对象，引用更合适。\n编译器优化 • 内联优化：编译器可能将 char& 的间接寻址优化为直接操作原变量，消除性能差异。 • 寄存器分配：char 可能更容易被分配到寄存器中（尤其是临时变量），而引用可能因别名分析（Alias Analysis）的限制导致优化难度增加。\n内存占用 • char：占用 1 字节内存。 • char&：引用的内存占用与指针相同（如 4 字节或 8 字节，取决于系统），但编译器可能优化掉引用的实际存储。 • 应用场景：在需要节省内存的结构体或数组中，优先使用 char；引用更适合作为函数参数或返回值。\n实例对比 • 示例 1（循环操作）： ```cpp // 直接操作 char for (char c : str) { /* 操作 c */ } // 每次迭代复制字符值\n"><meta property='og:url' content='https://dyhes.github.io/p/leetcode-cperformance/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='LeetCode-C'><meta property='article:published_time' content='2025-03-12T00:00:00+00:00'><meta property='article:modified_time' content='2025-10-22T16:27:30+08:00'><meta name=twitter:title content="【LeetCode-C】Performance"><meta name=twitter:description content="基本类型 T 与 T& 在 C++ 中，char 和 char& 的性能差异主要体现在内存访问方式和编译器优化策略上。以下是综合分析：\n内存访问与间接寻址 • char：作为基本数据类型，直接存储值本身（1 字节）。对 char 的操作是直接访问内存中的字符值，无需额外寻址步骤。 • char&：作为引用类型，本质是变量的别名（底层通常通过指针实现）。每次访问 char& 需要一次间接寻址（解引用指针），理论上多一步内存访问操作。 • 性能影响：在频繁访问的场景下（如循环中），char 的直接访问可能比 char& 的间接寻址更快，但现代编译器通常会优化掉这种差异。\n函数参数传递 • 传值（char）：会复制字符值到函数栈，适合小数据量的场景。对于单个 char，复制的开销可以忽略不计。 • 传引用（char&）：传递的是变量的地址，避免了复制，适合需要修改原变量或传递大型对象的场景。但单个 char 的引用传递可能反而因间接寻址导致性能损失。 • 总结：对于单个 char，传值通常更高效；若需修改原值或传递复杂对象，引用更合适。\n编译器优化 • 内联优化：编译器可能将 char& 的间接寻址优化为直接操作原变量，消除性能差异。 • 寄存器分配：char 可能更容易被分配到寄存器中（尤其是临时变量），而引用可能因别名分析（Alias Analysis）的限制导致优化难度增加。\n内存占用 • char：占用 1 字节内存。 • char&：引用的内存占用与指针相同（如 4 字节或 8 字节，取决于系统），但编译器可能优化掉引用的实际存储。 • 应用场景：在需要节省内存的结构体或数组中，优先使用 char；引用更适合作为函数参数或返回值。\n实例对比 • 示例 1（循环操作）： ```cpp // 直接操作 char for (char c : str) { /* 操作 c */ } // 每次迭代复制字符值\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#基本类型-t-与-t>基本类型 <code>T</code> 与 <code>T&</code></a><ol><li><a href=#内存访问与间接寻址><strong>内存访问与间接寻址</strong></a></li><li><a href=#函数参数传递><strong>函数参数传递</strong></a></li><li><a href=#编译器优化><strong>编译器优化</strong></a></li><li><a href=#内存占用><strong>内存占用</strong></a></li><li><a href=#实例对比><strong>实例对比</strong></a></li><li><a href=#总结>总结</a></li><li><a href=#内存访问与间接寻址-1><strong>内存访问与间接寻址</strong></a></li><li><a href=#函数参数传递-1><strong>函数参数传递</strong></a></li><li><a href=#编译器优化-1><strong>编译器优化</strong></a></li><li><a href=#内存与缓存效率><strong>内存与缓存效率</strong></a></li><li><a href=#运算效率差异><strong>运算效率差异</strong></a></li><li><a href=#总结-1>总结</a></li></ol></li><li><a href=#const>const</a><ol><li><a href=#编译器的优化空间>编译器的优化空间</a></li><li><a href=#代码设计优化>代码设计优化</a></li><li><a href=#潜在性能陷阱>潜在性能陷阱</a></li><li><a href=#总结与建议>总结与建议</a></li><li><a href=#性能相同场景避免对象拷贝>性能相同场景：避免对象拷贝</a></li><li><a href=#性能差异场景临时对象处理>性能差异场景：临时对象处理</a></li><li><a href=#编译器优化差异>编译器优化差异</a></li><li><a href=#编码实践对性能的间接影响>编码实践对性能的间接影响</a></li><li><a href=#总结与建议-1>总结与建议</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/pearl/ style=background-color:#a7535a;color:>拾珠玑
</a><a href=/categories/temple/ style=background-color:#69a794;color:>白玉京</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/leetcode-cperformance/>【LeetCode-C】Performance</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 12, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>3 minute read</time></div></footer></div></header><section class=article-content><h2 id=基本类型-t-与-t>基本类型 <code>T</code> 与 <code>T&</code></h2><p>在 C++ 中，<code>char</code> 和 <code>char&</code> 的性能差异主要体现在内存访问方式和编译器优化策略上。以下是综合分析：</p><hr><h3 id=内存访问与间接寻址><strong>内存访问与间接寻址</strong></h3><p>• <strong><code>char</code></strong>：作为基本数据类型，直接存储值本身（1 字节）。对 <code>char</code> 的操作是直接访问内存中的字符值，无需额外寻址步骤。
• <strong><code>char&</code></strong>：作为引用类型，本质是变量的别名（底层通常通过指针实现）。每次访问 <code>char&</code> 需要一次间接寻址（解引用指针），理论上多一步内存访问操作。
• <strong>性能影响</strong>：在频繁访问的场景下（如循环中），<code>char</code> 的直接访问可能比 <code>char&</code> 的间接寻址更快，但现代编译器通常会优化掉这种差异。</p><hr><h3 id=函数参数传递><strong>函数参数传递</strong></h3><p>• <strong>传值（<code>char</code>）</strong>：会复制字符值到函数栈，适合小数据量的场景。对于单个 <code>char</code>，复制的开销可以忽略不计。
• <strong>传引用（<code>char&</code>）</strong>：传递的是变量的地址，避免了复制，适合需要修改原变量或传递大型对象的场景。但单个 <code>char</code> 的引用传递可能反而因间接寻址导致性能损失。
• <strong>总结</strong>：对于单个 <code>char</code>，传值通常更高效；若需修改原值或传递复杂对象，引用更合适。</p><hr><h3 id=编译器优化><strong>编译器优化</strong></h3><p>• <strong>内联优化</strong>：编译器可能将 <code>char&</code> 的间接寻址优化为直接操作原变量，消除性能差异。
• <strong>寄存器分配</strong>：<code>char</code> 可能更容易被分配到寄存器中（尤其是临时变量），而引用可能因别名分析（Alias Analysis）的限制导致优化难度增加。</p><hr><h3 id=内存占用><strong>内存占用</strong></h3><p>• <strong><code>char</code></strong>：占用 1 字节内存。
• <strong><code>char&</code></strong>：引用的内存占用与指针相同（如 4 字节或 8 字节，取决于系统），但编译器可能优化掉引用的实际存储。
• <strong>应用场景</strong>：在需要节省内存的结构体或数组中，优先使用 <code>char</code>；引用更适合作为函数参数或返回值。</p><hr><h3 id=实例对比><strong>实例对比</strong></h3><p>• <strong>示例 1（循环操作）</strong>：
```cpp
// 直接操作 char
for (char c : str) { /* 操作 c */ } // 每次迭代复制字符值</p><pre><code> // 通过引用操作 char
 for (char&amp; c : str) { /* 操作 c */ } // 直接操作原字符，避免复制
 ```
 对于大型字符串，引用版本可能更高效（减少拷贝开销）；对于小型数据，差异可忽略。
</code></pre><p>• <strong>示例 2（函数调用）</strong>：
<code>cpp void modify(char c) { c = 'a'; } // 传值，不影响原变量 void modify_ref(char& c) { c = 'a'; } // 传引用，修改原变量 </code>若仅需读取值，<code>char</code> 传值更优；若需修改，必须用引用。</p><hr><h3 id=总结>总结</h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><code>char</code> 优势</th><th><code>char&</code> 优势</th></tr></thead><tbody><tr><td>小型数据操作</td><td>直接访问，无额外开销</td><td>无优势</td></tr><tr><td>需要修改原变量</td><td>无法满足</td><td>必须使用引用</td></tr><tr><td>函数参数传递（大型数据）</td><td>复制开销大</td><td>避免复制，性能更优</td></tr><tr><td>内存敏感场景</td><td>占用更小内存</td><td>引用可能占用额外指针空间</td></tr></tbody></table></div><p><strong>实际建议</strong>：<br>• 优先使用 <code>char</code>，除非需要修改原变量或传递复杂对象。<br>• 在性能关键代码中，结合编译器优化能力测试具体差异（如通过反汇编或性能分析工具）。<br>• 对于底层二进制操作，可考虑 <code>std::byte</code>（C++17+）以明确语义，但需注意兼容性。</p><p>在 C++ 中，<code>char</code> 和 <code>char&</code> 的性能差异结论（如内存访问、传参开销、编译器优化等）<strong>对 <code>int</code>、<code>float</code>、<code>double</code> 等基本类型同样适用</strong>，但需结合类型特性调整具体分析。以下是综合对比：</p><hr><h3 id=内存访问与间接寻址-1><strong>内存访问与间接寻址</strong></h3><p>• <strong>所有基本类型</strong>（如 <code>int</code>、<code>float</code>、<code>double</code>）：传值（<code>T</code>）直接操作数据本身，而引用（<code>T&</code>）通过间接寻址实现。引用可能引入额外解引用开销，但现代编译器常优化为直接操作原变量。
• <strong>性能差异</strong>：对小类型（如 <code>int</code>、<code>float</code>，4 字节），传值复制的开销可忽略；对大类型（如 <code>double</code>，8 字节），传值可能因复制成本较高而影响性能。</p><hr><h3 id=函数参数传递-1><strong>函数参数传递</strong></h3><p>• <strong>小类型（<code>int</code>、<code>float</code>）</strong>：优先传值，复制的开销较小。例如，<code>float</code> 的传值效率通常高于引用，除非需要修改原变量。
• <strong>大类型（<code>double</code>）</strong>：传引用可避免复制 8 字节数据，但需权衡间接寻址的开销。在频繁访问场景中，引用可能更优。
• <strong>浮点类型特殊性</strong>：<code>float</code> 和 <code>double</code> 的混合精度运算（如 <code>float + double</code>）会引入隐式类型转换开销，需统一类型以提升性能。</p><hr><h3 id=编译器优化-1><strong>编译器优化</strong></h3><p>• <strong>内联与寄存器分配</strong>：编译器可能将引用优化为直接操作（如内联函数），但对浮点类型的优化可能更复杂，尤其在涉及硬件浮点单元（FPU）时。
• <strong>浮点运算性能</strong>：现代 CPU 对 <code>float</code> 和 <code>double</code> 的运算速度接近，但在无硬件浮点支持的设备（如嵌入式系统）中，浮点运算可能比整数慢几个数量级。</p><hr><h3 id=内存与缓存效率><strong>内存与缓存效率</strong></h3><p>• <strong>内存占用</strong>：<code>int</code> 和 <code>float</code> 各占 4 字节，<code>double</code> 占 8 字节。在内存敏感场景（如数组、结构体）中，优先选择小类型（如 <code>float</code> 而非 <code>double</code>）可提升缓存利用率。
• <strong>向量化优化</strong>：窄类型（如 <code>char</code>、<code>short</code>）在 SIMD 指令集中可能更高效，但需结合具体硬件支持。</p><hr><h3 id=运算效率差异><strong>运算效率差异</strong></h3><p>• <strong>整数 vs 浮点</strong>：整数运算（如 <code>int</code> 的加减乘）通常比浮点运算更快，但现代 CPU 的浮点单元已高度优化，差距缩小。
• <strong>除法与取余</strong>：整型的除法/取余运算速度优于浮点，尤其是无符号整型。例如，<code>unsigned int</code> 的除法比 <code>signed int</code> 更快。
• <strong>常量优化</strong>：除法运算中，若除数是 2 的幂次或常量，编译器会生成更优指令（如位运算），这对整型和浮点均适用。</p><hr><h3 id=总结-1>总结</h3><div class=table-wrapper><table><thead><tr><th><strong>类型</strong></th><th>与 <code>char</code>/<code>char&</code> 的共性</th><th>特殊注意事项</th></tr></thead><tbody><tr><td><code>int</code></td><td>传值更高效，引用优化类似 <code>char</code></td><td>无符号整型运算更快，适合位操作和寄存器优化</td></tr><tr><td><code>float</code></td><td>传值优先，引用用于修改或大对象</td><td>避免与 <code>double</code> 混用，注意精度转换开销</td></tr><tr><td><code>double</code></td><td>传引用减少复制，但需权衡间接寻址</td><td>内存占用高，优先用于科学计算等高精度场景</td></tr></tbody></table></div><p><strong>建议</strong>：<br>• 对小类型优先传值，对大类型或需修改的变量使用引用。<br>• 浮点运算需统一精度，避免隐式转换；在性能关键代码中，实测编译器优化效果。<br>• 内存敏感场景优先选择小类型（如 <code>float</code> 而非 <code>double</code>），以提升缓存命中率。</p><h2 id=const>const</h2><p>在C++中，<code>const</code>对性能的影响主要体现在编译器优化和代码设计优化两方面。以下是具体分析：</p><hr><h3 id=编译器的优化空间>编译器的优化空间</h3><ol><li><p><strong>返回值优化（RVO/NRVO）</strong><br><code>const</code>成员函数或返回<code>const</code>对象的函数，允许编译器通过<strong>移动语义</strong>或<strong>直接构造临时对象</strong>来避免拷贝。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>getName</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>name</span><span class=p>;</span> <span class=p>}</span>  <span class=c1>// 返回const引用，避免拷贝
</span></span></span></code></pre></div><p>编译器可对<code>const</code>返回值应用RVO（返回值优化）或NRVO（命名返回值优化），消除临时对象的构造和析构开销。</p></li><li><p><strong>减少运行时检查</strong><br><code>const</code>成员函数隐含了对象状态不变的承诺，编译器可省略某些类型检查和数据保护措施（如非必要的线程同步），从而降低运行时开销。</p></li></ol><hr><h3 id=代码设计优化>代码设计优化</h3><ol><li><p><strong>避免拷贝开销</strong><br>• <strong>传递参数时</strong>：使用<code>const</code>引用（如<code>const std::vector&lt;int>&</code>）传递大型对象，避免深拷贝。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>printVector</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>vec</span><span class=p>);</span>  <span class=c1>// 常量引用避免复制容器
</span></span></span></code></pre></div><p>• <strong>返回值时</strong>：返回<code>const</code>引用而非值类型（如类成员的<code>const&</code>接口），减少临时对象构造。</p></li><li><p><strong>多线程环境优化</strong><br><code>const</code>对象天然具有线程安全性，因其不可修改性可避免锁竞争。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>processData</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>data</span><span class=p>);</span>  <span class=c1>// 无锁读取共享资源
</span></span></span></code></pre></div></li><li><p><strong>内联函数协同</strong><br>小型的<code>const</code>成员函数更易被编译器内联（如<code>getter</code>函数），消除函数调用开销。现代编译器已能智能判断内联策略，<code>const</code>本身对是否内联影响较小。</p></li></ol><hr><h3 id=潜在性能陷阱>潜在性能陷阱</h3><ol><li><p><strong>内联限制（极少数情况）</strong><br>早期编译器可能因<code>const</code>函数的“不可修改性”假设而拒绝内联，但现代编译器（如GCC/Clang）已能优化此问题。</p></li><li><p><strong>常量折叠与存储优化</strong><br><code>const</code>变量可能被编译器放入只读内存段（如<code>.rodata</code>），减少内存占用并提升缓存命中率。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>bufferSize</span> <span class=o>=</span> <span class=mi>512</span><span class=p>;</span>  <span class=c1>// 编译时确定值，可能直接嵌入指令
</span></span></span></code></pre></div></li></ol><hr><h3 id=总结与建议>总结与建议</h3><p>• <strong>优先使用<code>const</code></strong>：在参数传递、返回值、成员函数中合理使用<code>const</code>，既能提升安全性，又能为编译器提供优化线索。
• <strong>关注对象大小</strong>：对大型对象（如容器、类实例）使用<code>const</code>引用；对基本类型（<code>int</code>等）直接传值。
• <strong>避免过度优化</strong>：现代编译器对<code>const</code>的优化已较成熟，无需为性能牺牲代码可读性。</p><p><code>T&</code> and <code>const T&</code>
在 C++ 中，<strong>普通引用</strong>和 <strong>const 引用</strong>在性能上的差异主要体现在编译器优化和代码场景适配性上，具体分析如下：</p><hr><h3 id=性能相同场景避免对象拷贝>性能相同场景：避免对象拷贝</h3><p>无论是普通引用还是 const 引用，<strong>传递大型对象时均通过地址操作避免拷贝</strong>，性能无差异。<br>• 示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>process</span><span class=p>(</span><span class=k>const</span> <span class=n>BigObject</span><span class=o>&amp;</span> <span class=n>obj</span><span class=p>);</span>  <span class=c1>// const 引用传递
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>modify</span><span class=p>(</span><span class=n>BigObject</span><span class=o>&amp;</span> <span class=n>obj</span><span class=p>);</span>         <span class=c1>// 普通引用传递
</span></span></span></code></pre></div><p>两者均直接传递对象地址，不涉及对象复制。对于大型结构体或容器（如 <code>std::vector</code>），相比值传递可显著提升效率。</p><hr><h3 id=性能差异场景临时对象处理>性能差异场景：临时对象处理</h3><p><strong>const 引用允许绑定临时对象或表达式</strong>，此特性可能引入临时对象构造/析构的额外开销，但对性能影响需具体分析：</p><ol><li><p><strong>基本类型</strong>（如 <code>int</code>、<code>double</code>）：<br>• 临时对象构造成本极低，性能差异可忽略。
• 示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>double</span> <span class=nf>distance</span><span class=p>(</span><span class=k>const</span> <span class=kt>double</span><span class=o>&amp;</span> <span class=n>x</span><span class=p>,</span> <span class=k>const</span> <span class=kt>double</span><span class=o>&amp;</span> <span class=n>y</span><span class=p>);</span>  <span class=c1>// 允许传递 x+3.0 表达式
</span></span></span></code></pre></div><p>编译器自动生成临时 <code>double</code> 变量，但构造时间几乎为零。</p></li><li><p><strong>复杂类型</strong>（如类实例）：<br>• 若表达式或类型转换涉及复杂对象的构造（如隐式转换构造函数），临时对象的生成可能引入性能损耗。
• 此时需权衡代码可读性与性能，必要时显式构造对象。</p></li></ol><hr><h3 id=编译器优化差异>编译器优化差异</h3><ol><li><p><strong>常量折叠与内存优化</strong><br><code>const</code> 引用参数可能触发编译器将对象放入只读内存段（如 <code>.rodata</code>），减少内存占用并提升缓存命中率。</p></li><li><p><strong>函数内联优化</strong><br><code>const</code> 成员函数或参数更易被编译器内联，尤其是简单的 <code>getter</code> 函数。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>getName</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>name</span><span class=p>;</span> <span class=p>}</span>  <span class=c1>// 高频调用时内联优化效果显著
</span></span></span></code></pre></div></li><li><p><strong>线程安全优化</strong><br>多线程环境中，<code>const</code> 引用天然具备只读性，编译器可省略锁机制或数据同步检查，降低运行时开销。</p></li></ol><hr><h3 id=编码实践对性能的间接影响>编码实践对性能的间接影响</h3><ol><li><p><strong>避免意外修改</strong><br><code>const</code> 引用强制只读语义，减少因误操作导致的逻辑错误，间接提升程序健壮性和维护效率。</p></li><li><p><strong>兼容性扩展</strong><br><code>const</code> 引用可接受右值（如字面量、表达式返回值），而普通引用仅限左值。此特性使 <code>const</code> 引用在泛型编程中更灵活，避免代码冗余。</p></li></ol><hr><h3 id=总结与建议-1>总结与建议</h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>性能建议</strong></th></tr></thead><tbody><tr><td>传递大型对象</td><td>优先使用 <code>const T&</code>，除非需要修改原对象。</td></tr><tr><td>传递基本类型或小对象</td><td>值传递即可，引用传递的优化收益可忽略。</td></tr><tr><td>需要绑定临时对象</td><td>必须使用 <code>const T&</code>，普通引用会导致编译错误。</td></tr><tr><td>多线程只读访问</td><td><code>const</code> 引用可省略锁机制，提升并发性能。</td></tr></tbody></table></div><blockquote><p><strong>核心结论</strong>：<br>普通引用和 const 引用在性能上无本质差异，主要区别在于语义约束和场景适配性。合理使用 <code>const</code> 引用可提升代码安全性和编译器优化潜力，但对性能的直接影响需结合具体场景评估。</p></blockquote></section><footer class=article-footer><section class=article-tags><a href=/tags/leetcode-c/>LeetCode-C</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Oct 22, 2025 16:27 CST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/leetcode-c25-jul/><div class=article-details><h2 class=article-title>【LeetCode-C】25-Jul</h2></div></a></article><article><a href=/p/leetcode-c-containerunorered_map-unorered_set-map-set/><div class=article-details><h2 class=article-title>【LeetCode-C-Container】unorered_map & unorered_set & map & set</h2></div></a></article><article><a href=/p/leetcode-c-containertype-cast/><div class=article-details><h2 class=article-title>【LeetCode-C-Container】type cast</h2></div></a></article><article><a href=/p/leetcode-cprimary/><div class=article-details><h2 class=article-title>【LeetCode-C】Primary</h2></div></a></article><article><a href=/p/leetcode-clambda/><div class=article-details><h2 class=article-title>【LeetCode-C】lambda</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>