<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='Callable & Runnable 在Java多线程编程中，Runnable和Callable是定义异步任务的两种核心接口，它们的设计目的和功能有显著差异。以下是两者的详细对比：\n⚙️ 方法定义与返回值 Runnable 定义单一方法 run()，返回类型为 void，不返回任何结果。 示例：日志记录、异步通知等无需返回值的任务。 Runnable task = () -> System.out.println("Task executed"); Callable 定义方法 call()，支持泛型返回值（如 Callable<Integer> 返回整数）。 示例：计算阶乘、数据库查询等需返回结果的任务。 Callable<Integer> task = () -> { return 42; }; ⚠️ 异常处理机制 Runnable run() 不能抛出受检异常（checked exception），只能在方法内部通过 try-catch 处理。 Runnable task = () -> { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } }; Callable call() 可抛出受检异常（如 throws Exception），异常会封装在 Future.get() 抛出的 ExecutionException 中，可通过 getCause() 获取原始异常。 Callable<Integer> task = () -> { if (invalid) throw new Exception("Error"); return result; }; 🔌 执行方式与线程池兼容性 Runnable 可通过 Thread 类直接启动（new Thread(runnable).start()）或提交给 ExecutorService。 提交后返回 Future<?>，但 get() 始终返回 null。 Callable 必须通过 ExecutorService.submit() 提交，返回 Future<V> 对象，用于获取结果或异常。 无法直接通过 Thread 类启动，需借助 FutureTask 包装（new Thread(new FutureTask<>(callable)).start()）。 📊 主要区别对比表 特性 Runnable Callable 返回值 ❌ 无 ✅ 支持泛型返回值 异常处理 ❌ 不能抛出受检异常 ✅ 可抛出受检异常 执行方式 ✅ 支持Thread或线程池 ❌ 仅支持线程池提交 任务状态跟踪 ⚠️ 仅能判断是否完成（Future.isDone()） ✅ 可获取结果、异常及取消任务 引入版本 Java 1.0 Java 5（java.util.concurrent包） 🧩 线程状态监控与结果获取 Runnable 通过 Future.isDone() 判断任务完成状态，但无法获取结果或异常详情。 Callable 通过 Future.get() 阻塞获取结果，支持超时设置（get(long timeout, TimeUnit unit)）。 可捕获 ExecutionException 处理任务内部异常，或通过 Future.cancel() 取消任务。 💡 适用场景 Runnable： 简单异步任务（如事件日志、线程池基础任务）。 Callable： 需返回结果或严格异常处理的任务（如并行计算、IO操作）。 📝 代码示例对比 // Runnable示例 ExecutorService executor = Executors.newSingleThreadExecutor(); Future<?> futureRunnable = executor.submit(() -> System.out.println("Runnable")); futureRunnable.get(); // 返回null // Callable示例 Future<Integer> futureCallable = executor.submit(() -> { return 100; }); Integer result = futureCallable.get(); // 返回100 💎 总结 Runnable是轻量级异步任务的基础接口，而Callable通过返回值、异常传递和Future交互机制，扩展了复杂任务的并发处理能力。选择依据：\n'><title>【Java】Runnable</title><link rel=canonical href=https://dyhes.github.io/p/javarunnable/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【Java】Runnable"><meta property='og:description' content='Callable & Runnable 在Java多线程编程中，Runnable和Callable是定义异步任务的两种核心接口，它们的设计目的和功能有显著差异。以下是两者的详细对比：\n⚙️ 方法定义与返回值 Runnable 定义单一方法 run()，返回类型为 void，不返回任何结果。 示例：日志记录、异步通知等无需返回值的任务。 Runnable task = () -> System.out.println("Task executed"); Callable 定义方法 call()，支持泛型返回值（如 Callable<Integer> 返回整数）。 示例：计算阶乘、数据库查询等需返回结果的任务。 Callable<Integer> task = () -> { return 42; }; ⚠️ 异常处理机制 Runnable run() 不能抛出受检异常（checked exception），只能在方法内部通过 try-catch 处理。 Runnable task = () -> { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } }; Callable call() 可抛出受检异常（如 throws Exception），异常会封装在 Future.get() 抛出的 ExecutionException 中，可通过 getCause() 获取原始异常。 Callable<Integer> task = () -> { if (invalid) throw new Exception("Error"); return result; }; 🔌 执行方式与线程池兼容性 Runnable 可通过 Thread 类直接启动（new Thread(runnable).start()）或提交给 ExecutorService。 提交后返回 Future<?>，但 get() 始终返回 null。 Callable 必须通过 ExecutorService.submit() 提交，返回 Future<V> 对象，用于获取结果或异常。 无法直接通过 Thread 类启动，需借助 FutureTask 包装（new Thread(new FutureTask<>(callable)).start()）。 📊 主要区别对比表 特性 Runnable Callable 返回值 ❌ 无 ✅ 支持泛型返回值 异常处理 ❌ 不能抛出受检异常 ✅ 可抛出受检异常 执行方式 ✅ 支持Thread或线程池 ❌ 仅支持线程池提交 任务状态跟踪 ⚠️ 仅能判断是否完成（Future.isDone()） ✅ 可获取结果、异常及取消任务 引入版本 Java 1.0 Java 5（java.util.concurrent包） 🧩 线程状态监控与结果获取 Runnable 通过 Future.isDone() 判断任务完成状态，但无法获取结果或异常详情。 Callable 通过 Future.get() 阻塞获取结果，支持超时设置（get(long timeout, TimeUnit unit)）。 可捕获 ExecutionException 处理任务内部异常，或通过 Future.cancel() 取消任务。 💡 适用场景 Runnable： 简单异步任务（如事件日志、线程池基础任务）。 Callable： 需返回结果或严格异常处理的任务（如并行计算、IO操作）。 📝 代码示例对比 // Runnable示例 ExecutorService executor = Executors.newSingleThreadExecutor(); Future<?> futureRunnable = executor.submit(() -> System.out.println("Runnable")); futureRunnable.get(); // 返回null // Callable示例 Future<Integer> futureCallable = executor.submit(() -> { return 100; }); Integer result = futureCallable.get(); // 返回100 💎 总结 Runnable是轻量级异步任务的基础接口，而Callable通过返回值、异常传递和Future交互机制，扩展了复杂任务的并发处理能力。选择依据：\n'><meta property='og:url' content='https://dyhes.github.io/p/javarunnable/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Java'><meta property='article:published_time' content='2025-06-19T00:00:00+00:00'><meta property='article:modified_time' content='2025-10-22T16:26:59+08:00'><meta name=twitter:title content="【Java】Runnable"><meta name=twitter:description content='Callable & Runnable 在Java多线程编程中，Runnable和Callable是定义异步任务的两种核心接口，它们的设计目的和功能有显著差异。以下是两者的详细对比：\n⚙️ 方法定义与返回值 Runnable 定义单一方法 run()，返回类型为 void，不返回任何结果。 示例：日志记录、异步通知等无需返回值的任务。 Runnable task = () -> System.out.println("Task executed"); Callable 定义方法 call()，支持泛型返回值（如 Callable<Integer> 返回整数）。 示例：计算阶乘、数据库查询等需返回结果的任务。 Callable<Integer> task = () -> { return 42; }; ⚠️ 异常处理机制 Runnable run() 不能抛出受检异常（checked exception），只能在方法内部通过 try-catch 处理。 Runnable task = () -> { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } }; Callable call() 可抛出受检异常（如 throws Exception），异常会封装在 Future.get() 抛出的 ExecutionException 中，可通过 getCause() 获取原始异常。 Callable<Integer> task = () -> { if (invalid) throw new Exception("Error"); return result; }; 🔌 执行方式与线程池兼容性 Runnable 可通过 Thread 类直接启动（new Thread(runnable).start()）或提交给 ExecutorService。 提交后返回 Future<?>，但 get() 始终返回 null。 Callable 必须通过 ExecutorService.submit() 提交，返回 Future<V> 对象，用于获取结果或异常。 无法直接通过 Thread 类启动，需借助 FutureTask 包装（new Thread(new FutureTask<>(callable)).start()）。 📊 主要区别对比表 特性 Runnable Callable 返回值 ❌ 无 ✅ 支持泛型返回值 异常处理 ❌ 不能抛出受检异常 ✅ 可抛出受检异常 执行方式 ✅ 支持Thread或线程池 ❌ 仅支持线程池提交 任务状态跟踪 ⚠️ 仅能判断是否完成（Future.isDone()） ✅ 可获取结果、异常及取消任务 引入版本 Java 1.0 Java 5（java.util.concurrent包） 🧩 线程状态监控与结果获取 Runnable 通过 Future.isDone() 判断任务完成状态，但无法获取结果或异常详情。 Callable 通过 Future.get() 阻塞获取结果，支持超时设置（get(long timeout, TimeUnit unit)）。 可捕获 ExecutionException 处理任务内部异常，或通过 Future.cancel() 取消任务。 💡 适用场景 Runnable： 简单异步任务（如事件日志、线程池基础任务）。 Callable： 需返回结果或严格异常处理的任务（如并行计算、IO操作）。 📝 代码示例对比 // Runnable示例 ExecutorService executor = Executors.newSingleThreadExecutor(); Future<?> futureRunnable = executor.submit(() -> System.out.println("Runnable")); futureRunnable.get(); // 返回null // Callable示例 Future<Integer> futureCallable = executor.submit(() -> { return 100; }); Integer result = futureCallable.get(); // 返回100 💎 总结 Runnable是轻量级异步任务的基础接口，而Callable通过返回值、异常传递和Future交互机制，扩展了复杂任务的并发处理能力。选择依据：\n'><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#callable--runnable>Callable & Runnable</a><ol><li><a href=#-方法定义与返回值>⚙️ <strong>方法定义与返回值</strong></a></li><li><a href=#-异常处理机制>⚠️ <strong>异常处理机制</strong></a></li><li><a href=#-执行方式与线程池兼容性>🔌 <strong>执行方式与线程池兼容性</strong></a></li><li><a href=#-主要区别对比表>📊 <strong>主要区别对比表</strong></a></li><li><a href=#-线程状态监控与结果获取>🧩 <strong>线程状态监控与结果获取</strong></a></li><li><a href=#-适用场景>💡 <strong>适用场景</strong></a></li><li><a href=#-代码示例对比>📝 <strong>代码示例对比</strong></a></li><li><a href=#-总结>💎 <strong>总结</strong></a></li></ol></li><li><a href=#future>Future</a><ol><li><a href=#-future-的核心定位与作用>⚙️ <strong>Future 的核心定位与作用</strong></a></li><li><a href=#-核心方法解析>🔧 <strong>核心方法解析</strong></a></li><li><a href=#-典型使用场景>⚡ <strong>典型使用场景</strong></a></li><li><a href=#-实现原理与核心类>🧩 <strong>实现原理与核心类</strong></a><ol><li><a href=#状态管理机制><strong>状态管理机制</strong></a></li><li><a href=#核心实现类对比><strong>核心实现类对比</strong></a></li></ol></li><li><a href=#-注意事项与最佳实践>⚠️ <strong>注意事项与最佳实践</strong></a></li><li><a href=#-演进与替代方案>🔄 <strong>演进与替代方案</strong></a><ol><li><a href=#future-的局限性><code>Future</code> 的局限性：</a></li><li><a href=#升级方案><strong>升级方案：<code>CompletableFuture</code></strong></a></li></ol></li><li><a href=#-总结-1>💎 <strong>总结</strong></a></li></ol></li><li><a href=#futuretask>FutureTask</a><ol><li><a href=#-实现>🔧 <strong>实现 <code>Runnable</code> 接口</strong></a></li><li><a href=#-内部持有>📦 <strong>内部持有 <code>Callable</code> 字段</strong></a></li><li><a href=#-任务执行流程>🔄 <strong>任务执行流程</strong></a></li><li><a href=#-总结-2>💎 <strong>总结</strong></a></li></ol></li><li><a href=#completionstage>CompletionStage</a><ol><li><a href=#-核心定位与设计思想>⚙️ <strong>核心定位与设计思想</strong></a></li><li><a href=#-核心任务模型与函数式接口>🧩 <strong>核心任务模型与函数式接口</strong></a></li><li><a href=#-任务编排能力详解>⛓️ <strong>任务编排能力详解</strong></a><ol><li><a href=#串行关系sequential><strong>串行关系（Sequential）</strong></a></li><li><a href=#并行组合combination><strong>并行组合（Combination）</strong></a></li><li><a href=#聚合关系andor><strong>聚合关系（AND/OR）</strong></a></li><li><a href=#异常处理><strong>异常处理</strong></a></li></ol></li><li><a href=#-底层实现机制>⚙️ <strong>底层实现机制</strong></a></li><li><a href=#-典型应用场景>🚀 <strong>典型应用场景</strong></a></li><li><a href=#-注意事项>⚠️ <strong>注意事项</strong></a></li><li><a href=#-总结-3>💎 <strong>总结</strong></a></li></ol></li><li><a href=#completablefuture>CompletableFuture</a><ol><li><a href=#-核心特性与设计定位>🔧 <strong>核心特性与设计定位</strong></a></li><li><a href=#-核心-api-详解>⚙️ <strong>核心 API 详解</strong></a><ol><li><a href=#创建异步任务><strong>创建异步任务</strong></a></li><li><a href=#链式回调方法><strong>链式回调方法</strong></a></li><li><a href=#多任务组合><strong>多任务组合</strong></a></li><li><a href=#异常处理-1><strong>异常处理</strong></a></li></ol></li><li><a href=#-典型应用场景-1>⚡ <strong>典型应用场景</strong></a></li><li><a href=#-注意事项与最佳实践-1>⚠️ <strong>注意事项与最佳实践</strong></a></li><li><a href=#-与传统-future-的核心差异>💎 <strong>与传统 Future 的核心差异</strong></a></li><li><a href=#-综合应用示例>🚀 <strong>综合应用示例</strong></a></li><li><a href=#-总结-4>💡 <strong>总结</strong></a></li></ol></li><li><a href=#executor-vs-executorservice>Executor vs. ExecutorService</a><ol><li><a href=#-接口层级与设计定位>🔧 <strong>接口层级与设计定位</strong></a></li><li><a href=#-核心功能对比>⚙️ <strong>核心功能对比</strong></a><ol><li><a href=#任务提交方式><strong>任务提交方式</strong></a></li><li><a href=#生命周期管理><strong>生命周期管理</strong></a></li><li><a href=#批量任务与高级控制><strong>批量任务与高级控制</strong></a></li></ol></li><li><a href=#-适用场景分析>🧩 <strong>适用场景分析</strong></a></li><li><a href=#-生产实践注意事项>⚠️ <strong>生产实践注意事项</strong></a></li><li><a href=#-总结核心差异全景图>💎 <strong>总结：核心差异全景图</strong></a></li></ol></li><li><a href=#executors>Executors</a><ol><li><a href=#-executors-的核心功能与架构定位>🔧 <strong>Executors 的核心功能与架构定位</strong></a></li><li><a href=#-executors-提供的线程池类型及特点>🧩 <strong>Executors 提供的线程池类型及特点</strong></a></li><li><a href=#-适用场景分析-1>⚡ <strong>适用场景分析</strong></a></li><li><a href=#-基本使用示例>💻 <strong>基本使用示例</strong></a><ol><li><a href=#固定线程池处理并发任务><strong>固定线程池处理并发任务</strong></a></li><li><a href=#定时任务调度><strong>定时任务调度</strong></a></li><li><a href=#获取异步结果future><strong>获取异步结果（Future）</strong></a></li></ol></li><li><a href=#-注意事项与最佳实践-2>⚠️ <strong>注意事项与最佳实践</strong></a></li><li><a href=#-总结-5>💎 <strong>总结</strong></a></li></ol></li><li><a href=#自定义-threadpool>自定义 ThreadPool</a><ol><li><a href=#-核心参数配置7大核心参数>🔧 核心参数配置（7大核心参数）</a></li><li><a href=#-完整配置示例>⚙️ 完整配置示例</a></li><li><a href=#-高级优化技巧>🛠️ 高级优化技巧</a></li><li><a href=#-生产环境建议>⚠️ 生产环境建议</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/temple/ style=background-color:#69a794;color:>白玉京</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/javarunnable/>【Java】Runnable</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 19, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>10 minute read</time></div></footer></div></header><section class=article-content><h2 id=callable--runnable>Callable & Runnable</h2><p>在Java多线程编程中，<code>Runnable</code>和<code>Callable</code>是定义异步任务的两种核心接口，它们的设计目的和功能有显著差异。以下是两者的详细对比：</p><hr><h3 id=-方法定义与返回值>⚙️ <strong>方法定义与返回值</strong></h3><ul><li><strong><code>Runnable</code></strong><ul><li>定义单一方法 <code>run()</code>，返回类型为 <code>void</code>，<strong>不返回任何结果</strong>。</li><li>示例：日志记录、异步通知等无需返回值的任务。</li></ul><pre tabindex=0><code>Runnable task = () -&gt; System.out.println(&#34;Task executed&#34;);
</code></pre></li><li><strong><code>Callable</code></strong><ul><li>定义方法 <code>call()</code>，<strong>支持泛型返回值</strong>（如 <code>Callable&lt;Integer></code> 返回整数）。</li><li>示例：计算阶乘、数据库查询等需返回结果的任务。</li></ul><pre tabindex=0><code>Callable&lt;Integer&gt; task = () -&gt; { return 42; };
</code></pre></li></ul><hr><h3 id=-异常处理机制>⚠️ <strong>异常处理机制</strong></h3><ul><li><strong><code>Runnable</code></strong><ul><li><code>run()</code> <strong>不能抛出受检异常（checked exception）</strong>，只能在方法内部通过 <code>try-catch</code> 处理。</li></ul><pre tabindex=0><code>Runnable task = () -&gt; {
    try { Thread.sleep(1000); } 
    catch (InterruptedException e) { e.printStackTrace(); }
};
</code></pre></li><li><strong><code>Callable</code></strong><ul><li><code>call()</code> <strong>可抛出受检异常</strong>（如 <code>throws Exception</code>），异常会封装在 <code>Future.get()</code> 抛出的 <code>ExecutionException</code> 中，可通过 <code>getCause()</code> 获取原始异常。</li></ul><pre tabindex=0><code>Callable&lt;Integer&gt; task = () -&gt; { 
    if (invalid) throw new Exception(&#34;Error&#34;);
    return result;
};
</code></pre></li></ul><hr><h3 id=-执行方式与线程池兼容性>🔌 <strong>执行方式与线程池兼容性</strong></h3><ul><li><strong><code>Runnable</code></strong><ul><li>可通过 <code>Thread</code> 类直接启动（<code>new Thread(runnable).start()</code>）或提交给 <code>ExecutorService</code>。</li><li>提交后返回 <code>Future&lt;?></code>，但 <code>get()</code> 始终返回 <code>null</code>。</li></ul></li><li><strong><code>Callable</code></strong><ul><li><strong>必须通过 <code>ExecutorService.submit()</code> 提交</strong>，返回 <code>Future&lt;V></code> 对象，用于获取结果或异常。</li><li>无法直接通过 <code>Thread</code> 类启动，需借助 <code>FutureTask</code> 包装（<code>new Thread(new FutureTask&lt;>(callable)).start()</code>）。</li></ul></li></ul><hr><h3 id=-主要区别对比表>📊 <strong>主要区别对比表</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>Runnable</strong></th><th><strong>Callable</strong></th></tr></thead><tbody><tr><td><strong>返回值</strong></td><td>❌ 无</td><td>✅ 支持泛型返回值</td></tr><tr><td><strong>异常处理</strong></td><td>❌ 不能抛出受检异常</td><td>✅ 可抛出受检异常</td></tr><tr><td><strong>执行方式</strong></td><td>✅ 支持<code>Thread</code>或线程池</td><td>❌ 仅支持线程池提交</td></tr><tr><td><strong>任务状态跟踪</strong></td><td>⚠️ 仅能判断是否完成（<code>Future.isDone()</code>）</td><td>✅ 可获取结果、异常及取消任务</td></tr><tr><td><strong>引入版本</strong></td><td>Java 1.0</td><td>Java 5（<code>java.util.concurrent</code>包）</td></tr></tbody></table></div><hr><h3 id=-线程状态监控与结果获取>🧩 <strong>线程状态监控与结果获取</strong></h3><ul><li><strong><code>Runnable</code></strong><ul><li>通过 <code>Future.isDone()</code> 判断任务完成状态，但无法获取结果或异常详情。</li></ul></li><li><strong><code>Callable</code></strong><ul><li>通过 <code>Future.get()</code> <strong>阻塞获取结果</strong>，支持超时设置（<code>get(long timeout, TimeUnit unit)</code>）。</li><li>可捕获 <code>ExecutionException</code> 处理任务内部异常，或通过 <code>Future.cancel()</code> 取消任务。</li></ul></li></ul><hr><h3 id=-适用场景>💡 <strong>适用场景</strong></h3><ul><li><strong><code>Runnable</code></strong>：
简单异步任务（如事件日志、线程池基础任务）。</li><li><strong><code>Callable</code></strong>：
需返回结果或严格异常处理的任务（如并行计算、IO操作）。</li></ul><hr><h3 id=-代码示例对比>📝 <strong>代码示例对比</strong></h3><pre tabindex=0><code>// Runnable示例
ExecutorService executor = Executors.newSingleThreadExecutor();
Future&lt;?&gt; futureRunnable = executor.submit(() -&gt; System.out.println(&#34;Runnable&#34;));
futureRunnable.get(); // 返回null

// Callable示例
Future&lt;Integer&gt; futureCallable = executor.submit(() -&gt; { 
    return 100; 
});
Integer result = futureCallable.get(); // 返回100
</code></pre><hr><h3 id=-总结>💎 <strong>总结</strong></h3><p><code>Runnable</code>是轻量级异步任务的基础接口，而<code>Callable</code>通过返回值、异常传递和<code>Future</code>交互机制，扩展了复杂任务的并发处理能力。选择依据：</p><ul><li>无需结果 → <code>Runnable</code>；</li><li>需结果/异常控制 → <code>Callable</code>。</li></ul><h2 id=future>Future</h2><p>以下是关于 Java 中 <code>Future</code> 接口的详细解析，结合其核心特性、实现原理、使用场景及注意事项进行系统性说明：</p><hr><h3 id=-future-的核心定位与作用>⚙️ <strong>Future 的核心定位与作用</strong></h3><p><code>Future</code> 是 Java 并发编程中<strong>异步计算结果的容器</strong>（位于 <code>java.util.concurrent</code> 包），代表一个尚未完成的异步任务的结果。其核心价值在于：</p><ul><li><strong>解耦任务提交与结果获取</strong>：主线程提交任务后继续执行其他逻辑，通过 <code>Future</code> 在需要时获取结果。</li><li><strong>任务生命周期控制</strong>：支持取消任务、检查完成状态及超时机制。</li></ul><blockquote><p>💡 <strong>同步 vs. 异步的直观对比</strong>：</p><ul><li><strong>同步</strong>：类似打电话，必须等待对方接通才能通信（主线程阻塞）。</li><li><strong>异步</strong>：类似广播，发送后无需等待回复（主线程非阻塞）。</li></ul></blockquote><hr><h3 id=-核心方法解析>🔧 <strong>核心方法解析</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>方法</strong></th><th><strong>功能说明</strong></th></tr></thead><tbody><tr><td><code>boolean cancel(boolean mayInterruptIfRunning)</code></td><td>尝试取消任务。<code>mayInterruptIfRunning=true</code> 时，可中断正在执行的任务。</td></tr><tr><td><code>boolean isCancelled()</code></td><td>检查任务是否被取消（正常完成前取消返回 <code>true</code>）。</td></tr><tr><td><code>boolean isDone()</code></td><td>检查任务是否完成（含正常结束、异常终止或取消）。</td></tr><tr><td><code>V get()</code></td><td><strong>阻塞</strong>直到任务完成并返回结果，若任务抛出异常则封装为 <code>ExecutionException</code>。</td></tr><tr><td><code>V get(long timeout, TimeUnit unit)</code></td><td>带超时的结果获取，超时抛出 <code>TimeoutException</code>。</td></tr></tbody></table></div><blockquote><p>⚠️ <strong>关键行为说明</strong>：</p><ul><li><strong>阻塞性</strong>：<code>get()</code> 方法会阻塞调用线程，直至任务完成或超时。</li><li><strong>异常传递</strong>：任务中的异常通过 <code>ExecutionException</code> 抛出，需调用 <code>e.getCause()</code> 获取原始异常。</li></ul></blockquote><hr><h3 id=-典型使用场景>⚡ <strong>典型使用场景</strong></h3><ol><li><strong>并行计算</strong>
将大任务拆分为子任务并行执行，通过 <code>Future</code> 列表统一收集结果：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>ExecutorService</span><span class=w> </span><span class=n>executor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Executors</span><span class=p>.</span><span class=na>newFixedThreadPool</span><span class=p>(</span><span class=n>4</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>List</span><span class=o>&lt;</span><span class=n>Future</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>futures</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>10</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>futures</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>executor</span><span class=p>.</span><span class=na>submit</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>compute</span><span class=p>(</span><span class=n>i</span><span class=p>)));</span><span class=w> </span><span class=c1>// 提交任务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Future</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>futures</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Integer</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>f</span><span class=p>.</span><span class=na>get</span><span class=p>();</span><span class=w> </span><span class=c1>// 按完成顺序获取结果</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>executor</span><span class=p>.</span><span class=na>shutdown</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><strong>优势</strong>：总耗时 ≈ 最慢子任务的耗时，显著提升效率。</li><li><strong>异步 I/O 操作</strong>
如网络请求或文件读写，主线程提交任务后立即返回，通过 <code>Future</code> 后续获取响应：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Future</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>responseFuture</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>executor</span><span class=p>.</span><span class=na>submit</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>httpClient</span><span class=p>.</span><span class=na>fetchData</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ... 主线程执行其他逻辑</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>data</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>responseFuture</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>5</span><span class=p>,</span><span class=w> </span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>);</span><span class=w> </span><span class=c1>// 超时控制</span><span class=w>
</span></span></span></code></pre></div></li><li><strong>任务取消与超时控制</strong><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Future</span><span class=o>&lt;?&gt;</span><span class=w> </span><span class=n>task</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>executor</span><span class=p>.</span><span class=na>submit</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>longRunningOperation</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>task</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>500</span><span class=p>,</span><span class=w> </span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>MILLISECONDS</span><span class=p>);</span><span class=w> </span><span class=c1>// 超时设置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>TimeoutException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>task</span><span class=p>.</span><span class=na>cancel</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span><span class=w> </span><span class=c1>// 中断正在执行的任务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ol><hr><h3 id=-实现原理与核心类>🧩 <strong>实现原理与核心类</strong></h3><h4 id=状态管理机制><strong>状态管理机制</strong></h4><p><code>FutureTask</code>（<code>Future</code> 的核心实现类）通过 7 种状态管理任务生命周期：</p><pre tabindex=0><code>private static final int NEW = 0;          // 新建
private static final int COMPLETING = 1;    // 完成中（结果即将设置）
private static final int NORMAL = 2;       // 正常完成
private static final int EXCEPTIONAL = 3;  // 异常结束
private static final int CANCELLED = 4;    // 已取消
private static final int INTERRUPTING = 5; // 中断中
private static final int INTERRUPTED = 6;  // 已中断
</code></pre><p>状态转换通过 <strong>CAS（Compare-And-Swap）</strong> 保证原子性。</p><h4 id=核心实现类对比><strong>核心实现类对比</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>类名</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong><code>FutureTask</code></strong></td><td>同时实现 <code>Runnable</code> 和 <code>Future</code>，可直接提交给 <code>Thread</code> 或线程池执行。</td><td>需手动管理任务执行与结果获取的简单场景。</td></tr><tr><td><strong><code>CompletableFuture</code></strong></td><td>Java 8+ 引入，支持链式调用、组合任务、异常回调（非阻塞）。</td><td>复杂异步流程（如多个任务依赖、结果转换）。</td></tr><tr><td><strong><code>ScheduledFuture</code></strong></td><td>扩展延迟/周期性任务调度能力（需配合 <code>ScheduledExecutorService</code>）。</td><td>定时任务（如心跳检测、周期数据同步）。</td></tr></tbody></table></div><blockquote><p>🌰 <strong><code>FutureTask</code> 使用示例</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>FutureTask</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>futureTask</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>FutureTask</span><span class=o>&lt;&gt;</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>42</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=n>futureTask</span><span class=p>).</span><span class=na>start</span><span class=p>();</span><span class=w> </span><span class=c1>// 直接启动线程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 或提交至线程池：executor.submit(futureTask);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Integer</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>futureTask</span><span class=p>.</span><span class=na>get</span><span class=p>();</span><span class=w> </span><span class=c1>// 阻塞获取结果</span><span class=w>
</span></span></span></code></pre></div></blockquote><hr><h3 id=-注意事项与最佳实践>⚠️ <strong>注意事项与最佳实践</strong></h3><ol><li><strong>线程池关闭</strong>
务必调用 <code>executor.shutdown()</code>，避免线程泄漏。</li><li>异常处理</li><li>任务内部异常不会自动传播，必须通过<pre tabindex=0><code>Future.get() 
</code></pre>捕获<pre tabindex=0><code>ExecutionException 
</code></pre>并解析：<pre tabindex=0><code>try {
    future.get();
} catch (ExecutionException e) {
    Throwable realCause = e.getCause(); // 获取原始异常
}
</code></pre></li><li>避免永久阻塞<ul><li>始终使用带超时的 <code>get(long timeout, TimeUnit unit)</code>。</li><li>结合 <code>isDone()</code> 轮询检查状态（非实时，需权衡性能）。</li></ul></li><li>资源竞争优化<ul><li>CPU 密集型任务 → 固定大小线程池（<code>newFixedThreadPool</code>）。</li><li>I/O 密集型任务 → 缓存线程池（<code>newCachedThreadPool</code>）。</li></ul></li></ol><hr><h3 id=-演进与替代方案>🔄 <strong>演进与替代方案</strong></h3><h4 id=future-的局限性><code>Future</code> 的局限性：</h4><ul><li><strong>阻塞式获取结果</strong>：<code>get()</code> 导致线程资源浪费。</li><li><strong>组合能力弱</strong>：多任务依赖需手动协调（嵌套 <code>get()</code> 代码臃肿）。</li></ul><h4 id=升级方案><strong>升级方案：<code>CompletableFuture</code></strong></h4><p>支持函数式编程模型，实现非阻塞链式调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>CompletableFuture</span><span class=p>.</span><span class=na>supplyAsync</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=s>&#34;Hello&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=na>thenApplyAsync</span><span class=p>(</span><span class=n>s</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; World&#34;</span><span class=p>)</span><span class=w>    </span><span class=c1>// 异步结果转换</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=na>exceptionally</span><span class=p>(</span><span class=n>e</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=s>&#34;Fallback&#34;</span><span class=p>)</span><span class=w>       </span><span class=c1>// 异常处理</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=na>thenAccept</span><span class=p>(</span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>::</span><span class=n>println</span><span class=p>);</span><span class=w>     </span><span class=c1>// 消费结果</span><span class=w>
</span></span></span></code></pre></div><p><strong>优势</strong>：</p><ul><li><strong>任务组合</strong>：<code>thenCombine()</code>、<code>allOf()</code> 等协调多任务。</li><li><strong>回调机制</strong>：完成时自动触发后续操作（无需阻塞等待）。</li></ul><hr><h3 id=-总结-1>💎 <strong>总结</strong></h3><p><code>Future</code> 是 Java 并发编程的<strong>基础异步控制单元</strong>，适用于简单异步场景。其核心价值在于：
✅ ​<strong>结果容器</strong>​：封装异步计算结果或异常。
✅ ​<strong>任务控制</strong>​：取消、状态查询与超时管理。
✅ ​<strong>线程池集成</strong>​：与 <code>ExecutorService</code> 无缝协作。
<strong>演进方向</strong>：</p><ul><li>简单任务 → <code>Future</code> + 线程池。</li><li>复杂异步流 → <code>CompletableFuture</code> 或响应式框架（如 RxJava）。
​<strong>生产建议</strong>​：
⚠️ 避免无界队列导致的 OOM（优先自定义 <code>ThreadPoolExecutor</code>）。
⚠️ 超时设置与异常处理是保障系统健壮性的关键。</li></ul><h2 id=futuretask>FutureTask</h2><p>是的，<code>FutureTask</code> 确实<strong>实现了 <code>Runnable</code> 接口</strong>，并且<strong>内部持有一个 <code>Callable</code> 类型的字段</strong>。以下是具体分析：</p><hr><h3 id=-实现>🔧 <strong>实现 <code>Runnable</code> 接口</strong></h3><p><code>FutureTask</code> 实现了 <code>RunnableFuture</code> 接口，而 <code>RunnableFuture</code> 同时继承了 <code>Runnable</code> 和 <code>Future</code> 接口。因此：</p><ul><li>✅ <strong>可作为 <code>Runnable</code> 使用</strong>：<code>FutureTask</code> 可以直接传递给 <code>Thread</code> 构造函数或提交给线程池（<code>ExecutorService</code>）执行。</li><li>✅ <strong>执行逻辑</strong>：其 <code>run()</code> 方法会调用内部任务的逻辑（如 <code>Callable.call()</code> 或 <code>Runnable.run()</code>）并将结果存储到 <code>outcome</code> 字段中。</li></ul><pre tabindex=0><code>// 示例：FutureTask 作为 Runnable 使用
Callable&lt;Integer&gt; task = () -&gt; 123;
FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(task);
Thread thread = new Thread(futureTask);  // 直接传递给 Thread
thread.start();
</code></pre><hr><h3 id=-内部持有>📦 <strong>内部持有 <code>Callable</code> 字段</strong></h3><p><code>FutureTask</code> 的核心设计是<strong>统一封装任务</strong>：</p><ul><li>✅ <strong><code>Callable</code> 字段</strong>：源码中声明了 <code>private Callable&lt;V> callable</code> 字段，用于存储传入的任务。</li><li>✅ 支持两种任务类型：<ul><li>若通过构造函数传入 <code>Callable</code> 对象，则直接赋值给 <code>callable</code> 字段。</li><li>若传入<pre tabindex=0><code>Runnable
</code></pre>对象，会通过<pre tabindex=0><code>Executors.callable()
</code></pre>将其适配为<pre tabindex=0><code>Callable
</code></pre>类型再存储。<pre tabindex=0><code>// Runnable 适配为 Callable 的源码逻辑
public FutureTask(Runnable runnable, V result) {
    this.callable = Executors.callable(runnable, result);
}
</code></pre></li></ul></li></ul><hr><h3 id=-任务执行流程>🔄 <strong>任务执行流程</strong></h3><p>当调用 <code>FutureTask.run()</code> 时：</p><ol><li><strong>执行 <code>callable.call()</code></strong>：运行任务逻辑。</li><li><strong>存储结果或异常</strong>：结果存入 <code>outcome</code> 字段，状态更新为 <code>NORMAL</code>（成功）或 <code>EXCEPTIONAL</code>（异常）。</li><li><strong>唤醒阻塞线程</strong>：通过 <code>get()</code> 等待结果的线程会被唤醒并获取结果。</li></ol><hr><h3 id=-总结-2>💎 <strong>总结</strong></h3><ul><li>✅ <strong>双重身份</strong>：<code>FutureTask</code> 既是 <code>Runnable</code>（可被线程执行），又是 <code>Future</code>（可管理任务状态和结果）。</li><li>✅ <strong>统一封装</strong>：通过内部 <code>Callable</code> 字段统一处理 <code>Callable</code> 和 <code>Runnable</code> 任务，确保执行逻辑的一致性。</li><li>✅ <strong>典型应用场景</strong>：需异步执行且获取结果的任务（如并行计算、IO 操作），或需取消任务执行的场景。</li></ul><h2 id=completionstage>CompletionStage</h2><p>CompletionStage 是 Java 8 引入的核心异步编程接口（位于 <code>java.util.concurrent</code> 包），用于描述异步计算中的一个<strong>阶段性任务</strong>，支持任务之间的链式组合和结果传递。它通过函数式编程模型解决了传统 <code>Future</code> 的阻塞调用和任务编排难题，是 <code>CompletableFuture</code> 的底层设计基础。以下从核心特性到实践应用展开详解：</p><hr><h3 id=-核心定位与设计思想>⚙️ <strong>核心定位与设计思想</strong></h3><ol><li>阶段化任务抽象<ul><li>一个异步计算流程可拆分为多个相互依赖的 <code>CompletionStage</code> 子任务，形成<strong>任务流水线</strong>。</li><li>每个阶段封装一个操作（如 <code>Function</code>、<code>Consumer</code>），并定义其输入/输出行为。</li></ul></li><li>非阻塞回调机制<ul><li>通过 <code>thenApply</code>、<code>thenAccept</code> 等方法注册回调，任务完成后自动触发后续操作，<strong>无需阻塞等待</strong>。</li></ul></li><li>时序关系描述<ul><li>明确表达任务间的<strong>串行、并行、聚合（AND/OR）</strong> 关系，实现声明式编排。</li></ul></li></ol><hr><h3 id=-核心任务模型与函数式接口>🧩 <strong>核心任务模型与函数式接口</strong></h3><p><code>CompletionStage</code> 子任务的操作类型由函数式接口决定，分为三类：</p><div class=table-wrapper><table><thead><tr><th><strong>函数式接口</strong></th><th><strong>特点</strong></th><th><strong>回调方法示例</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong><code>Function&lt;T,R></code></strong></td><td>有输入、有输出</td><td><code>thenApply(fn)</code></td><td>数据转换（如字符串处理）</td></tr><tr><td><strong><code>Consumer&lt;T></code></strong></td><td>有输入、无输出</td><td><code>thenAccept(consumer)</code></td><td>结果消费（如日志打印）</td></tr><tr><td><strong><code>Runnable</code></strong></td><td>无输入、无输出</td><td><code>thenRun(action)</code></td><td>清理资源或发送通知</td></tr><tr><td><strong>示例</strong>：</td><td></td><td></td><td></td></tr></tbody></table></div><pre tabindex=0><code>stage.thenApply(x -&gt; x * 2)      // 输入整数x，输出2x  
     .thenAccept(System.out::println) // 消费结果并打印  
     .thenRun(() -&gt; cleanUp());     // 无参数清理操作
</code></pre><hr><h3 id=-任务编排能力详解>⛓️ <strong>任务编排能力详解</strong></h3><h4 id=串行关系sequential><strong>串行关系（Sequential）</strong></h4><p>通过 <code>then*</code> 系列方法实现阶段顺序执行：</p><ul><li><strong><code>thenApply()</code></strong>：接收上阶段结果，转换后输出新值。</li><li><strong><code>thenCompose()</code></strong>：扁平化嵌套任务（如将 <code>CompletionStage&lt;String></code> 转换为 <code>CompletionStage&lt;Integer></code>）。</li></ul><pre tabindex=0><code>// 查询用户→查询订单（依赖前序结果）
userStage.thenCompose(user -&gt; orderService.getOrders(user.getId()));
</code></pre><h4 id=并行组合combination><strong>并行组合（Combination）</strong></h4><p>合并多个独立任务的结果：</p><ul><li><strong><code>thenCombine(stage2, fn)</code></strong>：合并两个阶段结果（如计算 BMI：体重+身高→指数）。</li><li><strong><code>thenAcceptBoth(stage2, consumer)</code></strong>：消费两个结果但无输出。</li></ul><pre tabindex=0><code>weightStage.thenCombine(heightStage, (w, h) -&gt; w / (h * h));
</code></pre><h4 id=聚合关系andor><strong>聚合关系（AND/OR）</strong></h4><p>控制多个任务的完成触发条件：</p><div class=table-wrapper><table><thead><tr><th><strong>方法</strong></th><th><strong>触发条件</strong></th><th><strong>返回类型</strong></th></tr></thead><tbody><tr><td><strong><code>allOf(stages...)</code></strong></td><td>所有任务完成</td><td><code>CompletableFuture&lt;Void></code></td></tr><tr><td><strong><code>anyOf(stages...)</code></strong></td><td>任意一个任务完成</td><td><code>CompletableFuture&lt;Object></code></td></tr></tbody></table></div><pre tabindex=0><code>// 批量下载网页，统计包含关键词的页面数  
CompletableFuture.allOf(urlFutures)  
    .thenApply(v -&gt; urlFutures.stream()  
        .filter(f -&gt; f.join().contains(&#34;Java&#34;))  
        .count());
</code></pre><h4 id=异常处理><strong>异常处理</strong></h4><p>支持链式捕获异常，避免中断流水线：</p><ul><li><strong><code>exceptionally(fallbackFn)</code></strong>：捕获异常并返回默认值。</li><li><strong><code>handle(biFn)</code></strong>：统一处理结果和异常（类似 <code>try-catch-finally</code>）。</li></ul><pre tabindex=0><code>stage.exceptionally(ex -&gt; &#34;Fallback&#34;)  
     .handle((res, ex) -&gt; ex != null ? &#34;Error&#34; : res);
</code></pre><hr><h3 id=-底层实现机制>⚙️ <strong>底层实现机制</strong></h3><ol><li>状态驱动<ul><li>每个 <code>CompletionStage</code> 维护任务状态（未完成、完成、异常），通过 <strong>CAS 原子操作</strong>更新。</li></ul></li><li>依赖栈管理<ul><li>回调方法注册为 <strong>LIFO 栈结构</strong>，任务完成时按注册顺序的<strong>逆序触发回调</strong>（同步模式）。</li></ul></li><li>线程池控制<ul><li>默认使用 <code>ForkJoinPool.commonPool()</code>，可通过 <code>*Async</code> 方法后缀（如 <code>thenApplyAsync</code>）指定自定义 <code>Executor</code>。</li></ul></li></ol><hr><h3 id=-典型应用场景>🚀 <strong>典型应用场景</strong></h3><ol><li><p>微服务调用链
异步串行调用鉴权→查询→结果组装，避免线程阻塞：</p><pre tabindex=0><code>authStage.thenCompose(token -&gt; userService.query(token))  
         .thenApply(user -&gt; buildResponse(user));
</code></pre></li><li><p><strong>批量并行计算</strong>
分治任务并行执行（如 MapReduce 模型），通过 <code>allOf</code> 聚合结果。</p></li><li><p>竞速查询优化
同时请求多个数据源，取首个返回结果（</p><pre tabindex=0><code>anyOf 
</code></pre><p>+ 超时控制）：</p><pre tabindex=0><code>CompletableFuture.anyOf(dbQuery, cacheQuery)  
    .orTimeout(500, TimeUnit.MILLISECONDS);
</code></pre></li><li><p><strong>流水线数据处理</strong>
逐阶段转换数据流（如读取→过滤→聚合→存储）。</p></li></ol><hr><h3 id=-注意事项>⚠️ <strong>注意事项</strong></h3><ol><li><strong>避免阻塞回调</strong>
回调中执行阻塞操作（如同步 I/O）会拖慢整个流水线，需改用异步 I/O 或指定专用线程池。</li><li><strong>线程池隔离</strong>
CPU 密集型与 I/O 密集型任务使用独立线程池，防止资源竞争。</li><li><strong>异常传播</strong>
未捕获的运行时异常会导致阶段中断，务必通过 <code>handle()</code> 或 <code>exceptionally()</code> 处理。</li></ol><hr><h3 id=-总结-3>💎 <strong>总结</strong></h3><p><code>CompletionStage</code> 是 Java 异步编程的<strong>范式革新</strong>，核心价值在于：
✅ ​<strong>声明式编排</strong>​：通过链式调用描述任务时序，替代 <code>Future</code> 的阻塞轮询。
✅ ​<strong>函数式集成</strong>​：无缝结合 Lambda 表达式，简化回调逻辑。
✅ ​<strong>灵活组合</strong>​：支持 AND/OR 聚合、异常恢复等复杂模式。
<strong>适用场景优先级</strong>：</p><ul><li>高并发服务编排 → 微服务调用链</li><li>批处理加速 → 并行计算与聚合</li><li>响应式系统 → 非阻塞流水线</li></ul><blockquote><p><strong>生产建议</strong>：优先使用 <code>CompletableFuture</code>（<code>CompletionStage</code> 的唯一实现），结合自定义线程池与超时机制，构建健壮异步链路。</p></blockquote><h2 id=completablefuture>CompletableFuture</h2><p>CompletableFuture 是 Java 8 引入的异步编程工具，实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口，提供了比传统 <code>Future</code> 更强大的任务编排、链式调用和异常处理能力，极大简化了复杂异步流程的开发。以下从核心特性、工作原理到实践应用展开详解：</p><hr><h3 id=-核心特性与设计定位>🔧 <strong>核心特性与设计定位</strong></h3><ol><li><strong>异步结果容器</strong><ul><li>表示一个可能未完成的异步计算结果，支持手动设置结果（<code>complete(T)</code>）或异常终止（<code>completeExceptionally(Throwable)</code>）。</li><li>与 <code>Future</code> 的阻塞式 <code>get()</code> 不同，支持非阻塞回调机制（如 <code>thenApply</code>、<code>thenAccept</code>）。</li></ul></li><li><strong>任务编排能力</strong><ul><li><strong>串行/并行组合</strong>：通过 <code>thenCompose</code>（串行依赖）、<code>thenCombine</code>（并行合并）、<code>allOf</code>/<code>anyOf</code>（多任务聚合）等方法构建复杂流水线。</li><li><strong>灵活线程控制</strong>：默认使用 <code>ForkJoinPool.commonPool()</code>，支持自定义 <code>Executor</code> 指定线程池。</li></ul></li><li><strong>异常处理机制</strong><ul><li><code>exceptionally()</code>：捕获异常并返回默认值。</li><li><code>handle()</code>：同时处理正常结果和异常，可转换结果类型。</li></ul></li></ol><hr><h3 id=-核心-api-详解>⚙️ <strong>核心 API 详解</strong></h3><h4 id=创建异步任务><strong>创建异步任务</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>方法</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><code>supplyAsync(Supplier&lt;T>)</code></td><td>执行有返回值的异步任务（如数据库查询）。</td></tr><tr><td><code>runAsync(Runnable)</code></td><td>执行无返回值的异步任务（如日志写入）。</td></tr><tr><td><code>completedFuture(T)</code></td><td>创建已完成的实例，直接携带结果。</td></tr><tr><td><strong>示例</strong>：</td><td></td></tr></tbody></table></div><pre tabindex=0><code>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#34;Hello&#34;);
</code></pre><h4 id=链式回调方法><strong>链式回调方法</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>方法</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td><code>thenApply(Function&lt;T,U>)</code></td><td>转换结果（如字符串拼接）。</td></tr><tr><td><code>thenAccept(Consumer&lt;T>)</code></td><td>消费结果（如打印输出），无返回值。</td></tr><tr><td><code>thenRun(Runnable)</code></td><td>任务完成后执行动作，不访问结果。</td></tr><tr><td><code>thenCompose(Function&lt;T, CompletableFuture&lt;U>>)</code></td><td>将当前结果作为输入启动新异步任务（链式依赖）。</td></tr><tr><td><strong>示例</strong>：</td><td></td></tr></tbody></table></div><pre tabindex=0><code>future.thenApply(s -&gt; s + &#34; World&#34;)
      .thenAccept(System.out::println); // 输出 &#34;Hello World&#34;
</code></pre><h4 id=多任务组合><strong>多任务组合</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>方法</strong></th><th><strong>场景</strong></th></tr></thead><tbody><tr><td><code>thenCombine(CompletionStage, BiFunction)</code></td><td>合并两个独立任务的结果（如计算 A+B）。</td></tr><tr><td><code>allOf(CompletableFuture...)</code></td><td>等待所有任务完成（如批量调用 API）。</td></tr><tr><td><code>anyOf(CompletableFuture...)</code></td><td>任意一个任务完成即触发（如竞速查询）。</td></tr><tr><td><strong>示例</strong>：</td><td></td></tr></tbody></table></div><pre tabindex=0><code>CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; 2);
CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; 3);
future1.thenCombine(future2, (a, b) -&gt; a + b)
       .thenAccept(sum -&gt; System.out.println(&#34;Sum: &#34; + sum)); // 输出 5
</code></pre><h4 id=异常处理-1><strong>异常处理</strong></h4><pre tabindex=0><code>CompletableFuture.supplyAsync(() -&gt; {
    if (error) throw new RuntimeException(&#34;Error&#34;);
    return &#34;Success&#34;;
}).exceptionally(ex -&gt; &#34;Fallback&#34;)  // 异常时返回默认值
  .handle((res, ex) -&gt; ex != null ? &#34;Recovered&#34; : res); // 统一处理结果和异常
</code></pre><hr><h3 id=-典型应用场景-1>⚡ <strong>典型应用场景</strong></h3><ol><li><strong>并行计算优化</strong>
将大任务拆分为子任务并行执行，通过 <code>allOf</code> 聚合结果，提升吞吐量：<pre tabindex=0><code>List&lt;CompletableFuture&lt;Integer&gt;&gt; futures = tasks.stream()
    .map(task -&gt; CompletableFuture.supplyAsync(task::compute, executor))
    .toList();
CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
    .thenApply(v -&gt; futures.stream().map(CompletableFuture::join).sum());
</code></pre></li><li><strong>微服务异步调用链</strong>
串行调用多个服务（如先鉴权后查询），避免阻塞线程：<pre tabindex=0><code>CompletableFuture&lt;String&gt; authFuture = authService.authAsync(token);
authFuture.thenCompose(auth -&gt; userService.queryAsync(auth.getUserId()))
          .thenAccept(user -&gt; System.out.println(user.getName()));
</code></pre></li><li><strong>竞速请求与超时控制</strong>
同时发起多个数据源查询，取首个响应结果：<pre tabindex=0><code>CompletableFuture&lt;Data&gt; source1 = fetchFromSource1();
CompletableFuture&lt;Data&gt; source2 = fetchFromSource2();
CompletableFuture.anyOf(source1, source2)
    .orTimeout(500, TimeUnit.MILLISECONDS) // 超时中断
    .thenAccept(data -&gt; System.out.println(&#34;First result: &#34; + data));
</code></pre></li></ol><hr><h3 id=-注意事项与最佳实践-1>⚠️ <strong>注意事项与最佳实践</strong></h3><ol><li><strong>线程池选择</strong><ul><li><strong>CPU 密集型</strong>：固定大小线程池（<code>Executors.newFixedThreadPool</code>）避免过度切换。</li><li><strong>I/O 密集型</strong>：缓存线程池（<code>Executors.newCachedThreadPool</code>）提高资源利用率。</li></ul></li><li><strong>避免回调地狱</strong>
链式调用不宜过长，复杂逻辑可拆分为独立方法，或用 <code>CompletableFuture</code> 组合器简化。</li><li><strong>资源泄漏预防</strong><ul><li>自定义线程池需显式关闭（<code>shutdown()</code>）。</li><li>任务内部捕获异常，防止未处理异常中断线程。</li></ul></li><li><strong>性能监控</strong>
异步链路较长时，结合 Micrometer 等工具追踪任务耗时和线程池负载。</li></ol><hr><h3 id=-与传统-future-的核心差异>💎 <strong>与传统 Future 的核心差异</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>Future</strong></th><th><strong>CompletableFuture</strong></th></tr></thead><tbody><tr><td><strong>结果获取</strong></td><td>阻塞式 <code>get()</code></td><td>非阻塞回调（<code>thenAccept</code> 等）</td></tr><tr><td><strong>任务组合</strong></td><td>需手动协调（嵌套阻塞）</td><td>声明式组合（<code>thenCombine</code>/<code>allOf</code>）</td></tr><tr><td><strong>异常处理</strong></td><td>需在 <code>get()</code> 中捕获</td><td>链式处理（<code>exceptionally</code>/<code>handle</code>）</td></tr><tr><td><strong>灵活性</strong></td><td>功能基础</td><td>支持手动完成、超时控制、回调链</td></tr></tbody></table></div><hr><h3 id=-综合应用示例>🚀 <strong>综合应用示例</strong></h3><pre tabindex=0><code>ExecutorService executor = Executors.newFixedThreadPool(4);

// 异步查询用户信息 + 订单历史
CompletableFuture&lt;User&gt; userFuture = CompletableFuture.supplyAsync(UserService::fetchUser, executor);
CompletableFuture&lt;List&lt;Order&gt;&gt; ordersFuture = userFuture.thenComposeAsync(
    user -&gt; OrderService.fetchOrders(user.getId()), executor
);

// 合并结果并处理异常
CompletableFuture&lt;Void&gt; result = userFuture.thenCombine(ordersFuture, (user, orders) -&gt; {
    return String.format(&#34;User: %s, Orders: %d&#34;, user.getName(), orders.size());
}).handle((res, ex) -&gt; {
    if (ex != null) return &#34;Error: &#34; + ex.getCause().getMessage();
    return res;
}).thenAcceptAsync(System.out::println, executor);

result.join(); // 等待所有任务完成
executor.shutdown();
</code></pre><hr><h3 id=-总结-4>💡 <strong>总结</strong></h3><p>CompletableFuture 是 Java 异步编程的<strong>核心进化</strong>，通过链式调用和组合操作解决了传统 Future 的阻塞与协作难题。<strong>适用场景</strong>包括：高并发服务编排、批量任务并行化、响应式微服务调用等。<strong>生产建议</strong>：</p><ul><li>优先使用 <code>supplyAsync</code>/<code>thenApply</code> 等链式方法替代阻塞调用；</li><li>自定义线程池控制资源，避免无界队列导致 OOM；</li><li>复杂链路结合 <code>allOf</code>/<code>anyOf</code> 和超时机制提升健壮性。</li></ul><h2 id=executor-vs-executorservice>Executor vs. ExecutorService</h2><p>在 Java 并发编程中，<code>Executor</code> 和 <code>ExecutorService</code> 是线程池管理的核心接口，二者虽有关联但职责和功能存在显著差异。以下是它们的核心区别及适用场景分析：</p><hr><h3 id=-接口层级与设计定位>🔧 <strong>接口层级与设计定位</strong></h3><ol><li><strong><code>Executor</code></strong><ul><li><strong>基础接口</strong>：仅定义单一方法 <code>void execute(Runnable command)</code>，用于提交 <code>Runnable</code> 任务。</li><li><strong>核心目标</strong>：解耦任务提交与执行策略（如线程创建、调度），但不涉及任务结果或生命周期管理。</li><li>示例代码：<pre tabindex=0><code>Executor executor = command -&gt; new Thread(command).start(); // 自定义执行策略
executor.execute(() -&gt; System.out.println(&#34;Task running&#34;));
</code></pre></li></ul></li><li><strong><code>ExecutorService</code></strong><ul><li><strong>子接口扩展</strong>：继承 <code>Executor</code>，新增任务管理、结果获取和线程池生命周期控制方法。</li><li><strong>核心目标</strong>：提供完整的异步任务框架，支持任务取消、结果跟踪及优雅关闭。</li></ul></li></ol><hr><h3 id=-核心功能对比>⚙️ <strong>核心功能对比</strong></h3><h4 id=任务提交方式><strong>任务提交方式</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>功能</strong></th><th><strong>Executor</strong></th><th><strong>ExecutorService</strong></th></tr></thead><tbody><tr><td><strong>任务类型支持</strong></td><td>仅 <code>Runnable</code></td><td><code>Runnable</code> 和 <code>Callable</code></td></tr><tr><td><strong>提交方法</strong></td><td><code>execute(Runnable)</code></td><td><code>submit(Runnable)</code> / <code>submit(Callable)</code></td></tr><tr><td><strong>返回值</strong></td><td>无</td><td>返回 <code>Future</code> 对象跟踪结果或异常</td></tr><tr><td><strong>示例代码</strong>：</td><td></td><td></td></tr></tbody></table></div><pre tabindex=0><code>// ExecutorService 提交 Callable 任务
ExecutorService executorService = Executors.newFixedThreadPool(2);
Future&lt;Integer&gt; future = executorService.submit(() -&gt; 42);
Integer result = future.get(); // 阻塞获取结果
</code></pre><h4 id=生命周期管理><strong>生命周期管理</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>能力</strong></th><th><strong>Executor</strong></th><th><strong>ExecutorService</strong></th></tr></thead><tbody><tr><td><strong>关闭线程池</strong></td><td>需手动实现</td><td>提供 <code>shutdown()</code> 和 <code>shutdownNow()</code></td></tr><tr><td><strong>状态检查</strong></td><td>不支持</td><td><code>isShutdown()</code> / <code>isTerminated()</code></td></tr><tr><td><strong>等待终止</strong></td><td>不支持</td><td><code>awaitTermination(timeout, unit)</code></td></tr><tr><td><strong>关闭流程示例</strong>：</td><td></td><td></td></tr></tbody></table></div><pre tabindex=0><code>executorService.shutdown(); // 停止接收新任务
if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {
    executorService.shutdownNow(); // 强制终止剩余任务
}
</code></pre><h4 id=批量任务与高级控制><strong>批量任务与高级控制</strong></h4><ul><li><strong>批量提交</strong>：
<code>ExecutorService</code> 支持 <code>invokeAll()</code>（等待所有任务完成）和 <code>invokeAny()</code>（任一任务完成即返回）。</li><li><strong>超时控制</strong>：
可通过 <code>Future.get(timeout, unit)</code> 实现结果获取的超时机制。</li></ul><hr><h3 id=-适用场景分析>🧩 <strong>适用场景分析</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐接口</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr><td>简单异步任务（无需结果）</td><td><code>Executor</code></td><td>轻量级提交，无需管理线程池生命周期</td></tr><tr><td>需获取结果的任务</td><td><code>ExecutorService</code></td><td>通过 <code>Future</code> 获取返回值或异常</td></tr><tr><td>定时/周期性任务</td><td><code>ExecutorService</code></td><td>需配合 <code>ScheduledExecutorService</code>（子接口）实现调度</td></tr><tr><td>高并发服务（如Web服务器）</td><td><code>ExecutorService</code></td><td>要求线程池动态管理、优雅关闭和资源回收</td></tr></tbody></table></div><hr><h3 id=-生产实践注意事项>⚠️ <strong>生产实践注意事项</strong></h3><ol><li>避免无界队列<pre tabindex=0><code>Executors.newFixedThreadPool() 
</code></pre>使用无界队列可能导致<pre tabindex=0><code>OOM
</code></pre>，建议自定义<pre tabindex=0><code>ThreadPoolExecutor
```：
</code></pre>new ThreadPoolExecutor(corePoolSize, maxPoolSize, keepAliveTime, unit, new ArrayBlockingQueue&lt;>(capacity));<pre tabindex=0><code></code></pre></li><li><strong>异常处理</strong>
<code>Executor</code> 中未捕获的异常会传递至 <code>UncaughtExceptionHandler</code>，而 <code>ExecutorService</code> 可通过 <code>Future.get()</code>捕获 <code>ExecutionException</code>。</li><li><strong>资源泄漏预防</strong>
务必调用 <code>shutdown()</code> 关闭线程池，否则 JVM 无法退出。</li></ol><hr><h3 id=-总结核心差异全景图>💎 <strong>总结：核心差异全景图</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>Executor</strong></th><th><strong>ExecutorService</strong></th></tr></thead><tbody><tr><td><strong>接口关系</strong></td><td>父接口</td><td>子接口（扩展功能）</td></tr><tr><td><strong>任务提交</strong></td><td>仅支持 <code>Runnable</code></td><td>支持 <code>Runnable</code> 和 <code>Callable</code></td></tr><tr><td><strong>结果获取</strong></td><td>不支持</td><td>通过 <code>Future</code> 跟踪结果</td></tr><tr><td><strong>生命周期管理</strong></td><td>无内置方法</td><td>提供关闭、状态检查等方法</td></tr><tr><td><strong>适用复杂度</strong></td><td>简单异步场景</td><td>生产级高并发管理</td></tr></tbody></table></div><blockquote><p>💡 <strong>实际建议</strong>：
除非极简场景（如单次异步日志），​<strong>优先使用 <code>ExecutorService</code></strong>。其完备的任务管理、结果跟踪和资源控制能力，更符合生产环境需求。对于定时任务，可进一步使用其子接口 <code>ScheduledExecutorService</code>。</p></blockquote><h2 id=executors>Executors</h2><p>Executors 是 Java 并发编程中用于<strong>简化线程池创建和管理</strong>的核心工具类（位于 <code>java.util.concurrent</code> 包）。它通过静态工厂方法提供预配置的线程池，帮助开发者避免手动管理线程的生命周期和资源分配。以下是其核心特性和使用详解：</p><hr><h3 id=-executors-的核心功能与架构定位>🔧 <strong>Executors 的核心功能与架构定位</strong></h3><ol><li><strong>线程池封装</strong>
Executors 封装了 <code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code> 的复杂配置，提供开箱即用的线程池实例。</li><li>任务与执行解耦
基于 Executor 框架的三层模型：<ul><li><strong>任务</strong>：<code>Runnable</code> 或 <code>Callable</code> 接口定义工作单元。</li><li><strong>执行机制</strong>：通过 <code>ExecutorService</code> 管理任务调度和线程资源。</li><li><strong>结果处理</strong>：<code>Future</code> 或 <code>FutureTask</code> 获取异步计算结果。</li></ul></li><li><strong>资源优化</strong>
复用线程减少创建/销毁开销，提升系统吞吐量（尤其在 I/O 密集型场景）。</li></ol><hr><h3 id=-executors-提供的线程池类型及特点>🧩 <strong>Executors 提供的线程池类型及特点</strong></h3><p>以下是六种常用线程池的对比：</p><div class=table-wrapper><table><thead><tr><th><strong>工厂方法</strong></th><th><strong>线程池类型</strong></th><th><strong>核心机制</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><code>newFixedThreadPool(int n)</code></td><td>固定大小线程池</td><td>核心线程数 = 最大线程数；无界队列（<code>LinkedBlockingQueue</code>）</td><td>CPU 密集型任务（如计算、图像处理）</td></tr><tr><td><code>newCachedThreadPool()</code></td><td>可缓存线程池</td><td>线程数无上限（可回收闲置线程）；同步队列（<code>SynchronousQueue</code>）</td><td>短期异步任务（如网络请求）</td></tr><tr><td><code>newSingleThreadExecutor()</code></td><td>单线程池</td><td>仅一个工作线程；无界队列</td><td>需顺序执行的任务（如日志写入）</td></tr><tr><td><code>newScheduledThreadPool(int n)</code></td><td>定时任务线程池</td><td>固定核心线程；支持延迟/周期性任务（<code>DelayedWorkQueue</code>）</td><td>心跳检测、定时数据同步</td></tr><tr><td><code>newSingleThreadScheduledExecutor()</code></td><td>单线程定时任务池</td><td>单线程版 <code>ScheduledThreadPool</code></td><td>需顺序执行的定时任务</td></tr><tr><td><code>newWorkStealingPool(int n)</code></td><td>工作窃取线程池（Java 8+）</td><td>基于 <code>ForkJoinPool</code>；并行处理任务；默认使用 CPU 核心数</td><td>分治任务或并行计算</td></tr></tbody></table></div><blockquote><p>⚠️ <strong>注意</strong>：<code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code> 使用<strong>无界队列</strong>，可能导致内存溢出（OOM），生产环境建议自定义 <code>ThreadPoolExecutor</code>。</p></blockquote><hr><h3 id=-适用场景分析-1>⚡ <strong>适用场景分析</strong></h3><ul><li><strong>CPU 密集型</strong>（计算逻辑为主）→ <code>FixedThreadPool</code>（限制并发线程数）。</li><li><strong>I/O 密集型</strong>（等待资源为主）→ <code>CachedThreadPool</code>（弹性扩缩容）。</li><li><strong>顺序执行需求</strong> → <code>SingleThreadExecutor</code>（避免并发问题）。</li><li><strong>定时/周期任务</strong> → <code>ScheduledThreadPool</code>（替代 <code>Timer</code>）。</li><li><strong>并行分治任务</strong> → <code>WorkStealingPool</code>（高效利用多核）。</li></ul><hr><h3 id=-基本使用示例>💻 <strong>基本使用示例</strong></h3><h4 id=固定线程池处理并发任务><strong>固定线程池处理并发任务</strong></h4><pre tabindex=0><code>ExecutorService executor = Executors.newFixedThreadPool(4);
for (int i = 0; i &lt; 10; i++) {
    executor.submit(() -&gt; {
        System.out.println(&#34;Task executed by &#34; + Thread.currentThread().getName());
    });
}
executor.shutdown();  // 停止接收新任务
executor.awaitTermination(60, TimeUnit.SECONDS);  // 等待剩余任务完成
</code></pre><h4 id=定时任务调度><strong>定时任务调度</strong></h4><pre tabindex=0><code>ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);
// 延迟 3 秒执行
scheduler.schedule(() -&gt; System.out.println(&#34;Delayed Task&#34;), 3, TimeUnit.SECONDS);
// 周期任务：初始延迟 1 秒，每 2 秒执行一次
scheduler.scheduleAtFixedRate(() -&gt; System.out.println(&#34;Periodic Task&#34;), 1, 2, TimeUnit.SECONDS);
</code></pre><h4 id=获取异步结果future><strong>获取异步结果（Future）</strong></h4><pre tabindex=0><code>ExecutorService executor = Executors.newCachedThreadPool();
Future&lt;Integer&gt; future = executor.submit(() -&gt; {
    TimeUnit.SECONDS.sleep(1);
    return 42;
});
Integer result = future.get();  // 阻塞直到结果就绪
System.out.println(&#34;Result: &#34; + result);  // 输出: 42
</code></pre><hr><h3 id=-注意事项与最佳实践-2>⚠️ <strong>注意事项与最佳实践</strong></h3><ol><li><p><strong>关闭线程池</strong>
必须调用 <code>shutdown()</code> 或 <code>shutdownNow()</code> 避免资源泄漏，推荐结合 <code>awaitTermination</code> 等待任务结束。</p></li><li><p><strong>异常处理</strong>
任务内部需捕获异常，否则线程可能因未处理异常而终止：</p><pre tabindex=0><code>executor.submit(() -&gt; {
    try { /* 业务代码 */ } 
    catch (Exception e) { e.printStackTrace(); }
});
</code></pre></li><li><p><strong>避免无界队列</strong>
生产环境建议使用 <code>ThreadPoolExecutor</code> 自定义队列大小（如 <code>ArrayBlockingQueue</code>）。</p></li><li><p><strong>谨慎使用 <code>CachedThreadPool</code></strong>
可能因任务激增创建大量线程，导致资源耗尽。</p></li></ol><hr><h3 id=-总结-5>💎 <strong>总结</strong></h3><p>Executors 的核心价值在于<strong>降低并发编程复杂度</strong>，通过预置线程池满足常见场景需求。但需注意：</p><ul><li>✅ <strong>简单场景</strong>：直接使用 <code>Executors</code> 工厂方法快速开发。</li><li>⚠️ <strong>复杂/生产环境</strong>：改用 <code>ThreadPoolExecutor</code> 自定义参数（核心线程数、队列类型、拒绝策略）。</li><li>🔧 <strong>线程资源管理</strong>：务必关闭线程池并处理任务异常，保障系统稳定性。</li></ul><h2 id=自定义-threadpool>自定义 ThreadPool</h2><p>在 Java 中自定义线程池主要通过 <code>ThreadPoolExecutor</code> 类实现，相比 <code>Executors</code> 提供的预设线程池，自定义方案能规避资源耗尽风险（如无界队列导致内存溢出），并针对业务场景优化性能。以下是详细步骤和关键配置：</p><hr><h3 id=-核心参数配置7大核心参数>🔧 核心参数配置（7大核心参数）</h3><p><code>ThreadPoolExecutor</code> 的构造函数包含以下参数，需根据业务需求调整：</p><ol><li><strong><code>corePoolSize</code>（核心线程数）</strong><ul><li>线程池常驻的最小线程数，即使空闲也不会销毁（除非设置 <code>allowCoreThreadTimeOut=true</code>）。</li><li><strong>建议</strong>：CPU 密集型任务设为 <code>CPU 核数</code>（<code>Runtime.getRuntime().availableProcessors()</code>），IO 密集型任务参考公式：<code>线程数 = CPU核数 / (1 - 阻塞系数)</code>（阻塞系数取 0.8~0.9）。</li></ul></li><li><strong><code>maximumPoolSize</code>（最大线程数）</strong><ul><li>线程池允许创建的最大线程数（包含核心线程）。</li><li><strong>建议</strong>：IO 密集型任务可设为 <code>corePoolSize * 2</code>，避免突发流量导致任务堆积。</li></ul></li><li><strong><code>keepAliveTime</code> + <code>unit</code>（线程空闲超时）</strong><ul><li>非核心线程空闲超过此时间会被回收。</li><li><strong>建议</strong>：设为 30~60 秒（如 <code>TimeUnit.SECONDS</code>），平衡资源复用与释放。</li></ul></li><li><strong><code>workQueue</code>（任务队列）</strong><ul><li>存储待执行任务的阻塞队列，<strong>必须使用有界队列</strong>（如 <code>LinkedBlockingQueue(capacity)</code>）防止 OOM。</li><li>队列类型选择：<ul><li><code>ArrayBlockingQueue</code>：固定容量，公平锁。</li><li><code>LinkedBlockingQueue</code>：默认无界，需显式指定容量（如 <code>new LinkedBlockingQueue&lt;>(100)</code>）。</li><li><code>SynchronousQueue</code>：直接移交任务，配合 <code>maximumPoolSize</code> 使用（适合短任务）。</li></ul></li></ul></li><li><strong><code>threadFactory</code>（线程工厂）</strong><ul><li>自定义线程名称、优先级、守护状态等，便于监控和排查问题：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>NamedThreadFactory</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>ThreadFactory</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>AtomicInteger</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>AtomicInteger</span><span class=p>(</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>prefix</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>NamedThreadFactory</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>prefix</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>prefix</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>prefix</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Thread</span><span class=w> </span><span class=nf>newThread</span><span class=p>(</span><span class=n>Runnable</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Thread</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=n>prefix</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34;-&#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>counter</span><span class=p>.</span><span class=na>getAndIncrement</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>t</span><span class=p>.</span><span class=na>setDaemon</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w> </span><span class=c1>// 非守护线程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>t</span><span class=p>.</span><span class=na>setPriority</span><span class=p>(</span><span class=n>Thread</span><span class=p>.</span><span class=na>NORM_PRIORITY</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>t</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul></li><li><strong><code>handler</code>（拒绝策略）</strong><ul><li>当任务队列满且线程数达上限时触发，内置策略有：<ul><li><code>AbortPolicy</code>（默认）：抛出 <code>RejectedExecutionException</code>。</li><li><code>CallerRunsPolicy</code>：由提交任务的线程直接执行。</li><li><code>DiscardPolicy</code>：静默丢弃任务。</li><li><code>DiscardOldestPolicy</code>：丢弃队列最旧的任务，重试提交。</li></ul></li><li>自定义策略（如记录日志或降级处理）：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>LogRejectedHandler</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>RejectedExecutionHandler</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>rejectedExecution</span><span class=p>(</span><span class=n>Runnable</span><span class=w> </span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=n>ThreadPoolExecutor</span><span class=w> </span><span class=n>executor</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>err</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Task rejected: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>r</span><span class=p>.</span><span class=na>toString</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 可选：重试或持久化任务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul></li></ol><hr><h3 id=-完整配置示例>⚙️ 完整配置示例</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.util.concurrent.*</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>CustomThreadPool</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>ThreadPoolExecutor</span><span class=w> </span><span class=nf>createPool</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>corePoolSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Runtime</span><span class=p>.</span><span class=na>getRuntime</span><span class=p>().</span><span class=na>availableProcessors</span><span class=p>();</span><span class=w> </span><span class=c1>// CPU核数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>maxPoolSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>corePoolSize</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>BlockingQueue</span><span class=o>&lt;</span><span class=n>Runnable</span><span class=o>&gt;</span><span class=w> </span><span class=n>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LinkedBlockingQueue</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>100</span><span class=p>);</span><span class=w> </span><span class=c1>// 有界队列</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ThreadFactory</span><span class=w> </span><span class=n>factory</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>NamedThreadFactory</span><span class=p>(</span><span class=s>&#34;business-pool&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>RejectedExecutionHandler</span><span class=w> </span><span class=n>handler</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ThreadPoolExecutor</span><span class=p>.</span><span class=na>CallerRunsPolicy</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ThreadPoolExecutor</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>corePoolSize</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>maxPoolSize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>60</span><span class=p>,</span><span class=w> </span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>queue</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>factory</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>handler</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 使用示例</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ThreadPoolExecutor</span><span class=w> </span><span class=n>executor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>createPool</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>executor</span><span class=p>.</span><span class=na>submit</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Task executed by: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>().</span><span class=na>getName</span><span class=p>()));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>executor</span><span class=p>.</span><span class=na>shutdown</span><span class=p>();</span><span class=w> </span><span class=c1>// 程序结束前关闭线程池</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><hr><h3 id=-高级优化技巧>🛠️ 高级优化技巧</h3><ol><li><strong>动态参数调整</strong>
通过 <code>setCorePoolSize()</code> 和 <code>setMaximumPoolSize()</code> 运行时调整线程数，适应流量波动。</li><li><strong>监控线程池状态</strong>
定期采集指标（如任务数、活跃线程数、队列大小）：<pre tabindex=0><code>executor.getTaskCount();     // 总任务数
executor.getCompletedTaskCount(); // 已完成任务数
executor.getQueue().size(); // 队列积压量
</code></pre></li><li><strong>优雅关闭</strong>
确保任务执行完毕再退出程序：<pre tabindex=0><code>executor.shutdown(); // 停止接收新任务
if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
    executor.shutdownNow(); // 强制终止剩余任务
}
</code></pre></li></ol><hr><h3 id=-生产环境建议>⚠️ 生产环境建议</h3><ul><li><strong>避免使用无界队列</strong>：防止任务堆积导致 OOM。</li><li><strong>线程命名规范</strong>：通过自定义 <code>ThreadFactory</code> 明确线程用途（如 <code>order-thread-1</code>），简化日志排查。</li><li>拒绝策略选择：<ul><li>核心业务用 <code>CallerRunsPolicy</code> 保证可用性。</li><li>非关键任务用 <code>DiscardPolicy</code> 减轻负载。</li></ul></li><li><strong>资源隔离</strong>：不同业务线使用独立线程池，避免互相影响。</li></ul><hr><blockquote><p>通过自定义 <code>ThreadPoolExecutor</code>，开发者可精准控制线程资源，在<strong>高并发</strong>、<strong>异步任务调度</strong>及<strong>资源敏感型应用</strong>中实现性能与稳定性的平衡。相比 <code>Executors</code> 的预设方案，自定义线程池是生产环境的必选项。</p></blockquote></section><footer class=article-footer><section class=article-tags><a href=/tags/java/>Java</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Oct 22, 2025 16:26 CST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/nowcoderjava-2/><div class=article-details><h2 class=article-title>【NowCoder】JAVA 2</h2></div></a></article><article><a href=/p/nowcoderjava/><div class=article-details><h2 class=article-title>【NowCoder】JAVA</h2></div></a></article><article><a href=/p/templejava-c/><div class=article-details><h2 class=article-title>【Temple】Java & C</h2></div></a></article><article><a href=/p/javamodule/><div class=article-details><h2 class=article-title>【Java】Module</h2></div></a></article><article><a href=/p/javaexception/><div class=article-details><h2 class=article-title>【Java】Exception</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>