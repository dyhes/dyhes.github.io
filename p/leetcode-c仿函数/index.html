<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="仿函数 在 C++ 中，operator() 是函数调用运算符的重载，它允许类的对象像函数一样被调用。你提供的代码片段 bool operator()(const int& a, const int& b) const 是一个典型的仿函数（Functor）实现，其核心作用是为类赋予类似函数的调用行为。\n基本含义 运算符重载：通过重载 operator()，可以让类的对象以 对象(参数) 的形式调用，例如 myObject(1, 2)，这等价于调用 myObject.operator()(1, 2)。 仿函数（Functor）：这种重载后的对象称为“仿函数”，它结合了函数的调用灵活性和类的封装性。 代码片段解析 bool operator()(const int& a, const int& b) const { return a > b; } 功能：该函数接受两个 int 类型的参数，返回 a > b 的比较结果。它定义了一个降序排序规则。 用途：常用于需要自定义比较逻辑的场景，例如作为 std::sort 的第三个参数。 const 修饰符：末尾的 const 表示该函数不会修改类的成员变量（若类有成员变量时）。 应用场景 (1) 自定义排序规则 在 STL 算法中（如 std::sort），可通过仿函数定义排序逻辑：\nstd::vector<int> vec = {3, 1, 4, 1, 5}; std::sort(vec.begin(), vec.end(), MyComparator()); // 若 MyComparator 中的 operator() 返回 a > b，则 vec 将被降序排序 (2) 作为谓词（Predicate） 在算法中筛选或处理数据：\nstd::vector<int> data = {5, 3, 8, 2}; auto it = std::find_if(data.begin(), data.end(), IsGreaterThan(4)); // 若 IsGreaterThan 的 operator() 检查元素是否大于阈值 (3) 封装复杂逻辑 仿函数可以保存状态，实现更复杂的逻辑复用：\n"><title>【LeetCode-C】仿函数</title><link rel=canonical href=https://dyhes.github.io/p/leetcode-c%E4%BB%BF%E5%87%BD%E6%95%B0/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【LeetCode-C】仿函数"><meta property='og:description' content="仿函数 在 C++ 中，operator() 是函数调用运算符的重载，它允许类的对象像函数一样被调用。你提供的代码片段 bool operator()(const int& a, const int& b) const 是一个典型的仿函数（Functor）实现，其核心作用是为类赋予类似函数的调用行为。\n基本含义 运算符重载：通过重载 operator()，可以让类的对象以 对象(参数) 的形式调用，例如 myObject(1, 2)，这等价于调用 myObject.operator()(1, 2)。 仿函数（Functor）：这种重载后的对象称为“仿函数”，它结合了函数的调用灵活性和类的封装性。 代码片段解析 bool operator()(const int& a, const int& b) const { return a > b; } 功能：该函数接受两个 int 类型的参数，返回 a > b 的比较结果。它定义了一个降序排序规则。 用途：常用于需要自定义比较逻辑的场景，例如作为 std::sort 的第三个参数。 const 修饰符：末尾的 const 表示该函数不会修改类的成员变量（若类有成员变量时）。 应用场景 (1) 自定义排序规则 在 STL 算法中（如 std::sort），可通过仿函数定义排序逻辑：\nstd::vector<int> vec = {3, 1, 4, 1, 5}; std::sort(vec.begin(), vec.end(), MyComparator()); // 若 MyComparator 中的 operator() 返回 a > b，则 vec 将被降序排序 (2) 作为谓词（Predicate） 在算法中筛选或处理数据：\nstd::vector<int> data = {5, 3, 8, 2}; auto it = std::find_if(data.begin(), data.end(), IsGreaterThan(4)); // 若 IsGreaterThan 的 operator() 检查元素是否大于阈值 (3) 封装复杂逻辑 仿函数可以保存状态，实现更复杂的逻辑复用：\n"><meta property='og:url' content='https://dyhes.github.io/p/leetcode-c%E4%BB%BF%E5%87%BD%E6%95%B0/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='LeetCode-C'><meta property='article:published_time' content='2025-02-28T00:00:00+00:00'><meta property='article:modified_time' content='2025-10-22T16:27:30+08:00'><meta name=twitter:title content="【LeetCode-C】仿函数"><meta name=twitter:description content="仿函数 在 C++ 中，operator() 是函数调用运算符的重载，它允许类的对象像函数一样被调用。你提供的代码片段 bool operator()(const int& a, const int& b) const 是一个典型的仿函数（Functor）实现，其核心作用是为类赋予类似函数的调用行为。\n基本含义 运算符重载：通过重载 operator()，可以让类的对象以 对象(参数) 的形式调用，例如 myObject(1, 2)，这等价于调用 myObject.operator()(1, 2)。 仿函数（Functor）：这种重载后的对象称为“仿函数”，它结合了函数的调用灵活性和类的封装性。 代码片段解析 bool operator()(const int& a, const int& b) const { return a > b; } 功能：该函数接受两个 int 类型的参数，返回 a > b 的比较结果。它定义了一个降序排序规则。 用途：常用于需要自定义比较逻辑的场景，例如作为 std::sort 的第三个参数。 const 修饰符：末尾的 const 表示该函数不会修改类的成员变量（若类有成员变量时）。 应用场景 (1) 自定义排序规则 在 STL 算法中（如 std::sort），可通过仿函数定义排序逻辑：\nstd::vector<int> vec = {3, 1, 4, 1, 5}; std::sort(vec.begin(), vec.end(), MyComparator()); // 若 MyComparator 中的 operator() 返回 a > b，则 vec 将被降序排序 (2) 作为谓词（Predicate） 在算法中筛选或处理数据：\nstd::vector<int> data = {5, 3, 8, 2}; auto it = std::find_if(data.begin(), data.end(), IsGreaterThan(4)); // 若 IsGreaterThan 的 operator() 检查元素是否大于阈值 (3) 封装复杂逻辑 仿函数可以保存状态，实现更复杂的逻辑复用：\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#仿函数>仿函数</a><ol><li><a href=#基本含义><strong>基本含义</strong></a></li><li><a href=#代码片段解析><strong>代码片段解析</strong></a></li><li><a href=#应用场景><strong>应用场景</strong></a><ol><li><a href=#1-自定义排序规则>(1) <strong>自定义排序规则</strong></a></li><li><a href=#2-作为谓词predicate>(2) <strong>作为谓词（Predicate）</strong></a></li><li><a href=#3-封装复杂逻辑>(3) <strong>封装复杂逻辑</strong></a></li></ol></li><li><a href=#优势><strong>优势</strong></a></li><li><a href=#5对比普通函数>5<strong>对比普通函数</strong></a></li><li><a href=#总结>总结</a></li></ol></li><li><a href=#仿函数-vs--operator-重载>仿函数 v.s. <code>operator&lt;</code> 重载</a><ol><li><a href=#核心差异><strong>核心差异</strong></a></li><li><a href=#适用场景><strong>适用场景</strong></a><ol><li><a href=#1-推荐使用仿函数的情况><strong>(1) 推荐使用仿函数的情况</strong></a></li><li><a href=#2-推荐重载><strong>(2) 推荐重载 <code>operator&lt;</code> 的情况</strong></a></li></ol></li><li><a href=#性能与设计考量><strong>性能与设计考量</strong></a></li><li><a href=#总结-1><strong>总结</strong></a><ol><li><a href=#典型场景对比><strong>典型场景对比</strong></a></li></ol></li></ol></li><li><a href=#stdless><code>std::less</code></a><ol><li><a href=#stdless-1><strong><code>std::less</code> 的典型用途</strong></a><ol><li><a href=#1-作为容器的默认比较器>(1) <strong>作为容器的默认比较器</strong></a></li><li><a href=#2-泛型算法中的比较逻辑>(2) <strong>泛型算法中的比较逻辑</strong></a></li><li><a href=#3-支持自定义类型的比较>(3) <strong>支持自定义类型的比较</strong></a></li></ol></li><li><a href=#为什么需要><strong>为什么需要 <code>std::less</code>？</strong></a></li><li><a href=#总结-2><strong>总结</strong></a></li></ol></li><li><a href=#stdless-的典型用途priority_queue-大根堆><code>std::less</code> 的典型用途：<code>priority_queue</code> 大根堆</a><ol><li><a href=#堆>堆</a></li><li><a href=#priority_queue><code>priority_queue</code></a><ol><li><a href=#1-默认行为解析><strong>(1) 默认行为解析</strong></a></li><li><a href=#2-代码示例><strong>(2) 代码示例</strong></a></li><li><a href=#3-对比小根堆><strong>(3) 对比小根堆</strong></a></li><li><a href=#4-设计原理><strong>(4) 设计原理</strong></a></li></ol></li><li><a href=#总结-3><strong>总结</strong></a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/pearl/ style=background-color:#a7535a;color:>拾珠玑
</a><a href=/categories/temple/ style=background-color:#69a794;color:>白玉京</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/leetcode-c%E4%BB%BF%E5%87%BD%E6%95%B0/>【LeetCode-C】仿函数</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Feb 28, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>4 minute read</time></div></footer></div></header><section class=article-content><h2 id=仿函数>仿函数</h2><p>在 C++ 中，<code>operator()</code> 是<strong>函数调用运算符</strong>的重载，它允许类的对象像函数一样被调用。你提供的代码片段 <code>bool operator()(const int& a, const int& b) const</code> 是一个典型的仿函数（Functor）实现，其核心作用是为类赋予类似函数的调用行为。</p><h3 id=基本含义><strong>基本含义</strong></h3><ul><li><strong>运算符重载</strong>：通过重载 <code>operator()</code>，可以让类的对象以 <code>对象(参数)</code> 的形式调用，例如 <code>myObject(1, 2)</code>，这等价于调用 <code>myObject.operator()(1, 2)</code>。</li><li><strong>仿函数（Functor）</strong>：这种重载后的对象称为“仿函数”，它结合了函数的调用灵活性和类的封装性。</li></ul><hr><h3 id=代码片段解析><strong>代码片段解析</strong></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>operator</span><span class=p>()(</span><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><strong>功能</strong>：该函数接受两个 <code>int</code> 类型的参数，返回 <code>a > b</code> 的比较结果。它定义了一个<strong>降序排序规则</strong>。</li><li><strong>用途</strong>：常用于需要自定义比较逻辑的场景，例如作为 <code>std::sort</code> 的第三个参数。</li><li><strong><code>const</code> 修饰符</strong>：末尾的 <code>const</code> 表示该函数不会修改类的成员变量（若类有成员变量时）。</li></ul><hr><h3 id=应用场景><strong>应用场景</strong></h3><h4 id=1-自定义排序规则>(1) <strong>自定义排序规则</strong></h4><p>在 STL 算法中（如 <code>std::sort</code>），可通过仿函数定义排序逻辑：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>sort</span><span class=p>(</span><span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vec</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>MyComparator</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=c1>// 若 MyComparator 中的 operator() 返回 a &gt; b，则 vec 将被降序排序
</span></span></span></code></pre></div><h4 id=2-作为谓词predicate>(2) <strong>作为谓词（Predicate）</strong></h4><p>在算法中筛选或处理数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data</span> <span class=o>=</span> <span class=p>{</span><span class=mi>5</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>2</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>find_if</span><span class=p>(</span><span class=n>data</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>data</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>IsGreaterThan</span><span class=p>(</span><span class=mi>4</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// 若 IsGreaterThan 的 operator() 检查元素是否大于阈值
</span></span></span></code></pre></div><h4 id=3-封装复杂逻辑>(3) <strong>封装复杂逻辑</strong></h4><p>仿函数可以保存状态，实现更复杂的逻辑复用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Counter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=k>operator</span><span class=p>()()</span> <span class=p>{</span> <span class=k>return</span> <span class=o>++</span><span class=n>count</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>Counter</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>c</span><span class=p>();</span> <span class=c1>// 返回 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>c</span><span class=p>();</span> <span class=c1>// 返回 2（状态被保留）
</span></span></span></code></pre></div><hr><h3 id=优势><strong>优势</strong></h3><ul><li><strong>灵活性</strong>：比普通函数更灵活，可携带状态（如计数器、配置参数）。</li><li><strong>兼容性</strong>：可直接用于 STL 算法和容器，而普通函数指针无法直接保存状态。</li><li><strong>性能</strong>：编译器通常对仿函数的内联优化更友好。</li></ul><hr><h3 id=5对比普通函数>5<strong>对比普通函数</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>仿函数</strong></th><th><strong>普通函数</strong></th></tr></thead><tbody><tr><td>状态保存</td><td>✔️（通过成员变量）</td><td>❌</td></tr><tr><td>内联优化</td><td>✔️（编译器友好）</td><td>可能受限</td></tr><tr><td>STL 兼容性</td><td>✔️（可直接传递）</td><td>需包装为函数指针或 Lambda</td></tr></tbody></table></div><hr><h3 id=总结>总结</h3><p>你提供的 <code>operator()</code> 重载定义了一个仿函数，用于比较两个整数的大小并返回降序结果。这种设计在需要<strong>自定义行为</strong>或<strong>封装状态</strong>的场景中非常有用，尤其适用于 STL 算法和泛型编程。</p><h2 id=仿函数-vs--operator-重载>仿函数 v.s. <code>operator&lt;</code> 重载</h2><p>在 C++ 中，“仿函数自定义比较函数”与“类中重载 <code>operator&lt;</code>”的选择取决于具体场景需求，两者各有优劣。以下是详细对比与分析：</p><hr><h3 id=核心差异><strong>核心差异</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>仿函数（自定义比较函数）</strong></th><th><strong>类中重载 <code>operator&lt;</code></strong></th></tr></thead><tbody><tr><td><strong>灵活性</strong></td><td>支持多种比较规则（如升序、降序）</td><td>仅定义类对象的默认比较逻辑</td></tr><tr><td><strong>适用范围</strong></td><td>可用于任意需要比较的场景（如 STL 算法、容器）</td><td>仅影响默认排序（如 <code>std::sort</code> <strong>无自定义比较</strong>时）</td></tr><tr><td><strong>状态保存</strong></td><td>可携带成员变量保存状态（如计数器、阈值）</td><td>无法保存状态，仅依赖对象自身属性</td></tr><tr><td><strong>代码复用性</strong></td><td>可复用同一比较逻辑于不同场景</td><td>仅适用于该类的默认比较逻辑</td></tr><tr><td><strong>STL 容器兼容性</strong></td><td>可作为模板参数传递（如 <code>std::set</code> 的 <code>Compare</code>）</td><td>仅当容器默认使用 <code>operator&lt;</code> 时生效</td></tr></tbody></table></div><hr><h3 id=适用场景><strong>适用场景</strong></h3><h4 id=1-推荐使用仿函数的情况><strong>(1) 推荐使用仿函数的情况</strong></h4><ul><li><strong>需要多种比较规则</strong><br>例如，对同一类对象，有时需按年龄排序，有时按姓名排序。仿函数可通过定义多个不同比较类实现。</li><li><strong>需要保存比较状态</strong><br>如动态调整比较阈值或记录比较次数（通过成员变量实现）。</li><li><strong>兼容 STL 容器模板参数</strong><br><code>std::set</code>、<code>std::map</code> 等容器的排序规则需通过模板参数指定仿函数。</li></ul><p><strong>示例：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 仿函数定义升序和降序两种规则
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>Ascending</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>operator</span><span class=p>()(</span><span class=k>const</span> <span class=n>Student</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>Student</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>a</span><span class=p>.</span><span class=n>score</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>.</span><span class=n>score</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Descending</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>operator</span><span class=p>()(</span><span class=k>const</span> <span class=n>Student</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>Student</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>a</span><span class=p>.</span><span class=n>score</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>.</span><span class=n>score</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>Student</span><span class=p>,</span> <span class=n>Ascending</span><span class=o>&gt;</span> <span class=n>set1</span><span class=p>;</span>  <span class=c1>// 按分数升序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>Student</span><span class=p>,</span> <span class=n>Descending</span><span class=o>&gt;</span> <span class=n>set2</span><span class=p>;</span> <span class=c1>// 按分数降序
</span></span></span></code></pre></div><h4 id=2-推荐重载><strong>(2) 推荐重载 <code>operator&lt;</code> 的情况</strong></h4><ul><li><strong>仅需默认排序逻辑</strong><br>例如，所有场景均按对象的某个固定属性（如学号）排序。</li><li><strong>简化代码</strong><br>当无需额外状态或复杂逻辑时，重载 <code>operator&lt;</code> 更简洁直观。</li></ul><p><strong>示例：</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=k>operator</span><span class=o>&lt;</span><span class=p>(</span><span class=k>const</span> <span class=n>Student</span><span class=o>&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>id</span> <span class=o>&lt;</span> <span class=n>other</span><span class=p>.</span><span class=n>id</span><span class=p>;</span> <span class=c1>// 默认按学号升序
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>Student</span><span class=o>&gt;</span> <span class=n>students</span><span class=p>;</span> <span class=c1>// 自动使用 operator&lt;
</span></span></span></code></pre></div><hr><h3 id=性能与设计考量><strong>性能与设计考量</strong></h3><ul><li><strong>性能</strong><br>两者性能接近，仿函数可能因内联优化更高效（编译器对仿函数的内联支持优于虚函数指针）。</li><li><strong>可维护性</strong><br>仿函数通过分离比较逻辑与类定义，符合“单一职责原则”，更易维护。</li><li><strong>扩展性</strong><br>仿函数支持组合其他逻辑（如日志记录、条件分支），而 <code>operator&lt;</code> 仅能实现简单比较。</li></ul><hr><h3 id=总结-1><strong>总结</strong></h3><ul><li><strong>优先选择仿函数</strong>：需要灵活比较规则、保存状态或适配 STL 模板参数时。</li><li><strong>优先重载 <code>operator&lt;</code></strong>：仅需默认排序且逻辑简单时。</li></ul><hr><h4 id=典型场景对比><strong>典型场景对比</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>需求</strong></th><th><strong>仿函数</strong></th><th><strong>重载 <code>operator&lt;</code></strong></th></tr></thead><tbody><tr><td>同一类多种排序规则</td><td>✔️</td><td>❌</td></tr><tr><td>优先队列自定义比较逻辑</td><td>✔️（必须）</td><td>❌</td></tr><tr><td>默认按属性排序</td><td>❌</td><td>✔️</td></tr><tr><td>比较时需动态调整阈值</td><td>✔️</td><td>❌</td></tr></tbody></table></div><p>若需进一步了解具体实现，可参考仿函数在 STL 中的应用 或运算符重载的设计原则。</p><h2 id=stdless><code>std::less</code></h2><p>std::less 是 C++ 标准库中定义的一个<strong>仿函数（Functor）</strong> ，用于实现通用的“小于”比较操作。</p><pre tabindex=0><code>
### **`std::less` 的仿函数特性**
`std::less` 是标准库提供的模板类，定义在 `&lt;functional&gt;` 头文件中：
```cpp
template&lt;typename T&gt;
struct less {
    constexpr bool operator()(const T&amp; lhs, const T&amp; rhs) const {
    return lhs &lt; rhs; // assumes that the implementation handles pointer total order
	}
};
</code></pre><ul><li><strong>重载了 <code>operator()</code></strong>：允许通过 <code>std::less&lt;T>()(a, b)</code> 调用比较逻辑。</li><li><strong>泛型设计</strong>：适用于所有支持 <code>&lt;</code> 操作的类型（如 <code>int</code>、<code>std::string</code>、自定义类等）。</li></ul><hr><h3 id=stdless-1><strong><code>std::less</code> 的典型用途</strong></h3><h4 id=1-作为容器的默认比较器>(1) <strong>作为容器的默认比较器</strong></h4><ul><li><code>std::set</code>、<code>std::map</code> 等有序容器默认使用 <code>std::less&lt;T></code> 排序：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>less</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>s</span><span class=p>;</span> <span class=c1>// 默认升序排序（可省略显式指定）
</span></span></span></code></pre></div><h4 id=2-泛型算法中的比较逻辑>(2) <strong>泛型算法中的比较逻辑</strong></h4><ul><li>在 <code>std::sort</code>、<code>std::lower_bound</code> 等算法中提供比较规则：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span><span class=mi>5</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>sort</span><span class=p>(</span><span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vec</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>std</span><span class=o>::</span><span class=n>less</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=c1>// 结果：1, 3, 4, 5（升序）
</span></span></span></code></pre></div><h4 id=3-支持自定义类型的比较>(3) <strong>支持自定义类型的比较</strong></h4><p>若自定义类型重载了 <code>&lt;</code> 运算符，可直接用 <code>std::less</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=k>operator</span><span class=o>&lt;</span><span class=p>(</span><span class=k>const</span> <span class=n>Student</span><span class=o>&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>id</span> <span class=o>&lt;</span> <span class=n>other</span><span class=p>.</span><span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>Student</span><span class=o>&gt;</span> <span class=n>students</span><span class=p>;</span> <span class=c1>// 默认使用 std::less&lt;Student&gt;，依赖 operator&lt;
</span></span></span></code></pre></div><hr><h3 id=为什么需要><strong>为什么需要 <code>std::less</code>？</strong></h3><ul><li><strong>统一接口</strong>：将比较逻辑封装为对象，便于传递给模板或函数。</li><li><strong>灵活扩展</strong>：可通过特化 <code>std::less</code> 修改默认行为。例如，对 <code>const char*</code> 按字符串内容比较：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>std</span><span class=o>::</span><span class=n>less</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>char</span><span class=o>*&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>operator</span><span class=p>()(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>b</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>strcmp</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><hr><h3 id=总结-2><strong>总结</strong></h3><ul><li><strong><code>std::less</code> 是仿函数</strong>：因为它通过 <code>operator()</code> 提供函数调用语义。</li><li><strong>核心作用</strong>：标准化“小于”比较逻辑，为泛型编程提供统一接口。</li><li><strong>扩展性</strong>：可通过特化或自定义仿函数实现灵活的比较规则。
好的，我需要帮用户生成关于std::less在priority_queue中生成大根堆的典型用途。用户之前已经讨论过std::less作为仿函数以及它在set和sort中的应用，现在他们可能想了解如何利用它来调整优先队列的行为。</li></ul><p>首先，我需要确认priority_queue的默认行为。默认情况下，priority_queue使用std::less作为比较函数，但实际上会生成大根堆还是小根堆呢？这里可能存在误解。根据C++标准，priority_queue默认是最大堆，即顶部元素最大，而比较函数默认是std::less，这看起来有点矛盾。需要解释清楚，因为std::less对应的是元素按升序排列，但在堆结构中，比较函数的逻辑是反的。例如，堆的调整是通过比较父节点和子节点，使用std::less时，父节点需要比子节点大，从而形成大根堆。</p><p>接下来，我需要详细说明如何通过std::less来实现大根堆。可能需要指出，虽然std::less在排序算法中是升序，但在priority_queue中的比较逻辑是反向的，因为它是一个最大堆实现。因此，用户可能想确认使用std::less是否真的生成大根堆，或者是否需要使用其他比较函数。例如，使用std::greater会生成小根堆，而默认的std::less生成大根堆。</p><p>然后，我需要给出一个代码示例，展示如何用std::less来声明一个最大堆的priority_queue。同时，对比使用std::greater生成最小堆的情况，帮助用户理解两者之间的区别。此外，可能还需要解释为什么默认情况下使用std::less会产生大根堆，这涉及到堆的内部结构和比较函数的关系。</p><p>用户可能存在的疑问点在于，为什么比较函数和堆的类型看起来相反。例如，使用std::less作为比较器，但得到的是最大堆。需要解释清楚比较函数在堆中的实际应用方式，即每次插入元素时，比较函数决定元素的排列顺序，而堆的结构维护依赖于这个比较结果。</p><p>最后，总结std::less在priority_queue中的作用，并提醒用户注意默认情况下生成的是大根堆，而如果需要小根堆，则需要显式使用std::greater。这可能帮助用户避免常见的误解和错误。</p><p>需要确保内容准确，避免误导，同时语言要简洁明了，符合用户之前讨论的详细技术风格。可能需要参考C++标准库文档来确认priority_queue的默认行为，确保给出的信息正确无误。</p><hr><h2 id=stdless-的典型用途priority_queue-大根堆><code>std::less</code> 的典型用途：<code>priority_queue</code> 大根堆</h2><h3 id=堆>堆</h3><p><strong>逻辑结构</strong>
堆是一棵<strong>完全二叉树</strong>，满足以下性质</p><ul><li><strong>最大堆</strong>：父节点的值 ≥ 子节点的值（根节点为最大值）。</li><li><strong>最小堆</strong>：父节点的值 ≤ 子节点的值（根节点为最小值）。示例：数组 [90, 45, 60, 20, 10] 可表示为最大堆（根节点90最大）。
<strong>物理存储</strong> 堆通常用<strong>数组实现</strong>，通过下标关系维护父子节点</li><li>父节点下标：parent(i) = (i-1)/2（向下取整）。</li><li>左子节点下标：left_child(i) = 2i + 1。</li><li>右子节点下标：right_child(i) = 2i + 2</li></ul><h3 id=priority_queue><code>priority_queue</code></h3><p>在 C++ 中，<code>std::priority_queue</code> 默认使用 <code>std::less&lt;T></code> 作为比较函数，但生成的却是<strong>大根堆（最大堆）</strong>。这是由于其底层实现逻辑决定的：堆的构建过程中，<strong>父节点始终“大于”子节点</strong>（通过比较函数判定），而 <code>std::less</code> 的返回值决定了这种父子关系。</p><h4 id=1-默认行为解析><strong>(1) 默认行为解析</strong></h4><ul><li><p><strong><code>std::priority_queue</code> 声明</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>T</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Container</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Compare</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>less</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>Container</span><span class=o>::</span><span class=n>value_type</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>priority_queue</span><span class=p>;</span>
</span></span></code></pre></div><p>默认比较器为 <code>std::less&lt;T></code>，但会按<strong>从大到小</strong>顺序排列（堆顶为最大值）。</p></li><li><p><strong>底层逻辑</strong>：<br><code>std::priority_queue</code> 内部维护一个堆，通过 <code>Compare</code> 函数判断是否要交换父子节点。<br>当 <code>Compare(a, b)</code> 返回 <code>true</code> 时，表示 <code>a</code> 应该排在 <code>b</code> 之后（即 <code>a &lt; b</code> 时，<code>b</code> 优先）。<br>因此，使用 <code>std::less&lt;T></code> 会确保较大的元素上升到堆顶。</p></li></ul><hr><h4 id=2-代码示例><strong>(2) 代码示例</strong></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;queue&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 默认使用 std::less&lt;int&gt;，生成大根堆
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>priority_queue</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>pq</span><span class=p>;</span> <span class=c1>// 等价于 std::priority_queue&lt;int, std::vector&lt;int&gt;, std::less&lt;int&gt;&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>pq</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>pq</span><span class=p>.</span><span class=n>top</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span> <span class=c1>// 输出顺序：4 3 2 1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pq</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h4 id=3-对比小根堆><strong>(3) 对比小根堆</strong></h4><p>若要生成小根堆（堆顶为最小值），需显式指定比较器为 <code>std::greater&lt;T></code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;functional&gt;</span><span class=cp> </span><span class=c1>// 需要包含此头文件
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>priority_queue</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>greater</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>min_pq</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>min_pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>min_pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>min_pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>min_pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 输出顺序：1 2 3 4
</span></span></span></code></pre></div><hr><h4 id=4-设计原理><strong>(4) 设计原理</strong></h4><ul><li><p><strong><code>Compare</code> 函数的语义</strong>：<br><code>Compare(a, b)</code> 返回 <code>true</code> 表示 <code>a</code> 的优先级低于 <code>b</code>（即 <code>a</code> 应排在 <code>b</code> 后面）。</p><ul><li>对于 <code>std::less&lt;T></code>，当 <code>a &lt; b</code> 时返回 <code>true</code>，说明 <code>b</code> 优先级更高，最终形成大根堆。</li><li>对于 <code>std::greater&lt;T></code>，当 <code>a > b</code> 时返回 <code>true</code>，说明 <code>a</code> 优先级更低，形成小根堆。</li></ul></li><li><p><strong>内存与性能</strong>：<br><code>std::priority_queue</code> 的插入和删除操作时间复杂度为 <strong>O(log n)</strong>，与比较函数的选择无关。</p></li></ul><h3 id=总结-3><strong>总结</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>比较器</strong></th><th><strong>堆类型</strong></th><th><strong>堆顶元素</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><code>std::less&lt;T></code></td><td>大根堆</td><td>最大值</td><td>默认场景（如求 Top-K 大）</td></tr><tr><td><code>std::greater&lt;T></code></td><td>小根堆</td><td>最小值</td><td>需要快速获取最小值时</td></tr></tbody></table></div><p>通过 <code>std::less</code> 和 <code>std::priority_queue</code> 的配合，可以高效实现最大值优先的队列逻辑。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/leetcode-c/>LeetCode-C</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Oct 22, 2025 16:27 CST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/leetcode-c25-jul/><div class=article-details><h2 class=article-title>【LeetCode-C】25-Jul</h2></div></a></article><article><a href=/p/leetcode-c-containerunorered_map-unorered_set-map-set/><div class=article-details><h2 class=article-title>【LeetCode-C-Container】unorered_map & unorered_set & map & set</h2></div></a></article><article><a href=/p/leetcode-c-containertype-cast/><div class=article-details><h2 class=article-title>【LeetCode-C-Container】type cast</h2></div></a></article><article><a href=/p/leetcode-cprimary/><div class=article-details><h2 class=article-title>【LeetCode-C】Primary</h2></div></a></article><article><a href=/p/leetcode-clambda/><div class=article-details><h2 class=article-title>【LeetCode-C】lambda</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>