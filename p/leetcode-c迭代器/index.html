<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="C++迭代器是连接容器与算法的核心机制，它提供了一种统一的元素访问方式，同时隐藏了底层数据结构的实现细节。以下从迭代器类型、操作特性、实现原理和实际应用四个维度进行详细解析：\n迭代器的核心分类与特性 输入迭代器（Input Iterator）\n仅支持单向读取操作，适用于单次遍历场景。典型应用如std::find算法，istream。\n支持操作：解引用（*it）、前置/后置递增（++it、it++）、相等性判断（==/!=）\n输出迭代器（Output Iterator）\n仅支持单向写入操作，常用于数据输出场景（如ostream）。例如std::copy算法将数据写入目标容器时使用。\n支持操作：赋值（*it = value）、递增（++it）\n前向迭代器（Forward Iterator）\n支持读写操作和多次遍历，适用于需要重复访问的场景。std::forward_list的迭代器即为此类。\n特性：继承输入迭代器功能，支持多趟遍历\n双向迭代器（Bidirectional Iterator）\n增加反向移动能力，如std::list和关联式容器。典型应用是std::reverse逆序算法。\n新增操作：前置/后置递减（--it、it--）\n随机访问迭代器（Random Access Iterator）\n支持直接跳转和数学运算，性能最优。std::vector和std::array的迭代器属于此类。\n关键操作：算术运算（it + n）、下标访问（it[n]）、比较运算符（</>等）\n迭代器的实现机制 类指针设计\n迭代器通过重载运算符模拟指针行为，例如operator*实现解引用，operator++实现移动。自定义迭代器需定义以下类型特征：\nclass Iterator { public: using iterator_category = std::forward_iterator_tag; using value_type = T; using difference_type = std::ptrdiff_t; // 运算符重载... }; 特征萃取技术\n通过std::iterator_traits提取迭代器类型信息，使算法能根据迭代器类型选择最优实现。例如std::sort对随机访问迭代器采用快速排序，其他类型则需拷贝到临时数组处理。\n迭代器适配器\n逆向迭代器（rbegin()/rend()）：通过std::reverse_iterator实现倒序遍历 插入迭代器：如std::back_inserter自动调用push_back() 流迭代器：实现流数据与容器间的转换 迭代器的进阶应用 STL算法集成\n所有标准算法（如std::transform、std::accumulate）通过迭代器接口操作容器，实现算法与数据结构的解耦。\n范围for循环\n底层通过begin()/end()获取迭代器实现遍历，但需注意：\n不支持反向遍历 修改元素需使用引用for(auto& x : container) 现代C++特性\nauto类型推导简化迭代器声明：auto it = vec.begin() 常量迭代器（cbegin()/cend()）保障数据只读性 设计原则与最佳实践 失效问题处理\n容器修改可能导致迭代器失效（如vector扩容），需特别注意插入/删除操作后的迭代器有效性。\n性能优化\n优先选择随机访问迭代器，其时间复杂度为O(1)，而双向迭代器移动操作为O(n)。\n"><title>【LeetCode-C】迭代器</title><link rel=canonical href=https://dyhes.github.io/p/leetcode-c%E8%BF%AD%E4%BB%A3%E5%99%A8/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【LeetCode-C】迭代器"><meta property='og:description' content="C++迭代器是连接容器与算法的核心机制，它提供了一种统一的元素访问方式，同时隐藏了底层数据结构的实现细节。以下从迭代器类型、操作特性、实现原理和实际应用四个维度进行详细解析：\n迭代器的核心分类与特性 输入迭代器（Input Iterator）\n仅支持单向读取操作，适用于单次遍历场景。典型应用如std::find算法，istream。\n支持操作：解引用（*it）、前置/后置递增（++it、it++）、相等性判断（==/!=）\n输出迭代器（Output Iterator）\n仅支持单向写入操作，常用于数据输出场景（如ostream）。例如std::copy算法将数据写入目标容器时使用。\n支持操作：赋值（*it = value）、递增（++it）\n前向迭代器（Forward Iterator）\n支持读写操作和多次遍历，适用于需要重复访问的场景。std::forward_list的迭代器即为此类。\n特性：继承输入迭代器功能，支持多趟遍历\n双向迭代器（Bidirectional Iterator）\n增加反向移动能力，如std::list和关联式容器。典型应用是std::reverse逆序算法。\n新增操作：前置/后置递减（--it、it--）\n随机访问迭代器（Random Access Iterator）\n支持直接跳转和数学运算，性能最优。std::vector和std::array的迭代器属于此类。\n关键操作：算术运算（it + n）、下标访问（it[n]）、比较运算符（</>等）\n迭代器的实现机制 类指针设计\n迭代器通过重载运算符模拟指针行为，例如operator*实现解引用，operator++实现移动。自定义迭代器需定义以下类型特征：\nclass Iterator { public: using iterator_category = std::forward_iterator_tag; using value_type = T; using difference_type = std::ptrdiff_t; // 运算符重载... }; 特征萃取技术\n通过std::iterator_traits提取迭代器类型信息，使算法能根据迭代器类型选择最优实现。例如std::sort对随机访问迭代器采用快速排序，其他类型则需拷贝到临时数组处理。\n迭代器适配器\n逆向迭代器（rbegin()/rend()）：通过std::reverse_iterator实现倒序遍历 插入迭代器：如std::back_inserter自动调用push_back() 流迭代器：实现流数据与容器间的转换 迭代器的进阶应用 STL算法集成\n所有标准算法（如std::transform、std::accumulate）通过迭代器接口操作容器，实现算法与数据结构的解耦。\n范围for循环\n底层通过begin()/end()获取迭代器实现遍历，但需注意：\n不支持反向遍历 修改元素需使用引用for(auto& x : container) 现代C++特性\nauto类型推导简化迭代器声明：auto it = vec.begin() 常量迭代器（cbegin()/cend()）保障数据只读性 设计原则与最佳实践 失效问题处理\n容器修改可能导致迭代器失效（如vector扩容），需特别注意插入/删除操作后的迭代器有效性。\n性能优化\n优先选择随机访问迭代器，其时间复杂度为O(1)，而双向迭代器移动操作为O(n)。\n"><meta property='og:url' content='https://dyhes.github.io/p/leetcode-c%E8%BF%AD%E4%BB%A3%E5%99%A8/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='LeetCode-C'><meta property='article:published_time' content='2025-03-07T00:00:00+00:00'><meta property='article:modified_time' content='2025-10-22T16:27:30+08:00'><meta name=twitter:title content="【LeetCode-C】迭代器"><meta name=twitter:description content="C++迭代器是连接容器与算法的核心机制，它提供了一种统一的元素访问方式，同时隐藏了底层数据结构的实现细节。以下从迭代器类型、操作特性、实现原理和实际应用四个维度进行详细解析：\n迭代器的核心分类与特性 输入迭代器（Input Iterator）\n仅支持单向读取操作，适用于单次遍历场景。典型应用如std::find算法，istream。\n支持操作：解引用（*it）、前置/后置递增（++it、it++）、相等性判断（==/!=）\n输出迭代器（Output Iterator）\n仅支持单向写入操作，常用于数据输出场景（如ostream）。例如std::copy算法将数据写入目标容器时使用。\n支持操作：赋值（*it = value）、递增（++it）\n前向迭代器（Forward Iterator）\n支持读写操作和多次遍历，适用于需要重复访问的场景。std::forward_list的迭代器即为此类。\n特性：继承输入迭代器功能，支持多趟遍历\n双向迭代器（Bidirectional Iterator）\n增加反向移动能力，如std::list和关联式容器。典型应用是std::reverse逆序算法。\n新增操作：前置/后置递减（--it、it--）\n随机访问迭代器（Random Access Iterator）\n支持直接跳转和数学运算，性能最优。std::vector和std::array的迭代器属于此类。\n关键操作：算术运算（it + n）、下标访问（it[n]）、比较运算符（</>等）\n迭代器的实现机制 类指针设计\n迭代器通过重载运算符模拟指针行为，例如operator*实现解引用，operator++实现移动。自定义迭代器需定义以下类型特征：\nclass Iterator { public: using iterator_category = std::forward_iterator_tag; using value_type = T; using difference_type = std::ptrdiff_t; // 运算符重载... }; 特征萃取技术\n通过std::iterator_traits提取迭代器类型信息，使算法能根据迭代器类型选择最优实现。例如std::sort对随机访问迭代器采用快速排序，其他类型则需拷贝到临时数组处理。\n迭代器适配器\n逆向迭代器（rbegin()/rend()）：通过std::reverse_iterator实现倒序遍历 插入迭代器：如std::back_inserter自动调用push_back() 流迭代器：实现流数据与容器间的转换 迭代器的进阶应用 STL算法集成\n所有标准算法（如std::transform、std::accumulate）通过迭代器接口操作容器，实现算法与数据结构的解耦。\n范围for循环\n底层通过begin()/end()获取迭代器实现遍历，但需注意：\n不支持反向遍历 修改元素需使用引用for(auto& x : container) 现代C++特性\nauto类型推导简化迭代器声明：auto it = vec.begin() 常量迭代器（cbegin()/cend()）保障数据只读性 设计原则与最佳实践 失效问题处理\n容器修改可能导致迭代器失效（如vector扩容），需特别注意插入/删除操作后的迭代器有效性。\n性能优化\n优先选择随机访问迭代器，其时间复杂度为O(1)，而双向迭代器移动操作为O(n)。\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><ol><li><a href=#迭代器的核心分类与特性>迭代器的核心分类与特性</a></li><li><a href=#迭代器的实现机制>迭代器的实现机制</a></li><li><a href=#迭代器的进阶应用>迭代器的进阶应用</a></li><li><a href=#设计原则与最佳实践>设计原则与最佳实践</a></li></ol></li><li><a href=#stdconst_iterator><code>std::const_iterator</code></a><ol><li><a href=#核心区别>核心区别</a></li><li><a href=#具体实现对比>具体实现对比</a><ol><li><a href=#常量迭代器的实现>常量迭代器的实现</a></li><li><a href=#迭代器适配器的实现>迭代器适配器的实现</a></li></ol></li><li><a href=#应用场景差异>应用场景差异</a></li><li><a href=#总结>总结</a></li></ol></li><li><a href=#stdreverse_iterator><code>std::reverse_iterator</code></a><ol><li><a href=#核心功能与原理>核心功能与原理</a></li><li><a href=#构造函数与成员函数>构造函数与成员函数</a></li><li><a href=#应用场景>应用场景</a></li><li><a href=#实现细节与注意事项>实现细节与注意事项</a></li><li><a href=#示例代码>示例代码</a></li><li><a href=#引用说明>引用说明</a></li></ol></li><li><a href=#stdback_inserter><code>std::back_inserter</code></a><ol><li><a href=#核心原理与实现>核心原理与实现</a></li><li><a href=#典型应用场景>典型应用场景</a></li><li><a href=#与其他插入迭代器的对比>与其他插入迭代器的对比</a></li><li><a href=#注意事项>注意事项</a></li><li><a href=#代码示例>代码示例</a></li></ol></li><li><a href=#流迭代器>流迭代器</a><ol><li><a href=#核心联系>核心联系</a></li><li><a href=#核心区别-1>核心区别</a><ol><li><a href=#功能定位><strong>功能定位</strong></a></li><li><a href=#操作特性><strong>操作特性</strong></a></li><li><a href=#性能与应用场景><strong>性能与应用场景</strong></a></li></ol></li><li><a href=#典型应用对比>典型应用对比</a></li><li><a href=#总结-1>总结</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/pearl/ style=background-color:#a7535a;color:>拾珠玑
</a><a href=/categories/temple/ style=background-color:#69a794;color:>白玉京</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/leetcode-c%E8%BF%AD%E4%BB%A3%E5%99%A8/>【LeetCode-C】迭代器</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 07, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>4 minute read</time></div></footer></div></header><section class=article-content><p>C++迭代器是连接容器与算法的核心机制，它提供了一种统一的元素访问方式，同时隐藏了底层数据结构的实现细节。以下从迭代器类型、操作特性、实现原理和实际应用四个维度进行详细解析：</p><h3 id=迭代器的核心分类与特性>迭代器的核心分类与特性</h3><ol><li><p><strong>输入迭代器（Input Iterator）</strong><br>仅支持单向读取操作，适用于单次遍历场景。典型应用如<code>std::find</code>算法，<code>istream</code>。<br><em>支持操作</em>：解引用（<code>*it</code>）、前置/后置递增（<code>++it</code>、<code>it++</code>）、相等性判断（<code>==</code>/<code>!=</code>）</p></li><li><p><strong>输出迭代器（Output Iterator）</strong><br>仅支持单向写入操作，常用于数据输出场景（如<code>ostream</code>）。例如<code>std::copy</code>算法将数据写入目标容器时使用。<br><em>支持操作</em>：赋值（<code>*it = value</code>）、递增（<code>++it</code>）</p></li><li><p><strong>前向迭代器（Forward Iterator）</strong><br>支持读写操作和多次遍历，适用于需要重复访问的场景。<code>std::forward_list</code>的迭代器即为此类。<br><em>特性</em>：继承输入迭代器功能，支持多趟遍历</p></li><li><p><strong>双向迭代器（Bidirectional Iterator）</strong><br>增加反向移动能力，如<code>std::list</code>和关联式容器。典型应用是<code>std::reverse</code>逆序算法。<br><em>新增操作</em>：前置/后置递减（<code>--it</code>、<code>it--</code>）</p></li><li><p><strong>随机访问迭代器（Random Access Iterator）</strong><br>支持直接跳转和数学运算，性能最优。<code>std::vector</code>和<code>std::array</code>的迭代器属于此类。<br><em>关键操作</em>：算术运算（<code>it + n</code>）、下标访问（<code>it[n]</code>）、比较运算符（<code>&lt;</code>/<code>></code>等）</p></li></ol><hr><h3 id=迭代器的实现机制>迭代器的实现机制</h3><ol><li><p><strong>类指针设计</strong><br>迭代器通过重载运算符模拟指针行为，例如<code>operator*</code>实现解引用，<code>operator++</code>实现移动。自定义迭代器需定义以下类型特征：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Iterator</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>iterator_category</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>forward_iterator_tag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>value_type</span> <span class=o>=</span> <span class=n>T</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>difference_type</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>ptrdiff_t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 运算符重载...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div></li><li><p><strong>特征萃取技术</strong><br>通过<code>std::iterator_traits</code>提取迭代器类型信息，使算法能根据迭代器类型选择最优实现。例如<code>std::sort</code>对随机访问迭代器采用快速排序，其他类型则需拷贝到临时数组处理。</p></li><li><p><strong>迭代器适配器</strong></p><ul><li>逆向迭代器（<code>rbegin()</code>/<code>rend()</code>）：通过<code>std::reverse_iterator</code>实现倒序遍历</li><li>插入迭代器：如<code>std::back_inserter</code>自动调用<code>push_back()</code></li><li>流迭代器：实现流数据与容器间的转换</li></ul></li></ol><hr><h3 id=迭代器的进阶应用>迭代器的进阶应用</h3><ol><li><p><strong>STL算法集成</strong><br>所有标准算法（如<code>std::transform</code>、<code>std::accumulate</code>）通过迭代器接口操作容器，实现算法与数据结构的解耦。</p></li><li><p><strong>范围for循环</strong><br>底层通过<code>begin()</code>/<code>end()</code>获取迭代器实现遍历，但需注意：</p><ul><li>不支持反向遍历</li><li>修改元素需使用引用<code>for(auto& x : container)</code></li></ul></li><li><p><strong>现代C++特性</strong></p><ul><li><code>auto</code>类型推导简化迭代器声明：<code>auto it = vec.begin()</code></li><li>常量迭代器（<code>cbegin()</code>/<code>cend()</code>）保障数据只读性</li></ul></li></ol><hr><h3 id=设计原则与最佳实践>设计原则与最佳实践</h3><ol><li><p><strong>失效问题处理</strong><br>容器修改可能导致迭代器失效（如<code>vector</code>扩容），需特别注意插入/删除操作后的迭代器有效性。</p></li><li><p><strong>性能优化</strong><br>优先选择随机访问迭代器，其时间复杂度为O(1)，而双向迭代器移动操作为O(n)。</p></li><li><p><strong>自定义容器支持</strong><br>实现容器时需要：</p><ul><li>定义<code>begin()</code>/<code>end()</code>方法</li><li>为迭代器类添加必要的类型特征（如<code>iterator_category</code>）</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 自定义环形缓冲区的迭代器示例
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CircularBuffer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Iterator</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 实现随机访问运算符...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>Iterator</span> <span class=nf>begin</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>Iterator</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Iterator</span> <span class=nf>end</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>Iterator</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>capacity</span><span class=p>,</span> <span class=k>this</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>通过理解迭代器的分层设计和使用场景，开发者可以更高效地利用STL的强大功能，同时为自定义数据结构提供标准化的访问接口。</p><h2 id=stdconst_iterator><code>std::const_iterator</code></h2><p>常量迭代器<strong>不是</strong>迭代器适配器，两者是 C++ 中不同的概念，分别属于迭代器分类和功能扩展机制。</p><hr><h3 id=核心区别>核心区别</h3><ol><li><p><strong>本质不同</strong><br>• <strong>常量迭代器</strong>（如 <code>const_iterator</code>）是迭代器的<strong>类型</strong>，属于迭代器分类中的一种，核心特性是<strong>只读</strong>（无法修改指向元素的值）。<br>• <strong>迭代器适配器</strong>（如 <code>reverse_iterator</code>）是<strong>功能扩展工具</strong>，通过封装现有迭代器改变其行为（如反向遍历或插入元素），属于对迭代器功能的二次封装。</p></li><li><p><strong>设计目的</strong><br>• 常量迭代器旨在<strong>保证数据安全</strong>，防止误修改容器内容，常用于只读遍历场景。<br>• 迭代器适配器旨在<strong>扩展迭代器功能</strong>，例如将正向迭代器转换为反向迭代器，或实现流式插入操作。</p></li></ol><hr><h3 id=具体实现对比>具体实现对比</h3><h4 id=常量迭代器的实现>常量迭代器的实现</h4><p>• 定义方式为 <code>容器名::const_iterator</code>，通过限制解引用操作的写权限实现只读。<br>示例代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>const_iterator</span> <span class=n>cit</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>cbegin</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>// *cit = 4; // 编译错误，无法修改值
</span></span></span></code></pre></div><h4 id=迭代器适配器的实现>迭代器适配器的实现</h4><p>• 适配器通过重载运算符和内部逻辑转换迭代行为。例如：<br>• <strong>反向迭代器</strong>（<code>reverse_iterator</code>）：将递增操作映射为基础迭代器的递减操作。<br>• <strong>插入迭代器</strong>（如 <code>back_inserter</code>）：将赋值操作转换为容器的 <code>push_back</code> 调用。<br>示例代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>rit</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>rbegin</span><span class=p>();</span> <span class=c1>// 反向迭代器适配器
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>rit</span><span class=p>;</span> <span class=c1>// 输出3（指向末尾元素）
</span></span></span></code></pre></div><hr><h3 id=应用场景差异>应用场景差异</h3><ol><li><p><strong>常量迭代器</strong><br>• 用于需要遍历容器但禁止修改元素的场景（如算法中的只读参数）。<br>• 与普通迭代器（<code>iterator</code>）形成互补，增强代码的健壮性。</p></li><li><p><strong>迭代器适配器</strong><br>• <strong>反向遍历</strong>：通过 <code>rbegin()</code>/<code>rend()</code> 实现逆序访问。<br>• <strong>流式操作</strong>：如 <code>ostream_iterator</code> 将数据写入输出流。<br>• <strong>动态插入</strong>：如 <code>back_inserter</code> 自动扩展容器容量。</p></li></ol><hr><h3 id=总结>总结</h3><p>• <strong>常量迭代器</strong>是迭代器的一种<strong>类型</strong>，核心特性是只读。<br>• <strong>迭代器适配器</strong>是<strong>功能扩展层</strong>，通过封装现有迭代器提供新行为。<br>两者在语法和功能上属于不同层级的机制，但可结合使用（如 <code>const_reverse_iterator</code> 实现反向只读遍历）。</p><h2 id=stdreverse_iterator><code>std::reverse_iterator</code></h2><p><code>std::reverse_iterator</code> 是 C++ 标准库中的一种<strong>迭代器适配器</strong>，用于以反向顺序遍历容器或序列。它通过封装一个基础迭代器（如双向或随机访问迭代器），并反转其移动方向来实现反向遍历功能。以下是其核心特性的详细解析：</p><hr><h3 id=核心功能与原理>核心功能与原理</h3><ol><li><p><strong>反向遍历机制</strong><br><code>std::reverse_iterator</code> 内部维护一个基础迭代器（<code>current</code>），但所有递增/递减操作会被反向处理：</p><ul><li><strong>递增操作（<code>++</code>）</strong>：实际调用基础迭代器的 <code>--</code> 操作，使其向序列起始方向移动。</li><li><strong>递减操作（<code>--</code>）</strong>：实际调用基础迭代器的 <code>++</code> 操作，使其向序列末尾方向移动。</li></ul></li><li><p><strong>解引用特性</strong><br>反向迭代器的解引用（<code>*</code>）返回的是基础迭代器<strong>前一个位置</strong>的元素值。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>rit</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>rbegin</span><span class=p>();</span> <span class=c1>// 指向3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=n>rit</span><span class=p>;</span> <span class=c1>// 等价于 *(vec.end() - 1)
</span></span></span></code></pre></div><p>这种设计确保反向迭代器与容器结束迭代器（如<code>vec.end()</code>）的安全关联，避免访问无效内存。</p></li></ol><hr><h3 id=构造函数与成员函数>构造函数与成员函数</h3><ol><li><p><strong>构造函数</strong></p><ul><li><strong>默认构造</strong>：创建一个未指向任何元素的反向迭代器。</li><li><strong>基础迭代器构造</strong>：接受一个正向迭代器参数，将其反向封装。<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>reverse_iterator</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span><span class=o>&gt;</span> <span class=n>rit</span><span class=p>(</span><span class=n>vec</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span></code></pre></div></li><li><strong>拷贝构造</strong>：允许从其他反向迭代器初始化。</li></ul></li><li><p><strong>关键成员函数</strong></p><ul><li><strong><code>base()</code></strong>：返回底层的基础迭代器（注意其指向比反向迭代器<strong>后移一位</strong>）。</li><li><strong>运算符重载</strong>：包括解引用（<code>*</code>、<code>-></code>）、算术运算（<code>+</code>、<code>-</code>）、递增/递减（<code>++</code>、<code>--</code>）等，模拟迭代器行为但方向相反。</li></ul></li></ol><hr><h3 id=应用场景>应用场景</h3><ol><li><p><strong>容器反向遍历</strong><br>通过容器的 <code>rbegin()</code> 和 <code>rend()</code> 方法获取反向迭代器，简化反向遍历代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>rit</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>rbegin</span><span class=p>();</span> <span class=n>rit</span> <span class=o>!=</span> <span class=n>vec</span><span class=p>.</span><span class=n>rend</span><span class=p>();</span> <span class=o>++</span><span class=n>rit</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>rit</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span> <span class=c1>// 输出3 2 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div></li><li><p><strong>算法适配</strong><br>标准库算法（如<code>std::sort</code>）可通过反向迭代器逆序处理数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>sort</span><span class=p>(</span><span class=n>vec</span><span class=p>.</span><span class=n>rbegin</span><span class=p>(),</span> <span class=n>vec</span><span class=p>.</span><span class=n>rend</span><span class=p>());</span> <span class=c1>// 将vec按降序排列
</span></span></span></code></pre></div></li><li><p><strong>流式数据处理</strong><br>结合流迭代器，实现反向读取或写入数据流。</p></li></ol><hr><h3 id=实现细节与注意事项>实现细节与注意事项</h3><ol><li><p><strong>基础迭代器要求</strong><br>必须为<strong>双向迭代器</strong>或<strong>随机访问迭代器</strong>。单向迭代器（如<code>std::forward_list</code>）无法使用反向迭代器。</p></li><li><p><strong>失效问题</strong><br>若底层容器结构变化（如元素插入/删除），反向迭代器可能失效，需重新获取迭代器。</p></li><li><p><strong>性能优化</strong><br>随机访问迭代器的反向版本支持直接跳转（如<code>rit + 5</code>），时间复杂度为 O(1)；双向迭代器的反向版本仅支持逐步移动。</p></li></ol><hr><h3 id=示例代码>示例代码</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iterator&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 反向遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>reverse_iterator</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span><span class=o>&gt;</span> <span class=n>rit</span><span class=p>(</span><span class=n>vec</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>rit</span> <span class=o>!=</span> <span class=n>std</span><span class=o>::</span><span class=n>reverse_iterator</span><span class=p>(</span><span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>()))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>rit</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span> <span class=c1>// 输出5 4 3 2 1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>++</span><span class=n>rit</span><span class=p>;</span> <span class=c1>// 实际移动方向为向左
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h3 id=引用说明>引用说明</h3><ul><li>反向迭代器与基础迭代器的关系见示意图。</li><li>解引用行为的数学表达式为 <code>&*rit == &*(i - 1)</code>（<code>i</code>为基础迭代器）。</li><li>支持的操作符及其底层实现逻辑参考。</li></ul><h2 id=stdback_inserter><code>std::back_inserter</code></h2><p><code>std::back_inserter</code> 是 C++ 标准库中用于动态扩展容器尾部的<strong>插入迭代器适配器</strong>，其核心作用是将赋值操作转换为容器的 <code>push_back</code> 调用，简化容器末尾元素的批量插入操作。以下从实现原理、应用场景和注意事项三个维度进行详细解析：</p><hr><h3 id=核心原理与实现>核心原理与实现</h3><ol><li><p><strong>适配器本质</strong><br><code>std::back_inserter</code> 是一个函数模板，返回 <code>back_insert_iterator</code> 对象。该对象重载了赋值运算符（<code>operator=</code>），将赋值操作映射为容器的 <code>push_back</code> 方法，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>back_inserter</span><span class=p>(</span><span class=n>vec</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>it</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>  <span class=c1>// 等价于 vec.push_back(42)
</span></span></span></code></pre></div><p>这种设计使得迭代器在算法中作为输出位置时能自动扩展容器容量。</p></li><li><p><strong>容器要求</strong><br>目标容器必须支持 <code>push_back</code> 方法，例如 <code>std::vector</code>、<code>std::deque</code> 和 <code>std::string</code>。若容器不支持 <code>push_back</code>（如 <code>std::array</code>），编译将报错。</p></li><li><p><strong>迭代器特性</strong><br>• 属于<strong>输出迭代器</strong>，仅支持单向写入操作，不支持读取或反向移动。
• 解引用（<code>*it</code>）和递增（<code>++it</code>）操作仅返回迭代器自身，无实际意义，但需保持语法兼容性。</p></li></ol><hr><h3 id=典型应用场景>典型应用场景</h3><ol><li><p><strong>算法输出适配</strong><br>与标准库算法结合时，避免预先分配容器空间。例如 <code>std::copy</code> 将数据从输入范围复制到目标容器末尾：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>src</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>},</span> <span class=n>dst</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>copy</span><span class=p>(</span><span class=n>src</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>src</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>std</span><span class=o>::</span><span class=n>back_inserter</span><span class=p>(</span><span class=n>dst</span><span class=p>));</span>  <span class=c1>// dst 变为 {1, 2, 3}
</span></span></span></code></pre></div><p>此用法常见于数据转换、流处理等场景。</p></li><li><p><strong>动态填充容器</strong><br>通过 <code>fill_n</code> 等算法直接生成元素，无需手动控制容器大小：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>fill_n</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>back_inserter</span><span class=p>(</span><span class=n>vec</span><span class=p>),</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>  <span class=c1>// 添加 5 个 0
</span></span></span></code></pre></div></li><li><p><strong>流式数据处理</strong><br>结合 <code>std::istream_iterator</code> 从输入流读取数据并动态存储：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>copy</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>istream_iterator</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>cin</span><span class=p>),</span> 
</span></span><span class=line><span class=cl>         <span class=n>std</span><span class=o>::</span><span class=n>istream_iterator</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>         <span class=n>std</span><span class=o>::</span><span class=n>back_inserter</span><span class=p>(</span><span class=n>data</span><span class=p>));</span>
</span></span></code></pre></div></li></ol><hr><h3 id=与其他插入迭代器的对比>与其他插入迭代器的对比</h3><ol><li><p><strong><code>std::front_inserter</code></strong><br>调用容器的 <code>push_front</code>（如 <code>std::list</code>），插入方向为头部，但要求容器支持 <code>push_front</code>。</p></li><li><p><strong><code>std::inserter</code></strong><br>在指定位置调用 <code>insert</code>，例如向 <code>std::set</code> 中插入有序元素：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>inserter</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>s</span><span class=p>.</span><span class=n>begin</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>it</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>  <span class=c1>// 在指定位置插入
</span></span></span></code></pre></div></li></ol><div class=table-wrapper><table><thead><tr><th>迭代器类型</th><th>调用方法</th><th>适用容器示例</th></tr></thead><tbody><tr><td><code>std::back_inserter</code></td><td><code>push_back</code></td><td><code>vector</code>, <code>deque</code></td></tr><tr><td><code>std::front_inserter</code></td><td><code>push_front</code></td><td><code>list</code>, <code>forward_list</code></td></tr><tr><td><code>std::inserter</code></td><td><code>insert</code></td><td><code>set</code>, <code>map</code>, <code>list</code></td></tr></tbody></table></div><hr><h3 id=注意事项>注意事项</h3><ol><li><p><strong>性能优化</strong><br>多次插入可能导致容器多次扩容（如 <code>vector</code> 的容量倍增策略），若预知元素数量，建议先调用 <code>reserve</code> 预留空间。</p></li><li><p><strong>迭代器失效</strong><br>使用过程中若其他操作修改了容器（如 <code>erase</code>），需重新获取迭代器。</p></li><li><p><strong>与范围 for 循环的兼容性</strong><br>范围 for 循环依赖 <code>begin()</code>/<code>end()</code>，无法直接使用插入迭代器，需通过算法间接操作。</p></li></ol><hr><h3 id=代码示例>代码示例</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;algorithm&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iterator&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 动态填充数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>inserter</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>back_inserter</span><span class=p>(</span><span class=n>vec</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>inserter</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=mi>10</span><span class=p>;</span>  <span class=c1>// 等价于 vec.push_back(10*i)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 算法应用：逆序复制
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>reversed</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>reverse_copy</span><span class=p>(</span><span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vec</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>std</span><span class=o>::</span><span class=n>back_inserter</span><span class=p>(</span><span class=n>reversed</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// reversed 内容为 {20, 10, 0}
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>std::back_inserter</code> 通过封装容器操作，使算法与容器实现解耦，是 C++ 泛型编程中实现灵活数据操作的重要工具。</p><h2 id=流迭代器>流迭代器</h2><p>流迭代器与输入/输出迭代器在 C++ 中既有联系又有区别，主要体现在功能定位、操作特性和应用场景上。以下是两者的对比分析：</p><hr><h3 id=核心联系>核心联系</h3><ol><li><p><strong>概念继承关系</strong><br>• <strong>输入流迭代器</strong>（如 <code>istream_iterator</code>）属于<strong>输入迭代器</strong>（Input Iterator）范畴，仅支持单向读取数据。
• <strong>输出流迭代器</strong>（如 <code>ostream_iterator</code>）属于<strong>输出迭代器</strong>（Output Iterator）范畴，仅支持单向写入数据。
• 流迭代器是输入/输出迭代器的<strong>具体实现形式</strong>，专门用于操作流对象（如 <code>cin</code>、<code>cout</code> 或文件流）。</p></li><li><p><strong>接口一致性</strong><br>流迭代器通过重载运算符（如 <code>operator++</code>、<code>operator*</code>）实现与标准输入/输出迭代器一致的接口，使其能与 STL 算法（如 <code>std::copy</code>、<code>std::accumulate</code>）无缝协作。</p></li></ol><hr><h3 id=核心区别-1>核心区别</h3><h4 id=功能定位><strong>功能定位</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>输入/输出迭代器</strong></th><th><strong>流迭代器</strong></th></tr></thead><tbody><tr><td><strong>目标对象</strong></td><td>泛型容器（如 <code>vector</code>、<code>list</code>）</td><td>流对象（如 <code>cin</code>、<code>cout</code>、文件流）</td></tr><tr><td><strong>数据转换</strong></td><td>直接操作容器元素类型</td><td>需通过流操作符（<code>>></code>/<code>&lt;&lt;</code>）转换数据类型</td></tr><tr><td><strong>终止条件</strong></td><td>依赖容器边界（如 <code>end()</code>）</td><td>依赖流结束符（如 <code>EOF</code> 或用户终止输入）</td></tr></tbody></table></div><h4 id=操作特性><strong>操作特性</strong></h4><p>• <strong>输入流迭代器</strong>（<code>istream_iterator</code>）：
• 通过 <code>operator>></code> 逐元素读取流数据，支持 <code>++</code> 操作，但<strong>仅能单次遍历</strong>，无法回溯。
• 示例：从 <code>cin</code> 读取整数序列到容器：
<code>cpp istream_iterator&lt;int> in_iter(cin), eof; vector&lt;int> vec(in_iter, eof); // 直接通过迭代器范围构造容器</code></p><p>• <strong>输出流迭代器</strong>（<code>ostream_iterator</code>）：
• 通过 <code>operator&lt;&lt;</code> 写入数据到流，支持 <code>*out = value</code> 或 <code>*out++ = value</code> 语法。
• 可指定分隔符（如逗号），适用于格式化输出：
<code>cpp ostream_iterator&lt;int> out_iter(cout, ", "); copy(vec.begin(), vec.end(), out_iter); // 输出：1, 2, 3,</code></p><p>• <strong>流缓冲区迭代器</strong>（如 <code>istreambuf_iterator</code>）：
• 直接操作流缓冲区字符，<strong>不涉及数据类型转换</strong>，性能更高。
• 示例：快速读取文件内容到字符串：
<code>cpp ifstream file("data.txt"); istreambuf_iterator&lt;char> file_iter(file), end; string content(file_iter, end); // 直接读取所有字符</code></p><h4 id=性能与应用场景><strong>性能与应用场景</strong></h4><p>• <strong>输入/输出迭代器</strong>：
• 通用性强，适用于所有支持迭代器的容器。
• 操作时间复杂度为 O(1)（随机访问）或 O(n)（单向遍历）。</p><p>• <strong>流迭代器</strong>：
• 适合流式数据处理（如实时输入、日志输出），但频繁的类型转换可能降低效率。
• 流缓冲区迭代器（<code>istreambuf_iterator</code>/<code>ostreambuf_iterator</code>）通过绕过类型转换提升性能，适用于大文件或高频 I/O 操作。</p><hr><h3 id=典型应用对比>典型应用对比</h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>输入/输出迭代器</strong></th><th><strong>流迭代器</strong></th></tr></thead><tbody><tr><td><strong>容器初始化</strong></td><td>通过 <code>begin()</code>/<code>end()</code> 遍历</td><td>从流直接构造容器（如 <code>vector&lt;int> vec(in_iter, eof)</code>）</td></tr><tr><td><strong>算法交互</strong></td><td>与 <code>std::sort</code>、<code>std::transform</code> 等算法协作</td><td>与 <code>std::copy</code>、<code>std::accumulate</code> 结合实现流-容器数据传输</td></tr><tr><td><strong>文件操作</strong></td><td>需手动打开/关闭文件流</td><td>直接绑定文件流对象，自动处理流状态</td></tr></tbody></table></div><hr><h3 id=总结-1>总结</h3><p>• <strong>联系</strong>：流迭代器是输入/输出迭代器在流操作中的特化实现，遵循相同的接口规范。
• <strong>区别</strong>：流迭代器专为流对象设计，依赖流操作符和终止符，而输入/输出迭代器更泛化，适用于容器操作。<strong>流缓冲区迭代器</strong>在需要高性能字符级 I/O 时更具优势。</p><p>通过合理选择迭代器类型，可平衡功能需求与性能要求，例如在格式化输出时使用 <code>ostream_iterator</code>，在大文件处理时优先选择 <code>istreambuf_iterator</code>。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/leetcode-c/>LeetCode-C</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Oct 22, 2025 16:27 CST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/leetcode-c25-jul/><div class=article-details><h2 class=article-title>【LeetCode-C】25-Jul</h2></div></a></article><article><a href=/p/leetcode-c-containerunorered_map-unorered_set-map-set/><div class=article-details><h2 class=article-title>【LeetCode-C-Container】unorered_map & unorered_set & map & set</h2></div></a></article><article><a href=/p/leetcode-c-containertype-cast/><div class=article-details><h2 class=article-title>【LeetCode-C-Container】type cast</h2></div></a></article><article><a href=/p/leetcode-cprimary/><div class=article-details><h2 class=article-title>【LeetCode-C】Primary</h2></div></a></article><article><a href=/p/leetcode-clambda/><div class=article-details><h2 class=article-title>【LeetCode-C】lambda</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>