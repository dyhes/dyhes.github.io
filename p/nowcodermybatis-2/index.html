<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="#{} 和 $ MyBatis 中的 #{}和 ${}是用于动态 SQL 参数处理的两种重要语法，它们在处理方式、安全性和适用场景上有本质区别。下面这个表格清晰地展示了它们的核心差异。\n对比维度 #{}(预编译占位符) ${}(字符串拼接符) 处理机制 参数化查询，生成预编译语句 (PreparedStatement) 直接字符串替换，生成静态语句 (Statement) 安全性 安全，天然防止 SQL 注入 不安全，存在 SQL 注入风险，需手动校验 性能 高，预编译 SQL 可缓存和复用执行计划 低，每次生成新 SQL，需重新编译 引号处理 自动根据参数类型添加或省略引号（如字符串加单引号，数字不加） 直接替换，不处理引号，需手动添加 主要应用场景 传入 参数值（WHERE 条件值、INSERT/UPDATE 值等） 动态 SQL 片段（表名、列名、ORDER BY 子句等） 💡 使用场景与最佳实践 理解区别的关键在于明确它们各自的适用场景。\n优先使用 #{}的场景\n所有由用户输入或外部传入的 值 都应使用 #{}。这是保证应用安全的第一原则。常见场景包括：\nWHERE 条件中的值：WHERE username = #{name} INSERT/UPDATE 语句中的值：VALUES - **LIKE 模糊查询的值**：虽然有时会看到LIKE &lsquo;%${value}%&rsquo;，但这非常危险。安全做法是在 Java 代码中拼接好通配符String nameParam = &ldquo;%&rdquo; + name + &ldquo;%&rdquo;;，然后传入LIKE #{nameParam}，或使用 SQL 函数LIKE CONCAT(&rsquo;%&rsquo;, #{name}, &lsquo;%&rsquo;)`。 不得已使用 ${}的场景\n"><title>【NowCoder】Mybatis 2</title><link rel=canonical href=https://dyhes.github.io/p/nowcodermybatis-2/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【NowCoder】Mybatis 2"><meta property='og:description' content="#{} 和 $ MyBatis 中的 #{}和 ${}是用于动态 SQL 参数处理的两种重要语法，它们在处理方式、安全性和适用场景上有本质区别。下面这个表格清晰地展示了它们的核心差异。\n对比维度 #{}(预编译占位符) ${}(字符串拼接符) 处理机制 参数化查询，生成预编译语句 (PreparedStatement) 直接字符串替换，生成静态语句 (Statement) 安全性 安全，天然防止 SQL 注入 不安全，存在 SQL 注入风险，需手动校验 性能 高，预编译 SQL 可缓存和复用执行计划 低，每次生成新 SQL，需重新编译 引号处理 自动根据参数类型添加或省略引号（如字符串加单引号，数字不加） 直接替换，不处理引号，需手动添加 主要应用场景 传入 参数值（WHERE 条件值、INSERT/UPDATE 值等） 动态 SQL 片段（表名、列名、ORDER BY 子句等） 💡 使用场景与最佳实践 理解区别的关键在于明确它们各自的适用场景。\n优先使用 #{}的场景\n所有由用户输入或外部传入的 值 都应使用 #{}。这是保证应用安全的第一原则。常见场景包括：\nWHERE 条件中的值：WHERE username = #{name} INSERT/UPDATE 语句中的值：VALUES - **LIKE 模糊查询的值**：虽然有时会看到LIKE &lsquo;%${value}%&rsquo;，但这非常危险。安全做法是在 Java 代码中拼接好通配符String nameParam = &ldquo;%&rdquo; + name + &ldquo;%&rdquo;;，然后传入LIKE #{nameParam}，或使用 SQL 函数LIKE CONCAT(&rsquo;%&rsquo;, #{name}, &lsquo;%&rsquo;)`。 不得已使用 ${}的场景\n"><meta property='og:url' content='https://dyhes.github.io/p/nowcodermybatis-2/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='NowCoder'><meta property='article:published_time' content='2025-10-04T00:00:00+00:00'><meta property='article:modified_time' content='2025-10-08T22:34:47+08:00'><meta name=twitter:title content="【NowCoder】Mybatis 2"><meta name=twitter:description content="#{} 和 $ MyBatis 中的 #{}和 ${}是用于动态 SQL 参数处理的两种重要语法，它们在处理方式、安全性和适用场景上有本质区别。下面这个表格清晰地展示了它们的核心差异。\n对比维度 #{}(预编译占位符) ${}(字符串拼接符) 处理机制 参数化查询，生成预编译语句 (PreparedStatement) 直接字符串替换，生成静态语句 (Statement) 安全性 安全，天然防止 SQL 注入 不安全，存在 SQL 注入风险，需手动校验 性能 高，预编译 SQL 可缓存和复用执行计划 低，每次生成新 SQL，需重新编译 引号处理 自动根据参数类型添加或省略引号（如字符串加单引号，数字不加） 直接替换，不处理引号，需手动添加 主要应用场景 传入 参数值（WHERE 条件值、INSERT/UPDATE 值等） 动态 SQL 片段（表名、列名、ORDER BY 子句等） 💡 使用场景与最佳实践 理解区别的关键在于明确它们各自的适用场景。\n优先使用 #{}的场景\n所有由用户输入或外部传入的 值 都应使用 #{}。这是保证应用安全的第一原则。常见场景包括：\nWHERE 条件中的值：WHERE username = #{name} INSERT/UPDATE 语句中的值：VALUES - **LIKE 模糊查询的值**：虽然有时会看到LIKE &lsquo;%${value}%&rsquo;，但这非常危险。安全做法是在 Java 代码中拼接好通配符String nameParam = &ldquo;%&rdquo; + name + &ldquo;%&rdquo;;，然后传入LIKE #{nameParam}，或使用 SQL 函数LIKE CONCAT(&rsquo;%&rsquo;, #{name}, &lsquo;%&rsquo;)`。 不得已使用 ${}的场景\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#-和->#{} 和 $</a><ol><li><a href=#-使用场景与最佳实践>💡 使用场景与最佳实践</a></li><li><a href=#-安全警示sql注入风险详解>🔒 安全警示：SQL注入风险详解</a></li><li><a href=#-总结>💎 总结</a></li></ol></li><li><a href=#缓存>缓存</a><ol><li><a href=#-一级缓存会话级加速>💾 一级缓存：会话级加速</a></li><li><a href=#-二级缓存应用级共享>🌐 二级缓存：应用级共享</a></li><li><a href=#-缓存协同工作原理与顺序>🔄 缓存协同工作原理与顺序</a></li><li><a href=#-实践建议与常见问题>💡 实践建议与常见问题</a></li></ol></li><li><a href=#缓存层级>缓存层级</a><ol><li><a href=#-如何选择与协同使用>💡 如何选择与协同使用</a></li><li><a href=#-使用缓存的通用注意事项>⚠️ 使用缓存的通用注意事项</a></li><li><a href=#-总结-1>💎 总结</a></li></ol></li><li><a href=#spring-data-jpa-缓存>Spring DATA JPA 缓存</a><ol><li><a href=#-深入理解各级缓存>💾 深入理解各级缓存</a><ol><li><a href=#一级缓存session级别>一级缓存（Session级别）</a></li><li><a href=#二级缓存应用级别>二级缓存（应用级别）</a></li><li><a href=#查询缓存>查询缓存</a></li></ol></li><li><a href=#-缓存的挑战与最佳实践>⚠️ 缓存的挑战与最佳实践</a></li><li><a href=#-在spring-boot中配置二级缓存>💡 在Spring Boot中配置二级缓存</a></li></ol></li><li><a href=#mybatis-plus>Mybatis Plus</a></li><li><a href=#动态-sql>动态 sql</a><ol><li><a href=#-核心标签详解与最佳实践>💡 核心标签详解与最佳实践</a><ol><li><a href=#1><strong>1. <code>&lt;if></code>标签：基础的条件判断</strong></a></li><li><a href=#2><strong>2. <code>&lt;choose></code>标签组：实现多路分支</strong></a></li><li><a href=#3><strong>3. <code>&lt;set></code>标签：优雅的动态更新</strong></a></li><li><a href=#4><strong>4. <code>&lt;foreach></code>标签：处理集合操作</strong></a></li><li><a href=#5><strong>5. <code>&lt;trim></code>标签：更灵活的字符串修剪</strong></a></li></ol></li><li><a href=#-核心优势与使用建议>⚠️ 核心优势与使用建议</a></li></ol></li><li><a href=#底层原理>底层原理</a><ol><li><a href=#-核心组件深度解析>🔎 核心组件深度解析</a></li><li><a href=#-动态-sql-的解析魔法>⚙️ 动态 SQL 的解析魔法</a></li><li><a href=#-总结与价值>💡 总结与价值</a></li></ol></li><li><a href=#mybatis-插件>Mybatis 插件</a><ol><li><a href=#-工作原理与开发步骤>🔧 工作原理与开发步骤</a></li><li><a href=#-常见应用场景>💡 常见应用场景</a></li><li><a href=#-使用注意事项与最佳实践>⚠️ 使用注意事项与最佳实践</a></li><li><a href=#-总结-2>💎 总结</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/arts/ style=background-color:#a7535a;color:>文武艺</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/nowcodermybatis-2/>【NowCoder】Mybatis 2</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Oct 04, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>7 minute read</time></div></footer></div></header><section class=article-content><h2 id=-和->#{} 和 $</h2><p>MyBatis 中的 <code>#{}</code>和 <code>${}</code>是用于动态 SQL 参数处理的两种重要语法，它们在处理方式、安全性和适用场景上有本质区别。下面这个表格清晰地展示了它们的核心差异。</p><div class=table-wrapper><table><thead><tr><th>对比维度</th><th><code>#{}</code>(<strong>预编译占位符</strong>)</th><th><code>${}</code>(<strong>字符串拼接符</strong>)</th></tr></thead><tbody><tr><td><strong>处理机制</strong></td><td>参数化查询，生成预编译语句 (<code>PreparedStatement</code>)</td><td>直接字符串替换，生成静态语句 (<code>Statement</code>)</td></tr><tr><td><strong>安全性</strong></td><td><strong>安全</strong>，天然防止 SQL 注入</td><td><strong>不安全</strong>，存在 SQL 注入风险，需手动校验</td></tr><tr><td><strong>性能</strong></td><td><strong>高</strong>，预编译 SQL 可缓存和复用执行计划</td><td><strong>低</strong>，每次生成新 SQL，需重新编译</td></tr><tr><td><strong>引号处理</strong></td><td>自动根据参数类型添加或省略引号（如字符串加单引号，数字不加）</td><td>直接替换，不处理引号，需手动添加</td></tr><tr><td><strong>主要应用场景</strong></td><td>传入 <strong>参数值</strong>（WHERE 条件值、INSERT/UPDATE 值等）</td><td>动态 <strong>SQL 片段</strong>（表名、列名、ORDER BY 子句等）</td></tr></tbody></table></div><h3 id=-使用场景与最佳实践>💡 使用场景与最佳实践</h3><p>理解区别的关键在于明确它们各自的适用场景。</p><ul><li><p><strong>优先使用 <code>#{}</code>的场景</strong></p><p>所有由用户输入或外部传入的 <strong>值</strong> 都应使用 <code>#{}</code>。这是保证应用安全的第一原则。常见场景包括：</p><ul><li><strong>WHERE 条件中的值</strong>：<code>WHERE username = #{name}</code></li><li><strong>INSERT/UPDATE 语句中的值</strong>：<code>VALUES - **LIKE 模糊查询的值**：虽然有时会看到</code>LIKE &lsquo;%${value}%&rsquo;<code>，但这非常危险。安全做法是在 Java 代码中拼接好通配符</code>String nameParam = &ldquo;%&rdquo; + name + &ldquo;%&rdquo;;<code>，然后传入</code>LIKE #{nameParam}<code>，或使用 SQL 函数</code>LIKE CONCAT(&rsquo;%&rsquo;, #{name}, &lsquo;%&rsquo;)`。</li></ul></li><li><p><strong>不得已使用 <code>${}</code>的场景</strong></p><p>当需要动态改变 SQL 语句的 <strong>结构部分</strong>，而这些部分（如表名、列名）无法作为预编译参数时，才考虑使用 <code>${}</code>。使用时 <strong>必须</strong> 对参数值进行严格的白名单校验。</p><ul><li><strong>动态表名/列名</strong>：在分表场景中，如 <code>SELECT * FROM ${tableName}</code>。</li><li><strong>ORDER BY 排序字段</strong>：如 <code>ORDER BY ${sortField} ${sortOrder}</code>。更安全的做法是用 <code>&lt;choose></code>指令枚举可选字段。</li><li><strong>批量删除的 IN 语句</strong>：<code>DELETE FROM t_car WHERE id IN(${ids})</code>，因为 <code>#{}</code>会将整个 ID 序列视为一个带引号的字符串导致语法错误。</li></ul></li></ul><h3 id=-安全警示sql注入风险详解>🔒 安全警示：SQL注入风险详解</h3><p>这是两者最核心的区别，值得深入理解。</p><ul><li><p><strong><code>#{}</code>为何安全？</strong></p><p>它采用 <strong>预编译</strong> 机制。MyBatis 会先将 <code>#{}</code>解析为 JDBC 的 <code>?</code>占位符，SQL 语句结构先被确定。随后参数值通过 <code>PreparedStatement</code>的 <code>setXxx</code>方法传入，数据库驱动会负责对值进行正确的转义和处理，从根本上杜绝了注入。</p></li><li><p><strong><code>${}</code>为何危险？</strong></p><p>它只是简单的 <strong>字符串拼接</strong>。假设有一条 SQL：<code>SELECT * FROM users WHERE name = '${name}'</code>。如果用户输入的 <code>name</code>值是 <code>' OR '1'='1</code>，拼接后的 SQL 将变为：</p><pre tabindex=0><code>SELECT * FROM users WHERE name = &#39;&#39; OR &#39;1&#39;=&#39;1&#39;
</code></pre><p>这条语句会返回所有用户数据，造成严重的信息泄露。如果参数用于表名等场景，攻击者甚至可能执行删表等破坏性操作。</p></li></ul><h3 id=-总结>💎 总结</h3><p>在选择使用 <code>#{}</code>还是 <code>${}</code>时，请遵循以下原则：</p><ol><li><strong>默认使用 <code>#{}</code></strong>：对于所有传入 <strong>值</strong> 的场景，这是唯一安全的选择。</li><li><strong>谨慎评估 <code>${}</code></strong>：仅在需要动态改变 SQL <strong>关键字或结构</strong>（表名、列名、排序）时使用。</li><li><strong>安全第一</strong>：使用 <code>${}</code>时，必须对传入的参数值进行 <strong>白名单验证</strong>，绝不直接将不可信的用户输入拼接到 SQL 中。</li></ol><p>希望这份详细的对比能帮助你更安全、高效地使用 MyBatis。如果你有关于特定使用场景的疑问，我们可以继续探讨。</p><h2 id=缓存>缓存</h2><p>MyBatis 的缓存机制是提升数据库交互性能的核心特性，它通过两级缓存有效减少数据库访问压力。下面这个表格清晰地展示了其核心构成与区别。</p><div class=table-wrapper><table><thead><tr><th>特性维度</th><th>一级缓存</th><th>二级缓存</th></tr></thead><tbody><tr><td><strong>作用范围</strong></td><td><code>SqlSession</code>级别（同一数据库会话）</td><td><code>Mapper</code>级别（同一命名空间，跨 <code>SqlSession</code>）</td></tr><tr><td><strong>开启方式</strong></td><td><strong>默认开启</strong>，无需配置</td><td>需在全局配置和具体 <code>Mapper.xml</code>中<strong>手动开启</strong></td></tr><tr><td><strong>生命周期</strong></td><td>与 <code>SqlSession</code>绑定，会话关闭则缓存失效</td><td>与整个应用绑定，生命周期更长</td></tr><tr><td><strong>数据共享</strong></td><td><strong>隔离</strong>，不同 <code>SqlSession</code>缓存不共享</td><td><strong>共享</strong>，多个 <code>SqlSession</code>可访问同一缓存</td></tr><tr><td><strong>存储结构</strong></td><td>基于 <code>HashMap</code>的 <code>PerpetualCache</code></td><td>可扩展，支持集成第三方缓存（如 EhCache, Redis）</td></tr></tbody></table></div><h3 id=-一级缓存会话级加速>💾 一级缓存：会话级加速</h3><p>一级缓存是 MyBatis 默认提供的，其设计目标是优化同一数据库会话内的重复查询。</p><ul><li><strong>工作流程与生命周期</strong>：当你执行一次查询时，MyBatis 会为这条查询语句（结合参数等因素）生成一个唯一的键（Key），并将查询结果作为值（Value）存入当前 <code>SqlSession</code>内部的缓存映射（Map）中。此后，在同一会话中执行完全相同的查询时，MyBatis 会直接从这个映射中返回结果，而无需再次访问数据库。一级缓存的生命周期与 <code>SqlSession</code>紧密绑定，当会话通过 <code>close()</code>方法关闭时，缓存也随之销毁。</li><li><strong>缓存失效时机</strong>：为确保数据的一致性，在执行 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>等数据变更操作，或调用 <code>commit()</code>、<code>rollback()</code>方法，以及显式调用 <code>sqlSession.clearCache()</code>时，当前 <code>SqlSession</code>的一级缓存会被<strong>清空</strong>。</li></ul><h3 id=-二级缓存应用级共享>🌐 二级缓存：应用级共享</h3><p>二级缓存的作用域更广，旨在跨会话共享常用数据，适合应用级别的高频只读数据缓存。</p><ul><li><strong>启用与配置</strong>：启用二级缓存需要两步：<ol><li>在 MyBatis 全局配置文件（如 <code>mybatis-config.xml</code>）中确保 <code>&lt;setting name="cacheEnabled" value="true"/></code>（新版本通常默认开启）。</li><li>在需要启用二级缓存的特定 <code>Mapper.xml</code>文件中添加 <code>&lt;cache/></code>标签。你可以在此标签中配置详细的缓存策略，例如 <code>eviction</code>（回收策略，如 LRU、FIFO）、<code>flushInterval</code>（自动刷新间隔）、<code>size</code>（缓存引用数目）和 <code>readOnly</code>（是否只读）等。</li></ol></li><li><strong>工作机制与序列化要求</strong>：二级缓存的工作机制可以概括为：一个 <code>SqlSession</code>查询数据后，在它被关闭或提交时，查询结果会从其一级缓存<strong>转存</strong>到对应的二级缓存区域（以 Mapper 的命名空间划分）。由于这些数据可能需要被序列化到磁盘或在不同会话间传输，因此对应的 Java 实体类<strong>必须实现 <code>Serializable</code>接口</strong>。</li><li><strong>缓存同步与清空</strong>：当执行同命名空间下的增、删、改操作并提交事务后，MyBatis 会自动<strong>清空</strong>该命名空间下的二级缓存，以防止出现脏读。</li></ul><h3 id=-缓存协同工作原理与顺序>🔄 缓存协同工作原理与顺序</h3><p>当同时启用一级和二级缓存时，MyBatis 处理一条查询请求的顺序遵循一个标准的查询流程，如下图所示：</p><pre tabindex=0><code>flowchart TD
    A[执行查询请求] --&gt; B{二级缓存&lt;br&gt;是否命中？}
    B -- 命中 --&gt; C[直接返回数据]
    B -- 未命中 --&gt; D{一级缓存&lt;br&gt;是否命中？}
    D -- 命中 --&gt; E[返回数据至二级缓存]
    D -- 未命中 --&gt; F[查询数据库]
    F --&gt; G[数据存入一级缓存]
    G --&gt; E
    E --&gt; C
</code></pre><p>需要注意的是，在 Spring Boot 等集成环境中，由于 <code>SqlSession</code>的生命周期可能受事务管理器影响，一级缓存的行为可能会有所不同。</p><h3 id=-实践建议与常见问题>💡 实践建议与常见问题</h3><ul><li><strong>适用场景</strong>：<ul><li><strong>一级缓存</strong>：最适合于会话内短期内重复查询相同数据的操作。</li><li><strong>二级缓存</strong>：非常适合读多写少、对数据实时性要求不高的数据，例如系统配置项、静态字典表等。</li></ul></li><li><strong>数据一致性挑战</strong>：二级缓存的主要挑战在于数据一致性。由于缓存是以 <code>namespace</code>（命名空间）为粒度管理的，对表中任何数据的修改都会导致整个命名空间的缓存失效。这在关联查询复杂的场景下可能导致大范围的缓存清空，需要谨慎设计。</li><li><strong>自定义缓存集成</strong>：MyBatis 的缓存接口是开放的，允许你轻松集成更强大、更适合生产环境的第三方缓存库，如 <strong>Redis</strong>（用于分布式缓存）或 <strong>EhCache</strong>（功能丰富的本地缓存）来替代默认实现。这为应对高并发和分布式场景提供了灵活性。</li></ul><p>希望这份详细的介绍能帮助你更好地理解和使用 MyBatis 缓存。如果你对某个特定细节有进一步疑问，我们可以继续深入探讨。</p><h2 id=缓存层级>缓存层级</h2><p>MyBatis缓存和Spring Cache是不同层面的缓存解决方案，它们的核心区别在于作用范围和抽象层级。下面这个表格能帮你快速把握它们的核心差异。</p><div class=table-wrapper><table><thead><tr><th>特性维度</th><th><strong>MyBatis缓存</strong> (持久层缓存)</th><th><strong>Spring Cache</strong> (应用层缓存抽象)</th></tr></thead><tbody><tr><td><strong>核心定位</strong></td><td><strong>ORM框架内部缓存</strong>，专注于缓存SQL查询结果，减少数据库访问</td><td><strong>缓存抽象框架</strong>，提供统一的注解和API，屏蔽不同缓存实现（如Redis、Ehcache）的差异</td></tr><tr><td><strong>作用层级</strong></td><td><strong>持久层（DAO层）</strong>，与<code>SqlSession</code>和<code>Mapper</code>紧密绑定</td><td><strong>业务层（Service层）</strong>，用于缓存方法执行结果</td></tr><tr><td><strong>缓存粒度</strong></td><td><strong>SQL级别</strong>，以查询语句和参数为键缓存结果集</td><td><strong>方法级别</strong>，以方法名和参数为键缓存返回值</td></tr><tr><td><strong>数据共享</strong></td><td><strong>一级缓存</strong>：<code>SqlSession</code>内共享；<strong>二级缓存</strong>：<code>Mapper</code>命名空间内共享</td><td>取决于底层缓存实现（如Redis可跨应用共享，Caffeine则本地使用）</td></tr><tr><td><strong>数据一致性</strong></td><td>与数据库操作天然联动，执行同命名空间的增删改操作会自动清空相关缓存</td><td>需手动配置（如使用<code>@CacheEvict</code>注解），框架无法自动感知数据变更</td></tr></tbody></table></div><h3 id=-如何选择与协同使用>💡 如何选择与协同使用</h3><p>理解区别后，关键在于根据你的业务场景做出合适的选择。</p><ul><li><p><strong>优先使用 MyBatis 缓存的场景</strong></p><ul><li><strong>高频静态数据查询</strong>：非常适合缓存变化极少的数据，例如<strong>字典表、配置信息、城市列表</strong>等。这些数据读多写少，使用MyBatis二级缓存能极大降低数据库压力。</li><li><strong>简单的单表查询</strong>：对于关联关系简单的查询，开启二级缓存能获得很好的性能提升，且不易出现脏数据。</li><li><strong>⚠️ 注意事项</strong>：MyBatis默认的二级缓存是<strong>本地缓存</strong>，在分布式环境下会存在数据不一致问题。生产环境建议通过<code>&lt;cache type="..."></code>配置集成<strong>Redis</strong>或<strong>Ehcache</strong>等分布式/集中式缓存实现。</li></ul></li><li><p><strong>优先使用 Spring Cache 的场景</strong></p><ul><li><strong>缓存业务计算结果</strong>：当某个Service方法需要进行复杂计算（如数据分析、报表生成），但其结果在一段时间内可复用时，使用<code>@Cacheable</code>非常合适。</li><li><strong>调用外部API或复杂查询</strong>：如果方法内部需要调用耗时的第三方接口，或者组合多个DAO查询得到一个复杂结果，缓存整个方法的返回值比只缓存单个DAO查询更高效。</li><li><strong>更灵活的缓存控制</strong>：Spring Cache的<code>unless</code>、<code>condition</code>等属性允许你根据返回值或参数动态决定是否缓存，控制粒度更细。</li></ul></li><li><p><strong>两者协同工作</strong></p><p>在实际项目中，MyBatis缓存和Spring Cache完全可以协同工作，形成多级缓存，进一步提升性能。其协同工作的流程如下图所示：</p></li></ul><pre tabindex=0><code>flowchart TD
    A[业务方法调用] --&gt; B{Spring Cache&lt;br&gt;是否命中?}
    B -- 命中 --&gt; C[直接返回结果]
    B -- 未命中 --&gt; D[执行方法内部逻辑]
    D --&gt; E[调用Mapper方法进行查询]
    E --&gt; F{MyBatis二级缓存&lt;br&gt;是否命中?}
    F -- 命中 --&gt; G[返回查询结果]
    F -- 未命中 --&gt; H{MyBatis一级缓存&lt;br&gt;是否命中?}
    H -- 命中 --&gt; G
    H -- 未命中 --&gt; I[查询数据库]
    I --&gt; G
    G --&gt; J[结果返回至业务方法]
    J --&gt; K[结果存入Spring Cache]
    K --&gt; C
</code></pre><p>举个例子，一个获取商品详情的方法可能内部调用了多个Mapper来组合信息（商品基本信息、SKU列表、商家信息）。你可以：</p><ol><li><p>使用<strong>MyBatis二级缓存</strong>来缓存每个Mapper各自的简单查询结果。</p></li><li><p>使用<strong>Spring Cache</strong>来缓存整个商品详情方法返回的复杂聚合对象。</p><p>这样，当商品基本信息未变，但SKU列表变化时，MyBatis缓存可能局部失效，而Spring Cache整体失效，策略清晰。</p></li></ol><h3 id=-使用缓存的通用注意事项>⚠️ 使用缓存的通用注意事项</h3><ul><li><strong>数据一致性</strong>：这是缓存带来的最大挑战。务必根据业务需求为缓存设置合理的过期时间。</li><li><strong>缓存穿透/击穿/雪崩</strong>：针对这些典型问题，需要采取相应措施，如为不存在的<code>key</code>也设置空值、使用互斥锁、设置不同的过期时间等。</li><li><strong>内存管理</strong>：特别是对于本地缓存，要设置合适的大小和淘汰策略（如LRU），防止内存溢出。</li></ul><h3 id=-总结-1>💎 总结</h3><p>简单来说，<strong>MyBatis缓存是数据访问层的“精细化”缓存，而Spring Cache是业务层的“粗粒度”缓存抽象</strong>。</p><ul><li>如果你的优化目标是<strong>减少重复的数据库查询</strong>，特别是简单的、静态的数据查询，应优先考虑<strong>MyBatis缓存</strong>，尤其是搭配Redis等实现的二级缓存。</li><li>如果你需要缓存的是<strong>复杂的业务逻辑计算结果</strong>，或者希望有一个<strong>统一、灵活、与底层缓存技术无关</strong>的缓存方式，那么<strong>Spring Cache</strong>是更佳选择。</li></ul><p>在很多现代应用中，一种常见的高效模式是：<strong>利用MyBatis（整合Redis）处理DAO层的SQL结果缓存，同时使用Spring Cache处理Service层的业务方法缓存</strong>，两者互补，共同构建高性能的应用架构。</p><p>希望这份详细的对比能帮助你做出更合适的技术决策。</p><h2 id=spring-data-jpa-缓存>Spring DATA JPA 缓存</h2><p>Spring Data JPA 的缓存机制是提升应用性能的重要特性，它通过多级缓存减少数据库访问。下面这个表格清晰地展示了其核心的<strong>三级缓存结构</strong>及其关键特点。</p><div class=table-wrapper><table><thead><tr><th>特性维度</th><th><strong>一级缓存</strong> (Session缓存)</th><th><strong>二级缓存</strong> (SessionFactory缓存)</th><th><strong>查询缓存</strong></th></tr></thead><tbody><tr><td><strong>作用范围</strong></td><td>单个 <code>EntityManager</code>(或事务) 内部</td><td>应用级别，跨 <code>EntityManager</code>共享</td><td>应用级别，缓存特定查询的结果列表</td></tr><tr><td><strong>开启方式</strong></td><td><strong>默认开启</strong>，无需配置</td><td>需<strong>手动开启</strong>并配置缓存提供商（如EhCache）</td><td>需<strong>手动开启</strong>并在查询方法上使用 <code>@QueryHints</code></td></tr><tr><td><strong>缓存内容</strong></td><td>实体对象</td><td>实体对象</td><td>查询语句和参数组合的结果集ID列表</td></tr><tr><td><strong>生命周期</strong></td><td>与 <code>EntityManager</code>绑定，会话结束则缓存失效</td><td>与应用同生命周期，直到缓存过期或被驱逐</td><td>依赖于缓存配置，可在数据变更时失效</td></tr><tr><td><strong>数据共享</strong></td><td><strong>隔离</strong>，无法跨会话共享</td><td><strong>共享</strong>，所有会话可访问</td><td><strong>共享</strong>，所有会话可访问</td></tr></tbody></table></div><h3 id=-深入理解各级缓存>💾 深入理解各级缓存</h3><h4 id=一级缓存session级别>一级缓存（Session级别）</h4><p>一级缓存是Hibernate（JPA的默认实现）内置的，其生命周期与一个<code>EntityManager</code>（大致对应一个数据库会话或事务）绑定。</p><ul><li><strong>工作机制</strong>：在同一会话中，首次根据ID查询某个实体时，数据会从数据库加载并存入一级缓存。后续再次根据相同ID查询时，会直接返回缓存中的同一对象实例（<code>==</code>判断为true）。</li><li><strong>失效与清空</strong>：当执行<code>em.flush()</code>、事务提交或调用<code>em.clear()</code>时，一级缓存会被清空。执行更新操作后，Hibernate会保证缓存与数据库的同步。</li></ul><h4 id=二级缓存应用级别>二级缓存（应用级别）</h4><p>二级缓存是进程或集群范围内的缓存，需要显式开启并配置。</p><ul><li><strong>启用步骤</strong>：<ol><li><strong>添加依赖</strong>：如<code>hibernate-ehcache</code>（如果使用EhCache）。</li><li><strong>配置启用</strong>：在<code>application.properties</code>中设置<code>spring.jpa.properties.hibernate.cache.use_second_level_cache=true</code>并指定缓存区域工厂（如<code>EhCacheRegionFactory</code>）。</li><li><strong>标记可缓存实体</strong>：在实体类上添加<code>@Cacheable</code>和<code>@org.hibernate.annotations.Cache</code>注解来定义缓存策略（如<code>READ_ONLY</code>）。</li></ol></li><li><strong>配置示例</strong>：在<code>ehcache.xml</code>中可以为不同实体配置详细的缓存策略，例如过期时间、内存中最大对象数量等。</li></ul><h4 id=查询缓存>查询缓存</h4><p>查询缓存用于缓存查询结果列表（如<code>List&lt;User></code>），适用于不常变化的列表数据。</p><ul><li><strong>启用与使用</strong>：<ol><li>全局启用：设置<code>spring.jpa.properties.hibernate.cache.use_query_cache=true</code>。</li><li>在查询方法上添加提示：在Repository的自定义查询方法上使用<code>@QueryHints(@QueryHint(name = "org.hibernate.cacheable", value = "true"))</code>。</li></ol></li><li><strong>注意</strong>：查询缓存仅缓存查询结果的主键ID列表。真正的实体对象仍由二级缓存存储，或按需从数据库加载。</li></ul><h3 id=-缓存的挑战与最佳实践>⚠️ 缓存的挑战与最佳实践</h3><p>使用缓存能提升性能，也带来一些挑战，需注意以下几点：</p><ul><li><strong>数据一致性</strong>：这是核心挑战。二级缓存和查询缓存可能导致<strong>脏读</strong>，即缓存数据与数据库实际数据不一致。解决方案包括：<ul><li>在写入、更新或删除数据时，通过<code>@CacheEvict</code>等注解<strong>手动清除相关缓存</strong>。</li><li>为缓存数据设置合理的<strong>过期时间</strong>。</li></ul></li><li><strong>事务与延迟提交</strong>：在事务中，数据的最终提交可能延迟到事务结束时。在此之前，数据库的约束检查可能不会立即触发，使用<code>save</code>方法后立即进行其他操作需留意。必要时可使用<code>saveAndFlush</code>方法立即同步。</li><li><strong>适用场景</strong>：缓存最适合<strong>读多写少</strong>、<strong>数据实时性要求不高</strong>的场景（如系统菜单、配置项）。对于<strong>写操作频繁</strong>或<strong>对数据强一致性要求极高</strong>的场景，需谨慎使用或考虑禁用缓存。</li></ul><h3 id=-在spring-boot中配置二级缓存>💡 在Spring Boot中配置二级缓存</h3><p>在Spring Boot项目中，可以按以下步骤启用和配置二级缓存：</p><ol><li><p><strong>添加依赖</strong>（以EhCache为例）：</p><pre tabindex=0><code>&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-ehcache&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre></li><li><p><strong>配置<code>application.properties</code></strong>：</p><pre tabindex=0><code>spring.jpa.properties.hibernate.cache.use_second_level_cache=true
spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory
# 指定EhCache配置文件路径（如果需要）
spring.jpa.properties.hibernate.cache.provider_configuration_file_resource_path=ehcache.xml
</code></pre></li><li><p><strong>实体类配置</strong>：</p><pre tabindex=0><code>@Entity
@Cacheable
@Cache(usage = CacheConcurrencyStrategy.READ_ONLY) // 例如只读策略
public class User {
    // ... 字段定义
}
</code></pre></li></ol><p>希望这份详细的梳理能帮助你更好地理解和应用Spring Data JPA的缓存机制。如果你对某个特定细节有进一步的疑问，我们可以继续探讨。</p><h2 id=mybatis-plus>Mybatis Plus</h2><div class=table-wrapper><table><thead><tr><th style=text-align:left><strong>特性</strong></th><th style=text-align:left><strong>MyBatis</strong></th><th style=text-align:left><strong>MyBatis-Plus</strong></th></tr></thead><tbody><tr><td style=text-align:left><strong>SQL 编写</strong></td><td style=text-align:left>需手动编写所有 SQL（XML 或注解）</td><td style=text-align:left>内置通用 CRUD，单表操作无需写 SQL</td></tr><tr><td style=text-align:left><strong>条件构造器</strong></td><td style=text-align:left>不支持，需手写动态 SQL</td><td style=text-align:left>提供QueryWrapper、LambdaQueryWrapper等，支持链式调用</td></tr><tr><td style=text-align:left><strong>代码生成</strong></td><td style=text-align:left>无内置支持</td><td style=text-align:left>内置代码生成器，可快速生成 Model、Mapper 等层代码</td></tr><tr><td style=text-align:left><strong>Lambda 支持</strong></td><td style=text-align:left>不支持</td><td style=text-align:left>支持 Lambda 表达式，避免硬编码字段名</td></tr><tr><td style=text-align:left><strong>主键策略</strong></td><td style=text-align:left>需手动配置</td><td style=text-align:left>支持 4 种主键策略（含分布式 ID 生成器）</td></tr><tr><td style=text-align:left><strong>分页插件</strong></td><td style=text-align:left>需手动实现或集成第三方插件</td><td style=text-align:left>内置物理分页插件，简化分页逻辑</td></tr><tr><td style=text-align:left><strong>SQL 注入防护</strong></td><td style=text-align:left>依赖开发者使用#{}占位符</td><td style=text-align:left>内置 SQL 注入剥离器，自动过滤危险字符</td></tr><tr><td style=text-align:left><strong>实体映射注解</strong></td><td style=text-align:left>需手动配置 XML 映射</td><td style=text-align:left>支持@TableName、@TableId等注解，简化表与字段映射</td></tr><tr><td style=text-align:left><strong>全局拦截与插件</strong></td><td style=text-align:left>需自定义拦截器</td><td style=text-align:left>内置全局拦截插件（如防全表删除/更新）</td></tr><tr><td style=text-align:left><strong>性能优化</strong></td><td style=text-align:left>依赖手动优化 SQL</td><td style=text-align:left>支持批量操作、二级缓存等优化</td></tr></tbody></table></div><div class=table-wrapper><table><thead><tr><th style=text-align:left><strong>场景</strong></th><th style=text-align:left><strong>推荐框架</strong></th><th style=text-align:left><strong>理由</strong></th></tr></thead><tbody><tr><td style=text-align:left><strong>复杂 SQL 或存储过程</strong></td><td style=text-align:left>MyBatis</td><td style=text-align:left>灵活控制 SQL，适合对 SQL 性能要求高的场景</td></tr><tr><td style=text-align:left><strong>快速开发单表 CRUD</strong></td><td style=text-align:left>MyBatis-Plus</td><td style=text-align:left>内置通用方法，减少重复代码</td></tr><tr><td style=text-align:left><strong>微服务或分布式项目</strong></td><td style=text-align:left>MyBatis-Plus</td><td style=text-align:left>支持分布式 ID、批量操作等优化</td></tr><tr><td style=text-align:left><strong>需要高度定制化</strong></td><td style=text-align:left>MyBatis</td><td style=text-align:left>原生 MyBatis 更灵活，无额外约束</td></tr></tbody></table></div><h2 id=动态-sql>动态 sql</h2><p>MyBatis 的动态 SQL 是一项强大而实用的功能，它允许你在 XML 映射文件中，根据运行时条件灵活地构建 SQL 语句，完美解决了传统 JDBC 开发中需要手动拼接 SQL 字符串的繁琐和安全隐患。</p><p>下面这个表格汇总了 MyBatis 核心的动态 SQL 标签，帮你快速掌握它们的用途。</p><div class=table-wrapper><table><thead><tr><th>标签名</th><th>核心作用</th><th>关键适用场景</th></tr></thead><tbody><tr><td><strong><code>&lt;if></code></strong></td><td>条件判断，根据表达式结果决定是否包含SQL片段</td><td>可选字段的查询条件、更新操作</td></tr><tr><td><strong><code>&lt;choose>/&lt;when>/&lt;otherwise></code></strong></td><td>多路选择，类似 Java 的 <code>switch-case</code>语句</td><td>多条件互斥，只需满足其中一个的场景</td></tr><tr><td><strong><code>&lt;where></code></strong></td><td>智能处理 <code>WHERE</code>子句，自动添加/移除关键字</td><td>包裹多个条件查询，避免 <code>WHERE</code>后直接跟 <code>AND</code>等语法错误</td></tr><tr><td><strong><code>&lt;set></code></strong></td><td>智能处理 <code>UPDATE</code>语句中的 <code>SET</code>子句，自动去除多余逗号</td><td>动态更新非空字段，实现部分更新</td></tr><tr><td><strong><code>&lt;foreach></code></strong></td><td>遍历集合（如 List、数组），拼接SQL片段</td><td><strong>IN</strong> 查询、批量插入、批量删除等</td></tr><tr><td><strong><code>&lt;trim></code></strong></td><td>自定义修剪SQL语句的前后缀，功能更灵活</td><td>可替代 <code>&lt;where></code>或 <code>&lt;set></code>，处理更复杂的字符串修剪需求</td></tr></tbody></table></div><h3 id=-核心标签详解与最佳实践>💡 核心标签详解与最佳实践</h3><p>掌握每个标签的具体用法和细节，是写出稳健、高效动态 SQL 的关键。</p><h4 id=1><strong>1. <code>&lt;if></code>标签：基础的条件判断</strong></h4><p><code>&lt;if></code>标签是最基础、最常用的标签，通过 <code>test</code>属性指定一个 OGNL 表达式进行条件判断。</p><pre tabindex=0><code>&lt;select id=&#34;findUsers&#34; resultType=&#34;User&#34;&gt;
  SELECT * FROM users
  &lt;where&gt;
    &lt;if test=&#34;username != null and username != &#39;&#39;&#34;&gt;
      AND username LIKE CONCAT(&#39;%&#39;, #{username}, &#39;%&#39;)
    &lt;/if&gt;
    &lt;if test=&#34;status != null&#34;&gt;
      AND status = #{status}
    &lt;/if&gt;
  &lt;/where&gt;
&lt;/select&gt;
</code></pre><p><strong>最佳实践</strong>：将 <code>&lt;if></code>标签包裹在 <code>&lt;where></code>标签内，可以自动处理可能产生的多余 <code>AND</code>或 <code>OR</code>关键字，无需再写 <code>WHERE 1=1</code>。</p><h4 id=2><strong>2. <code>&lt;choose></code>标签组：实现多路分支</strong></h4><p>当你的业务逻辑是“多选一”时，<code>&lt;choose></code>标签组比一连串的 <code>&lt;if></code>标签更清晰。</p><pre tabindex=0><code>&lt;select id=&#34;findUserByPriority&#34; resultType=&#34;User&#34;&gt;
  SELECT * FROM users
  &lt;where&gt;
    &lt;choose&gt;
      &lt;!-- 优先级1: 优先用id精确查找 --&gt;
      &lt;when test=&#34;id != null&#34;&gt;
        id = #{id}
      &lt;/when&gt;
      &lt;!-- 优先级2: 其次用用户名模糊匹配 --&gt;
      &lt;when test=&#34;username != null and username != &#39;&#39;&#34;&gt;
        username LIKE CONCAT(&#39;%&#39;, #{username}, &#39;%&#39;)
      &lt;/when&gt;
      &lt;!-- 默认情况: 查询活跃用户 --&gt;
      &lt;otherwise&gt;
        status = &#39;ACTIVE&#39;
      &lt;/otherwise&gt;
    &lt;/choose&gt;
  &lt;/where&gt;
&lt;/select&gt;
</code></pre><p><strong>注意</strong>：<code>&lt;choose></code>结构内，一旦某个 <code>&lt;when></code>的条件满足，就会执行其SQL片段，并且跳过其余分支。</p><h4 id=3><strong>3. <code>&lt;set></code>标签：优雅的动态更新</strong></h4><p><code>&lt;set></code>标签专用于 <code>UPDATE</code>语句，能够智能地处理 <code>SET</code>子句末尾可能因 <code>&lt;if></code>条件不成立而产生的多余逗号。</p><pre tabindex=0><code>&lt;update id=&#34;updateUser&#34; parameterType=&#34;User&#34;&gt;
  UPDATE user
  &lt;set&gt;
    &lt;if test=&#34;username != null&#34;&gt;
      username = #{username},
    &lt;/if&gt;
    &lt;if test=&#34;age != null&#34;&gt;
      age = #{age},
    &lt;/if&gt;
    &lt;if test=&#34;email != null&#34;&gt;
      email = #{email},
    &lt;/if&gt;
  &lt;/set&gt;
  WHERE id = #{id}
&lt;/update&gt;
</code></pre><p><strong>风险提示</strong>：务必确保至少有一个更新字段不为空，否则会生成 <code>UPDATE user SET WHERE id=?</code>的错误SQL。通常会在业务层进行校验。</p><h4 id=4><strong>4. <code>&lt;foreach></code>标签：处理集合操作</strong></h4><p><code>&lt;foreach></code>标签功能强大，常用于 <strong>IN</strong> 查询和批量操作。其属性配置是关键：</p><ul><li><code>collection</code>: 指定要遍历的集合参数名。如果接口方法参数是 <code>List</code>，默认名为 <code>list</code>；是数组，默认名为 <code>array</code>。推荐使用 <code>@Param</code>注解明确命名。</li><li><code>item</code>: 循环中当前元素的变量名。</li><li><code>open</code>/<code>close</code>: 循环内容包装的前缀和后缀符号。</li><li><code>separator</code>: 各元素间的分隔符。</li></ul><p><strong>批量 IN 查询示例</strong>：</p><pre tabindex=0><code>&lt;select id=&#34;selectUserByIds&#34; resultType=&#34;User&#34;&gt;
  SELECT * FROM user 
  WHERE id IN
  &lt;foreach collection=&#34;idList&#34; item=&#34;id&#34; open=&#34;(&#34; close=&#34;)&#34; separator=&#34;,&#34;&gt;
    #{id}
  &lt;/foreach&gt;
&lt;/select&gt;
</code></pre><p><strong>批量插入示例</strong>：</p><pre tabindex=0><code>&lt;insert id=&#34;batchInsert&#34;&gt;
  INSERT INTO user (name, age) VALUES
  &lt;foreach collection=&#34;userList&#34; item=&#34;user&#34; separator=&#34;,&#34;&gt;
    (#{user.name}, #{user.age})
  &lt;/foreach&gt;
&lt;/insert&gt;
</code></pre><h4 id=5><strong>5. <code>&lt;trim></code>标签：更灵活的字符串修剪</strong></h4><p><code>&lt;trim></code>标签是一个多功能标签，可以自定义地添加前缀、后缀，并覆盖（移除）不必要的前后缀，用它可以实现 <code>&lt;where></code>和 <code>&lt;set></code>的功能。</p><p><strong>用 <code>&lt;trim></code>模拟 <code>&lt;where></code>标签</strong>：</p><pre tabindex=0><code>&lt;trim prefix=&#34;WHERE&#34; prefixOverrides=&#34;AND |OR &#34;&gt;
  ...
&lt;/trim&gt;
</code></pre><p><strong>用 <code>&lt;trim></code>模拟 <code>&lt;set></code>标签</strong>：</p><pre tabindex=0><code>&lt;trim prefix=&#34;SET&#34; suffixOverrides=&#34;,&#34;&gt;
  ...
&lt;/trim&gt;
</code></pre><h3 id=-核心优势与使用建议>⚠️ 核心优势与使用建议</h3><ol><li><strong>根本优势</strong>：动态 SQL 最大的价值在于<strong>减少代码冗余</strong>。一个动态 SQL 模板可以替代传统 JDBC 中需要为不同条件组合编写的多个 SQL 变体，极大提高了灵活性和可维护性。</li><li><strong>安全基石</strong>：MyBatis 动态 SQL 与 <code>#{}</code>参数占位符紧密结合，所有参数都通过预编译处理，从根本上<strong>防止了 SQL 注入攻击</strong>，切勿使用 <code>${}</code>进行字符串拼接。</li><li><strong>性能考量</strong>：虽然动态 SQL 带来了灵活性，但过于复杂的动态 SQL 可能会影响 SQL 优化器的索引选择。建议结合数据库的 <strong><code>EXPLAIN</code></strong> 命令对生成的实际 SQL 进行性能分析。</li></ol><p>希望这份详细的介绍能帮助你深入理解并有效运用 MyBatis 的动态 SQL。如果你在具体实践中有任何疑问，欢迎随时提出。</p><h2 id=底层原理>底层原理</h2><p>MyBatis 是一款优秀的半自动化 ORM 框架，其核心价值在于将 Java 对象与数据库操作灵活地关联起来，同时将开发者从繁琐的 JDBC 代码中解放出来。为了让你对 MyBatis 的底层原理有一个全局的认识，我们先通过下面这张图来了解其核心架构和一次 SQL 执行的完整流程。</p><pre tabindex=0><code>flowchart TD
    A[配置文件&lt;br&gt;mybatis-config.xml] --&gt; B(Configuration&lt;br&gt;配置中心)
    C[Mapper文件&lt;br&gt;Mapper.xml] --&gt; B
    B --&gt; D[SqlSessionFactory&lt;br&gt;会话工厂]
    D --&gt; E[SqlSession&lt;br&gt;会话接口]
    E --&gt; F[Executor&lt;br&gt;执行器]
    F --&gt; G[MappedStatement&lt;br&gt;SQL封装]
    G --&gt; H[StatementHandler&lt;br&gt;语句处理器]
    H --&gt; I[ParameterHandler&lt;br&gt;参数处理器]
    I --&gt; J[(Database)]
    J --&gt; K[ResultSetHandler&lt;br&gt;结果集处理器]
    K --&gt; L[Result Object&lt;br&gt;结果对象]
    L --&gt; E
</code></pre><p>上图清晰地展示了 MyBatis 内部各核心组件的协作关系。下面，我们来详细解析图中的每一步，特别是这些核心组件各自扮演的角色。</p><h3 id=-核心组件深度解析>🔎 核心组件深度解析</h3><ol><li><p><strong>SqlSessionFactory 与 SqlSession</strong></p><ul><li><strong>SqlSessionFactory</strong> 是 MyBatis 的“会话工厂”，其职责是创建 <code>SqlSession</code>。它是线程安全的，通常在应用生命周期内只有一个实例（单例），通过 <code>SqlSessionFactoryBuilder</code>解析全局配置文件（<code>mybatis-config.xml</code>）构建而成。所有配置信息最终都被封装到一个全局的 <code>Configuration</code>对象中。</li><li><strong>SqlSession</strong> 是 MyBatis 最顶层的面向用户的 API，代表了一次与数据库的会话。它提供了 <code>selectOne</code>, <code>insert</code>等方法。<strong>注意：</strong> <code>SqlSession</code>的实例是<strong>非线程安全</strong>的，因此其生命周期应局限于方法或请求内部，使用完毕后必须正确关闭。</li></ul></li><li><p><strong>Executor – 执行引擎</strong></p><p><code>SqlSession</code>本身并不直接执行 SQL，而是将工作委托给 <strong>Executor</strong>（执行器）。它是 MyBatis 的调度核心，主要负责：</p><ul><li><strong>SQL 执行</strong>：调用底层数据库操作。</li><li><strong>缓存管理</strong>：维护<strong>一级缓存</strong>（默认开启，作用于同一个 <code>SqlSession</code>生命周期）和<strong>二级缓存</strong>（需手动开启，作用于 <code>SqlSessionFactory</code>级别，可跨会话共享）。上图所示的执行流程，在 <code>Executor</code>层面会优先查询缓存。</li></ul></li><li><p><strong>MappedStatement – SQL 指令库</strong></p><p>它是对 Mapper XML 文件中一个 SQL 语句（如 <code>&lt;select></code>标签）的完整封装。<code>Executor</code>执行时，会根据语句的 ID 从 <code>Configuration</code>中获取对应的 <code>MappedStatement</code>，其中包含了 SQL 源码、输入输出参数类型、缓存策略等所有元信息。</p></li><li><p><strong>StatementHandler – SQL 语句操作员</strong></p><p><code>Executor</code>会将具体的数据库操作交给 <strong>StatementHandler</strong>。它是对 JDBC <code>Statement</code>的直接封装，负责：</p><ul><li>向数据库发起调用，执行 SQL。</li><li>创建 <code>ParameterHandler</code>和 <code>ResultSetHandler</code>来处理参数和结果。</li></ul></li><li><p><strong>ParameterHandler 与 ResultSetHandler – 数据转换专家</strong></p><ul><li><strong>ParameterHandler</strong>：负责将传入的 Java 对象参数，按照规则转换成 JDBC <code>PreparedStatement</code>所需的参数值（例如，将 <code>java.util.Date</code>转换为 <code>java.sql.Timestamp</code>）。</li><li><strong>ResultSetHandler</strong>：负责将 JDBC 返回的 <code>ResultSet</code>结果集转换为 Java 对象（如 <code>List&lt;User></code>）。这是 MyBatis ORM 魔力的最终体现。</li></ul></li></ol><h3 id=-动态-sql-的解析魔法>⚙️ 动态 SQL 的解析魔法</h3><p>MyBatis 的强大之处在于其动态 SQL 能力。它允许在 XML 中编写包含条件判断、循环等逻辑的 SQL 语句。这个过程主要由 <code>SqlSource</code>和 <code>SqlNode</code>协作完成：</p><ul><li><strong>拼接阶段</strong>：MyBatis 会将 XML 中的 SQL 标签（如 <code>&lt;if></code>, <code>&lt;foreach></code>）和文本解析成一棵由 <strong>SqlNode</strong> 组成的语法树。执行时，根据传入的参数，遍历这棵树动态地拼接出最终的 SQL 字符串（此阶段会处理 <code>${}</code>和动态标签）。</li><li><strong>解析阶段</strong>：拼接好的 SQL 字符串（此时 <code>#{}</code>仍保留）会被传递给 <strong>SqlSource</strong>，它负责将 <code>#{}</code>解析为 JDBC 的 <code>?</code>占位符，并生成包含 SQL 和参数映射信息的 <code>BoundSql</code>对象，供 <code>StatementHandler</code>使用。</li></ul><h3 id=-总结与价值>💡 总结与价值</h3><p>通过以上的剖析，我们可以看到 MyBatis 底层原理的精髓在于：<strong>通过清晰的分层和组件化设计，将复杂的 JDBC 操作标准化、模块化</strong>。它不仅保留了 JDBC 的性能优势和对 SQL 的精准控制力，还通过动态 SQL、类型处理器、插件等机制提供了极大的灵活性和扩展性。</p><p>希望这份详细的介绍能帮助你深入理解 MyBatis 的工作机制。如果你对某个特定细节还有疑问，我们可以继续探讨。</p><h2 id=mybatis-插件>Mybatis 插件</h2><p>MyBatis 插件是其框架提供的一种强大扩展机制，允许你在不修改核心代码的情况下，拦截并增强 MyBatis 内部核心组件的行为，从而实现自定义功能。下面通过一个表格快速了解其核心组件和拦截点：</p><div class=table-wrapper><table><thead><tr><th>核心组件</th><th>角色描述</th><th>可拦截的关键方法示例</th></tr></thead><tbody><tr><td><strong><code>Executor</code></strong></td><td>SQL 执行的“发动机”，负责增删改查操作及事务管理。</td><td><code>update</code>, <code>query</code>, <code>commit</code>, <code>rollback</code></td></tr><tr><td><strong><code>StatementHandler</code></strong></td><td>处理 JDBC <code>Statement</code>的“翻译官”，负责 SQL 预编译和参数设置。</td><td><code>prepare</code>, <code>parameterize</code>, <code>batch</code>, <code>update</code>, <code>query</code></td></tr><tr><td><strong><code>ParameterHandler</code></strong></td><td>给 SQL 语句“喂参数”的“小助手”，将 Java 对象转换为 JDBC 参数。</td><td><code>setParameters</code>, <code>getParameterObject</code></td></tr><tr><td><strong><code>ResultSetHandler</code></strong></td><td>将结果集“转成 Java 对象”的“转换器”，处理查询结果映射。</td><td><code>handleResultSets</code>, <code>handleOutputParameters</code></td></tr></tbody></table></div><h3 id=-工作原理与开发步骤>🔧 工作原理与开发步骤</h3><p>MyBatis 插件的核心原理是 <strong>动态代理</strong>。当你在配置文件中注册一个插件后，MyBatis 在启动时会为这些核心组件创建代理对象。当方法被调用时，会先经过插件的 <code>intercept</code>方法，你可以在其中插入自定义逻辑，再决定是否继续执行原始方法 。</p><p>开发一个自定义插件通常只需三步：</p><ol><li><p><strong>实现接口与注解配置</strong></p><p>创建一个类实现 <code>org.apache.ibatis.plugin.Interceptor</code>接口，核心是重写 <code>intercept</code>方法。使用 <code>@Intercepts</code>和 <code>@Signature</code>注解精确指定要拦截的方法 。</p><pre tabindex=0><code>@Intercepts({
    @Signature(type = StatementHandler.class, method = &#34;prepare&#34;, args = {Connection.class, Integer.class})
})
public class SqlStatsInterceptor implements Interceptor {
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        long startTime = System.currentTimeMillis();
        try {
            // 执行原始方法
            return invocation.proceed();
        } finally {
            long costTime = System.currentTimeMillis() - startTime;
            System.out.println(&#34;SQL 执行耗时: &#34; + costTime + &#34;ms&#34;);
            // 实际项目中可将统计信息发送至监控系统
        }
    }
}
</code></pre></li><li><p><strong>注册插件</strong></p><p>让 MyBatis 知道并加载这个插件。</p><ul><li><strong>XML 配置</strong>（传统方式）：在 <code>mybatis-config.xml</code>中配置 。</li><li><strong>Java 代码配置</strong>（Spring Boot 项目）：通过 <code>@Bean</code>定义 <code>SqlSessionFactory</code>并设置插件 。</li></ul></li><li><p><strong>（可选）接收配置参数</strong></p><p>如果插件需要可配置项，可以重写 <code>setProperties</code>方法。在 XML 配置中通过 <code>&lt;property></code>标签传递的参数会封装到 <code>Properties</code>对象并传入此方法 。</p></li></ol><h3 id=-常见应用场景>💡 常见应用场景</h3><p>插件机制非常灵活，常见的应用场景包括：</p><ul><li><strong>性能监控与 SQL 日志记录</strong>：拦截 <code>StatementHandler</code>的 <code>prepare</code>方法或 <code>Executor</code>的 <code>query/update</code>方法，记录完整的 SQL 语句、参数和执行时间，帮助发现慢查询 。</li><li><strong>数据加密与脱敏</strong>：拦截 <code>ParameterHandler</code>的 <code>setParameters</code>方法，在数据入库前自动加密敏感字段（如密码）；拦截 <code>ResultSetHandler</code>的 <code>handleResultSets</code>方法，在数据查询出来后自动解密 。</li><li><strong>分页功能</strong>：拦截 <code>Executor</code>的 <code>query</code>方法，根据分页参数自动重写和执行统计总数的 SQL 及分页 SQL。知名的 PageHelper 插件就是基于此原理 。</li><li><strong>动态数据源与权限控制</strong>：在多租户等场景下，拦截 SQL 执行过程，根据当前上下文动态添加租户 ID 等过滤条件，实现数据隔离 。</li></ul><h3 id=-使用注意事项与最佳实践>⚠️ 使用注意事项与最佳实践</h3><ul><li><strong>拦截目标要精准</strong>：<code>@Signature</code>注解的参数必须精确匹配，避免拦截不必要的方法影响性能或导致错误 。</li><li><strong>注意插件执行顺序</strong>：多个插件会按注册顺序形成“代理链”。如果插件间有依赖关系，需要注意它们的注册顺序 。</li><li><strong>保持插件逻辑轻量</strong>：插件的 <code>intercept</code>方法会在每次目标方法调用时执行，应避免在此处进行复杂的计算或远程调用，以免成为性能瓶颈。非核心逻辑可考虑异步处理 。</li><li><strong>避免循环代理</strong>：在重写 <code>plugin</code>方法时，确保不会对同一个目标对象进行重复代理，否则可能导致栈溢出 。</li></ul><h3 id=-总结-2>💎 总结</h3><p>MyBatis 插件机制通过动态代理，为我们提供了一种非侵入式的、强大的框架扩展能力。无论是简单的 SQL 监控，还是复杂的业务逻辑如数据加密和分页，都可以通过插件优雅地实现。</p><p>希望这份详细的介绍能帮助你理解和运用 MyBatis 插件。如果你在具体实现过程中遇到问题，可以随时提出。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/nowcoder/>NowCoder</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Oct 08, 2025 22:34 CST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/nowcoderreference/><div class=article-details><h2 class=article-title>【NowCoder】Reference</h2></div></a></article><article><a href=/p/nowcoder25-oct/><div class=article-details><h2 class=article-title>【NowCoder】25 Oct</h2></div></a></article><article><a href=/p/nowcoderkafka-2/><div class=article-details><h2 class=article-title>【NowCoder】Kafka 2</h2></div></a></article><article><a href=/p/nowcoderredis-2/><div class=article-details><h2 class=article-title>【NowCoder】Redis 2</h2></div></a></article><article><a href=/p/nowcodernetwork-2/><div class=article-details><h2 class=article-title>【NowCoder】Network 2</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>