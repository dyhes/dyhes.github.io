<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="字符串匹配 以下是主流字符串匹配算法的系统梳理，涵盖核心思想、时间复杂度、适用场景及优缺点，结合技术原理与工程实践综合呈现：\n📊 算法分类与概览 算法类型 代表算法 时间复杂度 核心思想 适用场景 基本算法 暴力匹配 (Brute Force) O(m*n) 逐字符比较 短文本、简单场景 单模式匹配 KMP O(m+n) 失效函数避免回溯 通用场景、理论教学 Boyer-Moore (BM) O(n/m) ~ O(m*n) 反向匹配+双启发规则 长模式串、实际应用 Sunday O(n/m) 平均 BM改进+关注下一字符 快速匹配、中长文本 Rabin-Karp O(n*m) 平均 哈希值比较 多模式匹配基础 多模式匹配 Trie树 O(m) 建树, O(n) 匹配 前缀树结构 词典匹配、单词查询 Aho-Corasick (AC自动机) O(n+m+k) Trie+KMP思想 敏感词过滤、病毒检测 🔍 基本匹配算法：暴力法 (Brute Force) 原理：主串从每个字符开始与模式串逐位比较，失败后主串回溯到下一位置重新匹配1,3。 时间复杂度：最坏 O(m*n)（m, n为模式串和主串长度）。 优点：实现简单，短文本效率高。 缺点：长文本效率低，回溯冗余。 代码示例（Java）： for (int i = 0; i <= n - m; i++) { int j = 0; while (j < m && text[i+j] == pattern[j]) j++; if (j == m) return i; // 匹配成功 } ⚙️ 经典单模式匹配算法 KMP算法 (Knuth-Morris-Pratt) 核心思想：利用部分匹配表（next数组）记录模式串前缀后缀的最长公共长度。匹配失败时，模式串右移位数 = 已匹配字符数 - next[j]，避免主串回溯6,7,8。 关键步骤： 预处理：计算next数组（O(m)）。 匹配：主串指针不回溯，模式串按next数组跳跃（O(n)）。 时间复杂度：O(m+n)。 优势：理论高效，适合模式串较长场景。 局限性：实现复杂，实际性能常低于BM3。 Boyer-Moore (BM)算法 核心思想： 反向匹配（从模式串末尾开始） + 双启发规则： 坏字符规则 (Bad Character)：主串中不匹配的字符若不在模式串中，则跳过整个模式串；若存在，则对齐模式串中最右出现位置。 好后缀规则 (Good Suffix)：已匹配的后缀子串在模式串中再次出现时，对齐其最右位置。 移动策略：取两规则计算值的最大值。 时间复杂度： 最坏 O(m*n)（如全相同字符）。 平均 O(n/m)（跳跃性强）9,10。 优势：工业级高效（如grep工具），长模式串优势显著。 缺点：预处理开销大。 Rabin-Karp算法 核心思想：将模式串哈希值 H(p) 与主串中每个长度为m的子串哈希值比较。若哈希值相等，则进一步验证字符匹配2,4。 优化：滚动哈希（如多项式哈希），使相邻子串哈希值计算 O(1)。 时间复杂度：平均 O(n+m)，最坏 O(m*n)（哈希冲突时）。 适用场景：多模式匹配基础（如AC自动机预处理）。 ⚡ 高效单模式变种 Sunday算法 改进点：BM的简化版，匹配失败时关注主串中下一字符： 若该字符不在模式串中，跳过模式串长度+1。 若存在，对齐模式串中最右出现位置3,10。 优势：实现简单，平均性能优于BM（尤其英文文本）3。 Horspool算法 简化BM：仅用坏字符规则，且对齐模式串中最右字符（非任意字符）1,10。 适用场景：中等长度模式串。 🌐 多模式匹配算法 Trie树 (字典树) 原理：将模式集构建树结构，边为字符。匹配时沿树遍历主串，到达叶节点即匹配成功4,5。 时间复杂度：建树 O(M)（M为模式集总长），匹配 O(n)。 局限：仅适用精确匹配，内存占用高。 Aho-Corasick (AC自动机) 核心思想：Trie + KMP的next数组： Fail指针：匹配失败时跳转到最长后缀前缀节点（类似KMP）4,5。 时间复杂度：O(n + m + k)（k为匹配次数）。 应用：敏感词过滤（如腾讯内容安全服务）5。 🛠️ 应用场景与选型建议 短文本/简单场景：暴力法（如Java String.indexOf()）2。 单模式长文本：BM/Sunday（如文本编辑器搜索）9,10。 多模式匹配：AC自动机（如敏感词过滤）4,5。 动态模式集：Rabin-Karp（可扩展性高）2。 💡 性能提示：实际效率受字符集分布（如DNA序列用BM跳跃强）、模式串长度、硬件缓存等因素影响。例如，短模式串时暴力法常优于KMP1,3。 如需特定算法代码实现（如BM的坏字符表构建、AC自动机的Fail指针生成），可进一步提供语言和场景说明。\n"><title>【DSA】KMP & BM & Sunday</title><link rel=canonical href=https://dyhes.github.io/p/dsakmp-bm-sunday/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【DSA】KMP & BM & Sunday"><meta property='og:description' content="字符串匹配 以下是主流字符串匹配算法的系统梳理，涵盖核心思想、时间复杂度、适用场景及优缺点，结合技术原理与工程实践综合呈现：\n📊 算法分类与概览 算法类型 代表算法 时间复杂度 核心思想 适用场景 基本算法 暴力匹配 (Brute Force) O(m*n) 逐字符比较 短文本、简单场景 单模式匹配 KMP O(m+n) 失效函数避免回溯 通用场景、理论教学 Boyer-Moore (BM) O(n/m) ~ O(m*n) 反向匹配+双启发规则 长模式串、实际应用 Sunday O(n/m) 平均 BM改进+关注下一字符 快速匹配、中长文本 Rabin-Karp O(n*m) 平均 哈希值比较 多模式匹配基础 多模式匹配 Trie树 O(m) 建树, O(n) 匹配 前缀树结构 词典匹配、单词查询 Aho-Corasick (AC自动机) O(n+m+k) Trie+KMP思想 敏感词过滤、病毒检测 🔍 基本匹配算法：暴力法 (Brute Force) 原理：主串从每个字符开始与模式串逐位比较，失败后主串回溯到下一位置重新匹配1,3。 时间复杂度：最坏 O(m*n)（m, n为模式串和主串长度）。 优点：实现简单，短文本效率高。 缺点：长文本效率低，回溯冗余。 代码示例（Java）： for (int i = 0; i <= n - m; i++) { int j = 0; while (j < m && text[i+j] == pattern[j]) j++; if (j == m) return i; // 匹配成功 } ⚙️ 经典单模式匹配算法 KMP算法 (Knuth-Morris-Pratt) 核心思想：利用部分匹配表（next数组）记录模式串前缀后缀的最长公共长度。匹配失败时，模式串右移位数 = 已匹配字符数 - next[j]，避免主串回溯6,7,8。 关键步骤： 预处理：计算next数组（O(m)）。 匹配：主串指针不回溯，模式串按next数组跳跃（O(n)）。 时间复杂度：O(m+n)。 优势：理论高效，适合模式串较长场景。 局限性：实现复杂，实际性能常低于BM3。 Boyer-Moore (BM)算法 核心思想： 反向匹配（从模式串末尾开始） + 双启发规则： 坏字符规则 (Bad Character)：主串中不匹配的字符若不在模式串中，则跳过整个模式串；若存在，则对齐模式串中最右出现位置。 好后缀规则 (Good Suffix)：已匹配的后缀子串在模式串中再次出现时，对齐其最右位置。 移动策略：取两规则计算值的最大值。 时间复杂度： 最坏 O(m*n)（如全相同字符）。 平均 O(n/m)（跳跃性强）9,10。 优势：工业级高效（如grep工具），长模式串优势显著。 缺点：预处理开销大。 Rabin-Karp算法 核心思想：将模式串哈希值 H(p) 与主串中每个长度为m的子串哈希值比较。若哈希值相等，则进一步验证字符匹配2,4。 优化：滚动哈希（如多项式哈希），使相邻子串哈希值计算 O(1)。 时间复杂度：平均 O(n+m)，最坏 O(m*n)（哈希冲突时）。 适用场景：多模式匹配基础（如AC自动机预处理）。 ⚡ 高效单模式变种 Sunday算法 改进点：BM的简化版，匹配失败时关注主串中下一字符： 若该字符不在模式串中，跳过模式串长度+1。 若存在，对齐模式串中最右出现位置3,10。 优势：实现简单，平均性能优于BM（尤其英文文本）3。 Horspool算法 简化BM：仅用坏字符规则，且对齐模式串中最右字符（非任意字符）1,10。 适用场景：中等长度模式串。 🌐 多模式匹配算法 Trie树 (字典树) 原理：将模式集构建树结构，边为字符。匹配时沿树遍历主串，到达叶节点即匹配成功4,5。 时间复杂度：建树 O(M)（M为模式集总长），匹配 O(n)。 局限：仅适用精确匹配，内存占用高。 Aho-Corasick (AC自动机) 核心思想：Trie + KMP的next数组： Fail指针：匹配失败时跳转到最长后缀前缀节点（类似KMP）4,5。 时间复杂度：O(n + m + k)（k为匹配次数）。 应用：敏感词过滤（如腾讯内容安全服务）5。 🛠️ 应用场景与选型建议 短文本/简单场景：暴力法（如Java String.indexOf()）2。 单模式长文本：BM/Sunday（如文本编辑器搜索）9,10。 多模式匹配：AC自动机（如敏感词过滤）4,5。 动态模式集：Rabin-Karp（可扩展性高）2。 💡 性能提示：实际效率受字符集分布（如DNA序列用BM跳跃强）、模式串长度、硬件缓存等因素影响。例如，短模式串时暴力法常优于KMP1,3。 如需特定算法代码实现（如BM的坏字符表构建、AC自动机的Fail指针生成），可进一步提供语言和场景说明。\n"><meta property='og:url' content='https://dyhes.github.io/p/dsakmp-bm-sunday/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='DSA'><meta property='article:published_time' content='2025-06-29T00:00:00+00:00'><meta property='article:modified_time' content='2025-10-22T16:27:30+08:00'><meta name=twitter:title content="【DSA】KMP & BM & Sunday"><meta name=twitter:description content="字符串匹配 以下是主流字符串匹配算法的系统梳理，涵盖核心思想、时间复杂度、适用场景及优缺点，结合技术原理与工程实践综合呈现：\n📊 算法分类与概览 算法类型 代表算法 时间复杂度 核心思想 适用场景 基本算法 暴力匹配 (Brute Force) O(m*n) 逐字符比较 短文本、简单场景 单模式匹配 KMP O(m+n) 失效函数避免回溯 通用场景、理论教学 Boyer-Moore (BM) O(n/m) ~ O(m*n) 反向匹配+双启发规则 长模式串、实际应用 Sunday O(n/m) 平均 BM改进+关注下一字符 快速匹配、中长文本 Rabin-Karp O(n*m) 平均 哈希值比较 多模式匹配基础 多模式匹配 Trie树 O(m) 建树, O(n) 匹配 前缀树结构 词典匹配、单词查询 Aho-Corasick (AC自动机) O(n+m+k) Trie+KMP思想 敏感词过滤、病毒检测 🔍 基本匹配算法：暴力法 (Brute Force) 原理：主串从每个字符开始与模式串逐位比较，失败后主串回溯到下一位置重新匹配1,3。 时间复杂度：最坏 O(m*n)（m, n为模式串和主串长度）。 优点：实现简单，短文本效率高。 缺点：长文本效率低，回溯冗余。 代码示例（Java）： for (int i = 0; i <= n - m; i++) { int j = 0; while (j < m && text[i+j] == pattern[j]) j++; if (j == m) return i; // 匹配成功 } ⚙️ 经典单模式匹配算法 KMP算法 (Knuth-Morris-Pratt) 核心思想：利用部分匹配表（next数组）记录模式串前缀后缀的最长公共长度。匹配失败时，模式串右移位数 = 已匹配字符数 - next[j]，避免主串回溯6,7,8。 关键步骤： 预处理：计算next数组（O(m)）。 匹配：主串指针不回溯，模式串按next数组跳跃（O(n)）。 时间复杂度：O(m+n)。 优势：理论高效，适合模式串较长场景。 局限性：实现复杂，实际性能常低于BM3。 Boyer-Moore (BM)算法 核心思想： 反向匹配（从模式串末尾开始） + 双启发规则： 坏字符规则 (Bad Character)：主串中不匹配的字符若不在模式串中，则跳过整个模式串；若存在，则对齐模式串中最右出现位置。 好后缀规则 (Good Suffix)：已匹配的后缀子串在模式串中再次出现时，对齐其最右位置。 移动策略：取两规则计算值的最大值。 时间复杂度： 最坏 O(m*n)（如全相同字符）。 平均 O(n/m)（跳跃性强）9,10。 优势：工业级高效（如grep工具），长模式串优势显著。 缺点：预处理开销大。 Rabin-Karp算法 核心思想：将模式串哈希值 H(p) 与主串中每个长度为m的子串哈希值比较。若哈希值相等，则进一步验证字符匹配2,4。 优化：滚动哈希（如多项式哈希），使相邻子串哈希值计算 O(1)。 时间复杂度：平均 O(n+m)，最坏 O(m*n)（哈希冲突时）。 适用场景：多模式匹配基础（如AC自动机预处理）。 ⚡ 高效单模式变种 Sunday算法 改进点：BM的简化版，匹配失败时关注主串中下一字符： 若该字符不在模式串中，跳过模式串长度+1。 若存在，对齐模式串中最右出现位置3,10。 优势：实现简单，平均性能优于BM（尤其英文文本）3。 Horspool算法 简化BM：仅用坏字符规则，且对齐模式串中最右字符（非任意字符）1,10。 适用场景：中等长度模式串。 🌐 多模式匹配算法 Trie树 (字典树) 原理：将模式集构建树结构，边为字符。匹配时沿树遍历主串，到达叶节点即匹配成功4,5。 时间复杂度：建树 O(M)（M为模式集总长），匹配 O(n)。 局限：仅适用精确匹配，内存占用高。 Aho-Corasick (AC自动机) 核心思想：Trie + KMP的next数组： Fail指针：匹配失败时跳转到最长后缀前缀节点（类似KMP）4,5。 时间复杂度：O(n + m + k)（k为匹配次数）。 应用：敏感词过滤（如腾讯内容安全服务）5。 🛠️ 应用场景与选型建议 短文本/简单场景：暴力法（如Java String.indexOf()）2。 单模式长文本：BM/Sunday（如文本编辑器搜索）9,10。 多模式匹配：AC自动机（如敏感词过滤）4,5。 动态模式集：Rabin-Karp（可扩展性高）2。 💡 性能提示：实际效率受字符集分布（如DNA序列用BM跳跃强）、模式串长度、硬件缓存等因素影响。例如，短模式串时暴力法常优于KMP1,3。 如需特定算法代码实现（如BM的坏字符表构建、AC自动机的Fail指针生成），可进一步提供语言和场景说明。\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#字符串匹配>字符串匹配</a><ol><li><a href=#-算法分类与概览>📊 <strong>算法分类与概览</strong></a></li><li><a href=#-基本匹配算法暴力法-brute-force>🔍 <strong>基本匹配算法：暴力法 (Brute Force)</strong></a></li><li><a href=#-经典单模式匹配算法>⚙️ <strong>经典单模式匹配算法</strong></a><ol><li><a href=#kmp算法-knuth-morris-pratt><strong>KMP算法 (Knuth-Morris-Pratt)</strong></a></li><li><a href=#boyer-moore-bm算法><strong>Boyer-Moore (BM)算法</strong></a></li><li><a href=#rabin-karp算法><strong>Rabin-Karp算法</strong></a></li></ol></li><li><a href=#-高效单模式变种>⚡ <strong>高效单模式变种</strong></a><ol><li><a href=#sunday算法><strong>Sunday算法</strong></a></li><li><a href=#horspool算法><strong>Horspool算法</strong></a></li></ol></li><li><a href=#-多模式匹配算法>🌐 <strong>多模式匹配算法</strong></a><ol><li><a href=#trie树-字典树><strong>Trie树 (字典树)</strong></a></li><li><a href=#aho-corasick-ac自动机><strong>Aho-Corasick (AC自动机)</strong></a></li></ol></li><li><a href=#-应用场景与选型建议>🛠️ <strong>应用场景与选型建议</strong></a></li></ol></li><li><a href=#kmp>KMP</a><ol><li><a href=#-算法核心思想>🔍 <strong>算法核心思想</strong></a><ol><li><a href=#解决暴力匹配的缺陷><strong>解决暴力匹配的缺陷</strong></a></li><li><a href=#关键概念最长相同前后缀><strong>关键概念：最长相同前后缀</strong></a></li></ol></li><li><a href=#-next数组部分匹配表>⚙️ <strong>next数组（部分匹配表）</strong></a><ol><li><a href=#next数组的定义><strong>next数组的定义</strong></a></li><li><a href=#next数组的构建步骤><strong>next数组的构建步骤</strong></a></li></ol></li><li><a href=#-匹配流程>🔄 <strong>匹配流程</strong></a></li><li><a href=#-性能分析>📊 <strong>性能分析</strong></a><ol><li><a href=#与bm算法对比><strong>与BM算法对比</strong>：</a></li></ol></li><li><a href=#-优缺点与应用场景>⚖️ <strong>优缺点与应用场景</strong></a><ol><li><a href=#-优点>✅ <strong>优点</strong>：</a></li><li><a href=#-缺点>❌ <strong>缺点</strong>：</a></li><li><a href=#-应用场景>🛠️ <strong>应用场景</strong>：</a></li></ol></li><li><a href=#-代码实现python示例>💻 <strong>代码实现（Python示例）</strong></a></li><li><a href=#-总结>💎 <strong>总结</strong></a></li></ol></li><li><a href=#bm>BM</a><ol><li><a href=#-算法概述>🔍 算法概述</a><ol><li><a href=#-核心特征>⚡ 核心特征：</a></li></ol></li><li><a href=#-核心规则详解>⚙️ 核心规则详解</a><ol><li><a href=#坏字符规则><strong>坏字符规则</strong></a></li><li><a href=#好后缀规则><strong>好后缀规则</strong></a></li><li><a href=#-规则应用优先级>📊 规则应用优先级：</a></li></ol></li><li><a href=#-算法执行流程>🔄 算法执行流程</a></li><li><a href=#-复杂度分析>📈 复杂度分析</a></li><li><a href=#-优缺点与应用场景-1>⚖️ 优缺点与应用场景</a><ol><li><a href=#-优势>✅ <strong>优势</strong>：</a></li><li><a href=#-局限>❌ <strong>局限</strong>：</a></li><li><a href=#-适用场景>🛠️ <strong>适用场景</strong>：</a></li></ol></li><li><a href=#-完整python示例>💻 完整Python示例</a></li><li><a href=#-总结-1>💎 总结</a></li></ol></li><li><a href=#sunday>Sunday</a><ol><li><a href=#-算法概述-1>🔍 <strong>算法概述</strong></a><ol><li><a href=#-核心特征-1>⚡ <strong>核心特征</strong>：</a></li></ol></li><li><a href=#-算法原理与匹配流程>⚙️ <strong>算法原理与匹配流程</strong></a><ol><li><a href=#预处理构建移动表shift-table><strong>预处理：构建移动表（Shift Table）</strong></a></li><li><a href=#匹配过程><strong>匹配过程</strong></a></li></ol></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/nutrition/ style=background-color:#93b5cf;color:>积雪粮</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/dsakmp-bm-sunday/>【DSA】KMP & BM & Sunday</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 29, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>7 minute read</time></div></footer></div></header><section class=article-content><h2 id=字符串匹配>字符串匹配</h2><p>以下是主流字符串匹配算法的系统梳理，涵盖核心思想、时间复杂度、适用场景及优缺点，结合技术原理与工程实践综合呈现：</p><hr><h3 id=-算法分类与概览>📊 <strong>算法分类与概览</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>算法类型</strong></th><th><strong>代表算法</strong></th><th><strong>时间复杂度</strong></th><th><strong>核心思想</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>基本算法</strong></td><td>暴力匹配 (Brute Force)</td><td>O(m*n)</td><td>逐字符比较</td><td>短文本、简单场景</td></tr><tr><td><strong>单模式匹配</strong></td><td>KMP</td><td>O(m+n)</td><td>失效函数避免回溯</td><td>通用场景、理论教学</td></tr><tr><td></td><td>Boyer-Moore (BM)</td><td>O(n/m) ~ O(m*n)</td><td>反向匹配+双启发规则</td><td>长模式串、实际应用</td></tr><tr><td></td><td>Sunday</td><td>O(n/m) 平均</td><td>BM改进+关注下一字符</td><td>快速匹配、中长文本</td></tr><tr><td></td><td>Rabin-Karp</td><td>O(n*m) 平均</td><td>哈希值比较</td><td>多模式匹配基础</td></tr><tr><td><strong>多模式匹配</strong></td><td>Trie树</td><td>O(m) 建树, O(n) 匹配</td><td>前缀树结构</td><td>词典匹配、单词查询</td></tr><tr><td></td><td>Aho-Corasick (AC自动机)</td><td>O(n+m+k)</td><td>Trie+KMP思想</td><td>敏感词过滤、病毒检测</td></tr></tbody></table></div><hr><h3 id=-基本匹配算法暴力法-brute-force>🔍 <strong>基本匹配算法：暴力法 (Brute Force)</strong></h3><ul><li><strong>原理</strong>：主串从每个字符开始与模式串逐位比较，失败后主串回溯到下一位置重新匹配<a class=link href=@ref>1,3</a>。</li><li><strong>时间复杂度</strong>：最坏 O(m*n)（m, n为模式串和主串长度）。</li><li><strong>优点</strong>：实现简单，短文本效率高。</li><li><strong>缺点</strong>：长文本效率低，回溯冗余。</li><li>代码示例（Java）：<pre tabindex=0><code>for (int i = 0; i &lt;= n - m; i++) {
    int j = 0;
    while (j &lt; m &amp;&amp; text[i+j] == pattern[j]) j++;
    if (j == m) return i; // 匹配成功
}
</code></pre></li></ul><hr><h3 id=-经典单模式匹配算法>⚙️ <strong>经典单模式匹配算法</strong></h3><h4 id=kmp算法-knuth-morris-pratt><strong>KMP算法 (Knuth-Morris-Pratt)</strong></h4><ul><li><strong>核心思想</strong>：利用<strong>部分匹配表</strong>（next数组）记录模式串前缀后缀的最长公共长度。匹配失败时，模式串右移位数 = 已匹配字符数 - next[j]，避免主串回溯<a class=link href=@ref>6,7,8</a>。</li><li>关键步骤：<ul><li><strong>预处理</strong>：计算next数组（O(m)）。</li><li><strong>匹配</strong>：主串指针不回溯，模式串按next数组跳跃（O(n)）。</li></ul></li><li><strong>时间复杂度</strong>：O(m+n)。</li><li><strong>优势</strong>：理论高效，适合模式串较长场景。</li><li><strong>局限性</strong>：实现复杂，实际性能常低于BM<a class=link href=@ref>3</a>。</li></ul><h4 id=boyer-moore-bm算法><strong>Boyer-Moore (BM)算法</strong></h4><ul><li>核心思想：
反向匹配（从模式串末尾开始） + 双启发规则：<ul><li><strong>坏字符规则 (Bad Character)</strong>：主串中不匹配的字符若不在模式串中，则跳过整个模式串；若存在，则对齐模式串中最右出现位置。</li><li><strong>好后缀规则 (Good Suffix)</strong>：已匹配的后缀子串在模式串中再次出现时，对齐其最右位置。</li></ul></li><li><strong>移动策略</strong>：取两规则计算值的最大值。</li><li>时间复杂度：<ul><li>最坏 O(m*n)（如全相同字符）。</li><li>平均 O(n/m)（跳跃性强）<a class=link href=@ref>9,10</a>。</li></ul></li><li><strong>优势</strong>：工业级高效（如<code>grep</code>工具），长模式串优势显著。</li><li><strong>缺点</strong>：预处理开销大。</li></ul><h4 id=rabin-karp算法><strong>Rabin-Karp算法</strong></h4><ul><li><strong>核心思想</strong>：将模式串哈希值 H(p) 与主串中每个长度为m的子串哈希值比较。若哈希值相等，则进一步验证字符匹配<a class=link href=@ref>2,4</a>。</li><li><strong>优化</strong>：滚动哈希（如多项式哈希），使相邻子串哈希值计算 O(1)。</li><li><strong>时间复杂度</strong>：平均 O(n+m)，最坏 O(m*n)（哈希冲突时）。</li><li><strong>适用场景</strong>：多模式匹配基础（如AC自动机预处理）。</li></ul><hr><h3 id=-高效单模式变种>⚡ <strong>高效单模式变种</strong></h3><h4 id=sunday算法><strong>Sunday算法</strong></h4><ul><li>改进点：BM的简化版，匹配失败时关注主串中下一字符：<ul><li>若该字符不在模式串中，跳过模式串长度+1。</li><li>若存在，对齐模式串中最右出现位置<a class=link href=@ref>3,10</a>。</li></ul></li><li><strong>优势</strong>：实现简单，平均性能优于BM（尤其英文文本）<a class=link href=@ref>3</a>。</li></ul><h4 id=horspool算法><strong>Horspool算法</strong></h4><ul><li><strong>简化BM</strong>：仅用坏字符规则，且对齐模式串中最右字符（非任意字符）<a class=link href=@ref>1,10</a>。</li><li><strong>适用场景</strong>：中等长度模式串。</li></ul><hr><h3 id=-多模式匹配算法>🌐 <strong>多模式匹配算法</strong></h3><h4 id=trie树-字典树><strong>Trie树 (字典树)</strong></h4><ul><li><strong>原理</strong>：将模式集构建树结构，边为字符。匹配时沿树遍历主串，到达叶节点即匹配成功<a class=link href=@ref>4,5</a>。</li><li><strong>时间复杂度</strong>：建树 O(M)（M为模式集总长），匹配 O(n)。</li><li><strong>局限</strong>：仅适用精确匹配，内存占用高。</li></ul><h4 id=aho-corasick-ac自动机><strong>Aho-Corasick (AC自动机)</strong></h4><ul><li>核心思想：Trie + KMP的next数组：<ul><li><strong>Fail指针</strong>：匹配失败时跳转到最长后缀前缀节点（类似KMP）<a class=link href=@ref>4,5</a>。</li></ul></li><li><strong>时间复杂度</strong>：O(n + m + k)（k为匹配次数）。</li><li><strong>应用</strong>：敏感词过滤（如腾讯内容安全服务）<a class=link href=@ref>5</a>。</li></ul><hr><h3 id=-应用场景与选型建议>🛠️ <strong>应用场景与选型建议</strong></h3><ol><li><strong>短文本/简单场景</strong>：暴力法（如Java <code>String.indexOf()</code>）<a class=link href=@ref>2</a>。</li><li><strong>单模式长文本</strong>：BM/Sunday（如文本编辑器搜索）<a class=link href=@ref>9,10</a>。</li><li><strong>多模式匹配</strong>：AC自动机（如敏感词过滤）<a class=link href=@ref>4,5</a>。</li><li><strong>动态模式集</strong>：Rabin-Karp（可扩展性高）<a class=link href=@ref>2</a>。</li></ol><blockquote><p>💡 <strong>性能提示</strong>：实际效率受字符集分布（如DNA序列用BM跳跃强）、模式串长度、硬件缓存等因素影响。例如，短模式串时暴力法常优于KMP<a class=link href=@ref>1,3</a>。
如需特定算法代码实现（如BM的坏字符表构建、AC自动机的Fail指针生成），可进一步提供语言和场景说明。</p></blockquote><h2 id=kmp>KMP</h2><p>KMP算法（Knuth-Morris-Pratt算法）是一种高效的<strong>单模式字符串匹配算法</strong>，由Donald Knuth、Vaughan Pratt和James H. Morris于1977年联合提出。其核心思想是通过预处理模式串生成<strong>部分匹配表（next数组）</strong>，在匹配失败时避免主串回溯，仅调整模式串的位置，将时间复杂度优化至<strong>O(n+m)</strong>（n为主串长度，m为模式串长度）。以下是详细解析：</p><hr><h3 id=-算法核心思想>🔍 <strong>算法核心思想</strong></h3><h4 id=解决暴力匹配的缺陷><strong>解决暴力匹配的缺陷</strong></h4><ul><li><strong>暴力匹配（Brute-Force）</strong>：主串与模式串逐字符比较，失败时主串回溯至起始位置+1，模式串复位，时间复杂度 <strong>O(m×n)</strong><a class=link href=@ref>3,10</a>。</li><li><strong>KMP优化</strong>：匹配失败时，主串指针不回溯，模式串利用 <strong>next数组</strong> 跳转到<strong>最长相同前后缀</strong>的下一位置继续匹配，减少无效比较<a class=link href=@ref>1,8</a>。</li></ul><h4 id=关键概念最长相同前后缀><strong>关键概念：最长相同前后缀</strong></h4><ul><li><strong>前缀</strong>：不包含最后一个字符的子串（如"ABC"的前缀为"A"、&ldquo;AB&rdquo;）。</li><li><strong>后缀</strong>：不包含第一个字符的子串（如"ABC"的后缀为"BC"、&ldquo;C&rdquo;）。</li><li><strong>最长相同前后缀</strong>：如"ABABA"的最长相同前后缀为"ABA"（长度3）<a class=link href=@ref>3,10</a>。</li></ul><hr><h3 id=-next数组部分匹配表>⚙️ <strong>next数组（部分匹配表）</strong></h3><h4 id=next数组的定义><strong>next数组的定义</strong></h4><ul><li><code>next[j]</code>表示：模式串下标<code>0~j</code>的子串中，<strong>最长相同前后缀的长度</strong>。
​<strong>示例</strong>​：模式串<code>"ABABC"</code>的next数组为<code>[0,0,1,2,0]</code><a class=link href=@ref>2,8</a>。</li></ul><h4 id=next数组的构建步骤><strong>next数组的构建步骤</strong></h4><ul><li><strong>初始化</strong>：<code>next[0] = 0</code>（单字符无前后缀），指针<code>i=1</code>（后缀尾），<code>j=0</code>（前缀尾）。</li><li>迭代计算：<ul><li>若<code>pattern[i] == pattern[j]</code>，则<code>j++</code>，<code>next[i] = j</code>，<code>i++</code>。</li><li>若不等且<code>j > 0</code>，则<code>j = next[j-1]</code>（回退至上一匹配位置）。</li><li>若<code>j = 0</code>，则<code>next[i] = 0</code>，<code>i++</code><a class=link href=@ref>8,10</a>。
<strong>构建过程示例（模式串：&ldquo;ABABA&rdquo;）</strong>：<div class=table-wrapper><table><thead><tr><th>字符索引</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>字符</td><td>A</td><td>B</td><td>A</td><td>B</td><td>A</td></tr><tr><td>next值</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td></tr></tbody></table></div></li></ul></li></ul><hr><h3 id=-匹配流程>🔄 <strong>匹配流程</strong></h3><ol><li><strong>初始化指针</strong>：主串指针<code>i=0</code>，模式串指针<code>j=0</code>。</li><li>逐字符比较：<ul><li>若<code>text[i] == pattern[j]</code>，则<code>i++</code>, <code>j++</code>。</li></ul></li></ol><ul><li>若<code>j = m</code>（模式串完全匹配），记录位置，并令<code>j = next[j-1]</code>继续搜索。<ul><li>若字符不等且<code>j > 0</code>，则<code>j = next[j-1]</code>（模式串跳转）。</li></ul></li><li>若<code>j = 0</code>，则<code>i++</code>（主串后移）<a class=link href=@ref>4,8</a>。
<strong>匹配示例</strong>：</li><li>主串：<pre tabindex=0><code>&#34;ABABABCABAB&#34;
</code></pre>，模式串：<pre tabindex=0><code>&#34;ABABC&#34;
</code></pre><ul><li>匹配至<code>i=4</code>（主串&rsquo;C&rsquo;≠模式串&rsquo;B&rsquo;）→ <code>j = next[3] = 2</code> → 跳过"AB"比较，继续匹配<a class=link href=@ref>4</a>。</li></ul></li></ul><hr><h3 id=-性能分析>📊 <strong>性能分析</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>指标</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>时间复杂度</strong></td><td>预处理：<strong>O(m)</strong>，匹配：<strong>O(n)</strong>，总计 <strong>O(n+m)</strong><a class=link href=@ref>1,8</a>。</td></tr><tr><td><strong>空间复杂度</strong></td><td>需存储<code>next</code>数组：<strong>O(m)</strong><a class=link href=@ref>1</a>。</td></tr><tr><td><strong>对比暴力匹配</strong></td><td>避免主串回溯，尤其适合<strong>模式串重复度高</strong>或<strong>主串极长</strong>的场景<a class=link href=@ref>3</a>。</td></tr></tbody></table></div><h4 id=与bm算法对比><strong>与BM算法对比</strong>：</h4><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>KMP</strong></th><th><strong>BM（Boyer-Moore）</strong></th></tr></thead><tbody><tr><td><strong>匹配方向</strong></td><td>从左向右</td><td>从右向左</td></tr><tr><td><strong>跳跃能力</strong></td><td>依赖next数组，跳跃较保守</td><td>双启发规则（坏字符+好后缀），跳跃性强</td></tr><tr><td><strong>适用场景</strong></td><td>小字符集、模式串重复度高</td><td>大字符集（如英文、DNA序列）</td></tr></tbody></table></div><hr><h3 id=-优缺点与应用场景>⚖️ <strong>优缺点与应用场景</strong></h3><h4 id=-优点>✅ <strong>优点</strong>：</h4><ol><li><strong>理论高效</strong>：最坏情况下仍保持线性时间复杂度。</li><li><strong>无回溯</strong>：主串指针单向移动，适合流式数据处理<a class=link href=@ref>4</a>。</li></ol><h4 id=-缺点>❌ <strong>缺点</strong>：</h4><ol><li><strong>空间开销</strong>：需存储<code>next</code>数组，模式串极长时可能影响性能。</li><li><strong>实现复杂</strong>：理解<code>next</code>数组构建逻辑有一定门槛。</li><li><strong>特定场景低效</strong>：模式串无重复时（如"ABCDE"），性能接近暴力匹配<a class=link href=@ref>1,3</a>。</li></ol><h4 id=-应用场景>🛠️ <strong>应用场景</strong>：</h4><ul><li><strong>文本编辑器</strong>：查找/替换功能（如VS Code）。</li><li><strong>生物信息学</strong>：DNA序列模式匹配（如"ATCG"重复片段检测）。</li><li><strong>网络安全</strong>：病毒特征码扫描<a class=link href=@ref>8,9</a>。</li></ul><hr><h3 id=-代码实现python示例>💻 <strong>代码实现（Python示例）</strong></h3><pre tabindex=0><code>def kmp_search(text, pattern):
    def build_next(p):
        next_arr = [0] * len(p)
        j = 0  # 前缀尾指针
        for i in range(1, len(p)):  # i为后缀尾指针
            while j &gt; 0 and p[i] != p[j]:
                j = next_arr[j-1]  # 回退至上一匹配位置
            if p[i] == p[j]:
                j += 1
            next_arr[i] = j
        return next_arr

    next_arr = build_next(pattern)
    i, j = 0, 0  # 主串和模式串指针
    res = []
    while i &lt; len(text):
        if text[i] == pattern[j]:
            i += 1
            j += 1
        elif j &gt; 0:
            j = next_arr[j-1]  # 模式串跳转
        else:
            i += 1  # 主串后移
        if j == len(pattern):  # 完全匹配
            res.append(i - j)
            j = next_arr[j-1]  # 继续搜索下一匹配
    return res

# 测试
text = &#34;ABABABABCABAB&#34;
pattern = &#34;ABABC&#34;
print(kmp_search(text, pattern))  # 输出: [2]（匹配起始位置）
</code></pre><hr><h3 id=-总结>💎 <strong>总结</strong></h3><p>KMP算法通过 <strong>预处理模式串</strong> 生成<code>next</code>数组，在匹配失败时<strong>智能跳转模式串位置</strong>，避免主串回溯，实现了高效的字符串匹配。尽管在模式串无重复时优势减弱，但其理论完备性和线性时间复杂度使其在<strong>重复模式匹配</strong>、<strong>流式数据处理</strong>等场景中不可替代。理解<code>next</code>数组的构建逻辑（即<strong>最长相同前后缀</strong>）是掌握该算法的关键，而结合具体场景选择KMP或BM等算法，能进一步提升工程效率<a class=link href=@ref>1,8,9</a>。</p><h2 id=bm>BM</h2><p>以下是关于BM（Boyer-Moore）算法的详细解析，结合其核心原理、规则实现、复杂度分析及代码示例进行系统阐述：</p><hr><h3 id=-算法概述>🔍 算法概述</h3><p>BM算法由Bob Boyer和J Strother Moore于1977年提出，是一种<strong>高效的单模式字符串匹配算法</strong>。其核心思想是通过<strong>反向匹配</strong>（从模式串末尾向前比较）和<strong>启发式跳跃规则</strong>，跳过不必要的字符比较，显著提升匹配效率。实际应用中（如文本编辑器、<code>grep</code>工具），其性能通常优于KMP算法3-5倍<a class=link href=@ref>3,6</a>。</p><h4 id=-核心特征>⚡ 核心特征：</h4><ol><li><strong>反向匹配</strong>：从模式串末尾向前比较字符。</li><li>双启发规则：<ul><li><strong>坏字符规则</strong>（Bad Character Rule）</li><li><strong>好后缀规则</strong>（Good Suffix Rule）</li></ul></li><li><strong>跳跃式移动</strong>：失败时根据规则计算最大跳跃距离，避免逐字符移动。</li></ol><hr><h3 id=-核心规则详解>⚙️ 核心规则详解</h3><h4 id=坏字符规则><strong>坏字符规则</strong></h4><p>当模式串与文本串字符不匹配时，文本串中的该字符称为<strong>坏字符</strong>。规则通过预处理记录模式串中每个字符的最后出现位置，计算跳跃距离：</p><ul><li>Case 1：坏字符在模式串中存在跳跃距离 = 坏字符在模式串中的当前位置 - 该字符在模式串中最后一次出现的位置。<ul><li><em>示例</em>：模式串<code>"EXAMPLE"</code>，坏字符<code>'P'</code>在位置6，其最后出现位置为4 → 跳跃距离 = 6-4=2<a class=link href=@ref>8</a>。</li></ul></li><li><strong>Case 2</strong>：坏字符不在模式串中
直接跳跃整个模式串长度（<code>m</code>位）<a class=link href=@ref>3</a>。
<strong>预处理</strong>：构建坏字符表<code>bc[]</code>（数组下标为字符ASCII值，值为最后出现位置）：</li></ul><pre tabindex=0><code>def build_bc(pattern):
    bc = [-1] * 256  # 初始化所有字符位置为-1
    for i, char in enumerate(pattern):
        bc[ord(char)] = i  # 更新字符最后出现位置
    return bc
</code></pre><h4 id=好后缀规则><strong>好后缀规则</strong></h4><p>当模式串后缀与文本串匹配但前一个字符失配时，该后缀称为<strong>好后缀</strong>。规则分三种情况处理：</p><ul><li><strong>Case 1</strong>：好后缀在模式串前部再次出现
将最靠右的匹配子串与好后缀对齐<a class=link href=@ref>4,6</a>。</li><li><strong>Case 2</strong>：无完整匹配，但好后缀的后缀与模式串前缀匹配
将最长匹配前缀对齐好后缀后缀<a class=link href=@ref>6</a>。</li><li><strong>Case 3</strong>：无任何匹配
直接跳跃整个模式串长度（<code>m</code>位）<a class=link href=@ref>4</a>。
<strong>预处理</strong>：构建好后缀表<code>gs[]</code>（需先计算后缀数组<code>suff[i]</code>，表示以<code>i</code>结尾的子串与模式串后缀的最长匹配长度）：</li></ul><pre tabindex=0><code>def build_gs(pattern):
    m = len(pattern)
    suff = [0] * m
    gs = [m] * m  # 初始化为m（Case 3）
    
    # 计算suff数组
    suff[m-1] = m
    for i in range(m-2, -1, -1):
        k = 0
        while (i - k &gt;= 0 and pattern[i - k] == pattern[m-1 - k]):
            k += 1
        suff[i] = k
    
    # 更新gs数组（Case 1 &amp; 2）
    j = 0
    for i in range(m-1, -1, -1):
        if suff[i] == i+1:  # 前缀=后缀
            while j &lt; m-1-i:
                gs[j] = m-1-i
                j += 1
    for i in range(m-1):
        gs[m-1-suff[i]] = m-1-i  # Case 1
    return gs
</code></pre><h4 id=-规则应用优先级>📊 规则应用优先级：</h4><p>每次失配时，取两规则计算的跳跃距离<strong>最大值</strong>：
<code>jump = max(bc_shift, gs_shift)</code><a class=link href=@ref>3,6</a>。</p><hr><h3 id=-算法执行流程>🔄 算法执行流程</h3><ol><li>预处理：<ul><li>构建坏字符表<code>bc[]</code>（时间复杂度<code>O(m)</code>）</li><li>构建好后缀表<code>gs[]</code>（时间复杂度<code>O(m)</code>）</li></ul></li><li>匹配阶段：<ul><li>模式串与文本串右对齐，从右向左比较字符。</li><li>若完全匹配，记录位置并右移继续搜索。</li><li>若失配，按<code>max(bc_shift, gs_shift)</code>跳跃<a class=link href=@ref>5,6</a>。
<strong>伪代码</strong>：</li></ul></li></ol><pre tabindex=0><code>def bm_search(text, pattern):
    bc = build_bc(pattern)
    gs = build_gs(pattern)
    n, m = len(text), len(pattern)
    i = 0  # 文本串当前对齐位置
    
    while i &lt;= n - m:
        j = m - 1  # 从模式串末尾开始比较
        while j &gt;= 0 and text[i+j] == pattern[j]:
            j -= 1
        if j &lt; 0:  # 完全匹配
            print(&#34;Match at:&#34;, i)
            i += gs[0]  # 继续搜索下一位置
        else:
            # 计算坏字符跳跃距离
            bc_shift = j - bc.get(ord(text[i+j]), -1)
            # 计算好后缀跳跃距离
            gs_shift = gs[j] 
            i += max(bc_shift, gs_shift, 1)  # 至少移动1位
    return -1
</code></pre><hr><h3 id=-复杂度分析>📈 复杂度分析</h3><div class=table-wrapper><table><thead><tr><th><strong>指标</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>预处理时间</strong></td><td><code>O(m + σ)</code>（σ为字符集大小，如ASCII为256）<a class=link href=@ref>5</a></td></tr><tr><td><strong>匹配时间</strong></td><td>最好<code>O(n/m)</code>（如全坏字符跳跃），最坏<code>O(mn)</code>（如重复字符）<a class=link href=@ref>3,6</a></td></tr><tr><td><strong>空间占用</strong></td><td><code>O(m + σ)</code>（存储<code>bc[]</code>和<code>gs[]</code>）<a class=link href=@ref>5</a></td></tr><tr><td><strong>典型场景</strong>：</td><td></td></tr></tbody></table></div><ul><li><strong>高跳跃性</strong>：模式串较长且字符分布分散时，性能接近<code>O(n/m)</code>。</li><li><strong>低效场景</strong>：模式串为重复字符（如<code>"AAAA"</code>），退化至<code>O(mn)</code><a class=link href=@ref>6</a>。</li></ul><hr><h3 id=-优缺点与应用场景-1>⚖️ 优缺点与应用场景</h3><h4 id=-优势>✅ <strong>优势</strong>：</h4><ol><li><strong>实际效率高</strong>：长模式串下比KMP快3-5倍，尤其在英文文本中<a class=link href=@ref>3,6</a>。</li><li><strong>跳跃能力强</strong>：坏字符规则在字符集大时效果显著（如DNA序列）。</li></ol><h4 id=-局限>❌ <strong>局限</strong>：</h4><ol><li>预处理开销大，短模式串时不如暴力法。</li><li>实现复杂，需维护两个预处理数组。</li></ol><h4 id=-适用场景>🛠️ <strong>适用场景</strong>：</h4><ul><li>文本编辑器（如VS Code、Sublime的搜索功能）</li><li>病毒扫描（高效匹配特征码）</li><li>大字符集数据（如生物信息学中的基因序列匹配）</li></ul><hr><h3 id=-完整python示例>💻 完整Python示例</h3><pre tabindex=0><code>def boyer_moore(text, pattern):
    def build_bc(p):
        bc = [-1] * 256
        for i, c in enumerate(p):
            bc[ord(c)] = i
        return bc

    def build_gs(p):
        m = len(p)
        gs = [m] * m
        suff = [0] * m
        suff[m-1] = m
        
        # 计算suff数组
        for i in range(m-2, -1, -1):
            k = 0
            while (i - k &gt;= 0 and p[i - k] == p[m-1 - k]):
                k += 1
            suff[i] = k
        
        # Case 1 &amp; 2更新
        j = 0
        for i in range(m-1, -1, -1):
            if suff[i] == i + 1:
                while j &lt; m-1-i:
                    gs[j] = m-1-i
                    j += 1
        for i in range(m-1):
            if suff[i] &gt; 0:
                gs[m-1-suff[i]] = m-1-i
        return gs

    bc_table = build_bc(pattern)
    gs_table = build_gs(pattern)
    n, m = len(text), len(pattern)
    i = 0
    
    while i &lt;= n - m:
        j = m-1
        while j &gt;= 0 and text[i+j] == pattern[j]:
            j -= 1
        if j &lt; 0:
            return i  # 匹配成功
        else:
            bc_shift = j - bc_table[ord(text[i+j])]
            gs_shift = gs_table[j]
            i += max(bc_shift, gs_shift, 1)
    return -1  # 匹配失败
</code></pre><hr><h3 id=-总结-1>💎 总结</h3><p>BM算法通过<strong>反向匹配</strong>与<strong>双启发规则</strong>的协同，实现了匹配过程中的大规模跳跃，成为工程实践中最高效的单模式匹配算法之一。其优势在长模式串和大字符集场景下尤为显著，但需注意预处理开销和边缘场景的性能波动。理解其规则设计与跳跃逻辑，对优化高频字符串操作（如日志分析、基因比对）至关重要<a class=link href=@ref>3,5,6</a>。</p><h2 id=sunday>Sunday</h2><p>以下是关于 <strong>SUNDAY算法</strong> 的详细解析，涵盖核心思想、匹配规则、时间复杂度、代码实现及优化策略，结合技术原理与工程实践进行系统阐述：</p><hr><h3 id=-算法概述-1>🔍 <strong>算法概述</strong></h3><p><strong>SUNDAY算法</strong> 由 Daniel M.Sunday 于 1990 年提出，是一种 <strong>高效的单模式字符串匹配算法</strong>。其核心思想是通过 <strong>跳跃式移动模式串</strong>，在匹配失败时跳过尽可能多的无效字符，从而提升匹配效率。与 Boyer-Moore（BM）算法类似，但 SUNDAY 算法采用 <strong>从前往后匹配</strong> 的顺序，且关注点不同<a class=link href=@ref>1,6</a>。</p><h4 id=-核心特征-1>⚡ <strong>核心特征</strong>：</h4><ol><li><strong>匹配方向</strong>：从左向右匹配（与 BM 算法的从右向左相反）。</li><li><strong>关键启发点</strong>：匹配失败时，关注 <strong>文本串中参与匹配的最末字符的下一位字符</strong>（称为 <strong>关注字符</strong>）。</li><li>跳跃策略：根据关注字符是否在模式串中出现，决定移动步长：<ul><li>若未出现 → 移动步长 = 模式串长度 + 1。</li><li>若出现 → 移动步长 = 模式串长度 - 该字符在模式串中最右出现的位置<a class=link href=@ref>2,7</a>。</li></ul></li></ol><hr><h3 id=-算法原理与匹配流程>⚙️ <strong>算法原理与匹配流程</strong></h3><h4 id=预处理构建移动表shift-table><strong>预处理：构建移动表（Shift Table）</strong></h4><ul><li><strong>目的</strong>：记录模式串中每个字符 <strong>最右出现位置</strong> 到模式串末尾的距离 + 1（即跳跃步长）。</li><li>步骤：<ul><li>初始化一个长度为 256（ASCII 字符集）的数组 <code>shift[]</code>，默认值设为 <code>m + 1</code>（<code>m</code> 为模式串长度）。</li><li>遍历模式串，更新每个字符的跳跃步长：<code>shift[char] = m - i</code>（<code>i</code> 为字符位置）<a class=link href=@ref>3,6</a>。</li></ul></li><li>示例
（模式串</li></ul><pre tabindex=0><code>  &#34;search&#34;
</code></pre><p>）：</p><div class=table-wrapper><table><thead><tr><th>字符</th><th><code>s</code></th><th><code>e</code></th><th><code>a</code></th><th><code>r</code></th><th><code>c</code></th><th><code>h</code></th></tr></thead><tbody><tr><td>跳跃步长</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td></tr></tbody></table></div><h4 id=匹配过程><strong>匹配过程</strong></h4><ol><li><strong>对齐模式串</strong>：将模式串与文本串左对齐，起始位置 <code>pos = 0</code>。</li><li><strong>逐字符比较</strong>：从左向右比较模式串与文本串对应字符。</li><li>匹配失败处理：<ul><li>计算关注字符：<code>T[pos + m]</code>（<code>m</code> 为模式串长度）。</li><li>查移动表</li></ul></li></ol><pre tabindex=0><code>     shift[]
     ```：
     - 若 `shift[T[pos + m]] = m + 1` → 移动步长 = `m + 1`。
     - 否则 → 移动步长 = `shift[T[pos + m]]`。
   - 更新位置：`pos += shift[T[pos + m]]`[3,7](@ref)。
#### **匹配示例**

**文本串**：`&#34;substring searching&#34;`
​**模式串**​：`&#34;search&#34;`
​**步骤**​：
1. **初始对齐**：
</code></pre><p>substring searching
search ↑ 关注字符：&lsquo;i&rsquo;（不在模式串中）</p><pre tabindex=0><code>- 移动步长 = 6 + 1 = 7 → 跳到 `&#39;n&#39;` 处[2,5](@ref)。
2. **二次对齐**：
</code></pre><p>substring searching
search ↑ 关注字符：&lsquo;r&rsquo;（在模式串第 3 位）</p><pre tabindex=0><code>- 移动步长 = 6 - 3 = 3 → 对齐两个 `&#39;r&#39;`[5,7](@ref)。
3. **匹配成功**：
</code></pre><p>substring searching
search ✓</p><pre tabindex=0><code>

------
### 📊 **时间复杂度分析**

| **场景**     | **时间复杂度** | **说明**                                                     |
| ------------ | -------------- | ------------------------------------------------------------ |
| **最佳情况** | O(n/m)         | 每次匹配失败时关注字符均不在模式串中（如模式串无重复字符）[3](@ref)。 |
| **最坏情况** | O(m*n)         | 模式串重复度高（如 `&#34;aaaaa&#34;`），每次仅移动 1 位[5](@ref)。   |
| **平均情况** | O(n)           | 实际应用中跳跃效率高（如英文文本）[3](@ref)。                |


------
### ⚖️ **优缺点与适用场景**

#### ✅ **优势**：

1. **实现简单**：代码量少于 KMP/BM，预处理仅需构建移动表[6,7](@ref)。
2. **跳跃能力强**：在大字符集（如英文、DNA序列）中平均跳跃步长大。
3. **匹配顺序灵活**：无需固定比较方向（可优化为优先比较低概率字符）[5](@ref)。
#### ❌ **局限**：

1. **最坏情况效率低**：模式串重复度高时退化为暴力匹配。
2. **依赖字符集**：需预分配移动表空间（ASCII 为 256，Unicode 需优化）[3](@ref)。
#### 🛠️ **适用场景**：

- **文本编辑器**：快速查找/替换（如 Sublime Text）。
- **日志分析**：在大量日志中搜索关键词。
- **生物信息学**：基因序列匹配（ATCG 字符集小，跳跃高效）[4,7](@ref)。


------
### 💻 **代码实现（Python）**
</code></pre><p>def sunday_search(text, pattern):
m, n = len(pattern), len(text)
if m == 0:
return 0</p><pre><code># 构建移动表（默认步长 m+1）
shift = [m + 1] * 256  # ASCII 字符集
for i, char in enumerate(pattern):
    shift[ord(char)] = m - i  # 更新字符步长

pos = 0
while pos &lt;= n - m:
    # 尝试匹配
    j = 0
    while j &lt; m and text[pos + j] == pattern[j]:
        j += 1
    if j == m:  # 匹配成功
        return pos
    
    # 计算关注字符位置
    if pos + m &gt;= n:  # 边界检查
        break
    focus_char = text[pos + m]
    # 根据移动表跳跃
    pos += shift[ord(focus_char)]

return -1  # 未找到
</code></pre><h1 id=测试>测试</h1><p>text = &ldquo;substring searching&rdquo;
pattern = &ldquo;search&rdquo;
print(sunday_search(text, pattern)) # 输出: 10</p><pre tabindex=0><code>

------
### 🧠 **优化策略**

1. 
   避免最坏情况：
   - 检测模式串重复性，若重复度高则切换至 KMP 算法[5](@ref)。
2. 
   动态字符集处理：
   - Unicode 文本使用哈希表替代数组存储移动表，节省空间。
3. 
   多模式匹配扩展：
   - 结合 AC 自动机，实现高效多模式匹配（如敏感词过滤）[4](@ref)。


------
### 💎 **总结**

SUNDAY 算法以 **简洁的实现** 和 **高效的跳跃能力** 在字符串匹配领域占据独特地位。其核心在于 **利用关注字符预判无效区域**，大幅减少比较次数。尽管在最坏情况下性能受限，但在大字符集、低重复模式的场景中（如自然语言、生物序列），其平均效率接近理论最优值。工程实践中，可结合场景特性动态选择匹配算法（如短模式用暴力法，长模式用 SUNDAY/BM），以达到最佳性能[3,7](@ref)。
</code></pre></section><footer class=article-footer><section class=article-tags><a href=/tags/dsa/>DSA</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Oct 22, 2025 16:27 CST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/mac.db_store-file/><div class=article-image><img src=/covers/cover20.jpg loading=lazy data-key data-hash=/covers/cover20.jpg></div><div class=article-details><h2 class=article-title>【Mac】.DB_Store file</h2></div></a></article><article><a href=/p/dsared-black-tree/><div class=article-details><h2 class=article-title>【DSA】Red-Black Tree</h2></div></a></article><article><a href=/p/dsa%E5%9B%BE%E7%AE%97%E6%B3%95/><div class=article-details><h2 class=article-title>【DSA】图算法</h2></div></a></article><article><a href=/p/javagc/><div class=article-details><h2 class=article-title>【Java】GC</h2></div></a></article><article><a href=/p/java%E8%B0%83%E4%BC%98/><div class=article-details><h2 class=article-title>【Java】调优</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>