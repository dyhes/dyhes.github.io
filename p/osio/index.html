<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="select I/O多路复用中的select是一种同步I/O事件管理机制，允许单个线程同时监控多个文件描述符（如套接字）的读写或异常状态，从而实现对高并发连接的轻量化处理。以下从核心原理、实现方式、优缺点及对比展开详细分析：\n🔍 核心原理与工作流程 阻塞式事件监听 select通过轮询机制检查多个文件描述符的状态。调用select时，内核会阻塞线程，直到以下任一情况发生： 至少一个被监控的文件描述符就绪（可读/可写/异常）； 超时时间到达（由timeval参数指定）； 被信号中断1,6。 文件描述符集合管理 fd_set结构：使用位图（bitmap）表示文件描述符集合，每个比特位对应一个文件描述符。例如，fd=3对应第3个比特位4,6。 操作宏： FD_ZERO(&amp;set)：清空集合； FD_SET(fd, &amp;set)：添加文件描述符； FD_CLR(fd, &amp;set)：移除文件描述符； FD_ISSET(fd, &amp;set)：检查是否就绪1,6。 函数原型与参数 int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); nfds：需监控的最大文件描述符值+1（如最大fd=5，则nfds=6），限定内核检查范围； readfds/writefds/exceptfds：分别监控可读、可写、异常事件的描述符集合； timeout：超时时间（NULL表示无限阻塞）3,6。 ⚙️ 实现步骤（以TCP服务器为例） 初始化监听 创建监听套接字，绑定端口并监听； 初始化fd_set集合，将监听套接字加入readfds6。 循环监控与事件处理 while (1) { fd_set tmp_set = active_set; // 备份监控集合 int ready = select(max_fd+1, &amp;tmp_set, NULL, NULL, NULL); // 检查新连接 if (FD_ISSET(server_fd, &amp;tmp_set)) { int client_fd = accept(server_fd, ...); FD_SET(client_fd, &amp;active_set); // 加入监控集合 max_fd = (client_fd > max_fd) ? client_fd : max_fd; } // 检查客户端数据 for (int fd = server_fd+1; fd <= max_fd; fd++) { if (FD_ISSET(fd, &amp;tmp_set)) { recv(fd, ...); // 处理数据 // 若连接关闭，则FD_CLR移除 } } } 关键点：每次调用select前需重置监控集合，因其返回后会修改集合内容，仅保留就绪的描述符1,4,6。 ⚖️ 优缺点分析 优点 缺点 跨平台支持：几乎所有Unix/Linux系统均兼容1 文件描述符数量限制：默认最大1024（可调整但效率低）4,6 编程模型简单：适合低并发场景3 性能瓶颈： 每次调用需复制整个fd_set（用户态↔内核态）； 轮询复杂度O(n)，万级连接时效率骤降4,5 | | \u200b单线程处理多连接\u200b：减少线程切换开销1 | \u200b重复初始化\u200b：每次循环需重新设置监控集合6 | 🔄 与poll/epoll的对比 特性 select poll epoll 数据结构 位图（fd_set） 链表（pollfd数组） 红黑树+就绪链表 最大连接数 1024（默认） 无限制 10万+（1GB内存） 效率 O(n)轮询 O(n)轮询 O(1)事件回调 内存拷贝 每次调用全量复制 每次调用全量复制 首次注册后仅同步就绪事件 触发模式 水平触发（LT） 水平触发（LT） 支持LT/边缘触发（ET） 水平触发（LT）：只要缓冲区有数据，持续通知； \u200b边缘触发（ET）\u200b\u200b：仅状态变化时通知一次，需一次读完数据2,5。\n"><title>【OS】IO</title><link rel=canonical href=https://dyhes.github.io/p/osio/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【OS】IO"><meta property='og:description' content="select I/O多路复用中的select是一种同步I/O事件管理机制，允许单个线程同时监控多个文件描述符（如套接字）的读写或异常状态，从而实现对高并发连接的轻量化处理。以下从核心原理、实现方式、优缺点及对比展开详细分析：\n🔍 核心原理与工作流程 阻塞式事件监听 select通过轮询机制检查多个文件描述符的状态。调用select时，内核会阻塞线程，直到以下任一情况发生： 至少一个被监控的文件描述符就绪（可读/可写/异常）； 超时时间到达（由timeval参数指定）； 被信号中断1,6。 文件描述符集合管理 fd_set结构：使用位图（bitmap）表示文件描述符集合，每个比特位对应一个文件描述符。例如，fd=3对应第3个比特位4,6。 操作宏： FD_ZERO(&amp;set)：清空集合； FD_SET(fd, &amp;set)：添加文件描述符； FD_CLR(fd, &amp;set)：移除文件描述符； FD_ISSET(fd, &amp;set)：检查是否就绪1,6。 函数原型与参数 int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); nfds：需监控的最大文件描述符值+1（如最大fd=5，则nfds=6），限定内核检查范围； readfds/writefds/exceptfds：分别监控可读、可写、异常事件的描述符集合； timeout：超时时间（NULL表示无限阻塞）3,6。 ⚙️ 实现步骤（以TCP服务器为例） 初始化监听 创建监听套接字，绑定端口并监听； 初始化fd_set集合，将监听套接字加入readfds6。 循环监控与事件处理 while (1) { fd_set tmp_set = active_set; // 备份监控集合 int ready = select(max_fd+1, &amp;tmp_set, NULL, NULL, NULL); // 检查新连接 if (FD_ISSET(server_fd, &amp;tmp_set)) { int client_fd = accept(server_fd, ...); FD_SET(client_fd, &amp;active_set); // 加入监控集合 max_fd = (client_fd > max_fd) ? client_fd : max_fd; } // 检查客户端数据 for (int fd = server_fd+1; fd <= max_fd; fd++) { if (FD_ISSET(fd, &amp;tmp_set)) { recv(fd, ...); // 处理数据 // 若连接关闭，则FD_CLR移除 } } } 关键点：每次调用select前需重置监控集合，因其返回后会修改集合内容，仅保留就绪的描述符1,4,6。 ⚖️ 优缺点分析 优点 缺点 跨平台支持：几乎所有Unix/Linux系统均兼容1 文件描述符数量限制：默认最大1024（可调整但效率低）4,6 编程模型简单：适合低并发场景3 性能瓶颈： 每次调用需复制整个fd_set（用户态↔内核态）； 轮询复杂度O(n)，万级连接时效率骤降4,5 | | \u200b单线程处理多连接\u200b：减少线程切换开销1 | \u200b重复初始化\u200b：每次循环需重新设置监控集合6 | 🔄 与poll/epoll的对比 特性 select poll epoll 数据结构 位图（fd_set） 链表（pollfd数组） 红黑树+就绪链表 最大连接数 1024（默认） 无限制 10万+（1GB内存） 效率 O(n)轮询 O(n)轮询 O(1)事件回调 内存拷贝 每次调用全量复制 每次调用全量复制 首次注册后仅同步就绪事件 触发模式 水平触发（LT） 水平触发（LT） 支持LT/边缘触发（ET） 水平触发（LT）：只要缓冲区有数据，持续通知； \u200b边缘触发（ET）\u200b\u200b：仅状态变化时通知一次，需一次读完数据2,5。\n"><meta property='og:url' content='https://dyhes.github.io/p/osio/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='OS'><meta property='article:published_time' content='2025-06-28T00:00:00+00:00'><meta property='article:modified_time' content='2025-07-15T01:02:04+08:00'><meta name=twitter:title content="【OS】IO"><meta name=twitter:description content="select I/O多路复用中的select是一种同步I/O事件管理机制，允许单个线程同时监控多个文件描述符（如套接字）的读写或异常状态，从而实现对高并发连接的轻量化处理。以下从核心原理、实现方式、优缺点及对比展开详细分析：\n🔍 核心原理与工作流程 阻塞式事件监听 select通过轮询机制检查多个文件描述符的状态。调用select时，内核会阻塞线程，直到以下任一情况发生： 至少一个被监控的文件描述符就绪（可读/可写/异常）； 超时时间到达（由timeval参数指定）； 被信号中断1,6。 文件描述符集合管理 fd_set结构：使用位图（bitmap）表示文件描述符集合，每个比特位对应一个文件描述符。例如，fd=3对应第3个比特位4,6。 操作宏： FD_ZERO(&amp;set)：清空集合； FD_SET(fd, &amp;set)：添加文件描述符； FD_CLR(fd, &amp;set)：移除文件描述符； FD_ISSET(fd, &amp;set)：检查是否就绪1,6。 函数原型与参数 int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); nfds：需监控的最大文件描述符值+1（如最大fd=5，则nfds=6），限定内核检查范围； readfds/writefds/exceptfds：分别监控可读、可写、异常事件的描述符集合； timeout：超时时间（NULL表示无限阻塞）3,6。 ⚙️ 实现步骤（以TCP服务器为例） 初始化监听 创建监听套接字，绑定端口并监听； 初始化fd_set集合，将监听套接字加入readfds6。 循环监控与事件处理 while (1) { fd_set tmp_set = active_set; // 备份监控集合 int ready = select(max_fd+1, &amp;tmp_set, NULL, NULL, NULL); // 检查新连接 if (FD_ISSET(server_fd, &amp;tmp_set)) { int client_fd = accept(server_fd, ...); FD_SET(client_fd, &amp;active_set); // 加入监控集合 max_fd = (client_fd > max_fd) ? client_fd : max_fd; } // 检查客户端数据 for (int fd = server_fd+1; fd <= max_fd; fd++) { if (FD_ISSET(fd, &amp;tmp_set)) { recv(fd, ...); // 处理数据 // 若连接关闭，则FD_CLR移除 } } } 关键点：每次调用select前需重置监控集合，因其返回后会修改集合内容，仅保留就绪的描述符1,4,6。 ⚖️ 优缺点分析 优点 缺点 跨平台支持：几乎所有Unix/Linux系统均兼容1 文件描述符数量限制：默认最大1024（可调整但效率低）4,6 编程模型简单：适合低并发场景3 性能瓶颈： 每次调用需复制整个fd_set（用户态↔内核态）； 轮询复杂度O(n)，万级连接时效率骤降4,5 | | \u200b单线程处理多连接\u200b：减少线程切换开销1 | \u200b重复初始化\u200b：每次循环需重新设置监控集合6 | 🔄 与poll/epoll的对比 特性 select poll epoll 数据结构 位图（fd_set） 链表（pollfd数组） 红黑树+就绪链表 最大连接数 1024（默认） 无限制 10万+（1GB内存） 效率 O(n)轮询 O(n)轮询 O(1)事件回调 内存拷贝 每次调用全量复制 每次调用全量复制 首次注册后仅同步就绪事件 触发模式 水平触发（LT） 水平触发（LT） 支持LT/边缘触发（ET） 水平触发（LT）：只要缓冲区有数据，持续通知； \u200b边缘触发（ET）\u200b\u200b：仅状态变化时通知一次，需一次读完数据2,5。\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#select>select</a><ol><li><a href=#-核心原理与工作流程>🔍 核心原理与工作流程</a></li><li><a href=#-实现步骤以tcp服务器为例>⚙️ 实现步骤（以TCP服务器为例）</a></li><li><a href=#-优缺点分析>⚖️ 优缺点分析</a></li><li><a href=#-与pollepoll的对比>🔄 与poll/epoll的对比</a></li><li><a href=#-适用场景>💎 适用场景</a></li><li><a href=#-总结>💎 总结</a></li></ol></li><li><a href=#poll>poll</a><ol><li><a href=#-核心原理与工作流程-1>🔍 核心原理与工作流程</a></li><li><a href=#-使用步骤以-tcp-服务器为例>⚙️ 使用步骤（以 TCP 服务器为例）</a></li><li><a href=#-优缺点分析-1>⚖️ 优缺点分析</a></li><li><a href=#-与-selectepoll-的对比>🔄 与 select/epoll 的对比</a></li><li><a href=#-适用场景-1>💎 适用场景</a></li><li><a href=#-总结-1>📝 总结</a></li></ol></li><li><a href=#selectpoll>select/poll</a><ol><li><a href=#-select基于位掩码的轮询模型>⚙️ <strong>Select：基于位掩码的轮询模型</strong></a><ol><li><a href=#核心原理><strong>核心原理</strong></a></li><li><a href=#优缺点><strong>优缺点</strong></a></li><li><a href=#适用场景><strong>适用场景</strong></a></li></ol></li><li><a href=#-poll动态数组的改进模型>🔄 <strong>Poll：动态数组的改进模型</strong></a><ol><li><a href=#核心原理-1><strong>核心原理</strong></a></li><li><a href=#优缺点-1><strong>优缺点</strong></a></li><li><a href=#适用场景-1><strong>适用场景</strong></a></li></ol></li><li><a href=#-select-vs-poll关键差异详解>⚖️ <strong>Select vs Poll：关键差异详解</strong></a></li><li><a href=#-典型应用场景>🖥️ <strong>典型应用场景</strong></a></li><li><a href=#-总结技术选型建议>💎 <strong>总结：技术选型建议</strong></a></li></ol></li><li><a href=#epoll>epoll</a><ol><li><a href=#-核心原理与数据结构>🔍 核心原理与数据结构</a><ol><li><a href=#事件驱动模型><strong>事件驱动模型</strong></a></li><li><a href=#核心数据结构><strong>核心数据结构</strong></a></li><li><a href=#工作流程><strong>工作流程</strong></a></li></ol></li><li><a href=#-关键系统调用>⚙️ 关键系统调用</a><ol><li><a href=#epoll_createint-size><strong><code>epoll_create(int size)</code></strong></a></li><li><a href=#epoll_ctlint-epfd-int-op-int-fd-struct-epoll_event-event><strong><code>epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></strong></a></li><li><a href=#epoll_waitint-epfd-struct-epoll_event-events-int-maxevents-int-timeout><strong><code>epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code></strong></a></li></ol></li><li><a href=#-工作模式lt-vs-et>🔄 工作模式：LT vs ET</a><ol><li><a href=#水平触发lt默认模式><strong>水平触发（LT，默认模式）</strong></a></li><li><a href=#边缘触发et><strong>边缘触发（ET）</strong></a></li><li><a href=#模式对比>模式对比</a></li></ol></li><li><a href=#-性能优势详解>🚀 性能优势详解</a></li><li><a href=#-使用注意事项>⚠️ 使用注意事项</a></li><li><a href=#-适用场景-2>💎 适用场景</a></li><li><a href=#-与selectpoll的对比>📊 与select/poll的对比</a></li><li><a href=#-总结-2>💎 总结</a></li></ol></li><li><a href=#红黑树节点>红黑树节点</a><ol><li><a href=#-正常情况节点保留在红黑树中>🔍 正常情况：节点保留在红黑树中</a></li><li><a href=#-特殊情况节点被删除的场景>⚠️ 特殊情况：节点被删除的场景</a></li><li><a href=#-数据结构与内核行为>🔧 数据结构与内核行为</a></li><li><a href=#-总结何时节点会被删除>💎 总结：何时节点会被删除？</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/nutrition/ style=background-color:#93b5cf;color:>积雪粮
</a><a href=/categories/willow/ style=background-color:#dc9123;color:>满城风絮</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/osio/>【OS】IO</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 28, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>4 minute read</time></div></footer></div></header><section class=article-content><h2 id=select>select</h2><p>I/O多路复用中的<code>select</code>是一种<strong>同步I/O事件管理机制</strong>，允许单个线程同时监控多个文件描述符（如套接字）的读写或异常状态，从而实现对高并发连接的轻量化处理。以下从核心原理、实现方式、优缺点及对比展开详细分析：</p><hr><h3 id=-核心原理与工作流程>🔍 核心原理与工作流程</h3><ol><li><strong>阻塞式事件监听</strong>
<code>select</code>通过<strong>轮询机制</strong>检查多个文件描述符的状态。调用<code>select</code>时，内核会阻塞线程，直到以下任一情况发生：<ul><li>至少一个被监控的文件描述符就绪（可读/可写/异常）；</li><li>超时时间到达（由<code>timeval</code>参数指定）；</li><li>被信号中断<a class=link href=@ref>1,6</a>。</li></ul></li><li><strong>文件描述符集合管理</strong><ul><li><strong><code>fd_set</code>结构</strong>：使用位图（bitmap）表示文件描述符集合，每个比特位对应一个文件描述符。例如，<code>fd=3</code>对应第3个比特位<a class=link href=@ref>4,6</a>。</li><li>操作宏：<ul><li><code>FD_ZERO(&amp;set)</code>：清空集合；</li></ul></li><li><code>FD_SET(fd, &amp;set)</code>：添加文件描述符；<ul><li><code>FD_CLR(fd, &amp;set)</code>：移除文件描述符；</li></ul></li><li><code>FD_ISSET(fd, &amp;set)</code>：检查是否就绪<a class=link href=@ref>1,6</a>。</li></ul></li><li><strong>函数原型与参数</strong><pre tabindex=0><code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
</code></pre><ul><li><strong><code>nfds</code></strong>：需监控的最大文件描述符值+1（如最大<code>fd=5</code>，则<code>nfds=6</code>），限定内核检查范围；</li><li><strong><code>readfds/writefds/exceptfds</code></strong>：分别监控可读、可写、异常事件的描述符集合；</li><li><strong><code>timeout</code></strong>：超时时间（<code>NULL</code>表示无限阻塞）<a class=link href=@ref>3,6</a>。</li></ul></li></ol><hr><h3 id=-实现步骤以tcp服务器为例>⚙️ 实现步骤（以TCP服务器为例）</h3><ol><li><strong>初始化监听</strong><ul><li>创建监听套接字，绑定端口并监听；</li><li>初始化<code>fd_set</code>集合，将监听套接字加入<code>readfds</code><a class=link href=@ref>6</a>。</li></ul></li><li><strong>循环监控与事件处理</strong><pre tabindex=0><code>while (1) {
    fd_set tmp_set = active_set; // 备份监控集合
    int ready = select(max_fd+1, &amp;tmp_set, NULL, NULL, NULL);

    // 检查新连接
    if (FD_ISSET(server_fd, &amp;tmp_set)) {
        int client_fd = accept(server_fd, ...);
        FD_SET(client_fd, &amp;active_set); // 加入监控集合
        max_fd = (client_fd &gt; max_fd) ? client_fd : max_fd;
    }

    // 检查客户端数据
    for (int fd = server_fd+1; fd &lt;= max_fd; fd++) {
        if (FD_ISSET(fd, &amp;tmp_set)) {
            recv(fd, ...); // 处理数据
            // 若连接关闭，则FD_CLR移除
        }
    }
}
</code></pre><strong>关键点</strong>：每次调用<code>select</code>前需重置监控集合，因其返回后会<strong>修改集合内容</strong>，仅保留就绪的描述符<a class=link href=@ref>1,4,6</a>。</li></ol><hr><h3 id=-优缺点分析>⚖️ 优缺点分析</h3><div class=table-wrapper><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>跨平台支持</strong>：几乎所有Unix/Linux系统均兼容<a class=link href=@ref>1</a></td><td><strong>文件描述符数量限制</strong>：默认最大1024（可调整但效率低）<a class=link href=@ref>4,6</a></td></tr><tr><td><strong>编程模型简单</strong>：适合低并发场景<a class=link href=@ref>3</a></td><td><strong>性能瓶颈</strong>：</td></tr></tbody></table></div><ul><li>每次调用需复制整个<code>fd_set</code>（用户态↔内核态）；</li><li>轮询复杂度O(n)，万级连接时效率骤降<a class=link href=@ref>4,5</a> |
| ​<strong>单线程处理多连接</strong>​：减少线程切换开销<a class=link href=@ref>1</a> | ​<strong>重复初始化</strong>​：每次循环需重新设置监控集合<a class=link href=@ref>6</a> |</li></ul><hr><h3 id=-与pollepoll的对比>🔄 与poll/epoll的对比</h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>select</strong></th><th><strong>poll</strong></th><th><strong>epoll</strong></th></tr></thead><tbody><tr><td><strong>数据结构</strong></td><td>位图（<code>fd_set</code>）</td><td>链表（<code>pollfd</code>数组）</td><td>红黑树+就绪链表</td></tr><tr><td><strong>最大连接数</strong></td><td>1024（默认）</td><td>无限制</td><td>10万+（1GB内存）</td></tr><tr><td><strong>效率</strong></td><td>O(n)轮询</td><td>O(n)轮询</td><td>O(1)事件回调</td></tr><tr><td><strong>内存拷贝</strong></td><td>每次调用全量复制</td><td>每次调用全量复制</td><td>首次注册后仅同步就绪事件</td></tr><tr><td><strong>触发模式</strong></td><td>水平触发（LT）</td><td>水平触发（LT）</td><td>支持LT/边缘触发（ET）</td></tr></tbody></table></div><blockquote><p><strong>水平触发（LT）</strong>：只要缓冲区有数据，持续通知；
​<strong>边缘触发（ET）​</strong>​：仅状态变化时通知一次，需一次读完数据<a class=link href=@ref>2,5</a>。</p></blockquote><hr><h3 id=-适用场景>💎 适用场景</h3><ul><li><strong>低并发场景</strong>：客户端连接数&lt;1000，且需跨平台兼容时；</li><li><strong>嵌入式系统</strong>：资源受限环境，无需高并发支持；</li><li><strong>教学原型</strong>：因其接口简单，适合理解多路复用基础原理<a class=link href=@ref>1,6</a>。</li></ul><blockquote><p><strong>高并发替代方案</strong>：Linux首选<code>epoll</code>（如Nginx、Redis），FreeBSD用<code>kqueue</code>，可突破性能瓶颈<a class=link href=@ref>2,5</a>。</p></blockquote><h3 id=-总结>💎 总结</h3><p><code>select</code>作为最早的I/O多路复用实现，其核心价值在于<strong>简化单线程多连接模型</strong>，但性能限制使其难以应对万级并发。理解其轮询机制与<code>fd_set</code>操作是掌握高阶模型（如<code>epoll</code>）的基础，实际开发中需根据场景权衡选择<a class=link href=@ref>1,6</a>。</p><h2 id=poll>poll</h2><p>Poll 是 Linux 系统中用于 <strong>I/O 多路复用</strong>的核心系统调用，通过单线程同时监控多个文件描述符（如套接字）的可读、可写或异常事件，适用于网络服务器等并发场景。以下是其详细解析：</p><hr><h3 id=-核心原理与工作流程-1>🔍 核心原理与工作流程</h3><ol><li><strong>事件驱动模型</strong>
Poll 采用<strong>轮询机制</strong>，用户程序通过 <code>poll()</code> 系统调用向内核注册一组待监控的文件描述符及其关注的事件（如 <code>POLLIN</code> 可读）。内核会阻塞进程，直到以下任一情况发生：<ul><li>至少一个文件描述符的事件就绪；</li><li>超时时间到达（由 <code>timeout</code> 参数指定）；</li><li>被信号中断<a class=link href=@ref>1,6</a>。</li></ul></li><li><strong>数据结构</strong><ul><li>**<pre tabindex=0><code>struct pollfd
</code></pre>**：核心结构体，包含三个字段：<pre tabindex=0><code>struct pollfd {
    int   fd;      // 监控的文件描述符
    short events;  // 关注的事件（用户设置）
    short revents; // 实际发生的事件（内核填充）
};
</code></pre><ul><li><code>events</code> 由用户设置（如 <code>POLLIN | POLLOUT</code>），<code>revents</code> 由内核返回，标识实际触发的事件<a class=link href=@ref>1,5</a>。</li></ul></li><li>事件类型：<ul><li><code>POLLIN</code>：数据可读（等效于 <code>select</code> 的读事件）。</li><li><code>POLLOUT</code>：数据可写（不阻塞）。</li><li><code>POLLERR</code>：错误发生（如连接重置）。</li><li><code>POLLHUP</code>：连接挂起（对端关闭）<a class=link href=@ref>6,7</a>。</li></ul></li></ul></li><li><strong>函数原型</strong><pre tabindex=0><code>#include &lt;poll.h&gt;
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
</code></pre><ul><li><strong><code>fds</code></strong>：指向 <code>pollfd</code> 结构体数组的指针。</li><li><strong><code>nfds</code></strong>：数组长度（需监控的文件描述符数量）。</li><li><strong><code>timeout</code></strong>：超时时间（毫秒），<code>-1</code> 表示永久阻塞，<code>0</code> 表示非阻塞立即返回<a class=link href=@ref>1,3</a>。</li></ul></li></ol><hr><h3 id=-使用步骤以-tcp-服务器为例>⚙️ 使用步骤（以 TCP 服务器为例）</h3><ol><li><strong>初始化监听</strong><ul><li>创建监听套接字，绑定端口并监听。</li><li>初始化 <code>pollfd</code> 数组，将监听套接字加入数组，并设置 <code>events = POLLIN</code><a class=link href=@ref>5,8</a>。</li></ul></li><li><strong>事件循环与处理</strong><pre tabindex=0><code>struct pollfd fds[MAX_FD];
fds[0].fd = listen_fd;  // 监听套接字
fds[0].events = POLLIN;

while (1) {
    int ready = poll(fds, nfds, -1);  // 阻塞等待事件
    if (ready &lt; 0) { /* 错误处理 */ }

    for (int i = 0; i &lt; nfds; i++) {
        if (fds[i].revents &amp; POLLIN) {
            if (fds[i].fd == listen_fd) {
                // 接受新连接
                int conn_fd = accept(listen_fd, ...);
                fds[nfds].fd = conn_fd;  // 加入监控数组
                fds[nfds].events = POLLIN;
                nfds++;
            } else {
                // 处理客户端数据
                recv(fds[i].fd, ...);
                if (连接关闭) {
                    close(fds[i].fd);
                    fds[i].fd = -1;  // 标记为无效
                }
            }
        }
    }
}
</code></pre><strong>关键点</strong>：<ul><li>每次调用 <code>poll()</code> 后需遍历数组，通过 <code>revents</code> 判断就绪事件。</li><li>无效描述符需将 <code>fd</code> 设为 <code>-1</code>，内核会自动跳过<a class=link href=@ref>5,8</a>。</li></ul></li></ol><hr><h3 id=-优缺点分析-1>⚖️ 优缺点分析</h3><div class=table-wrapper><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>无文件描述符数量限制</strong>：使用动态数组，突破 <code>select</code> 的 1024 限制（仅受系统资源约束）<a class=link href=@ref>2,7</a>。</td><td><strong>轮询效率低</strong>：每次调用需遍历整个数组，时间复杂度 O(n)，万级连接时性能骤降<a class=link href=@ref>4,7</a>。</td></tr><tr><td><strong>事件分离设计</strong>：<code>events</code>（输入）与 <code>revents</code>（输出）分离，无需每次重置监控集合<a class=link href=@ref>5,8</a>。</td><td><strong>内存拷贝开销大</strong>：每次调用需将整个 <code>fds</code> 数组复制到内核空间，高并发时占用带宽<a class=link href=@ref>4,7</a>。</td></tr><tr><td><strong>跨平台支持</strong>：多数 Unix-like 系统兼容（如 Linux/FreeBSD）<a class=link href=@ref>1,3</a>。</td><td><strong>不支持动态事件更新</strong>：无法单独修改某个描述符的事件，需遍历数组<a class=link href=@ref>7</a>。</td></tr></tbody></table></div><hr><h3 id=-与-selectepoll-的对比>🔄 与 select/epoll 的对比</h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>select</strong></th><th><strong>poll</strong></th><th><strong>epoll</strong></th></tr></thead><tbody><tr><td><strong>数据结构</strong></td><td>固定位图（<code>fd_set</code>）</td><td>动态数组（<code>pollfd</code>）</td><td>红黑树 + 就绪链表</td></tr><tr><td><strong>最大连接数</strong></td><td>1024（硬编码）</td><td>无限制（受内存限制）</td><td>10万+（高效内存管理）</td></tr><tr><td><strong>事件通知</strong></td><td>每次需重置位图</td><td>无需重置数组</td><td>仅注册一次，事件回调触发</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(n) 轮询</td><td>O(n) 轮询</td><td>O(1) 事件回调（仅活跃连接）</td></tr><tr><td><strong>适用场景</strong></td><td>低并发、跨平台需求</td><td>中等并发（数千连接）</td><td>高并发（如 Nginx、Redis）</td></tr></tbody></table></div><blockquote><p><strong>水平触发（LT）</strong>：Poll 和 select 均采用 LT 模式——只要缓冲区有数据，持续通知；epoll 支持 ET 模式（仅状态变化时通知一次）<a class=link href=@ref>7</a>。</p></blockquote><hr><h3 id=-适用场景-1>💎 适用场景</h3><ol><li><strong>中等并发网络服务</strong>：连接数在数千级别，且需跨平台兼容的场景<a class=link href=@ref>3,8</a>。</li><li><strong>嵌入式系统</strong>：资源有限但需同时处理多个 I/O 设备（如串口、传感器）<a class=link href=@ref>6</a>。</li><li><strong>替代 select 的过渡方案</strong>：解决 select 的 1024 限制，但尚未需 epoll 的极致性能时<a class=link href=@ref>2,7</a>。</li></ol><blockquote><p><strong>性能瓶颈提示</strong>：若连接数超 5000，建议改用 <code>epoll</code>（Linux）或 <code>kqueue</code>（FreeBSD）以规避轮询开销<a class=link href=@ref>7</a>。</p></blockquote><hr><h3 id=-总结-1>📝 总结</h3><p>Poll 作为 I/O 多路复用的“中坚力量”，<strong>平衡了灵活性与复杂度</strong>：突破了 select 的硬性限制，简化了编程模型，但未解决轮询效率与内存拷贝的本质问题。理解其基于数组的事件注册/回调机制（<code>pollfd</code> 结构体）是掌握高阶模型（如 epoll）的基础，实际选型需根据并发规模与平台特性权衡<a class=link href=@ref>1,7</a>。</p><h2 id=selectpoll>select/poll</h2><p>Select和Poll是Linux系统中传统的I/O多路复用技术，用于实现单线程/进程高效监控多个文件描述符（如套接字）。它们通过<strong>统一监听多个I/O事件</strong>，避免为每个连接创建独立线程/进程的资源消耗，是高并发网络编程的基础组件。以下是详细解析：</p><hr><h3 id=-select基于位掩码的轮询模型>⚙️ <strong>Select：基于位掩码的轮询模型</strong></h3><h4 id=核心原理><strong>核心原理</strong></h4><ul><li><strong>数据结构</strong>：使用固定大小的位掩码<code>fd_set</code>（位图），比特位位置代表文件描述符（fd），值表示是否监控<a class=link href=@ref>1,3,7</a>。</li><li>事件类型：监控三类事件集合：<ul><li>读就绪（<code>readfds</code>）</li><li>写就绪（<code>writefds</code>）</li><li>异常（<code>exceptfds</code>）</li></ul></li><li>工作流程：<ol><li>初始化<code>fd_set</code>，通过<code>FD_SET()</code>添加待监控的fd。</li><li>调用<code>select</code>阻塞等待，内核轮询所有fd，检查就绪状态。</li><li>返回后，用户遍历所有fd，用<code>FD_ISSET()</code>判断哪些fd就绪<a class=link href=@ref>1,9</a>。</li></ol></li></ul><h4 id=优缺点><strong>优缺点</strong></h4><ul><li>优点：<ul><li><strong>跨平台支持</strong>：几乎所有Unix-like系统均支持<a class=link href=@ref>3,6</a>。</li><li><strong>简单易用</strong>：适合fd数量少（&lt;1000）的场景。</li></ul></li><li>缺点：<ul><li><strong>fd数量限制</strong>：默认最大1024（由<code>FD_SETSIZE</code>决定），需修改内核才能扩展<a class=link href=@ref>1,7</a>。</li><li>性能瓶颈：<ul><li>每次调用需将整个<code>fd_set</code>从用户态拷贝到内核态。</li><li>内核需遍历所有fd（时间复杂度O(n)），高并发时效率骤降<a class=link href=@ref>3,8</a>。</li><li>返回后用户仍需遍历所有fd确认就绪状态<a class=link href=@ref>9</a>。</li></ul></li></ul></li></ul><h4 id=适用场景><strong>适用场景</strong></h4><ul><li>小规模连接（如嵌入式设备、低并发本地服务）<a class=link href=@ref>6,9</a>。</li></ul><hr><h3 id=-poll动态数组的改进模型>🔄 <strong>Poll：动态数组的改进模型</strong></h3><h4 id=核心原理-1><strong>核心原理</strong></h4><ul><li>数据结构：使用动态数组<pre tabindex=0><code>struct pollfd[]
</code></pre>，每个元素包含：<ul><li><code>fd</code>：监控的文件描述符</li><li><code>events</code>：监控的事件（如<code>POLLIN</code>/<code>POLLOUT</code>）</li><li><code>revents</code>：返回的实际发生事件<a class=link href=@ref>2,7,9</a>。</li></ul></li><li><strong>事件类型</strong>：支持更丰富的事件（如<code>POLLPRI</code>紧急数据、<code>POLLHUP</code>挂断）<a class=link href=@ref>7</a>。</li><li>工作流程：<ol><li>初始化<code>pollfd</code>数组，设置需监控的fd及事件。</li><li>调用<code>poll</code>阻塞等待，内核轮询fd数组。</li><li>返回后，用户遍历数组，检查<code>revents</code>判断就绪fd<a class=link href=@ref>1,9</a>。</li></ol></li></ul><h4 id=优缺点-1><strong>优缺点</strong></h4><ul><li>优点：<ul><li><strong>无fd数量限制</strong>：动态数组理论上支持无限fd（受系统全局限制）<a class=link href=@ref>3,7</a>。</li><li><strong>事件分离</strong>：<code>events</code>（用户设置）与<code>revents</code>（内核返回）分离，无需每次重置数组<a class=link href=@ref>7</a>。</li></ul></li><li>缺点：<ul><li>性能问题：<ul><li>每次调用仍需复制整个<code>pollfd</code>数组到内核。</li><li>内核仍需遍历所有fd（O(n)复杂度）<a class=link href=@ref>3,8</a>。</li></ul></li><li><strong>水平触发（LT）</strong>：未处理的就绪事件会持续通知，可能造成无效唤醒<a class=link href=@ref>2,8</a>。</li></ul></li></ul><h4 id=适用场景-1><strong>适用场景</strong></h4><ul><li>中等规模连接（如企业内部服务、中并发代理）<a class=link href=@ref>6,9</a>。</li></ul><hr><h3 id=-select-vs-poll关键差异详解>⚖️ <strong>Select vs Poll：关键差异详解</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>Select</strong></th><th><strong>Poll</strong></th></tr></thead><tbody><tr><td><strong>数据结构</strong></td><td>固定大小位图（<code>fd_set</code>）</td><td>动态结构体数组（<code>pollfd[]</code>）</td></tr><tr><td><strong>最大fd数量</strong></td><td>1024（硬限制）</td><td>无限制（受系统全局限制）</td></tr><tr><td><strong>事件分离</strong></td><td>混合读写异常事件</td><td>分离<code>events</code>（输入）和<code>revents</code>（输出）</td></tr><tr><td><strong>时间精度</strong></td><td>微秒（<code>struct timeval</code>）</td><td>毫秒（<code>int timeout</code>）</td></tr><tr><td><strong>事件类型支持</strong></td><td>仅基础读写异常</td><td>更丰富（如<code>POLLRDHUP</code>半关闭）</td></tr><tr><td><strong>高并发性能</strong></td><td>差（O(n)遍历+拷贝开销）</td><td>中等（O(n)遍历，无硬限制）</td></tr></tbody></table></div><hr><h3 id=-典型应用场景>🖥️ <strong>典型应用场景</strong></h3><ol><li>Select：<ul><li>监控少量fd（如串口通信、嵌入式设备）<a class=link href=@ref>6,9</a>。</li><li>跨平台兼容性要求高的场景（如Windows/Linux双平台服务）<a class=link href=@ref>3</a>。</li></ul></li><li>Poll：<ul><li>中等规模服务器（如游戏后端、API网关），连接数在数千级别<a class=link href=@ref>6,9</a>。</li><li>需要精细事件控制的场景（如处理带外数据<code>POLLPRI</code>）<a class=link href=@ref>7</a>。</li></ul></li></ol><hr><h3 id=-总结技术选型建议>💎 <strong>总结：技术选型建议</strong></h3><ul><li><strong>选择Select当</strong>：
✅ 连接数少（&lt;500）且需跨平台兼容<a class=link href=@ref>3,6</a>。</li><li><strong>选择Poll当</strong>：
✅ 连接数中等（&lt;1万），需事件分离或无fd限制<a class=link href=@ref>7,9</a>。</li><li><strong>避免两者当</strong>：
❌ 高并发（>1万连接）场景——改用<strong>Epoll</strong>​（事件驱动+O(1)复杂度）<a class=link href=@ref>3,8</a>。</li></ul><blockquote><p>注：现代高并发系统（如Nginx、Redis）已全面转向Epoll。但在资源受限或兼容性优先的场景，Select/Poll仍是可靠选择<a class=link href=@ref>4,6</a>。</p></blockquote><h2 id=epoll>epoll</h2><p>epoll（event poll）是Linux内核提供的高性能I/O多路复用机制，专为处理大规模并发连接（尤其活跃连接占比低的场景）而设计，显著优于传统的<code>select</code>和<code>poll</code>。其核心在于<strong>事件驱动架构</strong>和<strong>高效数据结构</strong>的结合，以下是详细解析：</p><hr><h3 id=-核心原理与数据结构>🔍 核心原理与数据结构</h3><h4 id=事件驱动模型><strong>事件驱动模型</strong></h4><p>epoll通过回调机制实现事件驱动：</p><ul><li>当监控的文件描述符（fd）发生I/O事件（如数据到达）时，内核自动触发回调函数<code>ep_poll_callback</code>。</li><li>该回调将事件对应的<code>epitem</code>结构体加入<strong>就绪链表</strong>（<code>rdllist</code>），无需遍历所有fd<a class=link href=@ref>2,5,6</a>。</li></ul><h4 id=核心数据结构><strong>核心数据结构</strong></h4><p>epoll依赖两个关键结构：</p><ul><li><strong>红黑树（rbr）</strong>
存储所有注册的fd及其关注的事件（<code>epitem</code>），插入、删除、查找时间复杂度为<code>O(log n)</code>，避免重复添加<a class=link href=@ref>5,6</a>。</li><li><strong>双向就绪链表（rdllist）</strong>
存放已就绪的事件，<code>epoll_wait</code>直接从此链表获取就绪事件，时间复杂度<code>O(1)</code><a class=link href=@ref>2,6</a>。</li></ul><pre tabindex=0><code>struct eventpoll {
    struct rb_root rbr;      // 红黑树根节点
    struct list_head rdllist; // 就绪事件链表
};
</code></pre><h4 id=工作流程><strong>工作流程</strong></h4><ol><li><strong>初始化</strong>
<code>epoll_create()</code>创建<code>eventpoll</code>对象，初始化红黑树和就绪链表。</li><li><strong>事件注册</strong>
<code>epoll_ctl(EPOLL_CTL_ADD)</code>将fd加入红黑树，并注册回调函数。</li><li>事件等待<pre tabindex=0><code>epoll_wait()
</code></pre>检查就绪链表：<ul><li>链表非空：复制就绪事件到用户空间并返回数量；</li><li>链表为空：线程阻塞直到超时或新事件加入<a class=link href=@ref>5,6</a>。</li></ul></li></ol><hr><h3 id=-关键系统调用>⚙️ 关键系统调用</h3><h4 id=epoll_createint-size><strong><code>epoll_create(int size)</code></strong></h4><ul><li>创建epoll实例，返回epoll文件描述符（epfd）。</li><li><code>size</code>参数仅作历史兼容，现代内核自动动态调整<a class=link href=@ref>2,7</a>。</li></ul><h4 id=epoll_ctlint-epfd-int-op-int-fd-struct-epoll_event-event><strong><code>epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></strong></h4><ul><li>操作epoll实例：<ul><li><code>op</code>：操作类型（<code>EPOLL_CTL_ADD/MOD/DEL</code>）。</li><li><code>event</code>：指定监听的事件类型（如<code>EPOLLIN</code>可读、<code>EPOLLOUT</code>可写）。</li></ul></li><li>示例：注册fd的可读事件：<pre tabindex=0><code>struct epoll_event ev;
ev.events = EPOLLIN; 
ev.data.fd = sockfd;
epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);
</code></pre></li></ul><h4 id=epoll_waitint-epfd-struct-epoll_event-events-int-maxevents-int-timeout><strong><code>epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</code></strong></h4><ul><li>阻塞等待就绪事件，返回就绪事件数量。</li><li><code>events</code>：用户空间数组，用于接收就绪事件。</li><li><code>maxevents</code>：数组大小，防止溢出<a class=link href=@ref>2,7</a>。</li></ul><hr><h3 id=-工作模式lt-vs-et>🔄 工作模式：LT vs ET</h3><h4 id=水平触发lt默认模式><strong>水平触发（LT，默认模式）</strong></h4><ul><li><strong>行为</strong>：只要fd缓冲区有未读数据，持续通知。</li><li><strong>优点</strong>：编程简单，兼容阻塞/非阻塞I/O。</li><li><strong>缺点</strong>：可能频繁唤醒，处理效率较低。</li><li><strong>适用场景</strong>：监听套接字（如Nginx的<code>listen_fd</code>）<a class=link href=@ref>2,5</a>。</li></ul><h4 id=边缘触发et><strong>边缘触发（ET）</strong></h4><ul><li><strong>行为</strong>：仅在fd状态变化时通知一次（如数据首次到达）。</li><li><strong>要求</strong>：必须使用<strong>非阻塞I/O</strong>，且需一次性读完数据（循环读至<code>EAGAIN</code>错误）。</li><li><strong>优点</strong>：减少无效唤醒，提升性能（Nginx默认模式）。</li><li><strong>风险</strong>：数据未读完可能导致事件丢失<a class=link href=@ref>2,5,7</a>。</li></ul><h4 id=模式对比>模式对比</h4><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>LT模式</strong></th><th><strong>ET模式</strong></th></tr></thead><tbody><tr><td><strong>触发条件</strong></td><td>缓冲区有数据即触发</td><td>仅状态变化时触发一次</td></tr><tr><td><strong>I/O要求</strong></td><td>阻塞/非阻塞均可</td><td>必须非阻塞</td></tr><tr><td><strong>数据读取</strong></td><td>可分批读取</td><td>需一次性读完（避免事件丢失）</td></tr><tr><td><strong>性能</strong></td><td>较低（频繁通知）</td><td>较高（通知次数少）</td></tr><tr><td><strong>典型应用</strong></td><td>监听套接字</td><td>高并发数据连接（如Nginx）</td></tr></tbody></table></div><hr><h3 id=-性能优势详解>🚀 性能优势详解</h3><ol><li><strong>无FD数量限制</strong>
仅受系统最大打开文件数限制（通过<code>ulimit -n</code>调整），可支持10万+连接<a class=link href=@ref>1,4</a>。</li><li><strong>O(1)事件检测</strong>
通过就绪链表直接获取活跃事件，避免<code>select/poll</code>的<code>O(n)</code>轮询<a class=link href=@ref>5,6</a>。</li><li><strong>零拷贝优化</strong>
内核与用户空间通过<strong>共享内存</strong>传递就绪事件（<code>mmap</code>技术），减少数据拷贝<a class=link href=@ref>1,6</a>。</li><li><strong>高效回调机制</strong>
仅活跃fd触发回调，空闲连接不占用CPU资源<a class=link href=@ref>2,5</a>。</li></ol><hr><h3 id=-使用注意事项>⚠️ 使用注意事项</h3><ol><li><strong>ET模式必须搭配非阻塞I/O</strong>
避免因未读完数据导致线程阻塞：<pre tabindex=0><code>fcntl(fd, F_SETFL, O_NONBLOCK); // 设置非阻塞
while (read(fd, buf, size) != -1 || errno != EAGAIN); // 循环读至空
</code></pre></li><li><strong>避免事件丢失（ET模式）</strong>
需在单次回调中处理完所有数据，否则需重新注册事件<a class=link href=@ref>5,7</a>。</li><li><strong>多线程安全</strong>
epoll实例本身线程安全，但同一fd的并发操作需加锁<a class=link href=@ref>4</a>。</li></ol><hr><h3 id=-适用场景-2>💎 适用场景</h3><ol><li><strong>高并发网络服务</strong>
如Web服务器（Nginx）、即时通讯（QQ）、游戏服务器，连接数>1万<a class=link href=@ref>3,4</a>。</li><li><strong>实时数据处理</strong>
低延迟要求的场景（股票交易、实时监控）<a class=link href=@ref>3</a>。</li><li><strong>替代select/poll</strong>
连接数超1024或需极致性能时<a class=link href=@ref>1,2</a>。</li></ol><hr><h3 id=-与selectpoll的对比>📊 与select/poll的对比</h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>select/poll</strong></th><th><strong>epoll</strong></th></tr></thead><tbody><tr><td><strong>时间复杂度</strong></td><td>O(n) 轮询所有fd</td><td>O(1) 检测就绪事件</td></tr><tr><td><strong>FD数量限制</strong></td><td>1024（select） / 无硬限制（poll）</td><td>10万+（与内存相关）</td></tr><tr><td><strong>内存拷贝</strong></td><td>每次调用全量复制fd集合</td><td>首次注册后仅同步就绪事件</td></tr><tr><td><strong>触发模式</strong></td><td>仅LT</td><td>支持LT/ET</td></tr><tr><td><strong>适用规模</strong></td><td>&lt;1000连接</td><td>>10000连接</td></tr></tbody></table></div><hr><h3 id=-总结-2>💎 总结</h3><p>epoll通过<strong>红黑树管理连接</strong>+<strong>就绪链表获取事件</strong>+<strong>回调机制</strong>，实现了百万级连接的高效处理，尤其适合<strong>高并发低活跃</strong>场景。其核心价值在于：</p><ol><li><strong>资源高效</strong>：仅关注活跃连接，减少CPU空转；</li><li><strong>扩展性强</strong>：突破FD数量限制，支持C10M（千万并发）<a class=link href=@ref>5</a>；</li><li><strong>灵活性高</strong>：ET模式最大化提升性能，LT模式降低开发门槛。</li></ol><blockquote><p>实际开发中，Nginx、Redis等知名项目均默认采用epoll的ET模式<a class=link href=@ref>2,5</a>。掌握其原理及ET模式下的非阻塞I/O编程，是构建高性能服务的基石。</p></blockquote><h2 id=红黑树节点>红黑树节点</h2><p>在epoll机制中，<strong>回调事件触发（如数据到达）后，节点（epitem）通常不会从红黑树中自动删除</strong>，除非满足特定条件。以下是详细分析：</p><hr><h3 id=-正常情况节点保留在红黑树中>🔍 正常情况：节点保留在红黑树中</h3><ol><li><strong>事件触发后的默认行为</strong>
当文件描述符（fd）上的事件（如<code>EPOLLIN</code>）就绪时，内核通过回调函数<code>ep_poll_callback</code>将该事件对应的<code>epitem</code>节点<strong>加入就绪队列（rdllist）​</strong>，但<strong>不会将其从红黑树中移除</strong>。<ul><li><strong>原因</strong>：红黑树的作用是长期记录需要监控的fd及其事件。事件触发仅表示当前有数据可读/写，后续可能仍有新事件发生（如持续接收数据），因此需保留节点以继续监听<a class=link href=@ref>1,2,5</a>。</li></ul></li><li><strong>用户态处理流程</strong><ul><li>用户调用<code>epoll_wait</code>获取就绪事件后，需自行处理数据（如<code>read</code>/<code>write</code>）。</li><li>处理完毕后，<strong>红黑树中的节点依然存在</strong>，下次该fd事件就绪时会再次触发回调并加入就绪队列<a class=link href=@ref>1,4</a>。</li></ul></li></ol><hr><h3 id=-特殊情况节点被删除的场景>⚠️ 特殊情况：节点被删除的场景</h3><ol><li><strong>设置<code>EPOLLONESHOT</code>选项</strong><ul><li>若注册事件时指定<code>EPOLLONESHOT</code>，则事件触发后<strong>内核会自动将该fd从红黑树中移除</strong>。</li><li><strong>目的</strong>：确保事件仅被处理一次，避免多线程场景下同一事件被重复触发。</li><li><strong>后续操作</strong>：用户需显式调用<code>epoll_ctl(EPOLL_CTL_MOD)</code>重新添加fd，才能继续监听<a class=link href=@ref>1,4,5</a>。</li><li><em>适用场景</em>：高并发下需精确控制事件触发的次数（如定时任务）。</li></ul></li><li><strong>用户主动删除</strong>
调用<code>epoll_ctl(EPOLL_CTL_DEL, fd)</code>手动将fd从红黑树中删除<a class=link href=@ref>2,5</a>。<ul><li><em>常见场景</em>：连接关闭（<code>close(fd)</code>）或业务逻辑不再需要监听该fd时。</li></ul></li></ol><hr><h3 id=-数据结构与内核行为>🔧 数据结构与内核行为</h3><ol><li><strong>红黑树与就绪队列的关系</strong><ul><li><strong>红黑树（rbr）</strong>：存储所有注册的<code>epitem</code>节点，键值由fd和设备标识组成，确保唯一性。</li><li><strong>就绪队列（rdllist）</strong>：临时存放已触发事件的<code>epitem</code>节点（通过回调函数动态插入）。</li><li>节点同时存在于红黑树和就绪队列中，但<strong>删除操作仅由用户或<code>EPOLLONESHOT</code>触发</strong><a class=link href=@ref>1,5</a>。</li></ul></li><li><strong>回调函数的角色</strong><ul><li>当数据到达时，网卡中断触发内核将数据写入socket缓冲区。</li><li>内核调用<code>ep_poll_callback</code>，将对应<code>epitem</code>节点加入就绪队列，<strong>不涉及红黑树修改</strong><a class=link href=@ref>4,5</a>。</li></ul></li></ol><hr><h3 id=-总结何时节点会被删除>💎 总结：何时节点会被删除？</h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>节点是否删除</strong></th><th><strong>触发方</strong></th><th><strong>后续操作</strong></th></tr></thead><tbody><tr><td><strong>默认情况</strong></td><td>❌ 否</td><td>-</td><td>节点保留，持续监听</td></tr><tr><td><strong>设置<code>EPOLLONESHOT</code></strong></td><td>✅ 是</td><td>内核自动删除</td><td>需显式调用<code>EPOLL_CTL_MOD</code>重新添加</td></tr><tr><td><strong>用户调用<code>DEL</code></strong></td><td>✅ 是</td><td>用户主动删除</td><td>不再监听该fd</td></tr></tbody></table></div><blockquote><p>⚙️ <strong>设计意图</strong>：epoll通过保留红黑树节点避免重复注册的开销，仅当明确要求（如<code>EPOLLONESHOT</code>）或连接关闭时才删除节点，以最大化性能<a class=link href=@ref>1,5</a>。
🔧 ​<strong>实践建议</strong>​：</p><ul><li>对于长连接通信（如Web服务器），无需设置<code>EPOLLONESHOT</code>；</li><li>对于单次任务（如定时触发），使用<code>EPOLLONESHOT</code>避免事件重复处理。</li></ul></blockquote></section><footer class=article-footer><section class=article-tags><a href=/tags/os/>OS</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Jul 15, 2025 01:02 CST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/milvusfundamentals/><div class=article-details><h2 class=article-title>【Milvus】Fundamentals</h2></div></a></article><article><a href=/p/mongodbfundamentals/><div class=article-details><h2 class=article-title>【MongoDB】Fundamentals</h2></div></a></article><article><a href=/p/nebulafundamentals/><div class=article-details><h2 class=article-title>【Nebula】Fundamentals</h2></div></a></article><article><a href=/p/distributedlock/><div class=article-details><h2 class=article-title>【Distributed】Lock</h2></div></a></article><article><a href=/p/rediscluster/><div class=article-details><h2 class=article-title>【Redis】Cluster</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>