<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='Thread 类 Java中的Thread类是java.lang包的核心类，用于实现多线程编程，允许程序并发执行多个任务，提升性能和资源利用率。以下是其核心概念与用法的系统梳理：\n⚙️ 线程的创建方式 继承Thread类 自定义类继承Thread，重写run()定义任务逻辑。 示例： class MyThread extends Thread { @Override public void run() { System.out.println("Thread running"); } } // 启动线程 new MyThread().start(); // 调用start()触发run()执行 实现Runnable接口（更推荐） 实现Runnable接口，将任务对象传入Thread构造器。 优势：避免单继承限制，任务与线程解耦。 class MyRunnable implements Runnable { public void run() { System.out.println("Task executed"); } } new Thread(new MyRunnable()).start(); 🔧 Thread类的核心方法 方法 作用 start() 启动线程，JVM自动调用run()，仅能调用一次 run() 线程任务逻辑入口，需重写或通过Runnable传入 sleep(long millis) 暂停当前线程指定毫秒，不释放锁，需处理InterruptedException join() / join(millis) 等待线程终止（或超时），用于线程同步 interrupt() 中断线程（设置标志位），需在run()中检查isInterrupted()响应中断 yield() 提示调度器让出CPU，但不保证立即切换 setDaemon(true) 设置为守护线程（JVM在所有非守护线程结束时退出） 📌 线程属性与状态 关键属性 ID：唯一标识（getId()） 名称：调试用（getName()/setName()） 优先级：1~10（默认5），高优先级仅增加调度概率，不保证优先 是否存活：isAlive()检测run()是否结束 线程状态（getState()） NEW：创建未启动 RUNNABLE：可运行（包括就绪和运行中） BLOCKED：等待锁 WAITING：无限期等待（如join()） TIMED_WAITING：超时等待（如sleep()） TERMINATED：执行完毕 ⚠️ 高级特性与注意事项 线程中断机制 通过interrupt()设置中断标志，线程需在run()中检查isInterrupted()并退出循环或捕获InterruptedException。 示例： while (!Thread.currentThread().isInterrupted()) { // 执行任务 } 线程同步 多线程访问共享资源需使用synchronized关键字或Lock接口，避免竞态条件。 线程局部变量（ThreadLocal） 为每个线程创建独立变量副本，避免共享冲突（如数据库连接）。 资源释放 线程终止后，其占用的内存资源（如堆栈）由JVM自动回收，但需确保无资源泄漏（如未关闭的文件流）。 💎 实践建议 优先选择Runnable接口：提升代码灵活性，符合组合优于继承原则。 避免直接调用run()：否则变为普通方法调用，失去并发性。 守护线程慎用：用于辅助任务（如心跳检测），避免影响JVM退出。 中断优于强制终止：弃用suspend()/resume()/stop()（易导致死锁）。 总结 Java的Thread类是多线程编程的基石，通过start()、状态管理、同步机制等实现并发控制。深入理解其生命周期、中断机制及同步策略，是构建高效安全并发应用的关键。实践中应结合Runnable、线程池（如ExecutorService）等高级工具提升可维护性。\n'><title>【Java】Thread</title><link rel=canonical href=https://dyhes.github.io/p/javathread/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【Java】Thread"><meta property='og:description' content='Thread 类 Java中的Thread类是java.lang包的核心类，用于实现多线程编程，允许程序并发执行多个任务，提升性能和资源利用率。以下是其核心概念与用法的系统梳理：\n⚙️ 线程的创建方式 继承Thread类 自定义类继承Thread，重写run()定义任务逻辑。 示例： class MyThread extends Thread { @Override public void run() { System.out.println("Thread running"); } } // 启动线程 new MyThread().start(); // 调用start()触发run()执行 实现Runnable接口（更推荐） 实现Runnable接口，将任务对象传入Thread构造器。 优势：避免单继承限制，任务与线程解耦。 class MyRunnable implements Runnable { public void run() { System.out.println("Task executed"); } } new Thread(new MyRunnable()).start(); 🔧 Thread类的核心方法 方法 作用 start() 启动线程，JVM自动调用run()，仅能调用一次 run() 线程任务逻辑入口，需重写或通过Runnable传入 sleep(long millis) 暂停当前线程指定毫秒，不释放锁，需处理InterruptedException join() / join(millis) 等待线程终止（或超时），用于线程同步 interrupt() 中断线程（设置标志位），需在run()中检查isInterrupted()响应中断 yield() 提示调度器让出CPU，但不保证立即切换 setDaemon(true) 设置为守护线程（JVM在所有非守护线程结束时退出） 📌 线程属性与状态 关键属性 ID：唯一标识（getId()） 名称：调试用（getName()/setName()） 优先级：1~10（默认5），高优先级仅增加调度概率，不保证优先 是否存活：isAlive()检测run()是否结束 线程状态（getState()） NEW：创建未启动 RUNNABLE：可运行（包括就绪和运行中） BLOCKED：等待锁 WAITING：无限期等待（如join()） TIMED_WAITING：超时等待（如sleep()） TERMINATED：执行完毕 ⚠️ 高级特性与注意事项 线程中断机制 通过interrupt()设置中断标志，线程需在run()中检查isInterrupted()并退出循环或捕获InterruptedException。 示例： while (!Thread.currentThread().isInterrupted()) { // 执行任务 } 线程同步 多线程访问共享资源需使用synchronized关键字或Lock接口，避免竞态条件。 线程局部变量（ThreadLocal） 为每个线程创建独立变量副本，避免共享冲突（如数据库连接）。 资源释放 线程终止后，其占用的内存资源（如堆栈）由JVM自动回收，但需确保无资源泄漏（如未关闭的文件流）。 💎 实践建议 优先选择Runnable接口：提升代码灵活性，符合组合优于继承原则。 避免直接调用run()：否则变为普通方法调用，失去并发性。 守护线程慎用：用于辅助任务（如心跳检测），避免影响JVM退出。 中断优于强制终止：弃用suspend()/resume()/stop()（易导致死锁）。 总结 Java的Thread类是多线程编程的基石，通过start()、状态管理、同步机制等实现并发控制。深入理解其生命周期、中断机制及同步策略，是构建高效安全并发应用的关键。实践中应结合Runnable、线程池（如ExecutorService）等高级工具提升可维护性。\n'><meta property='og:url' content='https://dyhes.github.io/p/javathread/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Java'><meta property='article:published_time' content='2025-06-20T00:00:00+00:00'><meta property='article:modified_time' content='2025-10-20T22:07:04+08:00'><meta name=twitter:title content="【Java】Thread"><meta name=twitter:description content='Thread 类 Java中的Thread类是java.lang包的核心类，用于实现多线程编程，允许程序并发执行多个任务，提升性能和资源利用率。以下是其核心概念与用法的系统梳理：\n⚙️ 线程的创建方式 继承Thread类 自定义类继承Thread，重写run()定义任务逻辑。 示例： class MyThread extends Thread { @Override public void run() { System.out.println("Thread running"); } } // 启动线程 new MyThread().start(); // 调用start()触发run()执行 实现Runnable接口（更推荐） 实现Runnable接口，将任务对象传入Thread构造器。 优势：避免单继承限制，任务与线程解耦。 class MyRunnable implements Runnable { public void run() { System.out.println("Task executed"); } } new Thread(new MyRunnable()).start(); 🔧 Thread类的核心方法 方法 作用 start() 启动线程，JVM自动调用run()，仅能调用一次 run() 线程任务逻辑入口，需重写或通过Runnable传入 sleep(long millis) 暂停当前线程指定毫秒，不释放锁，需处理InterruptedException join() / join(millis) 等待线程终止（或超时），用于线程同步 interrupt() 中断线程（设置标志位），需在run()中检查isInterrupted()响应中断 yield() 提示调度器让出CPU，但不保证立即切换 setDaemon(true) 设置为守护线程（JVM在所有非守护线程结束时退出） 📌 线程属性与状态 关键属性 ID：唯一标识（getId()） 名称：调试用（getName()/setName()） 优先级：1~10（默认5），高优先级仅增加调度概率，不保证优先 是否存活：isAlive()检测run()是否结束 线程状态（getState()） NEW：创建未启动 RUNNABLE：可运行（包括就绪和运行中） BLOCKED：等待锁 WAITING：无限期等待（如join()） TIMED_WAITING：超时等待（如sleep()） TERMINATED：执行完毕 ⚠️ 高级特性与注意事项 线程中断机制 通过interrupt()设置中断标志，线程需在run()中检查isInterrupted()并退出循环或捕获InterruptedException。 示例： while (!Thread.currentThread().isInterrupted()) { // 执行任务 } 线程同步 多线程访问共享资源需使用synchronized关键字或Lock接口，避免竞态条件。 线程局部变量（ThreadLocal） 为每个线程创建独立变量副本，避免共享冲突（如数据库连接）。 资源释放 线程终止后，其占用的内存资源（如堆栈）由JVM自动回收，但需确保无资源泄漏（如未关闭的文件流）。 💎 实践建议 优先选择Runnable接口：提升代码灵活性，符合组合优于继承原则。 避免直接调用run()：否则变为普通方法调用，失去并发性。 守护线程慎用：用于辅助任务（如心跳检测），避免影响JVM退出。 中断优于强制终止：弃用suspend()/resume()/stop()（易导致死锁）。 总结 Java的Thread类是多线程编程的基石，通过start()、状态管理、同步机制等实现并发控制。深入理解其生命周期、中断机制及同步策略，是构建高效安全并发应用的关键。实践中应结合Runnable、线程池（如ExecutorService）等高级工具提升可维护性。\n'><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#thread-类>Thread 类</a><ol><li><a href=#-线程的创建方式>⚙️ 线程的创建方式</a></li><li><a href=#-thread类的核心方法>🔧 Thread类的核心方法</a></li><li><a href=#-线程属性与状态>📌 线程属性与状态</a></li><li><a href=#-高级特性与注意事项>⚠️ 高级特性与注意事项</a></li><li><a href=#-实践建议>💎 实践建议</a></li><li><a href=#总结>总结</a></li></ol></li><li><a href=#thread-类默认实现><code>Thread</code> 类默认实现</a><ol><li><a href=#-默认构造方法>⚙️ <strong>默认构造方法：<code>Thread()</code></strong></a></li><li><a href=#-线程组threadgroup>🧩 <strong>线程组（ThreadGroup）</strong></a></li><li><a href=#-线程名称生成机制>📛 <strong>线程名称生成机制</strong></a></li><li><a href=#-守护状态与优先级继承>⚖️ <strong>守护状态与优先级继承</strong></a></li><li><a href=#-线程栈大小stacksize>🔍 <strong>线程栈大小（stackSize）</strong></a></li><li><a href=#-默认实现的实践意义与风险>⚠️ <strong>默认实现的实践意义与风险</strong></a></li><li><a href=#-总结>💎 <strong>总结</strong></a></li></ol></li><li><a href=#run>run()</a></li><li><a href=#runnable>Runnable</a><ol><li><a href=#-设计哲学职责分离与组合优于继承>🔧 <strong>设计哲学：职责分离与组合优于继承</strong></a></li><li><a href=#-技术实现委托机制与默认逻辑>⚙️ <strong>技术实现：委托机制与默认逻辑</strong></a></li><li><a href=#-实际应用灵活性与生态兼容>🚀 <strong>实际应用：灵活性与生态兼容</strong></a></li><li><a href=#-继承thread-vs-实现runnable的对比>⚖️ <strong>继承Thread vs 实现Runnable的对比</strong></a></li><li><a href=#-总结-1>💎 <strong>总结</strong></a></li></ol></li><li><a href=#join>Join()</a><ol><li><a href=#-等待的目标线程终止状态>⚙️ <strong>等待的目标：线程终止状态</strong></a></li><li><a href=#-底层实现基于锁与等待队列>🔧 <strong>底层实现：基于锁与等待队列</strong></a><ol><li><a href=#1阻塞当前线程><strong>（1）阻塞当前线程</strong></a></li><li><a href=#2唤醒机制><strong>（2）唤醒机制</strong></a></li></ol></li><li><a href=#-中断处理>⚠️ <strong>中断处理</strong></a></li><li><a href=#-超时控制>🔄 <strong>超时控制</strong></a></li><li><a href=#-总结等待的信号是什么>💎 <strong>总结：等待的“信号”是什么？</strong></a></li></ol></li><li><a href=#interrupt--yield>Interrupt() & yield()</a><ol><li><a href=#-interrupt>⚙️ <strong><code>interrupt()</code>方法的调用范围</strong></a></li><li><a href=#-yield>⏳ <strong><code>yield()</code>方法的调用范围</strong></a></li><li><a href=#-关键区别总结>💎 <strong>关键区别总结</strong></a></li><li><a href=#-使用注意事项>⚠️ <strong>使用注意事项</strong></a></li><li><a href=#-典型场景示例>💡 <strong>典型场景示例</strong></a></li><li><a href=#-总结-2>✅ <strong>总结</strong></a></li></ol></li><li><a href=#yield>yield()</a><ol><li><a href=#-线程状态的变化>⚙️ <strong>线程状态的变化</strong></a></li><li><a href=#-后续能否重新继续执行>🔄 <strong>后续能否重新继续执行？</strong></a></li><li><a href=#-重要注意事项>⚠️ <strong>重要注意事项</strong></a></li><li><a href=#-总结-3>💎 <strong>总结</strong></a></li></ol></li><li><a href=#主线程>主线程</a><ol><li><a href=#-主线程调用>⚙️ <strong>主线程调用 <code>yield()</code></strong></a></li><li><a href=#-主线程调用-1>⚡ <strong>主线程调用 <code>interrupt()</code></strong></a><ol><li><a href=#1中断自身><strong>（1）中断自身（<code>Thread.currentThread().interrupt()</code>）</strong></a></li><li><a href=#2中断其他线程><strong>（2）中断其他线程</strong></a></li></ol></li><li><a href=#-关键注意事项>⚠️ <strong>关键注意事项</strong></a></li><li><a href=#-总结-4>💎 <strong>总结</strong></a></li></ol></li><li><a href=#守护进程>守护进程</a><ol><li><a href=#-生命周期依赖非守护线程>⚙️ <strong>生命周期依赖非守护线程</strong></a></li><li><a href=#-jvm退出规则>🔄 <strong>JVM退出规则</strong></a></li><li><a href=#-资源与任务的中断机制>⚠️ <strong>资源与任务的中断机制</strong></a></li><li><a href=#-与用户线程的本质区别>🧩 <strong>与用户线程的本质区别</strong></a></li><li><a href=#-典型应用场景的合理性>💡 <strong>典型应用场景的合理性</strong></a></li><li><a href=#-注意潜在风险与限制>⚠️ 注意：潜在风险与限制</a></li><li><a href=#-总结-5>💎 总结</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/temple/ style=background-color:#69a794;color:>白玉京</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/javathread/>【Java】Thread</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 20, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>5 minute read</time></div></footer></div></header><section class=article-content><h2 id=thread-类>Thread 类</h2><p>Java中的<code>Thread</code>类是<code>java.lang</code>包的核心类，用于实现多线程编程，允许程序并发执行多个任务，提升性能和资源利用率。以下是其核心概念与用法的系统梳理：</p><hr><h3 id=-线程的创建方式>⚙️ 线程的创建方式</h3><ol><li><strong>继承Thread类</strong><ul><li>自定义类继承<code>Thread</code>，重写<code>run()</code>定义任务逻辑。</li><li>示例：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MyThread</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>Thread</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Thread running&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 启动线程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>new</span><span class=w> </span><span class=n>MyThread</span><span class=p>().</span><span class=na>start</span><span class=p>();</span><span class=w> </span><span class=c1>// 调用start()触发run()执行</span><span class=w>
</span></span></span></code></pre></div></li></ul></li><li><strong>实现Runnable接口</strong>（<strong>更推荐</strong>）<ul><li>实现<code>Runnable</code>接口，将任务对象传入<code>Thread</code>构造器。</li><li>优势：避免单继承限制，任务与线程解耦。<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MyRunnable</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Runnable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Task executed&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>MyRunnable</span><span class=p>()).</span><span class=na>start</span><span class=p>();</span><span class=w> 
</span></span></span></code></pre></div></li></ul></li></ol><hr><h3 id=-thread类的核心方法>🔧 Thread类的核心方法</h3><div class=table-wrapper><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>start()</code></td><td>启动线程，JVM自动调用<code>run()</code>，<strong>仅能调用一次</strong></td></tr><tr><td><code>run()</code></td><td>线程任务逻辑入口，需重写或通过<code>Runnable</code>传入</td></tr><tr><td><code>sleep(long millis)</code></td><td>暂停当前线程指定毫秒，<strong>不释放锁</strong>，需处理<code>InterruptedException</code></td></tr><tr><td><code>join()</code> / <code>join(millis)</code></td><td>等待线程终止（或超时），用于线程同步</td></tr><tr><td><code>interrupt()</code></td><td>中断线程（设置标志位），需在<code>run()</code>中检查<code>isInterrupted()</code>响应中断</td></tr><tr><td><code>yield()</code></td><td>提示调度器让出CPU，但不保证立即切换</td></tr><tr><td><code>setDaemon(true)</code></td><td>设置为守护线程（JVM在所有非守护线程结束时退出）</td></tr></tbody></table></div><hr><h3 id=-线程属性与状态>📌 线程属性与状态</h3><ol><li><strong>关键属性</strong><ul><li><strong>ID</strong>：唯一标识（<code>getId()</code>）</li><li><strong>名称</strong>：调试用（<code>getName()</code>/<code>setName()</code>）</li><li><strong>优先级</strong>：1~10（默认5），高优先级仅增加调度概率，不保证优先</li><li><strong>是否存活</strong>：<code>isAlive()</code>检测<code>run()</code>是否结束</li></ul></li><li><strong>线程状态（<code>getState()</code>）</strong><ul><li><strong>NEW</strong>：创建未启动</li><li><strong>RUNNABLE</strong>：可运行（包括就绪和运行中）</li><li><strong>BLOCKED</strong>：等待锁</li><li><strong>WAITING</strong>：无限期等待（如<code>join()</code>）</li><li><strong>TIMED_WAITING</strong>：超时等待（如<code>sleep()</code>）</li><li><strong>TERMINATED</strong>：执行完毕</li></ul></li></ol><hr><h3 id=-高级特性与注意事项>⚠️ 高级特性与注意事项</h3><ol><li><strong>线程中断机制</strong><ul><li>通过<code>interrupt()</code>设置中断标志，线程需在<code>run()</code>中检查<code>isInterrupted()</code>并退出循环或捕获<code>InterruptedException</code>。</li><li>示例：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>().</span><span class=na>isInterrupted</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 执行任务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul></li><li><strong>线程同步</strong><ul><li>多线程访问共享资源需使用<code>synchronized</code>关键字或<code>Lock</code>接口，避免竞态条件。</li></ul></li><li><strong>线程局部变量（ThreadLocal）</strong><ul><li>为每个线程创建独立变量副本，避免共享冲突（如数据库连接）。</li></ul></li><li><strong>资源释放</strong><ul><li>线程终止后，其占用的内存资源（如堆栈）由JVM自动回收，但需确保无资源泄漏（如未关闭的文件流）。</li></ul></li></ol><hr><h3 id=-实践建议>💎 实践建议</h3><ul><li><strong>优先选择<code>Runnable</code>接口</strong>：提升代码灵活性，符合组合优于继承原则。</li><li><strong>避免直接调用<code>run()</code></strong>：否则变为普通方法调用，失去并发性。</li><li><strong>守护线程慎用</strong>：用于辅助任务（如心跳检测），避免影响JVM退出。</li><li><strong>中断优于强制终止</strong>：弃用<code>suspend()</code>/<code>resume()</code>/<code>stop()</code>（易导致死锁）。</li></ul><hr><h3 id=总结>总结</h3><p>Java的<code>Thread</code>类是多线程编程的基石，通过<code>start()</code>、状态管理、同步机制等实现并发控制。深入理解其生命周期、中断机制及同步策略，是构建高效安全并发应用的关键。实践中应结合<code>Runnable</code>、线程池（如<code>ExecutorService</code>）等高级工具提升可维护性。</p><h2 id=thread-类默认实现><code>Thread</code> 类默认实现</h2><p>Java中的<code>Thread</code>类默认实现包含多个关键行为，这些行为在未显式重写或指定时自动生效。以下是其核心默认实现的系统梳理：</p><hr><h3 id=-默认构造方法>⚙️ <strong>默认构造方法：<code>Thread()</code></strong></h3><ol><li><strong>线程名称</strong><ul><li>默认生成格式为<code>"Thread-" + 自增数字</code>（如<code>Thread-0</code>、<code>Thread-1</code>），通过静态计数器<code>nextThreadNum()</code>实现。</li><li>可通过<code>Thread.currentThread().getName()</code>获取。</li></ul></li><li><strong>任务逻辑（run方法）</strong><ul><li>默认<code>run()</code>方法<strong>不执行任何操作</strong>。</li><li>若未传入<code>Runnable</code>任务对象或未重写<code>run()</code>，调用<code>start()</code>后线程会启动但无实际逻辑执行。</li><li>源码实现：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>target</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// target为传入的Runnable对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>target</span><span class=p>.</span><span class=na>run</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul></li></ol><hr><h3 id=-线程组threadgroup>🧩 <strong>线程组（ThreadGroup）</strong></h3><ul><li>默认分配规则：<ul><li>若未显式指定线程组，新线程会<strong>继承父线程的线程组</strong>（如主线程创建的子线程，其线程组与主线程相同）。</li><li>通过<code>ThreadGroup parentGroup = parent.getThreadGroup()</code>实现（<code>parent</code>为创建该线程的当前线程）。</li></ul></li><li><strong>安全性</strong>：线程组为空时，会通过<code>SecurityManager</code>检查权限。</li></ul><hr><h3 id=-线程名称生成机制>📛 <strong>线程名称生成机制</strong></h3><ul><li>自增规则：<ul><li>静态变量<code>threadInitNumber</code>记录全局线程数量，每次构造新线程时自增。</li><li>示例：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>().</span><span class=na>start</span><span class=p>();</span><span class=w> </span><span class=c1>// 线程名：Thread-0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>().</span><span class=na>start</span><span class=p>();</span><span class=w> </span><span class=c1>// 线程名：Thread-1</span><span class=w>
</span></span></span></code></pre></div></li></ul></li></ul><hr><h3 id=-守护状态与优先级继承>⚖️ <strong>守护状态与优先级继承</strong></h3><ol><li><strong>守护线程（Daemon）</strong><ul><li>默认<strong>非守护线程</strong>（<code>daemon = false</code>）。</li><li>守护线程需显式调用<code>setDaemon(true)</code>，且必须在<code>start()</code>前设置。</li></ul></li><li><strong>优先级</strong><ul><li>默认继承<strong>父线程优先级</strong>（通常主线程为<code>NORM_PRIORITY=5</code>）。</li><li>可通过<code>setPriority()</code>调整（1~10），但优先级仅作调度器参考，不保证执行顺序。</li></ul></li></ol><hr><h3 id=-线程栈大小stacksize>🔍 <strong>线程栈大小（stackSize）</strong></h3><ul><li>默认值为<code>0</code>，表示由JVM自动分配栈大小（通常取决于操作系统和JVM参数）。</li><li>可通过构造方法<code>Thread(ThreadGroup, Runnable, String, long)</code>显式指定栈大小（单位：字节），但平台兼容性较差。</li></ul><hr><h3 id=-默认实现的实践意义与风险>⚠️ <strong>默认实现的实践意义与风险</strong></h3><ol><li><strong>常见误区</strong><ul><li>直接调用<code>run()</code>而非<code>start()</code>：导致任务在当前线程同步执行，失去多线程意义。</li><li>未重写<code>run()</code>或传入<code>Runnable</code>：线程启动后无操作，易被忽略。</li></ul></li><li><strong>设计意图</strong><ul><li><strong>解耦任务与线程</strong>：默认<code>run()</code>留空，强制开发者通过<code>Runnable</code>或重写方式明确任务逻辑，符合组合优于继承原则。</li><li><strong>安全继承</strong>：线程组、优先级等属性的自动继承，减少重复配置，确保线程环境一致性。</li></ul></li></ol><hr><h3 id=-总结>💎 <strong>总结</strong></h3><p>Thread类的默认实现聚焦于<strong>基础框架搭建</strong>与<strong>安全约束</strong>：</p><ul><li>通过<strong>空run()方法</strong>强制任务显式定义，避免隐式行为；</li><li>通过<strong>名称自增、线程组继承</strong>等机制减少配置成本；</li><li>依赖<strong>父线程属性</strong>（优先级、守护状态）确保环境一致性。
​<strong>开发者需主动注入任务逻辑</strong>​（<code>Runnable</code>或重写<code>run()</code>）并理解默认行为，才能有效利用多线程能力。</li></ul><h2 id=run>run()</h2><p>源码</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>target</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>target</span><span class=p>.</span><span class=na>run</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=runnable>Runnable</h2><p>Thread 类实现 <code>Runnable</code> 接口是 Java 多线程设计的核心思想之一，其背后蕴含了职责分离、灵活性和框架兼容性等多重考量。以下从设计哲学、技术实现和实际应用三个维度详细解析原因：</p><hr><h3 id=-设计哲学职责分离与组合优于继承>🔧 <strong>设计哲学：职责分离与组合优于继承</strong></h3><ol><li><strong>统一任务执行标准</strong>
<code>Runnable</code> 接口定义了线程任务的唯一方法 <code>run()</code>，而 <code>Thread</code> 作为线程的载体，通过实现 <code>Runnable</code> 接口，自身也成为一个可执行的任务。这种设计使得：<ul><li><strong>任务与线程解耦</strong>：<code>Runnable</code> 仅描述任务逻辑，<code>Thread</code> 负责线程的创建、调度和管理。</li><li><strong>灵活组合</strong>：用户可通过继承 <code>Thread</code> 重写 <code>run()</code>（自身即任务），或向 <code>Thread</code> 传入外部 <code>Runnable</code> 对象（委托执行任务），实现任务逻辑的多样化封装<a class=link href=@ref>1,5</a>。</li></ul></li><li><strong>规避单继承限制</strong>
Java 不支持多继承，若 <code>Thread</code> 未实现 <code>Runnable</code>，则通过继承 <code>Thread</code> 定义任务的方式会永久占用类的继承权。而实现 <code>Runnable</code> 接口后：<ul><li>开发者可选择更灵活的 <strong>组合模式</strong>（传入 <code>Runnable</code> 任务），避免因继承 <code>Thread</code> 导致无法继承其他业务类的问题<a class=link href=@ref>4,7</a>。</li></ul></li></ol><hr><h3 id=-技术实现委托机制与默认逻辑>⚙️ <strong>技术实现：委托机制与默认逻辑</strong></h3><ol><li><strong>源码中的委托模式</strong>
在 <code>Thread</code> 类的源码中，通过 <code>target</code> 字段支持外部任务：<pre tabindex=0><code>public class Thread implements Runnable {
    private Runnable target; // 存储外部任务
    @Override
    public void run() {
        if (target != null) {
            target.run(); // 委托执行外部任务
        }
    }
}
</code></pre><ul><li><strong>默认行为</strong>：直接继承 <code>Thread</code> 时，需重写 <code>run()</code> 方法（覆盖默认逻辑）。</li><li><strong>外部任务</strong>：通过构造函数传入 <code>Runnable</code> 对象时，<code>Thread.run()</code> 会调用其 <code>target.run()</code><a class=link href=@ref>3,5</a>。</li></ul></li><li><strong>支持两种任务定义方式</strong><ul><li>方式1（继承 Thread）：<pre tabindex=0><code>class MyThread extends Thread {
    @Override public void run() { /* 自定义逻辑 */ }
}
new MyThread().start();
</code></pre></li><li>方式2（组合 Runnable）：<pre tabindex=0><code>class MyTask implements Runnable {
    @Override public void run() { /* 自定义逻辑 */ }
}
new Thread(new MyTask()).start();
</code></pre>两种方式最终均通过 <code>Thread.run()</code> 统一执行，体现了接口的适配性<a class=link href=@ref>4,8</a>。</li></ul></li></ol><hr><h3 id=-实际应用灵活性与生态兼容>🚀 <strong>实际应用：灵活性与生态兼容</strong></h3><ol><li><strong>任务复用与线程池集成</strong><ul><li><strong>资源共享</strong>：同一个 <code>Runnable</code> 任务可被多个 <code>Thread</code> 实例执行（如线程池中的任务队列），避免重复创建任务对象<a class=link href=@ref>4,7</a>。</li><li>线程池兼容：Java 并发框架（如</li></ul></li></ol><pre tabindex=0><code>     ExecutorService
</code></pre><pre><code> ）直接接受
</code></pre><pre tabindex=0><code>     Runnable
</code></pre><p>任务，与</p><pre tabindex=0><code>     Thread
</code></pre><p>解耦：
<code>ExecutorService pool = Executors.newFixedThreadPool(2); pool.submit(() -> System.out.println("Runnable任务")); // 无需绑定Thread实例</code>
2. <strong>函数式编程支持</strong>
<code>Runnable</code> 是函数式接口（仅有一个抽象方法），可直接用 Lambda 表达式简化代码：</p><pre tabindex=0><code>new Thread(() -&gt; System.out.println(&#34;Lambda任务&#34;)).start(); 
</code></pre><p>若 <code>Thread</code> 未实现 <code>Runnable</code>，此写法将无法成立<a class=link href=@ref>4,5</a>。
3. <strong>框架设计的扩展性</strong></p><ul><li><strong>Callable/Future 兼容</strong>：<code>Callable</code> 作为 <code>Runnable</code> 的增强版（支持返回值），通过 <code>FutureTask</code> 适配 <code>Runnable</code> 接口，最终仍由 <code>Thread</code> 执行。</li><li><strong>虚拟线程支持</strong>：Java 21 的虚拟线程（<code>Thread.startVirtualThread()</code>）直接接受 <code>Runnable</code> 任务，延续了统一的任务抽象<a class=link href=@ref>5,8</a>。</li></ul><hr><h3 id=-继承thread-vs-实现runnable的对比>⚖️ <strong>继承Thread vs 实现Runnable的对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>维度</strong></th><th><strong>继承 Thread</strong></th><th><strong>实现 Runnable</strong></th></tr></thead><tbody><tr><td><strong>任务定义</strong></td><td>重写 <code>run()</code>，任务与线程绑定</td><td>实现 <code>run()</code>，任务可独立于线程存在</td></tr><tr><td><strong>继承灵活性</strong></td><td>占用继承权，无法继承其他类</td><td>可继承其他类，无限制</td></tr><tr><td><strong>任务复用</strong></td><td>一个线程实例只能执行自身任务</td><td>同一任务可被多个线程执行</td></tr><tr><td><strong>函数式支持</strong></td><td>不支持 Lambda</td><td>支持 Lambda 表达式</td></tr><tr><td><strong>线程池兼容</strong></td><td>需包装成 <code>Runnable</code> 提交</td><td>直接提交任务对象</td></tr></tbody></table></div><blockquote><p>💡 <strong>设计启示</strong>：<code>Thread</code> 实现 <code>Runnable</code> 本质是 <strong>“自身即任务”</strong> 与 <strong>“委托外部任务”</strong> 的辩证统一，既保留了传统用法，又为现代并发框架铺平道路。</p></blockquote><hr><h3 id=-总结-1>💎 <strong>总结</strong></h3><p>Thread 实现 <code>Runnable</code> 接口的核心价值在于：</p><ol><li><strong>统一性</strong>：通过 <code>run()</code> 方法统一所有线程任务的执行入口。</li><li><strong>解耦性</strong>：分离线程控制（<code>Thread</code>）与任务逻辑（<code>Runnable</code>），支持组合优于继承。</li><li><strong>扩展性</strong>：为线程池、函数式编程、虚拟线程等高级特性提供底层兼容。
这一设计是 Java 并发模型的基石，深刻体现了 <strong>“简单性不应牺牲灵活性”</strong> 的工程哲学<a class=link href=@ref>1,5,7</a>。实际开发中，<strong>优先使用 <code>Runnable</code></strong>（或 <code>Callable</code>）配合线程池，已成为现代 Java 并发的黄金实践。</li></ol><h2 id=join>Join()</h2><p>在Java中，<code>Thread.join()</code>方法等待的<strong>不是显式的信号量或事件</strong>，而是<strong>目标线程终止（即线程执行结束）的状态变化</strong>。其底层实现依赖于JVM内部的线程状态管理与同步机制，具体原理如下：</p><hr><h3 id=-等待的目标线程终止状态>⚙️ <strong>等待的目标：线程终止状态</strong></h3><p><code>join()</code>的核心作用是<strong>阻塞当前线程，直到目标线程（调用<code>join</code>方法的线程实例）结束运行</strong>。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Thread</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=cm>/* 任务逻辑 */</span><span class=w> </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>t</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>t</span><span class=p>.</span><span class=na>join</span><span class=p>();</span><span class=w> </span><span class=c1>// 当前线程在此阻塞，直到t线程执行完毕</span><span class=w>
</span></span></span></code></pre></div><p>这里等待的“信号”实质是<strong>目标线程从<code>RUNNABLE</code>状态转变为<code>TERMINATED</code>状态</strong>。</p><hr><h3 id=-底层实现基于锁与等待队列>🔧 <strong>底层实现：基于锁与等待队列</strong></h3><p><code>join()</code>的阻塞和唤醒依赖Java的<strong>对象监视器锁（Monitor）</strong> 和 <strong><code>wait/notify</code>机制</strong>，具体流程如下：</p><h4 id=1阻塞当前线程><strong>（1）阻塞当前线程</strong></h4><ul><li>当调用<code>t.join()</code>时，当前线程（如主线程）会<strong>获取目标线程对象<code>t</code>的锁</strong>（<code>synchronized</code>修饰的方法）。</li><li>在锁内部，通过<pre tabindex=0><code>while (t.isAlive())
</code></pre>循环检查目标线程是否存活：<ul><li>若目标线程存活，则调用<code>t.wait(0)</code>，<strong>释放锁并进入等待状态</strong>（WAITING或TIMED_WAITING）。</li></ul></li></ul><h4 id=2唤醒机制><strong>（2）唤醒机制</strong></h4><ul><li>当目标线程<code>t</code>执行完毕（进入<code>TERMINATED</code>状态）时，<strong>JVM在底层自动调用<code>notifyAll()</code></strong>，唤醒所有在<code>t</code>对象上等待的线程。</li><li>这一过程在JVM源码中由<pre tabindex=0><code>ensure_join()
</code></pre>函数触发（参考HotSpot的<pre tabindex=0><code>thread.cpp
</code></pre>）：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>void</span><span class=w> </span><span class=n>JavaThread</span><span class=p>::</span><span class=n>exit</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ensure_join</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=w> </span><span class=c1>// 唤醒等待该线程结束的线程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>ensure_join</span><span class=p>(</span><span class=n>JavaThread</span><span class=o>*</span><span class=w> </span><span class=n>thread</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>lock</span><span class=p>.</span><span class=na>notify_all</span><span class=p>(</span><span class=n>thread</span><span class=p>);</span><span class=w> </span><span class=c1>// 调用notifyAll唤醒等待者</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul><blockquote><p><strong>关键点</strong>：开发者无需手动调用<code>notify()</code>，JVM在<strong>线程结束时自动处理唤醒逻辑</strong>。</p></blockquote><hr><h3 id=-中断处理>⚠️ <strong>中断处理</strong></h3><p>若等待过程中当前线程被中断（调用<code>interrupt()</code>）：</p><ul><li><code>join()</code>会抛出<code>InterruptedException</code>，并<strong>清除中断标志位</strong>；</li><li>此时需捕获异常并处理中断（如退出任务或重置状态）。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>t</span><span class=p>.</span><span class=na>join</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>InterruptedException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 处理中断：恢复标志位或终止任务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>().</span><span class=na>interrupt</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><hr><h3 id=-超时控制>🔄 <strong>超时控制</strong></h3><p><code>join(long millis)</code>允许设置最大等待时间：</p><ul><li>若超时后目标线程仍未结束，当前线程会<strong>自动唤醒并继续执行</strong>；</li><li>实现通过<code>wait(delay)</code>循环检查时间，避免永久阻塞。</li></ul><hr><h3 id=-总结等待的信号是什么>💎 <strong>总结：等待的“信号”是什么？</strong></h3><ul><li><strong>物理层面</strong>：线程对象<code>t</code>的锁状态变化（<code>wait()</code> → <code>notifyAll()</code>）；</li><li><strong>逻辑层面</strong>：目标线程从存活（<code>isAlive() == true</code>）到终止（<code>TERMINATED</code>）的状态切换；</li><li><strong>触发方</strong>：JVM在目标线程结束时自动触发唤醒操作，无需开发者干预。
通过这一机制，<code>join()</code>实现了线程间的<strong>顺序控制</strong>，常用于主线程等待子线程完成后再进行结果汇总或资源回收。</li></ul><h2 id=interrupt--yield>Interrupt() & yield()</h2><p>在Java中，<code>interrupt()</code>和<code>yield()</code>方法的调用范围和行为有显著区别，具体分析如下：</p><hr><h3 id=-interrupt>⚙️ <strong><code>interrupt()</code>方法的调用范围</strong></h3><ul><li><strong>线程内调用</strong>：
线程可以在自身内部调用<code>interrupt()</code>，例如在<code>run()</code>方法中通过<code>Thread.currentThread().interrupt()</code>中断自己。这种方式通常用于在捕获<code>InterruptedException</code>后重新设置中断标志（例如在<code>catch</code>块中）。</li><li>线程外调用：允许在其他线程中调用目标线程的<pre tabindex=0><code>interrupt()
</code></pre>方法。例如，主线程可以通过<pre tabindex=0><code>thread.interrupt()
</code></pre>中断子线程。但需注意：<ul><li>若目标线程处于运行状态，仅设置中断标志位，需线程内部主动检查（如<code>isInterrupted()</code>）才能响应中断。</li><li>若目标线程处于阻塞状态（如<code>sleep()</code>、<code>wait()</code>、<code>join()</code>），会立即抛出<code>InterruptedException</code>并清除中断标志。</li><li><strong>权限要求</strong>：调用方需持有目标线程对象的引用，且若跨线程调用需通过安全权限检查（否则抛出<code>SecurityException</code>）。</li></ul></li></ul><hr><h3 id=-yield>⏳ <strong><code>yield()</code>方法的调用范围</strong></h3><ul><li><strong>线程内调用</strong>：
<code>yield()</code>是静态方法，​<strong>只能在当前运行线程内部调用</strong>​（如<code>Thread.yield()</code>）。它的作用是提示调度器让出当前线程的CPU使用权，使当前线程从运行状态（Running）转为就绪状态（Ready）。</li><li><strong>线程外调用</strong>：
​<strong>无法在其他线程中调用<code>yield()</code>控制目标线程</strong>。因为<code>yield()</code>仅影响调用它的当前线程，且不接收任何线程对象参数。</li></ul><hr><h3 id=-关键区别总结>💎 <strong>关键区别总结</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>方法</strong></th><th><strong>线程内调用</strong></th><th><strong>线程外调用</strong></th><th><strong>行为特点</strong></th></tr></thead><tbody><tr><td><strong><code>interrupt()</code></strong></td><td>支持（如<code>Thread.currentThread().interrupt()</code>）</td><td>支持（需持有目标线程引用）</td><td>设置中断标志或抛出异常；可跨线程控制目标线程中断。</td></tr><tr><td><strong><code>yield()</code></strong></td><td>支持（<code>Thread.yield()</code>）</td><td><strong>不支持</strong>（无法让其他线程让出CPU）</td><td>仅影响当前线程；提示调度器让出CPU，不保证立即切换；不释放锁。</td></tr></tbody></table></div><hr><h3 id=-使用注意事项>⚠️ <strong>使用注意事项</strong></h3><ol><li><pre tabindex=0><code>interrupt()
</code></pre>的可靠性：<ul><li>若目标线程未检查中断标志或未处理<code>InterruptedException</code>，中断可能无效。</li><li>I/O阻塞（如<code>socket.accept()</code>）无法通过<code>interrupt()</code>中断，需关闭底层资源。</li></ul></li><li><pre tabindex=0><code>yield()
</code></pre>的局限性：<ul><li>仅是<strong>提示</strong>而非强制让出CPU，实际效果依赖操作系统调度器。</li><li>过度使用可能导致频繁线程切换，降低性能。</li></ul></li><li>设计替代方案：<ul><li>需精确控制线程执行顺序时，优先使用<code>wait/notify</code>、锁或<code>Semaphore</code>。</li></ul></li></ol><ul><li>避免依赖<code>yield()</code>实现同步逻辑（因行为不可预测）。</li></ul><hr><h3 id=-典型场景示例>💡 <strong>典型场景示例</strong></h3><ul><li><strong><code>interrupt()</code></strong>：主线程等待子线程超时后中断任务：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Thread</span><span class=w> </span><span class=n>worker</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>().</span><span class=na>isInterrupted</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 执行任务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>worker</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Thread</span><span class=p>.</span><span class=na>sleep</span><span class=p>(</span><span class=n>5000</span><span class=p>);</span><span class=w> </span><span class=c1>// 等待5秒</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>worker</span><span class=p>.</span><span class=na>interrupt</span><span class=p>();</span><span class=w> </span><span class=c1>// 外部中断</span><span class=w>
</span></span></span></code></pre></div></li><li><strong><code>yield()</code></strong>：当前线程在耗时循环中主动让出CPU：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>1000000</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>1000</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=n>Thread</span><span class=p>.</span><span class=na>yield</span><span class=p>();</span><span class=w> </span><span class=c1>// 每1000次迭代让出CPU</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul><hr><h3 id=-总结-2>✅ <strong>总结</strong></h3><ul><li><strong><code>interrupt()</code></strong>：支持线程内外调用，是<strong>跨线程协作</strong>的核心中断机制。</li><li><strong><code>yield()</code></strong>：仅支持线程内调用，用于<strong>当前线程主动优化CPU资源分配</strong>，不影响其他线程。
两者均需结合线程状态和任务逻辑谨慎使用，避免误用导致性能或稳定性问题。</li></ul><h2 id=yield>yield()</h2><p>在Java多线程编程中，<code>Thread.yield()</code>方法用于提示线程调度器当前线程愿意暂时让出CPU资源。以下是调用<code>yield()</code>后线程状态的变化及其后续执行行为的详细分析：</p><hr><h3 id=-线程状态的变化>⚙️ <strong>线程状态的变化</strong></h3><ol><li><strong>从运行态转为就绪态</strong><ul><li>当线程调用<code>yield()</code>时，会从<strong>运行状态（Running）</strong> 主动退回到<strong>就绪状态（Runnable）</strong>。</li><li>关键特性：<ul><li><strong>非阻塞</strong>：线程不会进入阻塞（Blocked）或等待（Waiting）状态，仅释放当前CPU时间片。</li><li><strong>不释放锁</strong>：即使让出CPU，线程仍持有已获取的锁资源，其他线程无法抢占这些锁。</li><li><strong>无休眠时间</strong>：与<code>sleep()</code>不同，<code>yield()</code>不指定暂停时长，线程可立即参与下一轮CPU竞争。</li></ul></li></ul></li><li><strong>操作系统调度器的角色</strong><ul><li><code>yield()</code>仅是<strong>提示性请求</strong>，操作系统调度器可忽略该请求，继续让当前线程执行。</li><li>若调度器接受请求，会从就绪队列中选择其他线程执行（优先级相同或更高的线程可能优先）。</li></ul></li></ol><hr><h3 id=-后续能否重新继续执行>🔄 <strong>后续能否重新继续执行？</strong></h3><ol><li><strong>立即重新调度的可能性</strong><ul><li>线程调用<pre tabindex=0><code>yield()
</code></pre>后仍处于就绪队列，
可能被立即重新选中执行
。例如：<ul><li>若系统中无其他就绪线程，调度器可能再次分配CPU给该线程。</li><li>若线程优先级较高，重获执行权的概率更高（尽管规范要求优先同级线程）。</li></ul></li></ul></li><li><strong>执行位置的延续性</strong><ul><li>线程被重新调度后，<strong>从<code>yield()</code>之后的代码继续执行</strong>，而非从头开始。</li><li>示例：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>5</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>2</span><span class=p>)</span><span class=w> </span><span class=n>Thread</span><span class=p>.</span><span class=na>yield</span><span class=p>();</span><span class=w> </span><span class=c1>// 让出CPU</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div>若线程在<pre tabindex=0><code>i=2
</code></pre>时让出CPU，恢复后直接从<pre tabindex=0><code>i=3
</code></pre>继续循环。</li></ul></li></ol><hr><h3 id=-重要注意事项>⚠️ <strong>重要注意事项</strong></h3><ol><li><p><strong>行为的不确定性</strong></p><ul><li><pre tabindex=0><code>yield()
</code></pre><p>的效果高度依赖操作系统和JVM实现：</p><ul><li>在Windows和Linux等系统中，调度策略差异可能导致结果不一致。</li><li>测试时需多次运行观察（如<a class=link href=https://blog.csdn.net/qq_43071699/article/details/144625959 target=_blank rel=noopener>示例代码</a>中线程交替顺序不固定）。</li></ul></li></ul></li><li><p><strong>与<code>sleep(0)</code>的区别</strong></p><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><code>yield()</code></th><th><code>sleep(0)</code></th></tr></thead><tbody><tr><td><strong>状态变化</strong></td><td>运行态 → 就绪态</td><td>运行态 → 阻塞态（TIMED_WAITING）</td></tr><tr><td><strong>锁释放</strong></td><td>否</td><td>否</td></tr><tr><td><strong>调度层级</strong></td><td>JVM层面提示</td><td>操作系统级调度</td></tr><tr><td><strong>异常处理</strong></td><td>无</td><td>需处理<code>InterruptedException</code></td></tr></tbody></table></div><blockquote><p>注：<code>sleep(0)</code>会触发操作系统级线程切换，而<code>yield()</code>仅在JVM层面提示。</p></blockquote></li><li><p><strong>适用场景与限制</strong></p><ul><li><strong>适用</strong>：调试、性能测试、自旋等待优化（如减少CPU空转）。</li><li>避免：<ul><li>依赖<code>yield()</code>控制线程顺序（结果不可靠）；</li><li>频繁调用导致线程切换开销激增（降低性能）。</li></ul></li></ul></li></ol><hr><h3 id=-总结-3>💎 <strong>总结</strong></h3><ul><li><strong>状态变化</strong>：<code>yield()</code>使线程从<strong>运行态 → 就绪态</strong>，不阻塞、不释放锁。</li><li><strong>后续执行</strong>：线程可能<strong>立即被重新调度</strong>，且从<code>yield()</code>后代码继续执行。</li><li><strong>核心风险</strong>：行为不可预测，<strong>不应用于关键线程同步</strong>（优先使用<code>Lock</code>、<code>Semaphore</code>等）。</li></ul><blockquote><p>通过<code>yield()</code>，开发者可提示系统优化资源分配，但需理解其非强制性本质，避免误用为同步机制。</p></blockquote><h2 id=主线程>主线程</h2><p>主线程在Java中与其他线程地位相同，其调用<code>yield()</code>或<code>interrupt()</code>的可行性及效果需分情况讨论。以下是具体分析：</p><hr><h3 id=-主线程调用>⚙️ <strong>主线程调用 <code>yield()</code></strong></h3><ul><li><strong>可行性</strong>：
​<strong>支持调用</strong>。<code>yield()</code>是静态方法，主线程可通过<code>Thread.yield()</code>主动让出CPU。</li><li>行为效果：<ul><li><strong>状态变化</strong>：主线程从<strong>运行态（Running）</strong> 转为<strong>就绪态（Runnable）</strong>，允许其他同级或更高优先级线程获得CPU时间片。</li><li><strong>不确定性</strong>：调度器可能忽略该提示，主线程可能立即被重新调度（尤其在无其他活跃线程时）。</li><li><strong>无锁释放</strong>：即使让出CPU，主线程仍持有已获取的锁资源。</li></ul></li><li><strong>典型场景</strong>：
主线程在循环中执行密集型计算时，适时调用<code>yield()</code>避免长时间独占CPU，提升其他后台线程响应性（如GUI事件处理）。</li></ul><hr><h3 id=-主线程调用-1>⚡ <strong>主线程调用 <code>interrupt()</code></strong></h3><h4 id=1中断自身><strong>（1）中断自身（<code>Thread.currentThread().interrupt()</code>）</strong></h4><ul><li><p><strong>可行性</strong>：
​<strong>支持调用</strong>。主线程可中断自己，设置自身的中断标志位为<code>true</code>。</p></li><li><p>行为效果：</p><ul><li><strong>中断状态标记</strong>：仅设置标志位，<strong>不会强制终止</strong>主线程。</li><li><strong>后续响应</strong>：主线程需主动检查中断状态（如<code>Thread.interrupted()</code>）并决定是否退出任务。</li><li><strong>异常触发</strong>：若主线程在阻塞方法（如<code>Thread.sleep()</code>）中，会立即抛出<code>InterruptedException</code>并清除中断标志。</li></ul></li><li><p>典型场景：</p><p>在捕获</p><pre tabindex=0><code>InterruptedException
</code></pre><p>后恢复中断状态，确保上层逻辑感知中断请求：</p><pre tabindex=0><code>try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    Thread.currentThread().interrupt(); // 重置中断标志
    System.out.println(&#34;主线程中断已恢复&#34;);
}
</code></pre></li></ul><h4 id=2中断其他线程><strong>（2）中断其他线程</strong></h4><ul><li><p><strong>可行性</strong>：
​<strong>支持调用</strong>。主线程可通过持有目标线程的引用（如<code>childThread.interrupt()</code>）中断子线程。</p></li><li><p>行为效果：</p><ul><li>子线程状态：<ul><li>若子线程在<strong>运行中</strong>，仅设置中断标志，需子线程主动检查并响应。</li><li>若子线程在<strong>阻塞中</strong>（如<code>sleep()</code>），会抛出<code>InterruptedException</code>并清除中断标志。</li></ul></li><li><strong>权限要求</strong>：需持有目标线程对象引用，且可能受<code>SecurityManager</code>限制。</li></ul></li><li><p>典型场景：</p><p>主线程超时后中断子线程：</p><pre tabindex=0><code>Thread worker = new Thread(() -&gt; {
    while (!Thread.interrupted()) {
        // 执行任务
    }
});
worker.start();
Thread.sleep(5000); // 等待5秒
worker.interrupt(); // 主线程中断子线程
</code></pre></li></ul><hr><h3 id=-关键注意事项>⚠️ <strong>关键注意事项</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>操作</strong></th><th><strong>可行性</strong></th><th><strong>风险/限制</strong></th><th><strong>替代方案</strong></th></tr></thead><tbody><tr><td><strong>主线程yield</strong></td><td>✔️ 支持</td><td>效果不可靠（依赖调度器）；频繁调用增加上下文切换开销</td><td>使用<code>Semaphore</code>控制并发资源分配</td></tr><tr><td><strong>主线程中断自身</strong></td><td>✔️ 支持</td><td>不自动终止线程，需配合状态检查；阻塞中触发异常需重置标志</td><td>设计协作式终止逻辑</td></tr><tr><td><strong>主线程中断子线程</strong></td><td>✔️ 支持（需引用权限）</td><td>子线程不检查中断则无效；I/O阻塞无法中断（需关闭底层资源）</td><td>使用<code>Future.cancel()</code>管理线程池任务</td></tr></tbody></table></div><hr><h3 id=-总结-4>💎 <strong>总结</strong></h3><ul><li><p><strong><code>yield()</code></strong>：主线程可主动让出CPU，但效果不保证，适用于优化资源分配，<strong>非同步控制</strong>。</p></li><li><pre tabindex=0><code>interrupt()
```：
- 中断自身：需显式检查状态或处理阻塞异常；
- 中断子线程：需目标线程协作响应，否则无效。
  ​**合理利用中断机制可实现优雅终止，而`yield()`应谨慎用于性能调优**。
</code></pre></li></ul><h2 id=守护进程>守护进程</h2><p>守护线程（Daemon Thread）在Java中不会干扰JVM的正常退出，其核心机制基于其<strong>生命周期设计</strong>和<strong>JVM的退出规则</strong>。以下是具体原因的分点解析：</p><hr><h3 id=-生命周期依赖非守护线程>⚙️ <strong>生命周期依赖非守护线程</strong></h3><ul><li><strong>绑定关系</strong>：守护线程的存在是为了服务非守护线程（用户线程）。当所有用户线程结束时，JVM会立即终止所有守护线程并退出，无论守护线程是否完成任务。</li><li><strong>设计原则</strong>：守护线程被定义为“辅助性角色”（如垃圾回收、日志记录），其任务结果不影响程序核心逻辑的完成。因此，当被服务的对象（用户线程）消失时，守护线程失去存在意义，JVM无需等待其结束。</li></ul><hr><h3 id=-jvm退出规则>🔄 <strong>JVM退出规则</strong></h3><ul><li>触发条件：JVM退出的唯一条件是所有用户线程终止。守护线程的运行状态不参与此判断。<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 示例：主线程退出后，JVM无视守护线程直接退出</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Thread</span><span class=w> </span><span class=n>daemonThread</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Daemon running...&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>daemonThread</span><span class=p>.</span><span class=na>setDaemon</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>daemonThread</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Main thread exits → JVM exits&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div>输出：主线程结束后，守护线程的循环被强制终止，JVM退出。</li></ul><hr><h3 id=-资源与任务的中断机制>⚠️ <strong>资源与任务的中断机制</strong></h3><ul><li><strong>无资源持有要求</strong>：守护线程不应持有需要显式释放的资源（如文件锁、数据库连接）。因为JVM退出时不会调用其<code>finally</code>块或清理资源，可能导致泄漏。</li><li><strong>任务可中断性</strong>：守护线程通常设计为可随时中断的任务（如周期性日志写入）。若任务需原子性完成（如事务提交），则不适合用守护线程。</li></ul><hr><h3 id=-与用户线程的本质区别>🧩 <strong>与用户线程的本质区别</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>用户线程</strong></th><th><strong>守护线程</strong></th></tr></thead><tbody><tr><td><strong>阻止JVM退出</strong></td><td>是（只要存在即阻止）</td><td>否（不参与JVM存活判断）</td></tr><tr><td><strong>任务重要性</strong></td><td>核心逻辑（如数据处理）</td><td>辅助任务（如垃圾回收）</td></tr><tr><td><strong>资源管理</strong></td><td>需显式释放资源</td><td>避免持有关键资源</td></tr><tr><td><strong>生命周期控制</strong></td><td>需主动结束或等待完成</td><td>随用户线程结束自动终止</td></tr></tbody></table></div><hr><h3 id=-典型应用场景的合理性>💡 <strong>典型应用场景的合理性</strong></h3><ul><li><strong>垃圾回收（GC）</strong>：GC线程是守护线程的典范。当用户线程全部结束后，内存中不再产生新垃圾，GC线程无需继续运行，JVM退出符合逻辑。</li><li><strong>心跳检测/日志记录</strong>：这类任务即使中途中断也不影响程序最终状态（如日志丢失部分记录可接受）。</li></ul><hr><h3 id=-注意潜在风险与限制>⚠️ 注意：潜在风险与限制</h3><ol><li><strong>不可靠的终止</strong>：守护线程中<code>finally</code>代码块可能不执行，导致清理逻辑失效。</li><li><strong>阻塞操作的风险</strong>：若守护线程因I/O阻塞（如<code>socket.accept()</code>），而所有用户线程已结束，JVM仍会强制退出，可能破坏操作原子性。</li><li>错误使用干扰JVM：<ul><li>在守护线程中调用<code>Thread.join()</code>会阻塞调用者（如主线程），反而阻止JVM退出。</li><li>若守护线程创建新用户线程，会违反JVM退出条件。</li></ul></li></ol><hr><h3 id=-总结-5>💎 总结</h3><p>守护线程不干扰JVM的本质在于：</p><ol><li><strong>定位机制</strong>：作为用户线程的“附属品”，其存活无独立价值；</li><li><strong>退出规则</strong>：JVM仅依赖用户线程判断退出时机，守护线程被强制终止；</li><li><strong>任务设计</strong>：适用于可丢弃、非关键的后台任务。
​<strong>合理使用守护线程能提升后台任务效率，但需严格规避关键操作和资源持有</strong>。</li></ol></section><footer class=article-footer><section class=article-tags><a href=/tags/java/>Java</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Oct 20, 2025 22:07 CST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/nowcoderjava-2/><div class=article-details><h2 class=article-title>【NowCoder】JAVA 2</h2></div></a></article><article><a href=/p/nowcoderjava/><div class=article-details><h2 class=article-title>【NowCoder】JAVA</h2></div></a></article><article><a href=/p/templejava-c/><div class=article-details><h2 class=article-title>【Temple】Java & C</h2></div></a></article><article><a href=/p/javamodule/><div class=article-details><h2 class=article-title>【Java】Module</h2></div></a></article><article><a href=/p/javaexception/><div class=article-details><h2 class=article-title>【Java】Exception</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>