<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="CAS CAS（Compare And Swap，比较并交换）是多线程编程中的一种无锁并发控制技术，通过硬件指令实现原子操作，避免传统锁机制的性能开销。其核心思想是通过比较内存值与预期值来决定是否更新，整个过程由CPU保证原子性。以下是详细解析：\n⚙️ CAS的核心原理 三步操作（原子性） CAS操作包含三个关键参数： 内存地址（V）：要修改的共享变量内存位置。 预期原值（A）：线程认为变量当前应有的值。 新值（B）：若内存值等于预期值，则更新为此值。 伪代码表示： boolean CAS(V, A, B) { if (V == A) { // 比较内存值与预期值 V = B; // 相等则更新为新值 return true; } return false; // 否则操作失败 } 原子性保障：这三步操作由单条CPU指令（如x86的lock cmpxchg）完成，执行期间不会被中断。 工作流程示例 假设共享变量 count=0，两个线程并发执行count++： 线程1读取count=0，执行CAS(0, 1)：内存值0等于预期值0，更新为1，成功。 线程2读取count=0（未及时刷新），执行CAS(0, 1)：内存值1≠预期值0，操作失败 → 重试读取count=1，再执行CAS(1, 2)，成功。 ⚖️ CAS的优缺点 ✅ 优点 无锁高性能 避免线程阻塞和上下文切换，适合低竞争场景（如计数器增减）。 吞吐量高于锁机制，尤其在细粒度操作中（如AtomicInteger自增）。 乐观并发 假设操作冲突少，失败时通过自旋重试（循环CAS）而非阻塞。 ⚠️ 缺点 ABA问题 若变量值从 A → B → A，CAS无法感知中间变化，可能误判“未被修改”。 解决方案：使用带版本号的原子类（如AtomicStampedReference），每次更新递增版本号。 自旋开销 高竞争场景下频繁失败重试，导致CPU空转（如100个线程争抢同一变量）。 单一变量限制 只能保证一个共享变量的原子操作。多变量需合并或改用锁。 ⚡️ Java中的CAS实现 Java通过 java.util.concurrent.atomic 包提供原子类，底层调用Unsafe类的CAS指令：\n"><title>【Java】Sync</title><link rel=canonical href=https://dyhes.github.io/p/javasync/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【Java】Sync"><meta property='og:description' content="CAS CAS（Compare And Swap，比较并交换）是多线程编程中的一种无锁并发控制技术，通过硬件指令实现原子操作，避免传统锁机制的性能开销。其核心思想是通过比较内存值与预期值来决定是否更新，整个过程由CPU保证原子性。以下是详细解析：\n⚙️ CAS的核心原理 三步操作（原子性） CAS操作包含三个关键参数： 内存地址（V）：要修改的共享变量内存位置。 预期原值（A）：线程认为变量当前应有的值。 新值（B）：若内存值等于预期值，则更新为此值。 伪代码表示： boolean CAS(V, A, B) { if (V == A) { // 比较内存值与预期值 V = B; // 相等则更新为新值 return true; } return false; // 否则操作失败 } 原子性保障：这三步操作由单条CPU指令（如x86的lock cmpxchg）完成，执行期间不会被中断。 工作流程示例 假设共享变量 count=0，两个线程并发执行count++： 线程1读取count=0，执行CAS(0, 1)：内存值0等于预期值0，更新为1，成功。 线程2读取count=0（未及时刷新），执行CAS(0, 1)：内存值1≠预期值0，操作失败 → 重试读取count=1，再执行CAS(1, 2)，成功。 ⚖️ CAS的优缺点 ✅ 优点 无锁高性能 避免线程阻塞和上下文切换，适合低竞争场景（如计数器增减）。 吞吐量高于锁机制，尤其在细粒度操作中（如AtomicInteger自增）。 乐观并发 假设操作冲突少，失败时通过自旋重试（循环CAS）而非阻塞。 ⚠️ 缺点 ABA问题 若变量值从 A → B → A，CAS无法感知中间变化，可能误判“未被修改”。 解决方案：使用带版本号的原子类（如AtomicStampedReference），每次更新递增版本号。 自旋开销 高竞争场景下频繁失败重试，导致CPU空转（如100个线程争抢同一变量）。 单一变量限制 只能保证一个共享变量的原子操作。多变量需合并或改用锁。 ⚡️ Java中的CAS实现 Java通过 java.util.concurrent.atomic 包提供原子类，底层调用Unsafe类的CAS指令：\n"><meta property='og:url' content='https://dyhes.github.io/p/javasync/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Java'><meta property='article:published_time' content='2025-06-19T00:00:00+00:00'><meta property='article:modified_time' content='2025-10-22T16:26:59+08:00'><meta name=twitter:title content="【Java】Sync"><meta name=twitter:description content="CAS CAS（Compare And Swap，比较并交换）是多线程编程中的一种无锁并发控制技术，通过硬件指令实现原子操作，避免传统锁机制的性能开销。其核心思想是通过比较内存值与预期值来决定是否更新，整个过程由CPU保证原子性。以下是详细解析：\n⚙️ CAS的核心原理 三步操作（原子性） CAS操作包含三个关键参数： 内存地址（V）：要修改的共享变量内存位置。 预期原值（A）：线程认为变量当前应有的值。 新值（B）：若内存值等于预期值，则更新为此值。 伪代码表示： boolean CAS(V, A, B) { if (V == A) { // 比较内存值与预期值 V = B; // 相等则更新为新值 return true; } return false; // 否则操作失败 } 原子性保障：这三步操作由单条CPU指令（如x86的lock cmpxchg）完成，执行期间不会被中断。 工作流程示例 假设共享变量 count=0，两个线程并发执行count++： 线程1读取count=0，执行CAS(0, 1)：内存值0等于预期值0，更新为1，成功。 线程2读取count=0（未及时刷新），执行CAS(0, 1)：内存值1≠预期值0，操作失败 → 重试读取count=1，再执行CAS(1, 2)，成功。 ⚖️ CAS的优缺点 ✅ 优点 无锁高性能 避免线程阻塞和上下文切换，适合低竞争场景（如计数器增减）。 吞吐量高于锁机制，尤其在细粒度操作中（如AtomicInteger自增）。 乐观并发 假设操作冲突少，失败时通过自旋重试（循环CAS）而非阻塞。 ⚠️ 缺点 ABA问题 若变量值从 A → B → A，CAS无法感知中间变化，可能误判“未被修改”。 解决方案：使用带版本号的原子类（如AtomicStampedReference），每次更新递增版本号。 自旋开销 高竞争场景下频繁失败重试，导致CPU空转（如100个线程争抢同一变量）。 单一变量限制 只能保证一个共享变量的原子操作。多变量需合并或改用锁。 ⚡️ Java中的CAS实现 Java通过 java.util.concurrent.atomic 包提供原子类，底层调用Unsafe类的CAS指令：\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#cas>CAS</a><ol><li><a href=#-cas的核心原理>⚙️ <strong>CAS的核心原理</strong></a></li><li><a href=#-cas的优缺点>⚖️ <strong>CAS的优缺点</strong></a><ol><li><a href=#-优点>✅ <strong>优点</strong></a></li><li><a href=#-缺点>⚠️ <strong>缺点</strong></a></li></ol></li><li><a href=#-java中的cas实现>⚡️ <strong>Java中的CAS实现</strong></a></li><li><a href=#-典型应用场景>🔧 <strong>典型应用场景</strong></a></li><li><a href=#-cas-vs-锁机制>↔️ <strong>CAS vs 锁机制</strong></a></li><li><a href=#-总结>💎 <strong>总结</strong></a></li></ol></li><li><a href=#atomicstampedreference>AtomicStampedReference</a><ol><li><a href=#-aba-问题与设计动机>🔍 <strong>ABA 问题与设计动机</strong></a></li><li><a href=#-实现原理与源码解析>⚙️ <strong>实现原理与源码解析</strong></a></li><li><a href=#-典型应用场景-1>⚡️ <strong>典型应用场景</strong></a></li><li><a href=#-与其他方案的对比>⚖️ <strong>与其他方案的对比</strong></a></li><li><a href=#-局限性与注意事项>⚠️ <strong>局限性与注意事项</strong></a></li><li><a href=#-总结-1>💎 <strong>总结</strong></a></li></ol></li><li><a href=#volatile>volatile</a><ol><li><a href=#-核心作用>⚙️ <strong>核心作用</strong></a></li><li><a href=#-局限性不保证原子性>⚠️ <strong>局限性：不保证原子性</strong></a></li><li><a href=#-实现原理>🔧 <strong>实现原理</strong></a></li><li><a href=#-适用场景>🛠️ <strong>适用场景</strong></a></li><li><a href=#-volatile>↔️ <strong><code>volatile</code> vs <code>synchronized</code></strong></a></li><li><a href=#-注意事项>⚠️ <strong>注意事项</strong></a></li></ol></li><li><a href=#synchronized>synchronized</a><ol><li><a href=#-synchronized>⚙️ <strong><code>synchronized</code> 的核心作用</strong></a></li><li><a href=#-synchronized-1>🛠️ <strong><code>synchronized</code> 的三种用法</strong></a><ol><li><a href=#修饰实例方法><strong>修饰实例方法</strong></a></li><li><a href=#修饰静态方法><strong>修饰静态方法</strong></a></li><li><a href=#修饰代码块><strong>修饰代码块</strong></a></li><li><a href=#-三种用法对比>🔍 <strong>三种用法对比</strong></a></li></ol></li><li><a href=#-底层实现原理>⚙️ <strong>底层实现原理</strong></a></li><li><a href=#-使用注意事项与最佳实践>⚠️ <strong>使用注意事项与最佳实践</strong></a></li><li><a href=#-synchronized-2>↔️ <strong><code>synchronized</code> vs <code>volatile</code></strong></a></li><li><a href=#-总结-2>💎 <strong>总结</strong></a></li></ol></li><li><a href=#object-monitor>Object Monitor</a><ol><li><a href=#-monitor-锁的核心结构>🔒 <strong>Monitor 锁的核心结构</strong></a></li><li><a href=#-monitor-锁的工作流程>⚙️ <strong>Monitor 锁的工作流程</strong></a><ol><li><a href=#加锁流程><strong>加锁流程（<code>monitorenter</code> 指令）</strong></a></li><li><a href=#释放锁><strong>释放锁（<code>monitorexit</code> 指令）</strong></a></li><li><a href=#wait><strong><code>wait()</code> 与 <code>notify()</code> 机制</strong></a></li></ol></li><li><a href=#-锁升级与重量级锁的关系>🔄 <strong>锁升级与重量级锁的关系</strong></a></li><li><a href=#-monitor-锁的特性总结>⚖️ <strong>Monitor 锁的特性总结</strong></a></li><li><a href=#-应用场景与注意事项>💡 <strong>应用场景与注意事项</strong></a></li></ol></li><li><a href=#synchronized-锁升级>synchronized 锁升级</a><ol><li><a href=#-锁的升级机制与设计背景>🔒 <strong>锁的升级机制与设计背景</strong></a></li><li><a href=#-三种锁的核心原理与特点>⚙️ <strong>三种锁的核心原理与特点</strong></a><ol><li><a href=#偏向锁biased-locking><strong>偏向锁（Biased Locking）</strong></a></li><li><a href=#轻量级锁lightweight-locking><strong>轻量级锁（Lightweight Locking）</strong></a></li><li><a href=#重量级锁heavyweight-locking><strong>重量级锁（Heavyweight Locking）</strong></a></li></ol></li><li><a href=#-三种锁的核心区别对比>🔍 <strong>三种锁的核心区别对比</strong></a></li><li><a href=#-锁升级流程与实战影响>⚠️ <strong>锁升级流程与实战影响</strong></a></li><li><a href=#-总结-3>💎 <strong>总结</strong></a></li></ol></li><li><a href=#偏向锁>偏向锁</a><ol><li><a href=#-核心原理与设计目标>⚙️ <strong>核心原理与设计目标</strong></a></li><li><a href=#-工作机制详解>🔄 <strong>工作机制详解</strong></a><ol><li><a href=#偏向锁的获取流程><strong>偏向锁的获取流程</strong></a></li><li><a href=#偏向锁的撤销与升级><strong>偏向锁的撤销与升级</strong></a></li><li><a href=#锁升级路径><strong>锁升级路径</strong></a></li></ol></li><li><a href=#-优缺点分析>⚖️ <strong>优缺点分析</strong></a><ol><li><a href=#-核心优势>✅ **核心优势</a></li><li><a href=#-局限性>⚠️ **局限性</a></li></ol></li><li><a href=#-适用场景与配置建议>🎯 <strong>适用场景与配置建议</strong></a><ol><li><a href=#理想场景><strong>理想场景</strong></a></li><li><a href=#不适用场景><strong>不适用场景</strong></a></li><li><a href=#jvm参数配置><strong>JVM参数配置</strong></a></li></ol></li><li><a href=#-与其他锁的对比>🔄 <strong>与其他锁的对比</strong></a></li><li><a href=#-总结-4>💎 <strong>总结</strong></a></li></ol></li><li><a href=#弃用偏向锁>弃用偏向锁</a><ol><li><a href=#-性能收益与成本失衡>🔧 <strong>性能收益与成本失衡</strong></a></li><li><a href=#-实现复杂性与维护负担>⚙️ <strong>实现复杂性与维护负担</strong></a></li><li><a href=#-现代硬件与并发模型的演进>🔄 <strong>现代硬件与并发模型的演进</strong></a></li><li><a href=#-开发者影响与应对建议>⚖️ <strong>开发者影响与应对建议</strong></a></li><li><a href=#-总结-5>💎 <strong>总结</strong></a></li></ol></li><li><a href=#unsafe>Unsafe</a><ol><li><a href=#-核心功能与原理>⚙️ <strong>核心功能与原理</strong></a><ol><li><a href=#内存操作><strong>内存操作</strong></a></li><li><a href=#对象操作><strong>对象操作</strong></a></li><li><a href=#cas原子操作><strong>CAS（原子操作）</strong></a></li><li><a href=#线程调度><strong>线程调度</strong></a></li><li><a href=#类与对象实例化><strong>类与对象实例化</strong></a></li></ol></li><li><a href=#-获取-unsafe-实例的方法>🔍 <strong>获取 Unsafe 实例的方法</strong></a></li><li><a href=#-主要风险与争议>⚠️ <strong>主要风险与争议</strong></a><ol><li><a href=#安全风险><strong>安全风险</strong></a></li><li><a href=#并发问题><strong>并发问题</strong></a></li><li><a href=#兼容性与官方态度><strong>兼容性与官方态度</strong></a></li></ol></li><li><a href=#-适用场景-vs-替代方案>⚖️ <strong>适用场景 vs 替代方案</strong></a></li><li><a href=#-总结与最佳实践>💎 <strong>总结与最佳实践</strong></a></li></ol></li><li><a href=#locksupport>LockSupport</a><ol><li><a href=#-核心原理许可机制permit>⚙️ <strong>核心原理：许可机制（Permit）</strong></a></li><li><a href=#-核心方法详解>🔧 <strong>核心方法详解</strong></a></li><li><a href=#-底层实现跨越三层架构>⚡ <strong>底层实现：跨越三层架构</strong></a></li><li><a href=#-与传统同步机制对比>🆚 <strong>与传统同步机制对比</strong></a></li><li><a href=#-应用场景与示例>🛠️ <strong>应用场景与示例</strong></a><ol><li><a href=#精准控制线程协作><strong>精准控制线程协作</strong></a></li><li><a href=#超时控制与中断处理><strong>超时控制与中断处理</strong></a></li><li><a href=#构建高级同步器如aqs><strong>构建高级同步器（如AQS）</strong></a></li></ol></li><li><a href=#-注意事项-1>⚠️ <strong>注意事项</strong></a></li><li><a href=#-总结-6>💎 <strong>总结</strong></a></li></ol></li><li><a href=#abstractqueuedsynchronizer>AbstractQueuedSynchronizer</a><ol><li><a href=#-核心设计原理>🔧 <strong>核心设计原理</strong></a><ol><li><a href=#状态管理state><strong>状态管理（State）</strong></a></li><li><a href=#等待队列clh-变体><strong>等待队列（CLH 变体）</strong></a></li><li><a href=#线程阻塞与唤醒><strong>线程阻塞与唤醒</strong></a></li></ol></li><li><a href=#-工作流程以独占模式为例>⚙️ <strong>工作流程（以独占模式为例）</strong></a><ol><li><a href=#获取资源><strong>获取资源（<code>acquire</code>）</strong></a></li><li><a href=#释放资源><strong>释放资源（<code>release</code>）</strong></a></li></ol></li><li><a href=#-aqs-的两种模式>🛠️ <strong>AQS 的两种模式</strong></a></li><li><a href=#-基于-aqs-的-jdk-同步工具>🌐 <strong>基于 AQS 的 JDK 同步工具</strong></a></li><li><a href=#-自定义同步器实现>💻 <strong>自定义同步器实现</strong></a><ol><li><a href=#步骤><strong>步骤</strong></a></li><li><a href=#示例非重入互斥锁><strong>示例：非重入互斥锁</strong></a></li><li><a href=#注意事项><strong>注意事项</strong></a></li></ol></li><li><a href=#-aqs-与-synchronized-对比>⚖️ <strong>AQS 与 synchronized 对比</strong></a></li><li><a href=#-总结-7>💎 <strong>总结</strong></a></li></ol></li><li><a href=#clh-队列>CLH 队列</a><ol><li><a href=#-核心结构与工作流程>⛓️ <strong>核心结构与工作流程</strong></a><ol><li><a href=#核心组件><strong>核心组件</strong></a></li><li><a href=#工作流程><strong>工作流程</strong></a></li></ol></li><li><a href=#-技术特点分析>⚙️ <strong>技术特点分析</strong></a><ol><li><a href=#核心优势><strong>核心优势</strong></a></li><li><a href=#局限性><strong>局限性</strong></a></li></ol></li><li><a href=#-clh在aqs中的变体实现>🔄 <strong>CLH在AQS中的变体实现</strong></a></li><li><a href=#-适用场景-1>🌐 <strong>适用场景</strong></a></li><li><a href=#-总结-8>💎 <strong>总结</strong></a></li></ol></li><li><a href=#lock>Lock</a><ol><li><a href=#-lock-接口的核心作用>🔒 <strong>Lock 接口的核心作用</strong></a></li><li><a href=#-lock-接口方法详解>⚙️ <strong>Lock 接口方法详解</strong></a></li><li><a href=#-lock-的主要实现类>🔧 <strong>Lock 的主要实现类</strong></a></li><li><a href=#-lock-vs-synchronized-核心对比>↔️ <strong>Lock vs Synchronized 核心对比</strong></a></li><li><a href=#-适用场景-2>🎯 <strong>适用场景</strong></a></li><li><a href=#-注意事项-2>⚠️ <strong>注意事项</strong></a></li><li><a href=#-总结-9>💎 <strong>总结</strong></a></li></ol></li><li><a href=#condition>Condition</a><ol><li><a href=#-condition-的核心作用与优势>⚙️ <strong>Condition 的核心作用与优势</strong></a></li><li><a href=#-底层实现原理基于-aqs>⛓️ <strong>底层实现原理（基于 AQS）</strong></a></li><li><a href=#-使用规范与注意事项>⚠️ <strong>使用规范与注意事项</strong></a><ol><li><a href=#强制使用规范><strong>强制使用规范</strong></a></li><li><a href=#中断处理><strong>中断处理</strong></a></li><li><a href=#唤醒策略建议><strong>唤醒策略建议</strong></a></li></ol></li><li><a href=#-典型应用场景与案例>🛠️ <strong>典型应用场景与案例</strong></a><ol><li><a href=#生产者-消费者模型多-condition-版><strong>生产者-消费者模型（多 Condition 版）</strong></a></li><li><a href=#多任务顺序调度精准唤醒><strong>多任务顺序调度（精准唤醒）</strong></a></li></ol></li><li><a href=#-condition-vs-object-监视器方法>🔄 <strong>Condition vs Object 监视器方法</strong></a></li><li><a href=#-工程实践注意事项>⚠️ <strong>工程实践注意事项</strong></a></li><li><a href=#-总结-10>💎 <strong>总结</strong></a></li></ol></li><li><a href=#semaphore>Semaphore</a><ol><li><a href=#-semaphore信号量详解原理实现与应用场景>🚦 Semaphore（信号量）详解：原理、实现与应用场景</a></li><li><a href=#-核心原理与模型>⚙️ <strong>核心原理与模型</strong></a><ol><li><a href=#信号量模型><strong>信号量模型</strong></a></li><li><a href=#公平性与非公平性><strong>公平性与非公平性</strong></a></li></ol></li><li><a href=#-底层实现基于-aqs>⚙️ <strong>底层实现（基于 AQS）</strong></a><ol><li><a href=#aqs-共享模式><strong>AQS 共享模式</strong></a></li><li><a href=#线程阻塞与唤醒-1><strong>线程阻塞与唤醒</strong></a></li></ol></li><li><a href=#-核心-api-与使用示例>🛠️ <strong>核心 API 与使用示例</strong></a><ol><li><a href=#常用方法><strong>常用方法</strong></a></li><li><a href=#代码示例限制并发下载线程数><strong>代码示例：限制并发下载线程数</strong></a></li></ol></li><li><a href=#-应用场景>🌐 <strong>应用场景</strong></a><ol><li><a href=#资源池管理><strong>资源池管理</strong></a></li><li><a href=#流量控制><strong>流量控制</strong></a></li><li><a href=#生产者-消费者协调><strong>生产者-消费者协调</strong></a></li></ol></li><li><a href=#-注意事项-3>⚠️ <strong>注意事项</strong></a></li><li><a href=#-总结-11>💎 <strong>总结</strong></a></li></ol></li><li><a href=#countdownlatch>CountDownLatch</a><ol><li><a href=#-核心机制计数器模型>⚙️ <strong>核心机制：计数器模型</strong></a><ol><li><a href=#核心组件-1><strong>核心组件</strong></a></li><li><a href=#一次性特性><strong>一次性特性</strong></a></li></ol></li><li><a href=#-使用方式与示例>📝 <strong>使用方式与示例</strong></a><ol><li><a href=#基础使用步骤><strong>基础使用步骤</strong></a></li><li><a href=#典型场景示例><strong>典型场景示例</strong></a></li></ol></li><li><a href=#-应用场景-1>🌐 <strong>应用场景</strong></a></li><li><a href=#-底层实现基于-aqs-1>🔧 <strong>底层实现（基于 AQS）</strong></a><ol><li><a href=#核心源码解析><strong>核心源码解析</strong></a></li><li><a href=#关键方法映射><strong>关键方法映射</strong></a></li></ol></li><li><a href=#-注意事项-4>⚠️ <strong>注意事项</strong></a></li><li><a href=#-与其他同步工具对比>⚖️ <strong>与其他同步工具对比</strong></a></li><li><a href=#-总结-12>💎 <strong>总结</strong></a></li></ol></li><li><a href=#cyclicbarrier>CyclicBarrier</a><ol><li><a href=#-核心原理循环屏障机制>⚙️ <strong>核心原理：循环屏障机制</strong></a><ol><li><a href=#核心设计><strong>核心设计</strong></a></li><li><a href=#工作流程-1><strong>工作流程</strong></a></li></ol></li><li><a href=#-底层实现基于锁与条件变量>⛓️ <strong>底层实现：基于锁与条件变量</strong></a><ol><li><a href=#核心组件源码关键字段><strong>核心组件（源码关键字段）</strong></a></li><li><a href=#await><strong><code>await()</code> 执行步骤</strong></a></li></ol></li><li><a href=#-使用场景与最佳实践>🛠️ <strong>使用场景与最佳实践</strong></a><ol><li><a href=#典型应用场景><strong>典型应用场景</strong></a></li><li><a href=#最佳实践与避坑指南><strong>最佳实践与避坑指南</strong></a></li></ol></li><li><a href=#-与-countdownlatch-的对比>⚖️ <strong>与 CountDownLatch 的对比</strong></a></li><li><a href=#-总结-13>💎 <strong>总结</strong></a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/temple/ style=background-color:#69a794;color:>白玉京</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/javasync/>【Java】Sync</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 19, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>19 minute read</time></div></footer></div></header><section class=article-content><h2 id=cas>CAS</h2><p>CAS（Compare And Swap，比较并交换）是多线程编程中的一种<strong>无锁并发控制技术</strong>，通过硬件指令实现原子操作，避免传统锁机制的性能开销。其核心思想是通过比较内存值与预期值来决定是否更新，整个过程由CPU保证原子性。以下是详细解析：</p><hr><h3 id=-cas的核心原理>⚙️ <strong>CAS的核心原理</strong></h3><ol><li><strong>三步操作（原子性）</strong>
CAS操作包含三个关键参数：<ul><li><strong>内存地址（V）</strong>：要修改的共享变量内存位置。</li><li><strong>预期原值（A）</strong>：线程认为变量当前应有的值。</li><li><strong>新值（B）</strong>：若内存值等于预期值，则更新为此值。
伪代码表示：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>boolean</span><span class=w> </span><span class=nf>CAS</span><span class=p>(</span><span class=n>V</span><span class=p>,</span><span class=w> </span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>B</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>V</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>A</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>   </span><span class=c1>// 比较内存值与预期值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>V</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>B</span><span class=p>;</span><span class=w>      </span><span class=c1>// 相等则更新为新值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>    </span><span class=c1>// 否则操作失败</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><strong>原子性保障</strong>：这三步操作由单条CPU指令（如x86的<code>lock cmpxchg</code>）完成，执行期间不会被中断。</li><li><strong>工作流程示例</strong>
假设共享变量 <code>count=0</code>，两个线程并发执行<code>count++</code>：<ul><li>线程1读取<code>count=0</code>，执行<code>CAS(0, 1)</code>：内存值<code>0</code>等于预期值<code>0</code>，更新为<code>1</code>，成功。</li><li>线程2读取<code>count=0</code>（未及时刷新），执行<code>CAS(0, 1)</code>：内存值<code>1</code>≠预期值<code>0</code>，操作失败 → 重试读取<code>count=1</code>，再执行<code>CAS(1, 2)</code>，成功。</li></ul></li></ol><hr><h3 id=-cas的优缺点>⚖️ <strong>CAS的优缺点</strong></h3><h4 id=-优点>✅ <strong>优点</strong></h4><ol><li>无锁高性能<ul><li>避免线程阻塞和上下文切换，适合<strong>低竞争场景</strong>（如计数器增减）。</li><li>吞吐量高于锁机制，尤其在细粒度操作中（如<code>AtomicInteger</code>自增）。</li></ul></li><li>乐观并发<ul><li>假设操作冲突少，失败时通过<strong>自旋重试</strong>（循环CAS）而非阻塞。</li></ul></li></ol><h4 id=-缺点>⚠️ <strong>缺点</strong></h4><ol><li>ABA问题<ul><li>若变量值从 <code>A → B → A</code>，CAS无法感知中间变化，可能误判“未被修改”。</li><li><strong>解决方案</strong>：使用带版本号的原子类（如<code>AtomicStampedReference</code>），每次更新递增版本号。</li></ul></li><li>自旋开销<ul><li>高竞争场景下频繁失败重试，导致<strong>CPU空转</strong>（如100个线程争抢同一变量）。</li></ul></li><li>单一变量限制<ul><li>只能保证<strong>一个共享变量</strong>的原子操作。多变量需合并或改用锁。</li></ul></li></ol><hr><h3 id=-java中的cas实现>⚡️ <strong>Java中的CAS实现</strong></h3><p>Java通过 <code>java.util.concurrent.atomic</code> 包提供原子类，底层调用<code>Unsafe</code>类的CAS指令：</p><pre tabindex=0><code>// 使用AtomicInteger实现线程安全自增
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet(); // 原子自增，无需锁
</code></pre><ul><li>关键方法：<ul><li><code>compareAndSet(expect, update)</code>：核心CAS操作。</li><li><code>getAndIncrement()</code>：循环CAS实现自增。</li></ul></li><li><strong>底层机制</strong>：
依赖<code>sun.misc.Unsafe#compareAndSwapInt</code>，通过JNI调用CPU指令。</li></ul><hr><h3 id=-典型应用场景>🔧 <strong>典型应用场景</strong></h3><ol><li><strong>无锁计数器</strong>
如<code>AtomicInteger</code>，替代<code>synchronized</code>实现高效计数。</li><li>自旋锁（SpinLock）通过CAS实现轻量级锁：<pre tabindex=0><code>public class SpinLock {
    private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;();
    public void lock() {
        while (!owner.compareAndSet(null, Thread.currentThread())) {
            // 自旋等待
        }
    }
    public void unlock() {
        owner.compareAndSet(Thread.currentThread(), null);
    }
}
</code></pre></li><li><strong>并发容器</strong>
<code>ConcurrentHashMap</code>的桶节点操作、<code>LinkedTransferQueue</code>等使用CAS减少锁竞争。</li></ol><hr><h3 id=-cas-vs-锁机制>↔️ <strong>CAS vs 锁机制</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>CAS</strong></th><th><strong>锁（如synchronized）</strong></th></tr></thead><tbody><tr><td><strong>机制</strong></td><td>乐观锁（无锁）</td><td>悲观锁（阻塞）</td></tr><tr><td><strong>原子性粒度</strong></td><td>单一变量</td><td>代码块/方法</td></tr><tr><td><strong>性能</strong></td><td>低竞争时高效，高竞争时CPU空转</td><td>高竞争时稳定，但上下文切换开销大</td></tr><tr><td><strong>适用场景</strong></td><td>简单原子操作（自增、标志位更新）</td><td>复合操作（如转账：先扣A再增B）</td></tr><tr><td><strong>问题</strong></td><td>ABA问题、自旋开销</td><td>死锁、优先级反转</td></tr></tbody></table></div><blockquote><p><strong>选择原则</strong>：</p><ul><li>简单变量且低竞争 → <strong>CAS</strong>（如计数器）。</li><li>复杂逻辑或高竞争 → <strong>锁</strong>（如<code>synchronized</code>或<code>ReentrantLock</code>）。</li></ul></blockquote><hr><h3 id=-总结>💎 <strong>总结</strong></h3><ul><li><strong>CAS本质</strong>：硬件级原子指令，通过“比较-交换”实现无锁并发。</li><li><strong>核心价值</strong>：高性能线程安全操作，避免锁开销。</li><li>使用注意：<ul><li>优先用于<strong>单一共享变量</strong>的简单操作。</li><li>高竞争场景需监控CPU占用，必要时切换为锁。</li><li><strong>ABA问题</strong>需通过版本号解决（<code>AtomicStampedReference</code>）。
合理运用CAS可在特定场景显著提升并发性能，但需严格评估其适用性，避免盲目替代锁机制。</li></ul></li></ul><h2 id=atomicstampedreference>AtomicStampedReference</h2><p>AtomicStampedReference 是 Java 并发包（<code>java.util.concurrent.atomic</code>）中解决 <strong>CAS 操作 ABA 问题</strong>的核心工具。它通过为对象引用附加一个整数版本戳（Stamp），实现对引用变化的版本追踪，确保并发修改的安全性。以下从原理、实现到应用场景展开分析：</p><hr><h3 id=-aba-问题与设计动机>🔍 <strong>ABA 问题与设计动机</strong></h3><ol><li><strong>ABA 问题本质</strong><ul><li><strong>场景描述</strong>：
线程 T1 读取共享变量值为 A → T2 将值改为 B 后再改回 A → T1 执行 CAS 操作，发现值仍为 A 并成功更新。此时 T1 ​<strong>无法感知中间状态变化</strong>​（A→B→A）。</li><li>危害：在无锁数据结构（如栈、队列）中可能导致数据丢失或逻辑错误。<ul><li>示例：无锁栈的 <code>pop()</code> 操作中，若节点被移除后重新入栈，CAS 可能误判为未变化，导致栈结构破坏。</li></ul></li><li>金融场景：账户余额被反复修改后还原，导致重复扣款（如 100→50→100→扣款 50 成功）。</li></ul></li><li><strong>AtomicStampedReference 的解决方案</strong><ul><li><strong>核心机制</strong>：
将对象引用 <code>V</code> 与整数戳 <code>int stamp</code> 绑定，每次更新时戳递增（类似版本号）。CAS 操作需<strong>同时校验引用值和戳</strong>，任一不匹配则失败。</li><li><strong>类比</strong>：检查物品时不仅看是否存在，还需确认版本号是否变化（如“房间物品未少，但版本号已变，说明曾被移动”）。</li></ul></li></ol><hr><h3 id=-实现原理与源码解析>⚙️ <strong>实现原理与源码解析</strong></h3><ol><li><strong>内部数据结构</strong><ul><li>不可变 Pair 类：封装引用 reference 和戳
stamp，保证原子替换时的状态一致性。<pre tabindex=0><code> private static class Pair&lt;T&gt; {
    final T reference;
 final int stamp; // 版本戳
}
</code></pre></li></ul></li></ol><ul><li><strong>AtomicReference 封装</strong>：
<code>volatile AtomicReference&lt;Pair&lt;V>> pair</code> 确保内存可见性，底层通过 <code>Unsafe</code> 或 <code>VarHandle</code> 实现 CAS。</li></ul><ol start=2><li><p><strong>核心方法 <code>compareAndSet</code></strong></p><ul><li>原子性保证：同时校验预期引用和戳，通过则更新为新引用和新戳：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>compareAndSet</span><span class=p>(</span><span class=n>V</span><span class=w> </span><span class=n>expectedReference</span><span class=p>,</span><span class=w> </span><span class=n>V</span><span class=w> </span><span class=n>newReference</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                           </span><span class=kt>int</span><span class=w> </span><span class=n>expectedStamp</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>newStamp</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Pair</span><span class=o>&lt;</span><span class=n>V</span><span class=o>&gt;</span><span class=w> </span><span class=n>current</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pair</span><span class=p>.</span><span class=na>get</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>expectedReference</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>current</span><span class=p>.</span><span class=na>reference</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w>  </span><span class=c1>// 校验引用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>           </span><span class=n>expectedStamp</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>current</span><span class=p>.</span><span class=na>stamp</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w>          </span><span class=c1>// 校验戳</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>           </span><span class=p>((</span><span class=n>newReference</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>current</span><span class=p>.</span><span class=na>reference</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w>     </span><span class=c1>// 避免无意义更新</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=n>newStamp</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>current</span><span class=p>.</span><span class=na>stamp</span><span class=p>)</span><span class=w> </span><span class=o>||</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>casPair</span><span class=p>(</span><span class=n>current</span><span class=p>,</span><span class=w> </span><span class=n>Pair</span><span class=p>.</span><span class=na>of</span><span class=p>(</span><span class=n>newReference</span><span class=p>,</span><span class=w> </span><span class=n>newStamp</span><span class=p>)));</span><span class=w> </span><span class=c1>// 执行 CAS</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><strong>短路优化</strong>：若新值与当前值相同，直接返回 <code>true</code> 避免 CAS 开销。</li></ul></li><li><p><strong>戳的管理</strong></p><ul><li><strong>递增规则</strong>：戳通常单调递增（如 <code>stamp+1</code>），防止状态回滚。</li><li>获取方法：<ul><li><code>get(int[] stampHolder)</code>：返回当前引用，并将戳存入数组 <code>stampHolder[0]</code>。</li><li><code>getStamp()</code>：直接返回当前戳。</li></ul></li></ul></li></ol><hr><h3 id=-典型应用场景-1>⚡️ <strong>典型应用场景</strong></h3><ol><li><strong>无锁数据结构</strong><ul><li>栈/队列节点更新：每次 push/pop 操作时递增戳，防止节点被复用导致的 ABA 问题。<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 无锁栈示例（简化）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>push</span><span class=p>(</span><span class=n>T</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>newNode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Node</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>oldTop</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>top</span><span class=p>.</span><span class=na>getReference</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>stamp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>top</span><span class=p>.</span><span class=na>getStamp</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>newNode</span><span class=p>.</span><span class=na>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>oldTop</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>top</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=n>oldTop</span><span class=p>,</span><span class=w> </span><span class=n>newNode</span><span class=p>,</span><span class=w> </span><span class=n>stamp</span><span class=p>,</span><span class=w> </span><span class=n>stamp</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>))</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul></li><li><strong>状态机与资源管理</strong><ul><li><strong>订单状态流转</strong>：
状态从 <code>UNPAID→PAID→REFUND→UNPAID</code> 时，戳的变化可避免误判为初始状态。</li><li>分布式开关控制：服务启停时通过戳校验防止重复操作：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>SafeSwitch</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>AtomicStampedReference</span><span class=o>&lt;</span><span class=n>Boolean</span><span class=o>&gt;</span><span class=w> </span><span class=n>status</span><span class=w> </span><span class=o>=</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>new</span><span class=w> </span><span class=n>AtomicStampedReference</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>turnOn</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>stamp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Boolean</span><span class=w> </span><span class=n>current</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>status</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>stamp</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=o>!</span><span class=n>current</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>               </span><span class=n>status</span><span class=p>.</span><span class=na>compareAndSet</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=n>stamp</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>stamp</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul></li><li><strong>资源池对象复用</strong><ul><li>对象从池中取出→修改→放回时，戳可检测对象是否被篡改。</li></ul></li></ol><hr><h3 id=-与其他方案的对比>⚖️ <strong>与其他方案的对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>方案</strong></th><th><strong>原理</strong></th><th><strong>ABA 防护</strong></th><th><strong>适用场景</strong></th><th><strong>性能开销</strong></th></tr></thead><tbody><tr><td><strong><code>AtomicStampedReference</code></strong></td><td>引用 + 整数版本戳</td><td>强（状态空间大）</td><td>需精细版本控制的场景</td><td>中</td></tr><tr><td><strong><code>AtomicMarkableReference</code></strong></td><td>引用 + 布尔标记</td><td>弱（仅两种状态）</td><td>简单状态标记（如“已读”）</td><td>低</td></tr><tr><td><strong>乐观锁（数据库）</strong></td><td>版本号或时间戳</td><td>强</td><td>数据库事务</td><td>中</td></tr><tr><td><strong>互斥锁</strong></td><td>完全串行化</td><td>无风险</td><td>复杂事务</td><td>高</td></tr></tbody></table></div><blockquote><p>💡 <strong>选型建议</strong>：</p><ul><li>需严格版本控制时选 <code>AtomicStampedReference</code>；</li><li>仅需二元状态时用 <code>AtomicMarkableReference</code> 更轻量。</li></ul></blockquote><hr><h3 id=-局限性与注意事项>⚠️ <strong>局限性与注意事项</strong></h3><ol><li><strong>戳溢出风险</strong><ul><li><code>int</code> 类型戳可能从 <code>Integer.MAX_VALUE</code> 溢出到 <code>Integer.MIN_VALUE</code>，导致版本回退误判。</li><li><strong>解决方案</strong>：监控戳范围或使用 <code>long</code> 类型（需自定义实现）。</li></ul></li><li><strong>性能开销</strong><ul><li>每次 CAS 需创建新 <code>Pair</code> 对象，增加 GC 压力。</li><li>在无竞争场景下，性能优于锁；高竞争时可能因自旋消耗 CPU。</li></ul></li><li><strong>正确使用规范</strong><ul><li><strong>戳必须递增</strong>：若回滚戳值（如重置为旧值），ABA 问题可能重现。</li><li><strong>强制校验戳</strong>：业务逻辑需依赖戳的变化，而非仅引用值。</li></ul></li></ol><hr><h3 id=-总结-1>💎 <strong>总结</strong></h3><p><code>AtomicStampedReference</code> 通过<strong>引用+版本戳</strong>的二元校验机制，为无锁并发提供了可靠的 ABA 问题解决方案。其核心价值在于：</p><ol><li><strong>状态追踪</strong>：戳的递增唯一标识引用变化历史，避免隐蔽的中间状态；</li><li><strong>无锁并发</strong>：基于 CAS 实现高性能线程安全，适用于栈、队列、状态机等场景；</li><li><strong>责任转移</strong>：将 ABA 风险从业务逻辑剥离至底层框架，提升代码健壮性。</li></ol><blockquote><p>实际开发中，优先用于需严格版本控制的并发结构，并遵循 <strong>戳递增+及时清理</strong> 原则，以规避溢出与性能陷阱。</p></blockquote><h2 id=volatile>volatile</h2><p><code>volatile</code> 是 Java 中用于多线程编程的关键字，主要解决共享变量的<strong>可见性</strong>和<strong>指令重排序</strong>问题，但<strong>不保证原子性</strong>。以下是详细解析：</p><hr><h3 id=-核心作用>⚙️ <strong>核心作用</strong></h3><ol><li><strong>内存可见性（Visibility）</strong><ul><li>普通变量的修改可能仅存在于线程的本地内存（如 CPU 缓存），其他线程无法立即感知。</li><li><code>volatile</code> 变量<strong>每次写操作直接刷新到主内存</strong>，<strong>每次读操作从主内存重新加载</strong>，确保所有线程看到最新值。</li><li>示例：<pre tabindex=0><code>private volatile boolean running = true;
// 线程A修改 running=false 后，线程B能立即退出循环
while (running) { /* 任务 */ }
</code></pre></li></ul></li><li><strong>禁止指令重排序（Ordering）</strong><ul><li>编译器和处理器可能为优化性能重排指令顺序，导致多线程逻辑错误。</li><li>volatile 通过内存屏障（Memory Barrier）禁止重排序：<ul><li><strong>写操作</strong>前插入 <code>StoreStore</code> 屏障，后插入 <code>StoreLoad</code> 屏障。</li><li><strong>读操作</strong>前插入 <code>LoadLoad</code> 屏障，后插入 <code>LoadStore</code> 屏障。</li></ul></li><li>典型场景：单例模式的双重检查锁定（Double-Checked Locking）：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Singleton</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>volatile</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=nf>getInstance</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>instance</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>synchronized</span><span class=w> </span><span class=p>(</span><span class=n>Singleton</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>instance</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>instance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Singleton</span><span class=p>();</span><span class=w> </span><span class=c1>// 避免重排序导致未初始化完成的对象暴露</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul></li></ol><hr><h3 id=-局限性不保证原子性>⚠️ <strong>局限性：不保证原子性</strong></h3><ul><li><strong>原子性问题</strong>：<code>volatile</code> 仅保证单次读/写的原子性（如 <code>long/double</code> 的 64 位操作），但<strong>复合操作（如 <code>i++</code>）仍非原子</strong>，因为包含“读-改-写”三步。</li><li><strong>解决方案</strong>：<ul><li>使用 <code>synchronized</code> 或 <code>Lock</code> 保证代码块原子性。</li><li>使用 <code>AtomicInteger</code> 等原子类（基于 CAS 实现）。</li></ul></li></ul><hr><h3 id=-实现原理>🔧 <strong>实现原理</strong></h3><ol><li><strong>内存屏障</strong>
JVM 在编译时插入屏障指令，强制刷新主内存数据并限制重排序。</li><li><strong>缓存一致性协议</strong>（如 MESI）
多核 CPU 通过嗅探总线，发现 <code>volatile</code> 变量修改后，将其他核心的缓存行设为无效，强制从主内存加载新值。</li></ol><hr><h3 id=-适用场景>🛠️ <strong>适用场景</strong></h3><ol><li><strong>状态标志位</strong>
简单布尔变量控制线程执行（如停止循环）。</li><li><strong>一次性发布</strong>
确保对象初始化完成前不被引用（如单例模式）。</li><li><strong>独立观察</strong>
定期更新供多线程读取的变量（如心跳标记）。</li></ol><hr><h3 id=-volatile>↔️ <strong><code>volatile</code> vs <code>synchronized</code></strong></h3><div class=table-wrapper><table><thead><tr><th>特性</th><th><code>volatile</code></th><th><code>synchronized</code></th></tr></thead><tbody><tr><td><strong>可见性</strong></td><td>✅ 直接读写主内存</td><td>✅ 锁释放时刷新主内存</td></tr><tr><td><strong>有序性</strong></td><td>✅ 禁止重排序</td><td>✅ 串行执行</td></tr><tr><td><strong>原子性</strong></td><td>❌ 仅单次读/写</td><td>✅ 代码块/方法级</td></tr><tr><td><strong>阻塞</strong></td><td>❌ 无阻塞</td><td>✅ 线程竞争锁时阻塞</td></tr><tr><td><strong>性能开销</strong></td><td>低（无上下文切换）</td><td>高（锁竞争、内核切换）</td></tr></tbody></table></div><blockquote><p><strong>选择原则</strong>：</p><ul><li>仅需可见性/有序性 → <code>volatile</code>（如状态标志）。</li><li>需原子性或复合操作 → <code>synchronized</code> 或原子类。</li></ul></blockquote><hr><h3 id=-注意事项>⚠️ <strong>注意事项</strong></h3><ol><li><strong>非万能替代锁</strong>：仅当变量独立于其他状态时适用（如 <code>flag</code> 不依赖其他变量值）。</li><li><strong>性能影响</strong>：频繁读写 <code>volatile</code> 变量因主内存同步略慢于普通变量，但仍优于锁。
通过合理使用 <code>volatile</code>，可在轻量级同步需求中平衡性能与线程安全，但需严格区分其与锁的适用边界。</li></ol><h2 id=synchronized>synchronized</h2><p>以下是对 Java 中 <code>synchronized</code> 关键字的详细解析，结合其作用、用法、底层实现及最佳实践：</p><hr><h3 id=-synchronized>⚙️ <strong><code>synchronized</code> 的核心作用</strong></h3><ol><li>互斥性（Mutex）<ul><li>确保同一时刻仅有一个线程能执行被修饰的代码块或方法，避免多线程并发修改共享资源导致的<strong>竞态条件</strong>（Race Condition）。</li></ul></li><li>可见性（Visibility）<ul><li>线程在释放锁前，强制将本地内存中的变量修改刷新到主内存；获取锁时，从主内存重新加载变量值，保证其他线程看到最新数据。</li></ul></li><li>有序性（Ordering）<ul><li>通过锁机制禁止编译器或处理器对同步代码块内的指令重排序，确保代码按顺序执行。</li></ul></li></ol><hr><h3 id=-synchronized-1>🛠️ <strong><code>synchronized</code> 的三种用法</strong></h3><h4 id=修饰实例方法><strong>修饰实例方法</strong></h4><ul><li><strong>锁对象</strong>：当前实例（<code>this</code>）。</li><li><strong>作用范围</strong>：整个方法体。</li></ul><pre tabindex=0><code>public synchronized void increment() {
    count++;  // 线程安全的复合操作
}
</code></pre><ul><li><strong>适用场景</strong>：保护对象实例内的共享变量。</li></ul><h4 id=修饰静态方法><strong>修饰静态方法</strong></h4><ul><li><strong>锁对象</strong>：类的 <code>Class</code> 对象（如 <code>MyClass.class</code>）。</li><li><strong>作用范围</strong>：所有实例共享同一把锁，影响整个类的<strong>静态资源</strong>。</li></ul><pre tabindex=0><code>public static synchronized void staticMethod() {
    // 操作静态变量
}
</code></pre><ul><li><strong>适用场景</strong>：保护静态变量或类级资源。</li></ul><h4 id=修饰代码块><strong>修饰代码块</strong></h4><ul><li><strong>锁对象</strong>：任意显式指定的对象（如 <code>Object lock = new Object()</code>）。</li><li><strong>作用范围</strong>：仅同步代码块内部，支持细粒度控制。</li></ul><pre tabindex=0><code>public void method() {
    synchronized (lockObj) {  // 自定义锁对象
        // 仅同步关键代码
    }
}
</code></pre><ul><li><strong>适用场景</strong>：减少锁范围，提升并发性能。</li></ul><h4 id=-三种用法对比>🔍 <strong>三种用法对比</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>用法类型</strong></th><th><strong>锁对象</strong></th><th><strong>作用域</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>修饰实例方法</td><td><code>this</code></td><td>整个方法体</td><td>保护实例变量</td></tr><tr><td>修饰静态方法</td><td><code>Class</code> 对象</td><td>整个类</td><td>保护静态变量</td></tr><tr><td>修饰代码块</td><td>自定义对象</td><td>代码块内部</td><td>细粒度控制，减少锁竞争</td></tr></tbody></table></div><hr><h3 id=-底层实现原理>⚙️ <strong>底层实现原理</strong></h3><ol><li><strong>Monitor 机制</strong><ul><li>每个 Java 对象关联一个<strong>监视器锁（Monitor）</strong>，通过字节码指令 <code>monitorenter</code> 和 <code>monitorexit</code> 实现锁的获取与释放。</li><li>线程进入同步块时尝试获取锁，成功则执行代码；失败则阻塞直至锁释放。</li></ul></li><li><strong>锁升级优化（JDK 1.6+）</strong><ul><li><strong>无锁 → 偏向锁</strong>：首次获取锁时标记偏向线程，避免重复 CAS 开销。</li><li><strong>偏向锁 → 轻量级锁</strong>：多线程竞争时，通过 CAS 自旋尝试获取锁（减少阻塞）。</li><li><strong>轻量级锁 → 重量级锁</strong>：自旋失败后升级为操作系统级互斥锁（Mutex），线程进入阻塞状态。</li><li><strong>目的</strong>：平衡性能与线程安全，减少锁操作的开销。</li></ul></li></ol><hr><h3 id=-使用注意事项与最佳实践>⚠️ <strong>使用注意事项与最佳实践</strong></h3><ol><li><strong>避免死锁</strong><ul><li>确保多线程获取锁的顺序一致（如：按固定顺序锁定多个对象）。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 示例：按锁对象的固定顺序加锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>obj1</span><span class=p>.</span><span class=na>lockOrder</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>obj2</span><span class=p>.</span><span class=na>lockOrder</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>synchronized</span><span class=p>(</span><span class=n>obj2</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>synchronized</span><span class=p>(</span><span class=n>obj1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><strong>减小锁粒度</strong><ul><li>优先使用<strong>同步代码块</strong>替代同步方法，仅锁定必要资源（如 <code>FineGrainLock</code> 类中的分段锁）。</li></ul></li><li><strong>替代方案</strong><ul><li>高并发场景下，考虑 <code>ReentrantLock</code>（支持公平锁、可中断）或 <code>StampedLock</code>（乐观读锁）提升性能。</li></ul></li><li><strong>单例模式的双重检查锁定（DCL）</strong><ul><li>结合 <code>volatile</code> 防止指令重排序导致未初始化完成的对象被暴露：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Singleton</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>volatile</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Singleton</span><span class=w> </span><span class=nf>getInstance</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>instance</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>synchronized</span><span class=w> </span><span class=p>(</span><span class=n>Singleton</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>instance</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>instance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Singleton</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>instance</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ol><hr><h3 id=-synchronized-2>↔️ <strong><code>synchronized</code> vs <code>volatile</code></strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><code>synchronized</code></th><th><code>volatile</code></th></tr></thead><tbody><tr><td><strong>原子性</strong></td><td>✅ 保证复合操作（如 <code>i++</code>）</td><td>❌ 仅保证单次读/写的原子性</td></tr><tr><td><strong>可见性</strong></td><td>✅ 通过锁刷新主内存</td><td>✅ 直接读写主内存</td></tr><tr><td><strong>有序性</strong></td><td>✅ 禁止同步块内指令重排序</td><td>✅ 禁止变量相关指令重排序</td></tr><tr><td><strong>互斥性</strong></td><td>✅ 同一时间仅一个线程访问</td><td>❌ 允许多线程并发读写</td></tr><tr><td><strong>性能开销</strong></td><td>较高（锁竞争、上下文切换）</td><td>较低（无锁机制）</td></tr><tr><td><strong>适用场景</strong></td><td>复杂逻辑或多步操作</td><td>单一状态标志（如 <code>boolean flag</code>）</td></tr></tbody></table></div><blockquote><p><strong>选择原则</strong>：</p><ul><li>需原子性 → <code>synchronized</code> 或原子类（<code>AtomicInteger</code>）。</li><li>仅需可见性 → <code>volatile</code>（如状态标志位）。</li></ul></blockquote><hr><h3 id=-总结-2>💎 <strong>总结</strong></h3><p><code>synchronized</code> 是 Java 线程安全的基石，通过 <strong>互斥性、可见性、有序性</strong> 解决并发问题。使用时需注意：</p><ol><li><strong>锁粒度</strong>：优先用代码块缩小同步范围。</li><li><strong>锁顺序</strong>：避免死锁，固定多锁获取顺序。</li><li><strong>性能权衡</strong>：高并发场景考虑 <code>ReentrantLock</code> 等替代方案。</li><li><strong>复合操作</strong>：确保原子性需依赖锁机制而非 <code>volatile</code>。
合理运用 <code>synchronized</code> 可高效构建线程安全程序，但需结合场景选择最优同步策略。</li></ol><h2 id=object-monitor>Object Monitor</h2><p>Object Monitor（监视器锁）是 Java 中实现线程同步的核心底层机制，与每个 Java 对象关联，通过 <code>synchronized</code>关键字触发。其工作原理基于 JVM 底层的 <code>ObjectMonitor</code> 类（C++实现），以下是详细解析：</p><hr><h3 id=-monitor-锁的核心结构>🔒 <strong>Monitor 锁的核心结构</strong></h3><p>每个 Java 对象在堆内存中均关联一个 <code>ObjectMonitor</code> 对象，关键字段如下：</p><div class=table-wrapper><table><thead><tr><th><strong>字段</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>_owner</code></td><td>指向持有锁的线程（<code>null</code> 表示锁未被占用）</td></tr><tr><td><code>_EntryList</code></td><td>存储等待获取锁的阻塞线程队列（竞争锁失败时进入）</td></tr><tr><td><code>_WaitSet</code></td><td>存储因调用 <code>wait()</code> 而主动放弃锁的线程队列（等待唤醒）</td></tr><tr><td><code>_recursions</code></td><td>记录锁的重入次数（同一线程多次获取锁时递增）</td></tr><tr><td><code>_count</code></td><td>锁计数器（线程获取锁时 <code>+1</code>，释放时 <code>-1</code>，<code>0</code> 表示可被竞争）</td></tr></tbody></table></div><blockquote><p>📌 <strong>对象头关联</strong>：对象的 Mark Word 中锁标志位为 <code>10</code> 时（重量级锁），存储指向 <code>ObjectMonitor</code> 的指针。</p></blockquote><hr><h3 id=-monitor-锁的工作流程>⚙️ <strong>Monitor 锁的工作流程</strong></h3><h4 id=加锁流程><strong>加锁流程（<code>monitorenter</code> 指令）</strong></h4><ul><li><strong>无竞争</strong>：若 <code>_owner</code> 为 <code>null</code>，线程通过 CAS 操作将 <code>_owner</code> 设为自己，<code>_count</code> 和 <code>_recursions</code> 置为 <code>1</code>。</li><li><strong>锁重入</strong>：若 <code>_owner</code> 是当前线程，<code>_recursions++</code>（体现可重入性）。</li><li>竞争失败：<ul><li>线程进入 <code>_EntryList</code> 队列阻塞（Linux 下通过 <code>pthread_mutex_lock</code> 实现 OS 级阻塞）。</li></ul></li><li>若开启自旋锁（JDK 6+ 默认），线程先自旋尝试获取锁（避免立刻阻塞）。</li></ul><h4 id=释放锁><strong>释放锁（<code>monitorexit</code> 指令）</strong></h4><ul><li>将 _recursions 减 1 ，若结果为 0 ：<ul><li>重置 <code>_owner</code> 为 <code>null</code>，<code>_count</code> 减 <code>1</code>。</li></ul></li><li>唤醒 <code>_EntryList</code> 中的首个线程（非公平锁）或按 FIFO 唤醒（公平锁）。</li></ul><h4 id=wait><strong><code>wait()</code> 与 <code>notify()</code> 机制</strong></h4><ul><li>wait()：<ul><li>持有锁的线程调用 wait()后：<ol><li>释放锁（<code>_owner=null</code>，<code>_count--</code>）。</li><li>线程封装为 <code>ObjectWaiter</code> 节点加入 <code>_WaitSet</code> 队列。</li><li>线程进入阻塞状态，等待唤醒。</li></ol></li></ul></li><li>notify()：<ul><li>从 <code>_WaitSet</code> 中移出首个线程节点，加入 <code>_EntryList</code> 参与锁竞争。</li><li><strong><code>notifyAll()</code></strong>：移出 <code>_WaitSet</code> 中所有线程节点。</li></ul></li></ul><blockquote><p>⚠️ <strong>注意</strong>：调用 <code>wait()/notify()</code> 前需持有锁，否则抛出 <code>IllegalMonitorStateException</code>。</p></blockquote><hr><h3 id=-锁升级与重量级锁的关系>🔄 <strong>锁升级与重量级锁的关系</strong></h3><p>当轻量级锁/偏向锁竞争加剧时，会升级为重量级锁（Monitor 锁）：</p><ol><li>升级条件：<ul><li>自旋获取轻量级锁失败（默认自旋 <code>10</code> 次）。</li><li>多线程激烈竞争同一资源。</li></ul></li><li>升级过程：<ul><li>对象头中的锁标志位变为 <code>10</code>（重量级锁）。</li><li>Mark Word 指向 <code>ObjectMonitor</code> 地址。</li></ul></li><li>性能影响：<ul><li><strong>优点</strong>：彻底解决竞争问题（通过 OS 阻塞队列）。</li><li><strong>缺点</strong>：线程阻塞/唤醒涉及用户态-内核态切换，性能开销大（微秒级）。</li></ul></li></ol><hr><h3 id=-monitor-锁的特性总结>⚖️ <strong>Monitor 锁的特性总结</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>可重入性</strong></td><td>同一线程多次获取锁时，<code>_recursions</code> 递增。</td></tr><tr><td><strong>非公平性</strong></td><td>默认唤醒 <code>_EntryList</code> 队首线程（允许新线程插队竞争，提高吞吐）。</td></tr><tr><td><strong>条件等待</strong></td><td>通过 <code>_WaitSet</code> 实现精细的线程等待/唤醒机制。</td></tr><tr><td><strong>互斥性</strong></td><td>仅一个线程可持有锁（<code>_owner</code> 唯一性）。</td></tr></tbody></table></div><hr><h3 id=-应用场景与注意事项>💡 <strong>应用场景与注意事项</strong></h3><ol><li>适用场景：<ul><li>高竞争、长耗时同步操作（如数据库连接池）。</li><li>需精细控制线程等待/唤醒的复杂同步逻辑（如生产者-消费者模型）。</li></ul></li><li>优化建议：<ul><li>减少同步范围（如用同步块替代同步方法）。</li><li>高并发场景可改用 <code>ReentrantLock</code>（支持超时、可中断）。</li></ul></li></ol><blockquote><p>💎 <strong>核心价值</strong>：Monitor 锁通过 <strong>OS 级阻塞队列</strong> 和 <strong>精准线程调度</strong>，为 Java 高竞争场景提供了终极线程安全解决方案，但需权衡其性能开销。</p></blockquote><h2 id=synchronized-锁升级>synchronized 锁升级</h2><p>以下是Java中偏向锁（Biased Locking）、轻量级锁（Lightweight Locking）和重量级锁（Heavyweight Locking）的详细解析及其核心区别，结合底层实现原理与适用场景展开说明：</p><hr><h3 id=-锁的升级机制与设计背景>🔒 <strong>锁的升级机制与设计背景</strong></h3><p>Java的<code>synchronized</code>锁在JDK 1.6后引入<strong>锁升级策略</strong>（无锁 → 偏向锁 → 轻量级锁 → 重量级锁），目的是在<strong>无竞争时降低开销</strong>，<strong>高竞争时保证线程安全</strong>。</p><ul><li>升级触发条件：<ul><li>偏向锁 → 轻量级锁：首次出现线程竞争时。</li><li>轻量级锁 → 重量级锁：自旋失败（默认10次）或竞争加剧。</li></ul></li><li><strong>不可降级</strong>：锁升级后无法回退，避免状态转换开销。</li></ul><hr><h3 id=-三种锁的核心原理与特点>⚙️ <strong>三种锁的核心原理与特点</strong></h3><h4 id=偏向锁biased-locking><strong>偏向锁（Biased Locking）</strong></h4><ul><li><strong>核心思想</strong>：优化<strong>单线程重复加锁</strong>场景。首次获取锁时记录线程ID到对象头（Mark Word），后续同一线程直接进入同步块，无需同步操作。</li><li>实现机制：<ul><li>对象头标记位：<code>biased_lock=1, lock=01</code>。</li><li>通过CAS记录线程ID，成功后锁进入偏向模式。</li></ul></li><li><strong>适用场景</strong>：单线程或线程交替执行同步块（如局部代码块）。</li><li><strong>缺点</strong>：竞争时需撤销偏向锁（STW暂停持有线程），开销较大。</li><li><strong>现状</strong>：JDK 15后默认禁用（高竞争场景下撤销成本过高）。</li></ul><h4 id=轻量级锁lightweight-locking><strong>轻量级锁（Lightweight Locking）</strong></h4><ul><li><strong>核心思想</strong>：通过<strong>CAS自旋</strong>避免线程阻塞，减少用户态/内核态切换开销。</li><li>实现机制：<ul><li>线程栈中创建锁记录（Lock Record），复制对象头的Mark Word（Displaced Mark Word）。</li></ul></li><li>通过CAS将对象头指向锁记录地址，成功则获取锁（标记位<code>lock=00</code>）。<ul><li>失败时自旋重试（自适应自旋：根据历史成功率动态调整自旋次数）。</li></ul></li><li><strong>适用场景</strong>：<strong>短时操作</strong>、<strong>低竞争</strong>（如计数器自增）。</li><li><strong>缺点</strong>：自旋消耗CPU，高竞争时效率低。</li></ul><h4 id=重量级锁heavyweight-locking><strong>重量级锁（Heavyweight Locking）</strong></h4><ul><li><strong>核心思想</strong>：依赖<strong>操作系统互斥量（Mutex）</strong> 实现线程阻塞，彻底解决竞争问题。</li><li>实现机制：<ul><li>对象头指向操作系统级Monitor（锁标志位<code>lock=10</code>）。</li><li>竞争失败线程进入阻塞队列，由OS调度唤醒。</li></ul></li><li><strong>适用场景</strong>：<strong>高竞争</strong>、<strong>长时同步操作</strong>（如数据库连接池）。</li><li><strong>缺点</strong>：线程阻塞/唤醒涉及上下文切换，性能损耗大（微秒级延迟）。</li></ul><hr><h3 id=-三种锁的核心区别对比>🔍 <strong>三种锁的核心区别对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th>偏向锁</th><th>轻量级锁</th><th>重量级锁</th></tr></thead><tbody><tr><td><strong>竞争场景</strong></td><td>单线程重复访问</td><td>多线程交替执行（无实际竞争）</td><td>多线程激烈竞争</td></tr><tr><td><strong>实现机制</strong></td><td>记录线程ID（无CAS）</td><td>CAS自旋 + 栈帧锁记录</td><td>操作系统Mutex + 阻塞队列</td></tr><tr><td><strong>线程阻塞</strong></td><td>❌ 无阻塞</td><td>❌ 自旋（不阻塞）</td><td>✅ 阻塞（OS调度）</td></tr><tr><td><strong>性能开销</strong></td><td>无竞争时最低</td><td>低竞争时较高（CPU自旋）</td><td>高竞争时最高（上下文切换）</td></tr><tr><td><strong>适用场景</strong></td><td>单线程场景</td><td>短时操作（&lt;纳秒级）</td><td>长时高竞争操作</td></tr><tr><td><strong>锁撤销/升级</strong></td><td>竞争时升级为轻量级锁</td><td>自旋失败升级为重量级锁</td><td>无降级机制</td></tr></tbody></table></div><blockquote><p>💡 <strong>性能关键点</strong>：</p><ul><li><strong>偏向锁</strong>：无竞争时效率最高，但竞争时撤销成本高。</li><li><strong>轻量级锁</strong>：平衡点在于<strong>自旋时间 &lt; 线程切换时间</strong>。</li><li><strong>重量级锁</strong>：完全消除CPU空转，但切换开销固定。</li></ul></blockquote><hr><h3 id=-锁升级流程与实战影响>⚠️ <strong>锁升级流程与实战影响</strong></h3><ol><li><strong>升级路径</strong>：<pre tabindex=0><code>graph LR  
A[无锁] --&gt;|首次加锁| B[偏向锁]  
B --&gt;|竞争发生| C[轻量级锁]  
C --&gt;|自旋失败/多线程竞争| D[重量级锁]  
</code></pre><ul><li>竞争触发升级后，对象头Mark Word结构永久变化。</li></ul></li><li><strong>工程实践建议</strong>：<ul><li><strong>避免过度同步</strong>：锁范围尽量缩小（如同步块代替同步方法）。</li><li><strong>监控锁竞争</strong>：使用<code>jstack</code>或<code>Arthas</code>查看锁状态（偏向/轻量/重量）。</li><li>高并发场景：<ul><li>替代方案：<code>ReentrantLock</code>（可中断/超时）或<code>StampedLock</code>（乐观读）。</li></ul></li></ul></li></ol><ul><li>禁用偏向锁：JDK 15+默认关闭，可通过<code>-XX:-UseBiasedLocking</code>显式禁用。</li></ul><hr><h3 id=-总结-3>💎 <strong>总结</strong></h3><ul><li><strong>偏向锁</strong>：为单线程设计，无竞争时效率极致，但竞争撤销成本高（JDK 15+已废弃）。</li><li><strong>轻量级锁</strong>：通过<strong>CAS自旋</strong>避免阻塞，适合短时低竞争操作，自旋失败则升级。</li><li><strong>重量级锁</strong>：终极方案，依赖OS互斥量，保证高竞争下的安全性，但性能代价最高。</li></ul><blockquote><p><strong>选择本质</strong>：JVM根据竞争强度<strong>动态选择锁类型</strong>，开发者需关注锁状态与竞争情况，避免重量级锁成为瓶颈。高并发场景下，结合<code>jstack</code>分析锁竞争，必要时采用显式锁（如<code>ReentrantLock</code>）替代<code>synchronized</code>。</p></blockquote><h2 id=偏向锁>偏向锁</h2><p>偏向锁（Biased Locking）是Java虚拟机（JVM）为优化<code>synchronized</code>关键字性能而设计的锁机制，旨在<strong>减少单线程重复获取锁的开销</strong>。其核心思想是“偏向”首个获取锁的线程，后续无需同步操作。以下从原理、工作机制、优缺点到实践场景展开详解：</p><hr><h3 id=-核心原理与设计目标>⚙️ <strong>核心原理与设计目标</strong></h3><ol><li><strong>设计背景</strong><ul><li><strong>问题</strong>：传统锁（如重量级锁）依赖操作系统互斥量（Mutex），涉及线程阻塞/唤醒，导致上下文切换开销大<a class=link href=@ref>6,8</a>。</li><li><strong>优化目标</strong>：针对单线程或低竞争场景，避免无意义的同步操作（如CAS），提升性能<a class=link href=@ref>2,7</a>。</li></ul></li><li><strong>技术基础：对象头与Mark Word</strong><ul><li>每个Java对象头部包含<strong>Mark Word</strong>字段（64位），存储锁状态、哈希码、GC分代年龄等信息<a class=link href=@ref>2,4</a>。</li><li>偏向锁状态下的Mark Word结构：<pre tabindex=0><code>| 锁标志位 (01) | 偏向线程ID (54 bits) | Epoch (2 bits) | 未使用 (1 bit) | 
</code></pre>其中：<ul><li><strong>偏向线程ID</strong>：记录首次获取锁的线程ID。</li><li><strong>Epoch</strong>：用于批量重偏向的版本号，避免频繁撤销<a class=link href=@ref>4,8</a>。</li></ul></li></ul></li></ol><hr><h3 id=-工作机制详解>🔄 <strong>工作机制详解</strong></h3><h4 id=偏向锁的获取流程><strong>偏向锁的获取流程</strong></h4><ul><li><strong>步骤1：初始无锁状态</strong>
对象创建时，Mark Word为无锁状态（锁标志位<code>01</code>）<a class=link href=@ref>2,7</a>。</li><li>步骤2：首次获取锁
线程T1首次进入同步块：<ul><li>JVM通过<strong>CAS操作</strong>将Mark Word的锁标志位改为偏向锁（<code>01</code>）。</li><li>将T1的线程ID写入Mark Word<a class=link href=@ref>4,8</a>。</li><li>此时锁进入“偏向模式”。</li></ul></li><li>步骤3：再次获取锁 T1后续进入同步块时：<ul><li>JVM检查Mark Word中的线程ID是否与T1匹配。</li><li><strong>若匹配</strong>：直接执行同步代码，<strong>无任何同步操作</strong>（如CAS或阻塞）<a class=link href=@ref>2,9</a>。</li></ul></li></ul><h4 id=偏向锁的撤销与升级><strong>偏向锁的撤销与升级</strong></h4><ul><li><strong>触发条件</strong>：当线程T2尝试获取已被T1偏向的锁时<a class=link href=@ref>4,8</a>。</li><li>撤销过程：<ol><li>暂停持有锁的线程T1（STW，Stop-The-World）。</li><li>检查T1是否仍活跃：若已退出同步块，则撤销偏向锁，恢复为无锁状态；若仍在执行，则升级为<strong>轻量级锁</strong>（锁标志位<code>00</code>）。</li><li>唤醒T1和T2，T2通过<strong>自旋（CAS）</strong> 竞争轻量级锁<a class=link href=@ref>6,8</a>。</li></ol></li><li><strong>批量重偏向优化</strong>：
若同一类的大量对象被不同线程交替访问，JVM会通过<code>Epoch</code>机制批量重偏向，避免频繁撤销<a class=link href=@ref>4,8</a>。</li></ul><h4 id=锁升级路径><strong>锁升级路径</strong></h4><pre tabindex=0><code>graph LR
  A[无锁状态] --&gt;|单线程重复访问| B[偏向锁]
  B --&gt;|多线程竞争| C[轻量级锁]
  C --&gt;|竞争激烈| D[重量级锁]
</code></pre><ul><li>轻量级锁通过<strong>自旋CAS</strong>减少阻塞，重量级锁依赖<strong>操作系统互斥量</strong><a class=link href=@ref>3,6</a>。</li></ul><hr><h3 id=-优缺点分析>⚖️ <strong>优缺点分析</strong></h3><h4 id=-核心优势>✅ **核心优势</h4><ul><li><strong>零同步开销</strong>：单线程重复访问时，无需CAS或线程调度，性能接近无锁<a class=link href=@ref>7,9</a>。</li><li><strong>减少上下文切换</strong>：避免线程阻塞/唤醒，降低CPU资源消耗<a class=link href=@ref>6,8</a>。</li></ul><h4 id=-局限性>⚠️ **局限性</h4><ul><li><strong>撤销开销大</strong>：竞争触发撤销时需STW，暂停所有线程，延迟敏感场景性能下降<a class=link href=@ref>4,8</a>。</li><li><strong>短生命周期对象无效</strong>：对象若被多个线程快速交替访问，偏向锁反复撤销反而降低效率<a class=link href=@ref>4,9</a>。</li><li><strong>高竞争场景不适用</strong>：频繁竞争导致锁升级为重量级锁，性能反而不如直接禁用偏向锁<a class=link href=@ref>6,8</a>。</li></ul><hr><h3 id=-适用场景与配置建议>🎯 <strong>适用场景与配置建议</strong></h3><h4 id=理想场景><strong>理想场景</strong></h4><ul><li><strong>单线程主导</strong>：如线程池中单线程处理任务、初始化阶段加载资源<a class=link href=@ref>9</a>。</li><li><strong>低竞争环境</strong>：锁被同一线程长期持有，偶有其他线程尝试竞争（如后台监控线程）<a class=link href=@ref>4,7</a>。</li><li>示例：<pre tabindex=0><code>// 单线程重复访问同步块
public void processTask() {
    synchronized(lock) {  // 首次获取后偏向当前线程
        // 业务逻辑
    }
}
</code></pre></li></ul><h4 id=不适用场景><strong>不适用场景</strong></h4><ul><li>高并发竞争（如秒杀系统）。</li><li>锁对象生命周期短（如临时对象同步块）。</li><li>需严格实时响应的系统（STW可能导致延迟波动）<a class=link href=@ref>4,8</a>。</li></ul><h4 id=jvm参数配置><strong>JVM参数配置</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>参数</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>-XX:+UseBiasedLocking</code></td><td>启用偏向锁（JDK 6u23后默认开启）</td></tr><tr><td><code>-XX:-UseBiasedLocking</code></td><td>禁用偏向锁（高竞争场景推荐）</td></tr><tr><td><code>-XX:BiasedLockingStartupDelay=0</code></td><td>取消偏向锁延迟（默认延迟4秒，避免短生命周期对象无效优化）<a class=link href=@ref>4,7</a></td></tr></tbody></table></div><blockquote><p>💡 <strong>注意</strong>：JDK 15后偏向锁默认关闭，JDK 18中彻底移除，因现代硬件环境下轻量级锁优化已足够高效<a class=link href=@ref>4</a>。</p></blockquote><hr><h3 id=-与其他锁的对比>🔄 <strong>与其他锁的对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th>偏向锁</th><th>轻量级锁</th><th>重量级锁</th></tr></thead><tbody><tr><td><strong>适用场景</strong></td><td>单线程/低竞争</td><td>多线程交替访问（低竞争）</td><td>高并发竞争</td></tr><tr><td><strong>实现机制</strong></td><td>记录线程ID，免同步操作</td><td>CAS自旋尝试获取锁</td><td>操作系统互斥量（Mutex）</td></tr><tr><td><strong>性能开销</strong></td><td>接近零开销（无竞争时）</td><td>低（自旋消耗CPU）</td><td>高（上下文切换）</td></tr><tr><td><strong>升级触发条件</strong></td><td>多线程竞争</td><td>自旋失败或竞争激烈</td><td>竞争超时或资源争用</td></tr><tr><td><strong>适用锁类型</strong></td><td><code>synchronized</code>方法/块</td><td><code>synchronized</code>方法/块</td><td><code>synchronized</code>、<code>ReentrantLock</code></td></tr></tbody></table></div><blockquote><p>来源：<a class=link href=@ref>3,6,8</a></p></blockquote><hr><h3 id=-总结-4>💎 <strong>总结</strong></h3><p>偏向锁通过<strong>消除单线程重复同步的开销</strong>，成为JVM锁优化的重要一环。其价值在于：</p><ul><li><strong>性能提升</strong>：单线程场景同步效率接近无锁操作。</li><li><strong>资源节约</strong>：减少CPU上下文切换与CAS操作。</li><li><strong>平滑升级</strong>：与轻量级锁、重量级锁形成动态优化链路。
<strong>实践建议</strong>：在明确单线程主导的场景启用偏向锁；高并发或短生命周期对象场景建议禁用（<code>-XX:-UseBiasedLocking</code>）。现代JDK中，随着自旋优化与硬件发展，轻量级锁已能覆盖多数场景，偏向锁逐渐退出历史舞台，但其设计思想仍值得借鉴<a class=link href=@ref>4,6,8</a>。</li></ul><h2 id=弃用偏向锁>弃用偏向锁</h2><p>偏向锁（Biased Locking）在JDK 15中被默认关闭（通过JEP 374实现），并在后续版本中被废弃甚至移除。这一决策是JVM团队基于现代硬件特性、应用场景变化和性能实测数据的综合考量，主要原因如下：</p><hr><h3 id=-性能收益与成本失衡>🔧 <strong>性能收益与成本失衡</strong></h3><ol><li><strong>优化场景减少</strong><ul><li>偏向锁的初衷是优化<strong>单线程重复访问同步块</strong>的场景（如初始化阶段或线程局部操作），通过避免CAS操作降低开销<a class=link href=@ref>2,3</a>。</li><li><strong>现代应用变化</strong>：微服务、高并发系统中，锁对象常被多线程竞争访问（如线程池处理请求），偏向锁的适用场景大幅减少<a class=link href=@ref>2,5</a>。</li></ul></li><li><strong>撤销开销过高</strong><ul><li>当其他线程尝试获取已被偏向的锁时，JVM需触发
撤销操作：<ul><li>暂停持有偏向锁的线程（<strong>Stop-The-World, STW</strong>），等待全局安全点（Safepoint）<a class=link href=@ref>2,6</a>。</li><li>升级为轻量级锁或重量级锁，涉及线程状态检查和Mark Word更新<a class=link href=@ref>4,5</a>。</li></ul></li><li><strong>高并发场景下</strong>：频繁撤销导致STW操作激增，成为延迟抖动和吞吐量下降的主因<a class=link href=@ref>3,5</a>。</li></ul></li><li><strong>对比收益不足</strong><ul><li>现代硬件（多核CPU）和JIT优化（如锁消除、自适应自旋）使轻量级锁的性能接近偏向锁，且无撤销成本<a class=link href=@ref>3,5</a>。</li><li>官方基准测试（如SPECjbb2015）显示：禁用偏向锁后，99%的延迟波动降低5%-10%，吞吐量无显著损失<a class=link href=@ref>3</a>。</li></ul></li></ol><hr><h3 id=-实现复杂性与维护负担>⚙️ <strong>实现复杂性与维护负担</strong></h3><ol><li><strong>代码耦合度高</strong><ul><li>偏向锁的实现（如<code>biased_locking.cpp</code>）与HotSpot的锁子系统深度耦合，约占JVM代码量的2%，增加了维护难度和潜在Bug风险<a class=link href=@ref>1,3</a>。</li><li>撤销逻辑涉及安全点机制、线程状态管理等复杂交互，阻碍了JVM其他特性的演进（如GraalVM即时编译优化）<a class=link href=@ref>2,4</a>。</li></ul></li><li><strong>与其他机制冲突</strong><ul><li><strong>HashCode调用</strong>：在偏向锁状态下调用<code>hashCode()</code>会强制撤销锁并升级，引发额外性能损耗<a class=link href=@ref>6</a>。</li><li><strong>短期对象无效</strong>：大量短暂对象（如HTTP请求上下文）的锁竞争直接跳过偏向阶段，使其优化无效<a class=link href=@ref>3,5</a>。</li></ul></li></ol><hr><h3 id=-现代硬件与并发模型的演进>🔄 <strong>现代硬件与并发模型的演进</strong></h3><ol><li><strong>多核处理器普及</strong><ul><li>服务器普遍具备数十核，线程竞争频率显著增加，偏向锁的“单线程假设”与高并发场景不匹配<a class=link href=@ref>3,5</a>。</li></ul></li><li><strong>轻量级锁足够高效</strong><ul><li>轻量级锁通过<strong>CAS自旋</strong>处理低竞争场景，避免了用户态-内核态切换，性能已接近偏向锁<a class=link href=@ref>4,6</a>。</li><li><strong>适应性自旋优化</strong>：JVM动态调整自旋次数（基于历史竞争情况），减少无效CPU消耗<a class=link href=@ref>5</a>。</li></ul></li><li><strong>无锁编程的兴起</strong><ul><li><code>java.util.concurrent</code>包提供的原子类（如<code>AtomicInteger</code>）、并发容器（如<code>ConcurrentHashMap</code>）替代了部分同步块需求<a class=link href=@ref>2,3</a>。</li></ul></li></ol><hr><h3 id=-开发者影响与应对建议>⚖️ <strong>开发者影响与应对建议</strong></h3><ol><li><strong>默认行为变化</strong><ul><li>JDK 15+：默认关闭偏向锁（等价于<pre tabindex=0><code>-XX:-UseBiasedLocking
</code></pre>），锁升级路径简化为：<pre tabindex=0><code>无锁 → 轻量级锁 → 重量级锁
</code></pre></li></ul></li><li><strong>性能调优建议</strong><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>建议</strong></th></tr></thead><tbody><tr><td>单线程高频访问同步块</td><td>通过<code>-XX:+UseBiasedLocking</code>手动启用，但需测试兼容性（未来版本可能移除）<a class=link href=@ref>2,3</a></td></tr><tr><td>高并发应用</td><td>接受默认配置，依赖轻量级锁优化</td></tr><tr><td>延迟敏感型系统</td><td>优先使用无锁数据结构（如<code>LongAdder</code>）或显式锁（如<code>ReentrantLock</code>）<a class=link href=@ref>3,5</a></td></tr></tbody></table></div></li><li><strong>代码优化方向</strong><ul><li><strong>减少同步块粒度</strong>：缩小临界区范围，避免长时间持有锁。</li><li><strong>锁消除与粗化</strong>：依赖JIT编译器自动消除无效锁，或合并连续锁操作<a class=link href=@ref>5,6</a>。</li></ul></li></ol><hr><h3 id=-总结-5>💎 <strong>总结</strong></h3><p>偏向锁的废弃是JVM适应时代发展的必然结果：</p><ol><li><strong>性能层面</strong>：撤销成本（STW）远超单线程优化收益，轻量级锁成为更普适的低开销方案<a class=link href=@ref>3,5</a>。</li><li><strong>工程层面</strong>：简化JVM锁子系统，提升可维护性，为未来优化腾出空间<a class=link href=@ref>1,4</a>。</li><li><strong>生态层面</strong>：推动开发者转向更适应高并发的同步策略（如无锁编程、显式锁控制）<a class=link href=@ref>2,6</a>。</li></ol><blockquote><p><strong>最终建议</strong>：除非明确需兼容遗留单线程高频锁场景，否则无需主动启用偏向锁。JDK 15+的默认配置已针对现代硬件和主流应用优化，性能更稳定可靠。</p></blockquote><h2 id=unsafe>Unsafe</h2><p>Unsafe 类是 Java 中位于 <code>sun.misc</code> 包下的特殊工具类，提供直接操作内存、线程调度、对象实例化等底层能力，因其绕过 JVM 安全机制而得名“不安全”。它是 JDK 内部实现高性能框架的核心，但普通开发需谨慎使用。以下是详细解析：</p><hr><h3 id=-核心功能与原理>⚙️ <strong>核心功能与原理</strong></h3><h4 id=内存操作><strong>内存操作</strong></h4><p>直接分配、读写堆外内存，避免 GC 开销：</p><ul><li><strong><code>allocateMemory(long bytes)</code></strong>：分配指定字节的堆外内存。</li><li><strong><code>putXXX(address, value)</code></strong> / <strong><code>getXXX(address)</code></strong>：直接读写内存数据（如 <code>putInt</code>、<code>getLong</code>）。</li><li><strong><code>freeMemory(address)</code></strong>：手动释放内存，否则导致内存泄漏。
​<strong>用途</strong>​：Netty 的 <code>DirectByteBuffer</code>、高频 I/O 场景。</li></ul><h4 id=对象操作><strong>对象操作</strong></h4><p>绕过访问控制，直接修改对象字段：</p><ul><li><strong><code>objectFieldOffset(Field f)</code></strong>：获取字段内存偏移量。</li><li><strong><code>putObject(Object o, long offset, Object value)</code></strong>：通过偏移量修改字段（无视 <code>private</code> 修饰）。
​<strong>示例</strong>​：</li></ul><pre tabindex=0><code>User user = new User();
long offset = unsafe.objectFieldOffset(User.class.getDeclaredField(&#34;age&#34;));
unsafe.putInt(user, offset, 25); // 强制修改age字段
</code></pre><h4 id=cas原子操作><strong>CAS（原子操作）</strong></h4><p>通过 CPU 指令实现无锁并发：</p><ul><li><strong><code>compareAndSwapInt(Object o, long offset, int expected, int update)</code></strong>：若当前值等于预期值，则更新。
​<strong>用途</strong>​：<code>AtomicInteger</code>、<code>ConcurrentHashMap</code> 的底层实现。</li></ul><h4 id=线程调度><strong>线程调度</strong></h4><p>精准控制线程阻塞与唤醒：</p><ul><li><strong><code>park(boolean isAbsolute, long timeout)</code></strong>：挂起当前线程（类似 <code>LockSupport.park</code>）。</li><li><strong><code>unpark(Thread thread)</code></strong>：唤醒指定线程。
​<strong>用途</strong>​：<code>StampedLock</code>、AQS 的阻塞队列实现。</li></ul><h4 id=类与对象实例化><strong>类与对象实例化</strong></h4><p>绕过构造函数创建对象：</p><ul><li><strong><code>allocateInstance(Class&lt;?> clazz)</code></strong>：不调用构造方法直接实例化对象（对象字段为默认值）。
​<strong>风险</strong>​：破坏对象不变性（如 <code>final</code> 字段未初始化）。</li></ul><hr><h3 id=-获取-unsafe-实例的方法>🔍 <strong>获取 Unsafe 实例的方法</strong></h3><p>由于设计限制，常规方法无法直接获取：</p><ol><li><strong>反射获取单例</strong>（最常用）：<pre tabindex=0><code>Field field = Unsafe.class.getDeclaredField(&#34;theUnsafe&#34;);
field.setAccessible(true);
Unsafe unsafe = (Unsafe) field.get(null);
</code></pre></li><li><strong>引导类加载器加载</strong>：通过 <code>-Xbootclasspath/a</code> 参数强制由 Bootstrap ClassLoader 加载调用类。</li></ol><hr><h3 id=-主要风险与争议>⚠️ <strong>主要风险与争议</strong></h3><h4 id=安全风险><strong>安全风险</strong></h4><ul><li><strong>内存泄漏</strong>：需手动释放内存，否则持续占用资源。</li><li><strong>JVM 崩溃</strong>：非法内存访问（如越界写操作）导致进程终止。</li><li><strong>对象状态破坏</strong>：绕过构造函数可能使对象处于不一致状态。</li></ul><h4 id=并发问题><strong>并发问题</strong></h4><ul><li><strong>数据竞争</strong>：不当的 CAS 操作或内存读写引发线程安全问题。</li><li><strong>安全漏洞</strong>：恶意代码可利用 Unsafe 修改敏感数据（如密码字段）。</li></ul><h4 id=兼容性与官方态度><strong>兼容性与官方态度</strong></h4><ul><li><strong>Java 9+ 限制</strong>：模块化系统禁止应用代码访问 <code>sun.misc.Unsafe</code>。</li><li><strong>未来移除计划</strong>：JEP 471 提议弃用内存访问方法，推荐 <code>jdk.incubator.foreign.MemorySegment</code>。</li></ul><hr><h3 id=-适用场景-vs-替代方案>⚖️ <strong>适用场景 vs 替代方案</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐方案</strong></th></tr></thead><tbody><tr><td><strong>堆外内存管理</strong></td><td>✅ Unsafe（高性能场景） → 替代：<code>ByteBuffer.allocateDirect</code> 或 <code>MemorySegment</code></td></tr><tr><td><strong>无锁并发控制</strong></td><td>✅ Unsafe 的 CAS → 替代：<code>AtomicInteger</code>、<code>LongAdder</code>（已封装安全操作）</td></tr><tr><td><strong>高性能框架开发</strong></td><td>✅ Netty、Disruptor 等底层依赖 → 普通应用无需直接使用</td></tr><tr><td><strong>对象字段反射修改</strong></td><td>❌ 避免 Unsafe → 替代：标准反射 API 或 <code>MethodHandles</code></td></tr></tbody></table></div><hr><h3 id=-总结与最佳实践>💎 <strong>总结与最佳实践</strong></h3><ul><li><strong>核心价值</strong>：
Unsafe 是 Java 高性能生态的基石，为并发框架、网络库提供底层支持，但其能力与风险并存。</li><li>使用原则：<ol><li><strong>仅限必要场景</strong>：如框架开发或极致性能优化。</li></ol></li></ul><ol start=2><li><strong>严格资源管理</strong>：内存分配后必须配对释放（<code>try-finally</code> 块确保）。</li><li><strong>升级替代方案</strong>：Java 17+ 优先使用 <code>VarHandle</code>、<code>MemorySegment</code> 等安全 API。</li></ol><ul><li>终极建议：<blockquote><p>“除非你清楚每一行代码的底层影响，否则远离 Unsafe。” —— 适用于 99% 的常规业务开发。</p></blockquote></li></ul><h2 id=locksupport>LockSupport</h2><p>LockSupport 是 Java 并发包（<code>java.util.concurrent.locks</code>）中的<strong>线程阻塞唤醒工具类</strong>，提供基于许可（Permit）的底层线程控制机制。它是构建高级同步器（如 AQS、ReentrantLock）的基础，相比传统同步机制更灵活高效。以下从核心原理、关键方法、应用场景及底层实现展开详解：</p><hr><h3 id=-核心原理许可机制permit>⚙️ <strong>核心原理：许可机制（Permit）</strong></h3><p>每个线程关联一个<strong>二元许可证</strong>（值仅为 <code>0</code> 或 <code>1</code>），默认初始值为 <code>0</code>：</p><ul><li>park()：<ul><li>若许可为 <code>1</code>，消耗许可并<strong>立即返回</strong>；</li><li>若许可为 <code>0</code>，<strong>阻塞线程</strong>，直到满足唤醒条件。</li></ul></li><li>unpark(Thread thread)：<ul><li>若目标线程许可为 <code>0</code>，将其置为 <code>1</code>；</li><li>若目标线程因 <code>park()</code> 阻塞，则<strong>唤醒它</strong>（唤醒后许可重置为 <code>0</code>）。</li></ul></li></ul><blockquote><p>📌 <strong>关键特性</strong>：</p><ul><li><strong>顺序无关性</strong>：<code>unpark</code> 可先于 <code>park</code> 调用（许可提前存储，<code>park</code> 不阻塞）。</li><li><strong>许可不累积</strong>：多次 <code>unpark</code> 仅保留一个许可。</li><li><strong>中断响应</strong>：阻塞线程被中断时，<code>park()</code> 自动返回（<strong>不抛异常</strong>），需手动检查 <code>Thread.interrupted()</code>。</li></ul></blockquote><hr><h3 id=-核心方法详解>🔧 <strong>核心方法详解</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>park()</code></td><td>无限阻塞当前线程，直到被唤醒或中断。</td></tr><tr><td><code>park(Object blocker)</code></td><td>阻塞线程并记录阻塞原因（<code>blocker</code>），便于监控工具诊断。</td></tr><tr><td><code>parkNanos(long nanos)</code></td><td>阻塞指定纳秒数后自动返回（支持超时控制）。</td></tr><tr><td><code>parkUntil(long deadline)</code></td><td>阻塞直到绝对时间戳 <code>deadline</code>（单位：毫秒）。</td></tr><tr><td><code>unpark(Thread thread)</code></td><td>唤醒指定线程（精准控制，避免随机唤醒）。</td></tr></tbody></table></div><blockquote><p>💡 <strong>唤醒条件</strong>：</p><ol><li>其他线程调用 <code>unpark(当前线程)</code>；</li><li>当前线程被中断（<code>thread.interrupt()</code>）；</li><li>虚假唤醒（极少发生）。</li></ol></blockquote><hr><h3 id=-底层实现跨越三层架构>⚡ <strong>底层实现：跨越三层架构</strong></h3><p>LockSupport 的高效性源于其分层设计：</p><ol><li><strong>Java API 层</strong>：
调用 <code>Unsafe.park()</code>/<code>Unsafe.unpark()</code> 的本地方法。</li><li>JVM 层（HotSpot）：
每个线程关联一个 Parker 对象（C++ 类），内含：<ul><li><code>_counter</code>：许可计数器（<code>0</code> 或 <code>1</code>）；</li><li><code>_mutex</code> 和 <code>_cond</code>：基于 OS 的同步原语（如 Linux 的 <code>pthread_cond_wait</code>）。</li></ul></li><li><strong>操作系统层</strong>：
Linux 通过 <code>futex</code> 系统调用实现高效线程阻塞/唤醒。</li></ol><pre tabindex=0><code>graph LR
A[Java: LockSupport.park()] --&gt; B[JVM: Parker.park()]
B --&gt; C[OS: futex/pthread_cond_wait]
C --&gt; D[CPU: 线程挂起]
</code></pre><hr><h3 id=-与传统同步机制对比>🆚 <strong>与传统同步机制对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th>LockSupport</th><th>Object.wait()/notify()</th><th>Condition.await()/signal()</th></tr></thead><tbody><tr><td><strong>依赖锁对象</strong></td><td>❌ 无需任何锁</td><td>✅ 需 <code>synchronized</code></td><td>✅ 需 <code>ReentrantLock</code></td></tr><tr><td><strong>唤醒精度</strong></td><td>✅ 指定线程唤醒</td><td>❌ <code>notify()</code> 随机唤醒</td><td>❌ <code>signal()</code> 随机唤醒</td></tr><tr><td><strong>顺序容错性</strong></td><td>✅ 支持先 <code>unpark</code> 后 <code>park</code></td><td>❌ 先 <code>notify</code> 后 <code>wait</code> 失效</td><td>❌ 先 <code>signal</code> 后 <code>await</code> 失效</td></tr><tr><td><strong>中断处理</strong></td><td>返回后需手动检查中断状态</td><td>抛出 <code>InterruptedException</code></td><td>抛出 <code>InterruptedException</code></td></tr><tr><td><strong>使用复杂度</strong></td><td>低（无锁竞争风险）</td><td>高（易死锁）</td><td>中（需管理锁）</td></tr></tbody></table></div><blockquote><p>⚠️ <strong>Object.wait() 的局限</strong>：
必须在 <code>synchronized</code> 块中使用，且 <code>notify()</code> 无法精准唤醒特定线程，易导致“信号丢失”或“惊群效应”。</p></blockquote><hr><h3 id=-应用场景与示例>🛠️ <strong>应用场景与示例</strong></h3><h4 id=精准控制线程协作><strong>精准控制线程协作</strong></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 示例：三个线程交替打印 ABC</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>AlternatePrint</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>static</span><span class=w> </span><span class=n>Thread</span><span class=w> </span><span class=n>t1</span><span class=p>,</span><span class=w> </span><span class=n>t2</span><span class=p>,</span><span class=w> </span><span class=n>t3</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Runnable</span><span class=w> </span><span class=n>taskA</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>LockSupport</span><span class=p>.</span><span class=na>park</span><span class=p>();</span><span class=w>  </span><span class=c1>// 等待唤醒</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>print</span><span class=p>(</span><span class=s>&#34;A&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>LockSupport</span><span class=p>.</span><span class=na>unpark</span><span class=p>(</span><span class=n>t2</span><span class=p>);</span><span class=w> </span><span class=c1>// 唤醒B</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 类似实现 taskB（打印B后唤醒C）、taskC（打印C后唤醒A）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>t1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=n>taskA</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>t2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=n>taskB</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>t3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=n>taskC</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>t1</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w> </span><span class=n>t2</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w> </span><span class=n>t3</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>LockSupport</span><span class=p>.</span><span class=na>unpark</span><span class=p>(</span><span class=n>t1</span><span class=p>);</span><span class=w> </span><span class=c1>// 启动流程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 输出：ABCABC</span><span class=w>
</span></span></span></code></pre></div><h4 id=超时控制与中断处理><strong>超时控制与中断处理</strong></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Thread</span><span class=w> </span><span class=n>worker</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>workFinished</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>Thread</span><span class=p>.</span><span class=na>interrupted</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>cleanUp</span><span class=p>();</span><span class=w> </span><span class=c1>// 响应中断清理资源</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>LockSupport</span><span class=p>.</span><span class=na>parkNanos</span><span class=p>(</span><span class=n>500_000_000</span><span class=p>);</span><span class=w> </span><span class=c1>// 阻塞0.5秒</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>worker</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 外部中断或超时后自动恢复</span><span class=w>
</span></span></span></code></pre></div><h4 id=构建高级同步器如aqs><strong>构建高级同步器（如AQS）</strong></h4><p>AQS 的阻塞队列依赖 <code>LockSupport.park()</code> 挂起线程，<code>release()</code> 时调用 <code>unpark()</code> 唤醒后继节点。</p><hr><h3 id=-注意事项-1>⚠️ <strong>注意事项</strong></h3><ol><li><strong>避免死锁</strong>：
<code>unpark()</code> 需确保目标线程已启动（否则唤醒无效）。</li><li><strong>许可不累积</strong>：
连续多次 <code>unpark()</code> 等效于一次，设计逻辑时勿依赖多次调用。</li><li><strong>中断处理</strong>：
在 <code>park()</code> 后检查 <code>Thread.interrupted()</code>，确保业务逻辑健壮性。</li><li><strong>阻塞原因记录</strong>：
使用 <code>park(Object blocker)</code> 便于诊断线程阻塞问题。</li></ol><hr><h3 id=-总结-6>💎 <strong>总结</strong></h3><p>LockSupport 是 Java 并发编程的<strong>底层基石</strong>，通过<strong>许可机制</strong>和<strong>精准唤醒</strong>解决了传统同步工具的局限性：</p><ul><li>✅ <strong>灵活性</strong>：脱离锁束缚，可在任意位置阻塞/唤醒线程；</li><li>✅ <strong>高效性</strong>：基于 JVM 和 OS 原语，性能优于 <code>synchronized</code>；</li><li>✅ <strong>精准性</strong>：指定线程唤醒，避免随机性和信号丢失；</li><li>✅ <strong>健壮性</strong>：支持超时控制和中断响应。
掌握 LockSupport 是理解 AQS、ReentrantLock 等高级同步器的关键，尤其适合构建高并发、低延迟的同步组件（如连接池、限流器）。</li></ul><h2 id=abstractqueuedsynchronizer>AbstractQueuedSynchronizer</h2><p>AbstractQueuedSynchronizer（AQS）是 Java 并发包（<code>java.util.concurrent.locks</code>）的核心框架，由 Doug Lea 设计，用于构建锁和其他同步器（如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code> 等）。其核心思想是通过 <strong>原子状态管理</strong> 和 <strong>FIFO 线程等待队列</strong> 实现高效的线程同步。以下从设计原理、核心结构、工作流程、应用场景及实现案例展开详解：</p><hr><h3 id=-核心设计原理>🔧 <strong>核心设计原理</strong></h3><h4 id=状态管理state><strong>状态管理（State）</strong></h4><ul><li>state 变量：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>volatile</span><span class=w> </span><span class=kt>int</span><span class=w>
</span></span></span></code></pre></div>类型，表示资源的可用状态（如锁是否被占用、信号量剩余许可数）。<ul><li>操作方法：<ul><li><code>getState()</code>：获取当前状态。</li></ul></li><li><code>setState(int)</code>：直接设置状态（非原子）。<ul><li><code>compareAndSetState(int, int)</code>：CAS 原子更新状态。</li></ul></li><li>应用示例：<ul><li><code>ReentrantLock</code>：<code>state=0</code> 表示未锁定，<code>state>0</code> 表示锁定次数（支持重入）。</li></ul></li></ul></li><li><code>Semaphore</code>：<code>state</code> 表示可用许可数量。</li></ul><h4 id=等待队列clh-变体><strong>等待队列（CLH 变体）</strong></h4><ul><li>双向链表队列：存储等待资源的线程，节点为 Node对象<ul><li>关键字段：<ul><li><code>head</code>/<code>tail</code>：队首和队尾指针。</li><li>Node 结构：<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kd>class</span> <span class=nc>Node</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>volatile</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>waitStatus</span><span class=p>;</span><span class=w>    </span><span class=c1>// 节点状态（如等待唤醒、已取消）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>volatile</span><span class=w> </span><span class=n>Node</span><span class=w> </span><span class=n>prev</span><span class=p>;</span><span class=w>         </span><span class=c1>// 前驱节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>volatile</span><span class=w> </span><span class=n>Node</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>         </span><span class=c1>// 后继节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>volatile</span><span class=w> </span><span class=n>Thread</span><span class=w> </span><span class=n>thread</span><span class=p>;</span><span class=w>     </span><span class=c1>// 关联线程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Node</span><span class=w> </span><span class=n>nextWaiter</span><span class=p>;</span><span class=w>            </span><span class=c1>// 条件队列的下一个节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul></li><li>waitStatus 状态值：<ul><li><code>CANCELLED (1)</code>：线程已取消等待。</li><li><code>SIGNAL (-1)</code>：后续节点需被唤醒。</li><li><code>CONDITION (-2)</code>：节点处于条件队列（如 <code>Condition</code> 的等待队列）。</li></ul></li></ul></li></ul><h4 id=线程阻塞与唤醒><strong>线程阻塞与唤醒</strong></h4><ul><li><strong><code>LockSupport</code> 工具</strong>：
基于许可机制阻塞（<code>park()</code>）或唤醒（<code>unpark()</code>）线程，避免死锁风险。</li></ul><hr><h3 id=-工作流程以独占模式为例>⚙️ <strong>工作流程（以独占模式为例）</strong></h3><h4 id=获取资源><strong>获取资源（<code>acquire</code>）</strong></h4><pre tabindex=0><code>public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp; 
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) {
        selfInterrupt();
    }
}
</code></pre><ul><li>流程：<ol><li><strong><code>tryAcquire(arg)</code></strong>：子类实现，尝试获取资源（如 CAS 设置 <code>state</code>）。</li><li>失败则入队：<ul><li><code>addWaiter()</code>：将线程封装为 <code>Node</code> 加入队尾（CAS 保证原子性）。</li></ul></li></ol><ul><li><code>acquireQueued()</code>：自旋尝试获取资源，失败则阻塞（<code>LockSupport.park()</code>）。</li></ul></li></ul><ol start=3><li><strong>唤醒后重试</strong>：前驱节点释放资源后，唤醒当前节点重新尝试获取。</li></ol><h4 id=释放资源><strong>释放资源（<code>release</code>）</strong></h4><pre tabindex=0><code>public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h); // 唤醒后继节点
        return true;
    }
    return false;
}
</code></pre><ul><li>流程：<ol><li><strong><code>tryRelease(arg)</code></strong>：子类实现，释放资源（如重置 <code>state</code>）。</li></ol></li></ul><ol start=2><li><strong>唤醒后继</strong>：若队列中存在有效节点，唤醒其线程。</li></ol><blockquote><p>📌 <strong>共享模式</strong>（如 <code>Semaphore</code>）逻辑类似，但允许多线程同时获取资源（<code>tryAcquireShared()</code> 返回剩余许可数）。</p></blockquote><hr><h3 id=-aqs-的两种模式>🛠️ <strong>AQS 的两种模式</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>模式</strong></th><th><strong>特点</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>独占模式</strong></td><td>同一时间仅一个线程可获取资源（如 <code>ReentrantLock</code>）</td><td>写操作、互斥访问</td></tr><tr><td><strong>共享模式</strong></td><td>多个线程可同时获取资源（如 <code>Semaphore</code>、<code>CountDownLatch</code>）</td><td>读操作、资源池管理</td></tr></tbody></table></div><hr><h3 id=-基于-aqs-的-jdk-同步工具>🌐 <strong>基于 AQS 的 JDK 同步工具</strong></h3><ol><li>ReentrantLock：<ul><li>独占锁，支持重入和公平性。</li><li><code>state</code> 记录重入次数，公平锁按队列顺序获取资源。</li></ul></li><li>Semaphore：<ul><li>共享模式，<code>state</code> 表示可用许可数。</li><li><code>acquire()</code> 减少许可，<code>release()</code> 增加许可。</li></ul></li><li>CountDownLatch：<ul><li>共享模式，初始化 <code>state=N</code>，<code>countDown()</code> 递减 <code>state</code>，<code>await()</code> 在 <code>state=0</code> 时唤醒线程。</li></ul></li><li>ReentrantReadWriteLock：<ul><li>混合模式：写锁独占，读锁共享。</li><li><code>state</code> 高 16 位记录读锁数量，低 16 位记录写锁重入次数。</li></ul></li></ol><hr><h3 id=-自定义同步器实现>💻 <strong>自定义同步器实现</strong></h3><h4 id=步骤><strong>步骤</strong></h4><ol><li>定义内部类继承 <code>AQS</code>，重写钩子方法（如 <code>tryAcquire</code>、<code>tryRelease</code>）。</li><li>封装同步接口（如 <code>Lock</code>），委托给 AQS 子类执行。</li></ol><h4 id=示例非重入互斥锁><strong>示例：非重入互斥锁</strong></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Mutex</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Lock</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Sync</span><span class=w> </span><span class=n>sync</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Sync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 委托给 Sync 类</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>lock</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>sync</span><span class=p>.</span><span class=na>acquire</span><span class=p>(</span><span class=n>1</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>class</span> <span class=nc>Sync</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>AbstractQueuedSynchronizer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>protected</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>tryAcquire</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>arg</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>compareAndSetState</span><span class=p>(</span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w> </span><span class=c1>// CAS 获取锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>protected</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>tryRelease</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>arg</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>setState</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w> </span><span class=c1>// 释放锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h4 id=注意事项><strong>注意事项</strong></h4><ul><li><strong>钩子方法需线程安全</strong>：避免使用阻塞操作。</li><li><strong>条件变量支持</strong>：通过 <code>newCondition()</code> 返回 <code>ConditionObject</code>（需实现 <code>isHeldExclusively()</code>）。</li></ul><hr><h3 id=-aqs-与-synchronized-对比>⚖️ <strong>AQS 与 synchronized 对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>AQS</strong></th><th><strong>synchronized</strong></th></tr></thead><tbody><tr><td><strong>可中断性</strong></td><td>✅ 支持 <code>lockInterruptibly()</code></td><td>❌ 不可中断</td></tr><tr><td><strong>超时机制</strong></td><td>✅ 支持 <code>tryLock(timeout, unit)</code></td><td>❌ 不支持</td></tr><tr><td><strong>公平性</strong></td><td>✅ 可配置（公平/非公平）</td><td>❌ 仅非公平</td></tr><tr><td><strong>实现复杂度</strong></td><td>需手动实现锁逻辑</td><td>JVM 自动管理</td></tr><tr><td><strong>性能</strong></td><td>高竞争场景更优（减少上下文切换）</td><td>低竞争场景足够高效</td></tr></tbody></table></div><hr><h3 id=-总结-7>💎 <strong>总结</strong></h3><p>AQS 通过 <strong>原子状态管理 + CLH 队列 + 模板方法</strong> 的设计，为构建高效同步组件提供了标准化框架：</p><ul><li><strong>核心价值</strong>：解耦同步状态管理与线程调度，支持独占/共享两种模式。</li><li><strong>适用场景</strong>：高并发需精细控制锁（如超时、公平性）的场景。</li><li><strong>实践建议</strong>：优先使用 JDK 内置同步工具（如 <code>ReentrantLock</code>），仅当特殊需求时自定义 AQS 子类。</li></ul><blockquote><p>深入理解 AQS 是掌握 Java 并发的关键，其设计思想（如 CAS、队列调度）广泛用于高性能中间件（如数据库连接池、限流器）。</p></blockquote><h2 id=clh-队列>CLH 队列</h2><p>CLH队列是一种基于链表的<strong>公平自旋锁实现</strong>，由Craig、Landin和Hagersten提出（取三人名字首字母命名）。它通过隐式队列管理线程的锁请求顺序，是Java并发框架中<code>AbstractQueuedSynchronizer</code>（AQS）的底层设计基础。以下从核心原理、实现机制、优缺点及应用场景展开详解：</p><hr><h3 id=-核心结构与工作流程>⛓️ <strong>核心结构与工作流程</strong></h3><h4 id=核心组件><strong>核心组件</strong></h4><ul><li>节点（Node）
每个线程请求锁时创建一个节点，包含：<ul><li><code>locked</code>：布尔值，标识线程是否需要等待（<code>true</code>表示等待锁，<code>false</code>表示可获取锁）。</li><li><code>prev</code>：指向前驱节点的引用（构建隐式链表）。</li></ul></li><li><strong>尾指针（Tail）</strong>
原子引用类型（如<code>AtomicReference</code>），指向队列中最新加入的节点，通过CAS操作保证线程安全。</li></ul><h4 id=工作流程><strong>工作流程</strong></h4><pre tabindex=0><code>graph LR
A[线程申请锁] --&gt; B[创建新节点 locked=true]
B --&gt; C[CAS操作加入队尾]
C --&gt; D[自旋检查前驱节点状态]
D --&gt; E{前驱节点 locked=false?}
E -- 是 --&gt; F[获取锁执行]
E -- 否 --&gt; D
F --&gt; G[执行临界区代码]
G --&gt; H[释放锁： locked=false]
H --&gt; I[断开前驱引用]
</code></pre><ol><li><strong>加锁流程</strong>：<ul><li><strong>步骤1</strong>：线程创建新节点，<code>locked=true</code>。</li><li><strong>步骤2</strong>：通过CAS将新节点置为队尾，并记录原尾节点作为前驱节点。</li><li><strong>步骤3</strong>：线程在前驱节点的<code>locked</code>字段上<strong>自旋等待</strong>，直到其变为<code>false</code>。</li></ul></li><li><strong>释放流程</strong>：<ul><li><strong>步骤1</strong>：线程将自身节点的<code>locked</code>设为<code>false</code>，通知后继线程可获取锁。</li><li><strong>步骤2</strong>：断开当前节点与前驱节点的引用（避免内存泄漏）。</li></ul></li></ol><blockquote><p>📌 <strong>示例</strong>：</p><ul><li>线程A获取锁 → 节点A(<code>locked=true</code>)入队 → <code>tail</code>指向A。</li><li>线程B加入 → 节点B入队 → <code>tail</code>指向B → B自旋检查A的<code>locked</code>。</li><li>A释放锁：设置A.<code>locked=false</code> → B检测到后退出自旋，获取锁。</li></ul></blockquote><hr><h3 id=-技术特点分析>⚙️ <strong>技术特点分析</strong></h3><h4 id=核心优势><strong>核心优势</strong></h4><ul><li><strong>严格公平性</strong>
按请求顺序分配锁（FIFO），彻底避免线程饥饿。</li><li><strong>局部自旋减少开销</strong>
线程仅自旋检查<strong>前驱节点</strong>的状态（而非全局变量），减少缓存同步和总线流量。</li><li><strong>无“惊群效应”</strong>
锁释放时仅唤醒直接后继节点，避免同时唤醒大量线程竞争资源。</li><li><strong>空间复杂度低</strong>
若有N个线程竞争L个锁，空间复杂度为<code>O(L+N)</code>。</li></ul><h4 id=局限性><strong>局限性</strong></h4><ul><li><strong>NUMA架构性能差</strong>
在非统一内存访问（NUMA）系统中，前驱节点可能位于远程内存，自旋检查延迟高。</li><li><strong>自旋消耗CPU</strong>
高竞争场景下，长时间自旋可能导致CPU空转（适用于短任务）。</li><li><strong>不直接支持锁重入</strong>
需额外机制实现重入（如AQS通过<code>state</code>计数支持）。</li></ul><hr><h3 id=-clh在aqs中的变体实现>🔄 <strong>CLH在AQS中的变体实现</strong></h3><p>AQS对CLH进行了关键改进以适应更复杂场景：</p><ol><li><strong>双向链表代替单向链表</strong>
增加<code>next</code>指针，支持高效取消节点（如超时或中断）。</li><li><strong>阻塞替代自旋</strong>
用<code>LockSupport.park()</code>挂起线程（非自旋），减少CPU消耗。</li><li>状态扩展节点<pre tabindex=0><code>waitStatus
</code></pre>支持多种状态：<ul><li><code>SIGNAL (-1)</code>：后继节点需唤醒。</li><li><code>CANCELLED (1)</code>：节点已取消。</li><li><code>CONDITION (-2)</code>：节点在条件队列等待。</li></ul></li><li><strong>双队列设计</strong>
分离<strong>同步队列</strong>​（锁竞争）和<strong>条件队列</strong>​（<code>Condition</code>等待），提升灵活性。</li></ol><blockquote><p>⚡ <strong>性能对比（CLH vs AQS变体）</strong>：</p><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th>CLH队列</th><th>AQS变体</th></tr></thead><tbody><tr><td><strong>高竞争</strong></td><td>CPU空转严重</td><td>线程挂起，减少开销</td></tr><tr><td><strong>长任务</strong></td><td>不适用</td><td>适用</td></tr><tr><td><strong>公平性</strong></td><td>严格FIFO</td><td>可配置公平/非公平</td></tr></tbody></table></div></blockquote><hr><h3 id=-适用场景-1>🌐 <strong>适用场景</strong></h3><ol><li><strong>SMP架构的短任务锁</strong>
多核CPU共享内存的场景（如计数器累加）。</li><li><strong>需严格公平性的场景</strong>
如交易系统按请求顺序处理。</li><li><strong>基础锁原语设计</strong>
数据库事务管理、分布式锁（如ZooKeeper）参考CLH思想。</li></ol><hr><h3 id=-总结-8>💎 <strong>总结</strong></h3><p>CLH队列通过<strong>隐式链表+前驱节点自旋</strong>的机制，以低开销实现了严格公平锁，尤其适合<strong>短任务</strong>和<strong>SMP架构</strong>。其局限性（如NUMA性能差、CPU空转）促使AQS等框架引入<strong>阻塞唤醒</strong>和<strong>状态扩展</strong>优化，成为Java高并发组件的基石。理解CLH是掌握现代同步器设计的关键一步。</p><h2 id=lock>Lock</h2><p>Lock 接口是 Java 并发编程中用于替代 <code>synchronized</code> 的线程同步机制，位于 <code>java.util.concurrent.locks</code> 包中。它提供了更灵活、功能更丰富的锁控制能力，适用于复杂并发场景。以下从核心作用、方法详解、实现类、与 <code>synchronized</code> 的对比及适用场景展开分析：</p><hr><h3 id=-lock-接口的核心作用>🔒 <strong>Lock 接口的核心作用</strong></h3><ol><li>精细化锁控制<ul><li>支持<strong>可中断锁</strong>、<strong>超时获取锁</strong>、<strong>非阻塞尝试锁</strong>等高级功能，弥补 <code>synchronized</code> 的不足。</li></ul></li><li>显式锁管理<ul><li>需手动调用 <code>lock()</code> 和 <code>unlock()</code> 方法，避免隐式锁的不可控性，但需在 <code>finally</code> 块中确保释放，防止死锁。</li></ul></li><li>支持多条件变量<ul><li>通过 <code>Condition</code> 对象实现多条件队列（如 <code>await()</code>/<code>signal()</code>），比 <code>synchronized</code> 的单一等待集更灵活。</li></ul></li></ol><hr><h3 id=-lock-接口方法详解>⚙️ <strong>Lock 接口方法详解</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>方法</strong></th><th><strong>功能说明</strong></th><th><strong>使用示例</strong></th></tr></thead><tbody><tr><td><strong><code>void lock()</code></strong></td><td>阻塞获取锁，若锁被占用则线程休眠等待</td><td>基础锁操作，需配合 <code>unlock()</code> 使用</td></tr><tr><td><strong><code>boolean tryLock()</code></strong></td><td>尝试非阻塞获取锁，成功返回 <code>true</code>，失败立即返回 <code>false</code></td><td>适用于轻量级任务，避免线程阻塞</td></tr><tr><td><strong><code>tryLock(long, TimeUnit)</code></strong></td><td>超时尝试获取锁，支持中断响应</td><td>避免无限等待，设置超时时间（如 <code>lock.tryLock(100, TimeUnit.MILLISECONDS)</code>）</td></tr><tr><td><strong><code>lockInterruptibly()</code></strong></td><td>可中断获取锁，等待过程中响应 <code>interrupt()</code> 信号并抛出 <code>InterruptedException</code></td><td>解决线程长期阻塞问题</td></tr><tr><td><strong><code>void unlock()</code></strong></td><td>释放锁，<strong>必须</strong>在 <code>finally</code> 块中调用</td><td>确保异常时锁仍释放</td></tr><tr><td><strong><code>Condition newCondition()</code></strong></td><td>创建绑定到锁的条件变量，支持精细线程通信</td><td>替代 <code>wait()</code>/<code>notify()</code>，实现多条件等待</td></tr></tbody></table></div><pre tabindex=0><code>// 标准使用模板（避免死锁）
Lock lock = new ReentrantLock();
lock.lock();
try {
    // 同步代码逻辑
} finally {
    lock.unlock(); // 确保释放
}
</code></pre><hr><h3 id=-lock-的主要实现类>🔧 <strong>Lock 的主要实现类</strong></h3><ol><li><strong><code>ReentrantLock</code>（可重入锁）</strong><ul><li>特性：<ul><li>同一线程可重复获取锁（重入计数）。</li><li>支持<strong>公平锁</strong>（按请求顺序分配）和<strong>非公平锁</strong>（默认，吞吐量高）。</li></ul></li><li><strong>适用场景</strong>：替代 <code>synchronized</code>，需重入或公平性的场景。</li></ul></li><li><strong><code>ReentrantReadWriteLock</code>（读写锁）</strong><ul><li>特性：<ul><li>分离读锁（共享）和写锁（独占），<strong>读多写少</strong>时大幅提升并发性能。</li><li>写锁优先：避免读线程饥饿。</li></ul></li><li>示例：<pre tabindex=0><code>ReadWriteLock rwLock = new ReentrantReadWriteLock();
rwLock.readLock().lock();  // 多线程可并发读
rwLock.writeLock().lock(); // 写锁独占
</code></pre></li></ul></li></ol><hr><h3 id=-lock-vs-synchronized-核心对比>↔️ <strong>Lock vs Synchronized 核心对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>Lock</strong></th><th><strong>Synchronized</strong></th></tr></thead><tbody><tr><td><strong>锁机制</strong></td><td>显式锁（手动获取/释放）</td><td>隐式锁（自动释放）</td></tr><tr><td><strong>可中断性</strong></td><td>✅ 支持 <code>lockInterruptibly()</code></td><td>❌ 不可中断</td></tr><tr><td><strong>超时机制</strong></td><td>✅ <code>tryLock(timeout)</code></td><td>❌ 不支持</td></tr><tr><td><strong>公平性</strong></td><td>✅ 可配置（公平/非公平）</td><td>❌ 仅非公平锁</td></tr><tr><td><strong>条件变量</strong></td><td>✅ 支持多个 <code>Condition</code></td><td>❌ 单一等待集</td></tr><tr><td><strong>性能（高竞争）</strong></td><td>更优（CAS 减少阻塞）</td><td>JDK 6+ 优化后接近</td></tr><tr><td><strong>死锁风险</strong></td><td>需手动释放（忘记 <code>unlock()</code> 易死锁）</td><td>自动释放（异常时安全）</td></tr><tr><td><strong>代码复杂度</strong></td><td>较高（需模板代码）</td><td>简洁（关键字修饰）</td></tr></tbody></table></div><blockquote><p><strong>选择原则</strong>：</p><ul><li><strong>简单同步</strong> → <code>synchronized</code>（代码简洁）。</li><li><strong>高级需求</strong>（可中断、超时、公平锁） → <code>Lock</code>。</li></ul></blockquote><hr><h3 id=-适用场景-2>🎯 <strong>适用场景</strong></h3><ol><li><strong>高并发读场景</strong>
使用 <code>ReentrantReadWriteLock</code> 提升读并发性能（如缓存系统）。</li><li><strong>避免线程无限阻塞</strong>
需超时（<code>tryLock</code>）或可中断（<code>lockInterruptibly</code>）的敏感任务（如网络请求）。</li><li><strong>复杂线程协作</strong>
多条件变量（<code>Condition</code>）实现精细调度（如生产者-消费者模型）。</li><li><strong>公平性要求</strong>
需按请求顺序分配资源（如交易系统）。</li></ol><hr><h3 id=-注意事项-2>⚠️ <strong>注意事项</strong></h3><ol><li><strong>锁释放</strong>：务必在 <code>finally</code> 中调用 <code>unlock()</code>，否则可能导致死锁。</li><li><strong>性能权衡</strong>：低竞争时 <code>synchronized</code> 性能接近，且代码更简洁。</li><li><strong>ABA 问题</strong>：<code>Lock</code> 本身不解决，需结合 <code>AtomicStampedReference</code>。</li></ol><hr><h3 id=-总结-9>💎 <strong>总结</strong></h3><p>Lock 接口通过<strong>显式锁管理</strong>、<strong>可中断性</strong>、<strong>超时控制</strong>及<strong>多条件变量</strong>，提供了比 <code>synchronized</code> 更灵活的并发控制能力。其核心实现类 <code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 分别适用于重入锁和读写分离场景。选择时需权衡：</p><ul><li><strong>简单需求</strong> → <code>synchronized</code>（安全简洁）。</li><li><strong>复杂控制</strong> → <code>Lock</code>（功能强大，需谨慎释放锁）。</li></ul><h2 id=condition>Condition</h2><p>以下是关于 Java 并发编程中 <code>Condition</code> 接口的详细解析，涵盖其核心原理、使用规范、底层实现及典型应用场景，结合权威技术文档与源码实现整理：</p><hr><h3 id=-condition-的核心作用与优势>⚙️ <strong>Condition 的核心作用与优势</strong></h3><p><code>Condition</code> 是 <code>java.util.concurrent.locks</code> 包中与显式锁（如 <code>ReentrantLock</code>）配套的线程协调机制，用于替代传统的 <code>Object.wait()/notify()</code>，提供更<strong>精细化的线程等待/通知控制</strong>：</p><ol><li>多条件队列：<ul><li>一个 <code>Lock</code> 可关联多个 <code>Condition</code>（例如生产者-消费者模型中的“非空”和“非满”条件），每个条件独立管理线程等待队列。</li><li>示例:<pre tabindex=0><code></code></pre></li></ul>ReentrantLock lock = new ReentrantLock();
Condition notEmpty = lock.newCondition(); // 队列非空条件
Condition notFull = lock.newCondition(); // 队列非满条件<pre tabindex=0><code></code></pre></li><li>精准唤醒：<ul><li>支持 <code>signal()</code>（唤醒单个等待线程）和 <code>signalAll()</code>（唤醒全部线程），避免 <code>notifyAll()</code> 导致的无效竞争。</li></ul></li><li>增强控制：<ul><li>提供超时等待（<code>awaitNanos()</code>）、不可中断等待（<code>awaitUninterruptibly()</code>）、截止时间等待（<code>awaitUntil()</code>）等灵活选项。</li></ul></li></ol><hr><h3 id=-底层实现原理基于-aqs>⛓️ <strong>底层实现原理（基于 AQS）</strong></h3><p><code>Condition</code> 的实现类 <code>ConditionObject</code> 是 AQS（<code>AbstractQueuedSynchronizer</code>）的内部类，核心机制如下：</p><ol><li>双队列模型：<ul><li><strong>同步队列</strong>：AQS 的主队列，管理竞争锁的线程。</li><li><strong>条件队列</strong>：每个 <code>Condition</code> 维护独立的 FIFO 队列，存储等待特定条件的线程节点（<code>Node</code>），节点状态为 <code>CONDITION</code>（-2）。</li></ul></li><li>await() 流程：</li></ol><ul><li>释放当前线程持有的锁（完全释放，即使重入锁也会清零计数）。<ul><li>创建 <code>CONDITION</code> 节点加入条件队列尾部。</li><li>阻塞线程，等待被唤醒或中断。</li><li>唤醒后，节点从条件队列转移到同步队列，重新竞争锁。</li></ul></li></ul><ol start=3><li>signal() 流程：<ul><li>将条件队列的头节点转移到同步队列。</li><li>修改节点状态，并通过 <code>LockSupport.unpark()</code> 唤醒线程（唤醒后仍需竞争锁）。</li></ul></li></ol><blockquote><p>📌 <strong>关键设计</strong>：条件队列与同步队列分离，通过节点迁移实现锁释放与重新获取的原子性，避免信号丢失。</p></blockquote><hr><h3 id=-使用规范与注意事项>⚠️ <strong>使用规范与注意事项</strong></h3><h4 id=强制使用规范><strong>强制使用规范</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>规则</strong></th><th><strong>说明</strong></th><th><strong>违规后果</strong></th></tr></thead><tbody><tr><td><strong>先获取锁</strong></td><td>调用 <code>await()/signal()</code> 前必须持有关联的 <code>Lock</code> 锁</td><td><code>IllegalMonitorStateException</code></td></tr><tr><td><strong>循环检查条件</strong></td><td>必须用 <code>while</code> 而非 <code>if</code> 检查条件，防止<strong>虚假唤醒（Spurious Wakeup）</strong></td><td>逻辑错误（条件不满足时错误执行）</td></tr><tr><td><strong>确保释放锁</strong></td><td><code>unlock()</code> 必须放在 <code>finally</code> 块中</td><td>死锁风险</td></tr></tbody></table></div><h4 id=中断处理><strong>中断处理</strong></h4><ul><li><code>await()</code> 可能抛出 <code>InterruptedException</code>，需明确处理中断逻辑（如重试或终止任务）。</li><li><code>awaitUninterruptibly()</code> 提供不可中断模式，适用于必须完成的任务。</li></ul><h4 id=唤醒策略建议><strong>唤醒策略建议</strong></h4><ul><li><strong>优先 <code>signal()</code></strong>：明确唤醒目标时使用，减少线程竞争开销。</li><li><strong>谨慎 <code>signalAll()</code></strong>：不确定唤醒目标时使用，但可能引发“惊群效应”。</li></ul><hr><h3 id=-典型应用场景与案例>🛠️ <strong>典型应用场景与案例</strong></h3><h4 id=生产者-消费者模型多-condition-版><strong>生产者-消费者模型（多 Condition 版）</strong></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>BoundedBuffer</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>buffer</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>capacity</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>ReentrantLock</span><span class=w> </span><span class=n>lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReentrantLock</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Condition</span><span class=w> </span><span class=n>notFull</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lock</span><span class=p>.</span><span class=na>newCondition</span><span class=p>();</span><span class=w>  </span><span class=c1>// 队列非满条件  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Condition</span><span class=w> </span><span class=n>notEmpty</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lock</span><span class=p>.</span><span class=na>newCondition</span><span class=p>();</span><span class=w> </span><span class=c1>// 队列非空条件  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>put</span><span class=p>(</span><span class=n>T</span><span class=w> </span><span class=n>item</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>buffer</span><span class=p>.</span><span class=na>size</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>capacity</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>notFull</span><span class=p>.</span><span class=na>await</span><span class=p>();</span><span class=w>  </span><span class=c1>// 队列满时等待  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>buffer</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>item</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>notEmpty</span><span class=p>.</span><span class=na>signal</span><span class=p>();</span><span class=w>    </span><span class=c1>// 唤醒一个消费者  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>T</span><span class=w> </span><span class=nf>take</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>buffer</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>notEmpty</span><span class=p>.</span><span class=na>await</span><span class=p>();</span><span class=w> </span><span class=c1>// 队列空时等待  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>T</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buffer</span><span class=p>.</span><span class=na>remove</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>notFull</span><span class=p>.</span><span class=na>signal</span><span class=p>();</span><span class=w>     </span><span class=c1>// 唤醒一个生产者  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>item</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>  
</span></span></span></code></pre></div><p><strong>优势</strong>：</p><ul><li>生产者仅唤醒消费者（而非所有线程），减少无效竞争。</li></ul><h4 id=多任务顺序调度精准唤醒><strong>多任务顺序调度（精准唤醒）</strong></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>TaskScheduler</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>ReentrantLock</span><span class=w> </span><span class=n>lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReentrantLock</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Condition</span><span class=w> </span><span class=n>condA</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lock</span><span class=p>.</span><span class=na>newCondition</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>Condition</span><span class=w> </span><span class=n>condB</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lock</span><span class=p>.</span><span class=na>newCondition</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>flag</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=c1>// 1:执行A, 2:执行B  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>runTaskA</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>flag</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>condA</span><span class=p>.</span><span class=na>await</span><span class=p>();</span><span class=w>    </span><span class=c1>// 仅等待条件A  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 执行任务A  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>flag</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>2</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>condB</span><span class=p>.</span><span class=na>signal</span><span class=p>();</span><span class=w>       </span><span class=c1>// 精准唤醒任务B  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// runTaskB 类似，唤醒 condA  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>  
</span></span></span></code></pre></div><p><strong>适用场景</strong>：多阶段任务（如加油→洗车→驶离）的顺序控制。</p><hr><h3 id=-condition-vs-object-监视器方法>🔄 <strong>Condition vs Object 监视器方法</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>Lock + Condition</strong></th><th><strong>synchronized + wait/notify</strong></th></tr></thead><tbody><tr><td>条件变量数量</td><td>✅ 多条件队列（可自定义）</td><td>❌ 单一等待队列</td></tr><tr><td>超时控制</td><td>✅ 支持 <code>awaitNanos()</code>, <code>awaitUntil()</code></td><td>⚠️ 仅有限超时（<code>wait(long timeout)</code>）</td></tr><tr><td>中断响应</td><td>✅ 支持可中断/不可中断模式</td><td>❌ 仅抛异常</td></tr><tr><td>唤醒精度</td><td>✅ 可精准唤醒指定条件队列</td><td>❌ 只能唤醒全部（<code>notifyAll()</code>）</td></tr><tr><td>锁机制</td><td>显式锁（代码控制）</td><td>隐式锁（JVM 管理）</td></tr></tbody></table></div><blockquote><p>💡 <strong>选型建议</strong>：</p><ul><li>简单同步 → <code>synchronized</code>（代码简洁）。</li><li>复杂线程协作（如多条件、超时控制）→ <code>Lock + Condition</code>。</li></ul></blockquote><hr><h3 id=-工程实践注意事项>⚠️ <strong>工程实践注意事项</strong></h3><ol><li>避免嵌套调用：<ul><li>禁止在 <code>Condition</code> 等待中嵌套调用其他锁操作，防止死锁。</li></ul></li><li>性能敏感场景：<ul><li>高并发队列（如 <code>ArrayBlockingQueue</code>）底层采用 <code>Condition</code> 实现，优先复用标准库组件。</li></ul></li><li>监控工具：<ul><li>使用 <code>jstack</code> 或 <code>JProfiler</code> 查看条件队列状态，定位线程阻塞问题。</li></ul></li></ol><hr><h3 id=-总结-10>💎 <strong>总结</strong></h3><p><code>Condition</code> 通过<strong>多条件队列、精准唤醒和灵活等待机制</strong>，实现了比传统 <code>wait/notify</code> 更精细的线程协作，尤其适用于生产者-消费者、任务调度等复杂同步场景。其底层依赖 AQS 的<strong>双队列模型和节点迁移机制</strong>，保证了操作的原子性。使用时需严守<strong>锁持有、循环检查条件和中断处理</strong>三大规范，避免死锁与逻辑错误。在 Java 并发编程中，<code>Condition</code> 是构建高效、可控同步逻辑的核心工具之一。</p><blockquote><p>本文技术要点源自 AQS 源码、《Java并发编程实战》及生产环境最佳实践。</p></blockquote><h2 id=semaphore>Semaphore</h2><h3 id=-semaphore信号量详解原理实现与应用场景>🚦 Semaphore（信号量）详解：原理、实现与应用场景</h3><p>Semaphore 是 Java 并发包（<code>java.util.concurrent</code>）中的核心同步工具，用于<strong>控制对共享资源的并发访问数量</strong>，通过维护“许可证”（Permits）实现线程数量的精确限制。以下是其全方位解析：</p><hr><h3 id=-核心原理与模型>⚙️ <strong>核心原理与模型</strong></h3><h4 id=信号量模型><strong>信号量模型</strong></h4><ul><li>计数器机制：
Semaphore 内部维护一个整数计数器（state），表示可用许可证数量：<ul><li><strong><code>acquire()</code></strong>（P操作）：请求许可证，计数器减 1；若计数器为 0，则线程阻塞。</li><li><strong><code>release()</code></strong>（V操作）：释放许可证，计数器加 1，唤醒等待线程。</li></ul></li><li><strong>经典类比</strong>：
停车场模型（3 个车位）→ 5 辆车同时到达，仅 3 辆可进入，后续车辆需等待空位。</li></ul><h4 id=公平性与非公平性><strong>公平性与非公平性</strong></h4><ul><li><strong>非公平模式（默认）</strong>：
线程直接尝试获取许可证，不保证顺序（高吞吐量）。</li><li><strong>公平模式</strong>：
线程按 FIFO 顺序获取许可证（通过 AQS 队列实现）。
构造函数示例：<code>new Semaphore(5, true)</code>。</li></ul><hr><h3 id=-底层实现基于-aqs>⚙️ <strong>底层实现（基于 AQS）</strong></h3><h4 id=aqs-共享模式><strong>AQS 共享模式</strong></h4><p>Semaphore 通过内部类 <code>Sync</code>（继承自 <code>AbstractQueuedSynchronizer</code>）实现：</p><ul><li><strong><code>state</code> 字段</strong>：存储可用许可证数量。</li><li>核心方法：<ul><li>非公平获取：<code>nonfairTryAcquireShared()</code><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>int</span><span class=w> </span><span class=nf>nonfairTryAcquireShared</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>acquires</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(;;)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=kt>int</span><span class=w> </span><span class=n>available</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getState</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>remaining</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>available</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>acquires</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>remaining</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>0</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>compareAndSetState</span><span class=p>(</span><span class=n>available</span><span class=p>,</span><span class=w> </span><span class=n>remaining</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>remaining</span><span class=p>;</span><span class=w> </span><span class=c1>// 负数表示获取失败</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li></ul></li><li><strong>公平获取</strong>：<code>tryAcquireShared()</code> 中先检查是否有前驱节点（<code>hasQueuedPredecessors()</code>）。</li></ul><h4 id=线程阻塞与唤醒-1><strong>线程阻塞与唤醒</strong></h4><ul><li><strong><code>acquire()</code></strong> → 调用 <code>sync.acquireSharedInterruptibly(1)</code>：
若 <code>tryAcquireShared()</code> 返回负值，线程加入 AQS 队列阻塞。</li><li><strong><code>release()</code></strong> → 调用 <code>sync.releaseShared(1)</code>：
通过 CAS 增加 <code>state</code>，并唤醒队列中的后继节点。</li></ul><hr><h3 id=-核心-api-与使用示例>🛠️ <strong>核心 API 与使用示例</strong></h3><h4 id=常用方法><strong>常用方法</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>acquire()</code></td><td>阻塞获取一个许可</td></tr><tr><td><code>tryAcquire()</code></td><td>尝试获取许可（立即返回成功/失败）</td></tr><tr><td><code>tryAcquire(long timeout, TimeUnit unit)</code></td><td>超时等待获取许可</td></tr><tr><td><code>release()</code></td><td>释放一个许可</td></tr><tr><td><code>availablePermits()</code></td><td>返回当前可用许可数</td></tr></tbody></table></div><h4 id=代码示例限制并发下载线程数><strong>代码示例：限制并发下载线程数</strong></h4><pre tabindex=0><code>// 允许最多 3 个线程同时下载
Semaphore semaphore = new Semaphore(3);

void downloadFile(String url) throws InterruptedException {
    semaphore.acquire(); // 获取许可
    try {
        // 模拟下载耗时
        Thread.sleep(1000);
        System.out.println(Thread.currentThread().getName() + &#34; 下载完成: &#34; + url);
    } finally {
        semaphore.release(); // 确保释放许可
    }
}
// 启动 10 个下载线程（仅 3 个并发执行）
for (int i = 0; i &lt; 10; i++) {
    new Thread(() -&gt; downloadFile(&#34;file&#34; + i)).start();
}
</code></pre><hr><h3 id=-应用场景>🌐 <strong>应用场景</strong></h3><h4 id=资源池管理><strong>资源池管理</strong></h4><ul><li><strong>数据库连接池</strong>：限制最大连接数（如最多 10 个连接）。</li><li>对象池：复用昂贵资源（如线程、网络连接）。<pre tabindex=0><code>public class ObjectPool&lt;T&gt; {
    private final Semaphore semaphore;
    private final BlockingQueue&lt;T&gt; pool;

    public ObjectPool(int size, Supplier&lt;T&gt; supplier) {
        semaphore = new Semaphore(size);
        pool = new LinkedBlockingQueue&lt;&gt;();
        for (int i = 0; i &lt; size; i++) {
            pool.add(supplier.get());
        }
    }

    public T borrow() throws InterruptedException {
        semaphore.acquire();
        return pool.take();
    }

    public void release(T obj) {
        pool.offer(obj);
        semaphore.release();
    }
}
</code></pre></li></ul><h4 id=流量控制><strong>流量控制</strong></h4><ul><li><strong>API 限流</strong>：限制每秒请求外部服务的次数（如每秒 100 次）。</li><li><strong>下载限速</strong>：控制同时下载文件的用户数（如最多 3 个）.</li></ul><h4 id=生产者-消费者协调><strong>生产者-消费者协调</strong></h4><ul><li><strong>缓冲队列</strong>：通过 Semaphore 控制生产速率（如生产前检查空闲缓冲区）.</li></ul><hr><h3 id=-注意事项-3>⚠️ <strong>注意事项</strong></h3><ol><li><strong>许可释放匹配</strong>：
确保每个 <code>acquire()</code> 都有对应的 <code>release()</code>，否则会导致资源泄漏或死锁。</li><li><strong>避免超额释放</strong>：
<code>release()</code> 次数 > <code>acquire()</code> 次数会抛出 <code>SemaphoreFullException</code>。</li><li>性能选择：<ul><li>单进程优先用 <code>SemaphoreSlim</code>（.NET 中的轻量级实现，用户态同步）。</li><li>跨进程同步需用带名称的 <code>Semaphore</code>（内核级同步）.</li></ul></li><li><strong>超时控制</strong>：
高并发场景使用 <code>tryAcquire(timeout)</code> 避免线程无限阻塞.</li></ol><hr><h3 id=-总结-11>💎 <strong>总结</strong></h3><ul><li><strong>核心价值</strong>：Semaphore 通过<strong>许可证计数</strong>实现对并发线程数的精确控制，适用于资源池、限流等高并发场景。</li><li>选型建议：<ul><li>简单限流 → <code>Semaphore</code>；</li></ul></li><li>高性能单进程 → <code>SemaphoreSlim</code>（其他语言）或非公平模式；<ul><li>严格顺序 → 公平模式。</li></ul></li><li><strong>底层基石</strong>：基于 AQS 的共享模式实现，结合 CAS 和队列管理保证高效与安全。</li></ul><blockquote><p>通过合理使用 Semaphore，可显著提升系统的稳定性和资源利用率，是并发编程中的“流量阀门”。</p></blockquote><h2 id=countdownlatch>CountDownLatch</h2><p>CountDownLatch 是 Java 并发包（<code>java.util.concurrent</code>）中的核心同步工具类，用于协调多个线程的执行顺序，<strong>允许一个或多个线程等待其他线程完成操作后再继续执行</strong>。其设计基于计数器机制，结合 AQS（AbstractQueuedSynchronizer）实现高效线程阻塞与唤醒。以下从核心原理、使用方式、应用场景、源码实现及对比分析展开详解：</p><hr><h3 id=-核心机制计数器模型>⚙️ <strong>核心机制：计数器模型</strong></h3><h4 id=核心组件-1><strong>核心组件</strong></h4><ul><li>计数器（State）初始化时指定正整数 count，表示需等待完成的线程/任务数量。<ul><li><strong><code>countDown()</code></strong>：任务完成后调用，计数器减 1（线程安全，基于 CAS）。</li><li><strong><code>await()</code></strong>：阻塞当前线程，直到计数器归零（支持超时和中断响应）。</li></ul></li></ul><h4 id=一次性特性><strong>一次性特性</strong></h4><p>计数器归零后无法重置，若需重复使用，需换用 <code>CyclicBarrier</code>。</p><hr><h3 id=-使用方式与示例>📝 <strong>使用方式与示例</strong></h3><h4 id=基础使用步骤><strong>基础使用步骤</strong></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 1. 初始化计数器（假设需等待3个任务）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>CountDownLatch</span><span class=w> </span><span class=n>latch</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>CountDownLatch</span><span class=p>(</span><span class=n>3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 2. 启动子线程（每个线程完成任务后调用 countDown()）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>doTask</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>latch</span><span class=p>.</span><span class=na>countDown</span><span class=p>();</span><span class=w> </span><span class=c1>// 任务完成，计数器-1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 3. 主线程等待所有子线程完成</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>latch</span><span class=p>.</span><span class=na>await</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;所有任务已完成！&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h4 id=典型场景示例><strong>典型场景示例</strong></h4><ul><li><strong>场景1：主线程等待所有子线程完成任务</strong>
主线程启动多个子线程执行任务，汇总最终结果（如批量文件处理）。<pre tabindex=0><code>ExecutorService executor = Executors.newFixedThreadPool(5);
CountDownLatch latch = new CountDownLatch(5);
for (int i = 0; i &lt; 5; i++) {
    executor.submit(() -&gt; {
        try {
            doWork();
        } finally {
            latch.countDown(); // 确保异常时仍释放计数器
        }
    });
}
latch.await(); // 主线程阻塞等待
executor.shutdown();
</code></pre></li><li><strong>场景2：并发测试（模拟同时触发）</strong>
多个线程等待统一信号后同时执行（如模拟秒杀请求）。<pre tabindex=0><code>CountDownLatch startSignal = new CountDownLatch(1); // 发令枪
for (int i = 0; i &lt; 10; i++) {
    new Thread(() -&gt; {
        startSignal.await(); // 等待发令
        executeConcurrentTask();
    }).start();
}
Thread.sleep(2000);
startSignal.countDown(); // 同时释放所有线程
</code></pre></li></ul><hr><h3 id=-应用场景-1>🌐 <strong>应用场景</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>场景类型</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><strong>主从协作</strong></td><td>主线程需等待所有子任务完成后再继续执行</td><td>服务启动时等待资源初始化完成</td></tr><tr><td><strong>阶段同步</strong></td><td>多阶段任务中，下一阶段需等待前一阶段所有子任务结束</td><td>分批次数据处理后汇总结果</td></tr><tr><td><strong>并发压力测试</strong></td><td>模拟高并发场景，控制多个线程同时触发请求</td><td>接口秒杀性能测试</td></tr><tr><td><strong>资源依赖检查</strong></td><td>确保所有依赖资源（如数据库连接、配置加载）就绪后再执行业务逻辑</td><td>分布式系统启动协调</td></tr></tbody></table></div><hr><h3 id=-底层实现基于-aqs-1>🔧 <strong>底层实现（基于 AQS）</strong></h3><h4 id=核心源码解析><strong>核心源码解析</strong></h4><ul><li>内部类 <code>Sync</code> 继承 AQS：<pre tabindex=0><code>private static final class Sync extends AbstractQueuedSynchronizer {
    Sync(int count) { setState(count); } // 初始化计数器

    // 尝试获取共享锁：计数器为0时返回1（成功），否则阻塞
    protected int tryAcquireShared(int acquires) {
        return (getState() == 0) ? 1 : -1;
    }

    // 释放共享锁：CAS 减少计数器，归零时唤醒等待线程
    protected boolean tryReleaseShared(int releases) {
        for (;;) {
            int c = getState();
            if (c == 0) return false;
            int nextc = c - 1;
            if (compareAndSetState(c, nextc))
                return nextc == 0; // 计数器归零时返回 true
        }
    }
}
</code></pre></li></ul><h4 id=关键方法映射><strong>关键方法映射</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>CountDownLatch 方法</strong></th><th><strong>AQS 操作</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>await()</code></td><td><code>acquireSharedInterruptibly(1)</code></td><td>阻塞线程，直到计数器归零</td></tr><tr><td><code>countDown()</code></td><td><code>releaseShared(1)</code></td><td>减少计数器，归零时唤醒所有阻塞线程</td></tr></tbody></table></div><blockquote><p>💡 <strong>共享模式优势</strong>：
允许多个线程同时等待计数器归零，唤醒时所有等待线程并发执行（对比独占模式效率更高）。</p></blockquote><hr><h3 id=-注意事项-4>⚠️ <strong>注意事项</strong></h3><ol><li><strong>不可重用性</strong>：
计数器归零后无法重置，重复使用需新建实例。</li><li><strong>异常处理</strong>：
子线程中务必在 <code>finally</code> 中调用 <code>countDown()</code>，避免任务异常导致主线程永久阻塞。</li><li><strong>超时控制</strong>：
使用 <code>await(long timeout, TimeUnit unit)</code> 避免死锁，超时返回 <code>false</code> 后可执行降级逻辑。</li><li><strong>性能影响</strong>：
高并发场景下，<code>await()</code> 阻塞线程可能增加上下文切换开销，需结合线程池优化。</li></ol><hr><h3 id=-与其他同步工具对比>⚖️ <strong>与其他同步工具对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th>CountDownLatch</th><th>CyclicBarrier</th><th>Semaphore</th></tr></thead><tbody><tr><td><strong>重置性</strong></td><td>❌ 一次性</td><td>✅ 可循环使用</td><td>✅ 动态调整许可数</td></tr><tr><td><strong>等待方向</strong></td><td>主等子</td><td>子等子（相互等待）</td><td>控制资源访问数量</td></tr><tr><td><strong>核心方法</strong></td><td><code>await()</code>/<code>countDown()</code></td><td><code>await()</code></td><td><code>acquire()</code>/<code>release()</code></td></tr><tr><td><strong>适用场景</strong></td><td>任务完成协调</td><td>分阶段任务同步</td><td>资源池限流</td></tr></tbody></table></div><blockquote><p><strong>选型建议</strong>：</p><ul><li>等待离散事件完成 → <code>CountDownLatch</code>；</li><li>多线程分阶段汇聚 → <code>CyclicBarrier</code>；</li><li>限制并发资源访问 → <code>Semaphore</code>。</li></ul></blockquote><hr><h3 id=-总结-12>💎 <strong>总结</strong></h3><p>CountDownLatch 是 Java 并发编程中的<strong>线程协调利器</strong>，通过简洁的计数器模型解决“主等子”场景的同步问题：</p><ul><li><strong>核心价值</strong>：解耦任务执行与结果汇总，提升多线程协作效率；</li><li><strong>最佳实践</strong>：结合线程池管理资源，严格处理异常与超时；</li><li><strong>适用边界</strong>：一次性任务协调，需重复同步时换用 <code>CyclicBarrier</code>。</li></ul><blockquote><p>深入理解其基于 AQS 的共享模式实现，可更好地驾驭高并发场景下的线程调度（如分布式系统启动、批量任务处理）。</p></blockquote><h2 id=cyclicbarrier>CyclicBarrier</h2><p>以下是关于 Java 并发工具 <code>CyclicBarrier</code> 的详细解析，结合其核心原理、源码实现、使用场景及与同类工具的对比展开说明：</p><hr><h3 id=-核心原理循环屏障机制>⚙️ <strong>核心原理：循环屏障机制</strong></h3><h4 id=核心设计><strong>核心设计</strong></h4><ul><li><strong>屏障点（Barrier Point）</strong>
初始化时指定线程数量 <code>parties</code>，每个线程调用 <code>await()</code> 表示到达屏障点并阻塞。当第 <code>parties</code> 个线程到达时，屏障打开，所有线程同时继续执行。</li><li><strong>可重用性（Cyclic）</strong>
屏障触发后自动重置计数器（<code>count = parties</code>），支持多轮同步，无需重新创建实例。</li><li><strong>屏障动作（Barrier Action）</strong>
可选的回调任务（<code>Runnable</code>），在所有线程唤醒前由<strong>最后一个到达的线程</strong>执行，用于汇总结果或发令。</li></ul><h4 id=工作流程-1><strong>工作流程</strong></h4><pre tabindex=0><code>graph LR
A[线程调用 await] --&gt; B{当前是第 parties 个线程?}
B -- 是 --&gt; C[执行 Barrier Action]
C --&gt; D[唤醒所有线程 &amp; 重置屏障]
B -- 否 --&gt; E[线程阻塞等待]
D --&gt; F[所有线程继续执行]
</code></pre><hr><h3 id=-底层实现基于锁与条件变量>⛓️ <strong>底层实现：基于锁与条件变量</strong></h3><h4 id=核心组件源码关键字段><strong>核心组件（源码关键字段）</strong></h4><ul><li><strong><code>ReentrantLock lock</code></strong>
保证线程安全的计数器操作和条件等待。</li><li><strong><code>Condition trip</code></strong>
线程阻塞队列，未到达屏障的线程在此等待。</li><li><strong><code>Generation generation</code></strong>
代际管理对象，记录当前屏障状态（是否损坏 <code>broken</code>）。每次屏障重置时创建新代，确保异常不影响下一轮。</li></ul><h4 id=await><strong><code>await()</code> 执行步骤</strong></h4><ol><li><p><strong>获取锁</strong>：通过 <code>lock.lock()</code> 进入临界区。</p></li><li><p><strong>检查状态</strong>：若屏障已损坏（<code>generation.broken</code>），抛出 <code>BrokenBarrierException</code>。</p></li><li><p><strong>计数器减1</strong>：<code>int index = --count</code>。</p></li><li><p>触发屏障：若</p><p>index == 0</p><ul><li>执行 <code>barrierCommand.run()</code>（若有）。</li><li>调用 <code>nextGeneration()</code>：唤醒所有线程、重置计数器、创建新代。</li></ul></li><li><p><strong>阻塞等待</strong>：非最后到达的线程进入 <code>trip.await()</code> 挂起。</p></li></ol><blockquote><p>📌 <strong>重置逻辑（<code>nextGeneration()</code>）</strong>：</p><pre tabindex=0><code>private void nextGeneration() {
trip.signalAll();          // 唤醒所有线程
count = parties;           // 重置计数器
generation = new Generation(); // 创建新代
}
</code></pre></blockquote><hr><h3 id=-使用场景与最佳实践>🛠️ <strong>使用场景与最佳实践</strong></h3><h4 id=典型应用场景><strong>典型应用场景</strong></h4><ul><li><p>多阶段任务同步
如并行计算中，每阶段结束后线程需同步数据后再进入下一阶段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>  </span><span class=c1>// 分阶段计算示例</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>CyclicBarrier</span><span class=w> </span><span class=n>barrier</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>CyclicBarrier</span><span class=p>(</span><span class=n>THREAD_NUM</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>stage</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>stage</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>STAGES</span><span class=p>;</span><span class=w> </span><span class=n>stage</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Thread</span><span class=w> </span><span class=n>thread</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>threads</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=n>thread</span><span class=p>.</span><span class=na>execute</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=n>computeStage</span><span class=p>(</span><span class=n>stage</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=n>barrier</span><span class=p>.</span><span class=na>await</span><span class=p>();</span><span class=w> </span><span class=c1>// 等待所有线程完成本阶段</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></li><li><p><strong>高并发测试</strong>
模拟瞬时高流量（如秒杀场景），控制所有线程同时发起请求。</p></li><li><p><strong>资源初始化</strong>
多个依赖资源并行初始化，全部就绪后启动服务。</p></li></ul><h4 id=最佳实践与避坑指南><strong>最佳实践与避坑指南</strong></h4><ul><li><strong>超时控制</strong>
使用 <code>await(long timeout, TimeUnit unit)</code> 避免线程永久阻塞（抛出 <code>TimeoutException</code>）。</li><li><strong>异常处理</strong>
线程中断或超时会导致屏障损坏（<code>broken=true</code>），其他线程唤醒时将抛出 <code>BrokenBarrierException</code>。</li><li><strong>屏障动作轻量化</strong>
<code>barrierCommand</code> 应快速执行，否则阻塞所有线程。</li><li><strong>重置谨慎性</strong>
<code>reset()</code> 方法强制重置屏障，可能中断等待中的线程。</li></ul><hr><h3 id=-与-countdownlatch-的对比>⚖️ <strong>与 CountDownLatch 的对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>CyclicBarrier</strong></th><th><strong>CountDownLatch</strong></th></tr></thead><tbody><tr><td><strong>重用性</strong></td><td>✅ 自动重置，支持多轮同步</td><td>❌ 一次性使用</td></tr><tr><td><strong>等待方向</strong></td><td>子线程互相等待（对等协作）</td><td>主线程等待子线程（主从协作）</td></tr><tr><td><strong>计数器</strong></td><td>加法计数（<code>parties</code> 初始化，递减至0触发）</td><td>减法计数（初始化后递减，归零触发）</td></tr><tr><td><strong>回调支持</strong></td><td>✅ 支持 <code>barrierAction</code></td><td>❌ 无</td></tr><tr><td><strong>适用场景</strong></td><td>多阶段任务、循环同步</td><td>单次任务完成等待（如服务启动）</td></tr></tbody></table></div><blockquote><p><strong>示例区分</strong>：</p><ul><li><p>赛跑场景：</p><ul><li><code>CyclicBarrier</code> 同步起跑（所有选手就绪后同时开始）。</li></ul></li><li><p><code>CountDownLatch</code> 等待所有选手完赛（主线程统计结果）。</p></li></ul></blockquote><hr><h3 id=-总结-13>💎 <strong>总结</strong></h3><ul><li><strong>核心价值</strong>：
<code>CyclicBarrier</code> 通过 <strong>可重用屏障</strong> 和 <strong>多线程对等同步</strong> 机制，解决了分阶段任务协作问题，尤其适合迭代式并行计算。</li><li>选型建议：<ul><li>需循环同步 → <code>CyclicBarrier</code>；</li></ul></li><li>单次等待 → <code>CountDownLatch</code>；<ul><li>资源限流 → <code>Semaphore</code>。</li></ul></li><li><strong>性能注意</strong>：
高竞争场景下，基于锁的实现可能成为瓶颈，可考虑无锁方案（如 <code>Phaser</code>）。</li></ul><blockquote><p>通过合理使用 <code>CyclicBarrier</code>，可显著提升多线程协作的简洁性与健壮性，是构建高并发系统的核心同步工具之一。</p></blockquote></section><footer class=article-footer><section class=article-tags><a href=/tags/java/>Java</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Oct 22, 2025 16:26 CST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/nowcoderjava-2/><div class=article-details><h2 class=article-title>【NowCoder】JAVA 2</h2></div></a></article><article><a href=/p/nowcoderjava/><div class=article-details><h2 class=article-title>【NowCoder】JAVA</h2></div></a></article><article><a href=/p/templejava-c/><div class=article-details><h2 class=article-title>【Temple】Java & C</h2></div></a></article><article><a href=/p/javamodule/><div class=article-details><h2 class=article-title>【Java】Module</h2></div></a></article><article><a href=/p/javaexception/><div class=article-details><h2 class=article-title>【Java】Exception</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>