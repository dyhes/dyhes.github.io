<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Redis Cluster Redis Cluster 是 Redis 官方推出的分布式集群解决方案，旨在解决单机 Redis 的内存限制、性能瓶颈和单点故障问题。它通过数据分片（Sharding）、主从复制（Replication） 和自动故障转移（Failover） 实现高可用性与水平扩展。以下从核心架构、工作机制、特性及限制四个维度展开详解：\n🔍 核心架构设计 数据分片（Hash Slot 机制） 16384 个哈希槽：所有数据通过 CRC16(key) % 16384 计算槽位，分散到不同节点1,5,7。 槽位分配：每个主节点负责部分槽位（如节点 A 管理槽 0-5000），集群通过槽位映射表快速定位数据节点1,6。 动态迁移：扩容/缩容时，槽位可在线迁移（redis-cli --cluster reshard），过程中通过 ASK 重定向保证数据一致性2,6。 节点角色 主节点（Master）：处理读写请求，参与故障检测与槽位管理。 从节点（Slave）：异步复制主节点数据，主节点故障时通过选举升主（Raft 算法）1,5,6。 最小集群配置：3 主 + 3 从，确保半数以上节点可投票完成故障转移1,2。 去中心化通信（Gossip 协议） 节点间通过 TCP 通道定期交换状态（Ping/Pong 消息），端口号为服务端口 +10000（如 6379 → 16379）5,7。 消息类型： MEET：新节点加入集群； FAIL：节点故障广播； PING/PONG：心跳检测与元数据同步5,7。 ⚙️ 关键工作机制 客户端请求路由 智能重定向：客户端连接任意节点，若 Key 不属于当前节点，返回 MOVED 错误并携带正确节点地址，客户端自动重试1,6,7。 迁移中的请求处理：槽位迁移期间，源节点返回 ASK 重定向，客户端临时访问目标节点6,7。 故障转移（Failover） 故障检测：半数以上主节点标记某节点为 PFAIL（疑似下线）后，升级为 FAIL（已下线）5,6。 从节点选举：从节点发起投票（FAILOVER_AUTH_REQUEST），获多数主节点同意后升主，并接管原主槽位5,6。 数据一致性：异步复制可能导致故障期间少量数据丢失（非强一致性）2,6。 集群扩容/缩容 扩容： 添加新节点：redis-cli --cluster add-node； 迁移槽位：redis-cli --cluster reshard2,5。 缩容： 迁移待删节点的槽位； 删除节点：redis-cli --cluster del-node5。 ⚡️ 核心特性与优势 高可用性 主从切换在秒级完成（默认节点超时时间 15 秒），服务不间断1,6。 支持读负载均衡：客户端可配置从节点处理读请求（FAILOVER_DISTRIBUTE 策略）4。 水平扩展能力 理论支持 ≤1000 个节点，数据分布均匀时可线性提升吞吐量1,5。 性能接近单机 Redis，单节点 QPS 可达 10 万+3,4。 无中心架构 无代理层，客户端直连节点，降低延迟与复杂性1,7。 ⚠️ 限制与应对策略 功能限制 跨槽位操作：事务（MULTI）、Lua 脚本、MGET/MSET 等需所有 Key 位于同一槽位（可用 {hash_tag}强制路由，如 {user}:1）1,3,6。 仅支持 db0：无法使用 SELECT 切换数据库2,5。 数据一致性风险 异步复制导致主节点写入成功后，从节点可能未同步（故障时丢失数据）2,6。 应对方案：对强一致性场景，需业务层补偿（如异步队列重试）6。 运维复杂度 扩缩容需手动迁移槽位，可能引发性能波动2,5。 优化建议：启用槽位缓存（如 phpredis 的 redis.clusters.cache_slots=1），减少重定向4。 💎 典型应用场景 高并发读写：如电商秒杀系统，分散请求至多节点1,3。 海量数据存储：突破单机内存限制，支持 PB 级数据1,7。 会话共享：在 PHP 等环境中存储分布式会话（需配置压缩与超时）4。 💎 总结 Redis Cluster 通过 分片机制 解决单机瓶颈，以 去中心化架构 确保高可用性，是 Redis 大规模部署的核心方案。尽管存在跨节点操作限制和数据一致性风险，其线性扩展能力和毫秒级故障转移仍使其成为高并发、大数据场景的首选。 \u200b实践建议\u200b：\n"><title>【Redis】Cluster</title><link rel=canonical href=https://dyhes.github.io/p/rediscluster/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【Redis】Cluster"><meta property='og:description' content="Redis Cluster Redis Cluster 是 Redis 官方推出的分布式集群解决方案，旨在解决单机 Redis 的内存限制、性能瓶颈和单点故障问题。它通过数据分片（Sharding）、主从复制（Replication） 和自动故障转移（Failover） 实现高可用性与水平扩展。以下从核心架构、工作机制、特性及限制四个维度展开详解：\n🔍 核心架构设计 数据分片（Hash Slot 机制） 16384 个哈希槽：所有数据通过 CRC16(key) % 16384 计算槽位，分散到不同节点1,5,7。 槽位分配：每个主节点负责部分槽位（如节点 A 管理槽 0-5000），集群通过槽位映射表快速定位数据节点1,6。 动态迁移：扩容/缩容时，槽位可在线迁移（redis-cli --cluster reshard），过程中通过 ASK 重定向保证数据一致性2,6。 节点角色 主节点（Master）：处理读写请求，参与故障检测与槽位管理。 从节点（Slave）：异步复制主节点数据，主节点故障时通过选举升主（Raft 算法）1,5,6。 最小集群配置：3 主 + 3 从，确保半数以上节点可投票完成故障转移1,2。 去中心化通信（Gossip 协议） 节点间通过 TCP 通道定期交换状态（Ping/Pong 消息），端口号为服务端口 +10000（如 6379 → 16379）5,7。 消息类型： MEET：新节点加入集群； FAIL：节点故障广播； PING/PONG：心跳检测与元数据同步5,7。 ⚙️ 关键工作机制 客户端请求路由 智能重定向：客户端连接任意节点，若 Key 不属于当前节点，返回 MOVED 错误并携带正确节点地址，客户端自动重试1,6,7。 迁移中的请求处理：槽位迁移期间，源节点返回 ASK 重定向，客户端临时访问目标节点6,7。 故障转移（Failover） 故障检测：半数以上主节点标记某节点为 PFAIL（疑似下线）后，升级为 FAIL（已下线）5,6。 从节点选举：从节点发起投票（FAILOVER_AUTH_REQUEST），获多数主节点同意后升主，并接管原主槽位5,6。 数据一致性：异步复制可能导致故障期间少量数据丢失（非强一致性）2,6。 集群扩容/缩容 扩容： 添加新节点：redis-cli --cluster add-node； 迁移槽位：redis-cli --cluster reshard2,5。 缩容： 迁移待删节点的槽位； 删除节点：redis-cli --cluster del-node5。 ⚡️ 核心特性与优势 高可用性 主从切换在秒级完成（默认节点超时时间 15 秒），服务不间断1,6。 支持读负载均衡：客户端可配置从节点处理读请求（FAILOVER_DISTRIBUTE 策略）4。 水平扩展能力 理论支持 ≤1000 个节点，数据分布均匀时可线性提升吞吐量1,5。 性能接近单机 Redis，单节点 QPS 可达 10 万+3,4。 无中心架构 无代理层，客户端直连节点，降低延迟与复杂性1,7。 ⚠️ 限制与应对策略 功能限制 跨槽位操作：事务（MULTI）、Lua 脚本、MGET/MSET 等需所有 Key 位于同一槽位（可用 {hash_tag}强制路由，如 {user}:1）1,3,6。 仅支持 db0：无法使用 SELECT 切换数据库2,5。 数据一致性风险 异步复制导致主节点写入成功后，从节点可能未同步（故障时丢失数据）2,6。 应对方案：对强一致性场景，需业务层补偿（如异步队列重试）6。 运维复杂度 扩缩容需手动迁移槽位，可能引发性能波动2,5。 优化建议：启用槽位缓存（如 phpredis 的 redis.clusters.cache_slots=1），减少重定向4。 💎 典型应用场景 高并发读写：如电商秒杀系统，分散请求至多节点1,3。 海量数据存储：突破单机内存限制，支持 PB 级数据1,7。 会话共享：在 PHP 等环境中存储分布式会话（需配置压缩与超时）4。 💎 总结 Redis Cluster 通过 分片机制 解决单机瓶颈，以 去中心化架构 确保高可用性，是 Redis 大规模部署的核心方案。尽管存在跨节点操作限制和数据一致性风险，其线性扩展能力和毫秒级故障转移仍使其成为高并发、大数据场景的首选。 \u200b实践建议\u200b：\n"><meta property='og:url' content='https://dyhes.github.io/p/rediscluster/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Redis'><meta property='article:published_time' content='2025-07-03T00:00:00+00:00'><meta property='article:modified_time' content='2025-07-31T19:25:11+08:00'><meta name=twitter:title content="【Redis】Cluster"><meta name=twitter:description content="Redis Cluster Redis Cluster 是 Redis 官方推出的分布式集群解决方案，旨在解决单机 Redis 的内存限制、性能瓶颈和单点故障问题。它通过数据分片（Sharding）、主从复制（Replication） 和自动故障转移（Failover） 实现高可用性与水平扩展。以下从核心架构、工作机制、特性及限制四个维度展开详解：\n🔍 核心架构设计 数据分片（Hash Slot 机制） 16384 个哈希槽：所有数据通过 CRC16(key) % 16384 计算槽位，分散到不同节点1,5,7。 槽位分配：每个主节点负责部分槽位（如节点 A 管理槽 0-5000），集群通过槽位映射表快速定位数据节点1,6。 动态迁移：扩容/缩容时，槽位可在线迁移（redis-cli --cluster reshard），过程中通过 ASK 重定向保证数据一致性2,6。 节点角色 主节点（Master）：处理读写请求，参与故障检测与槽位管理。 从节点（Slave）：异步复制主节点数据，主节点故障时通过选举升主（Raft 算法）1,5,6。 最小集群配置：3 主 + 3 从，确保半数以上节点可投票完成故障转移1,2。 去中心化通信（Gossip 协议） 节点间通过 TCP 通道定期交换状态（Ping/Pong 消息），端口号为服务端口 +10000（如 6379 → 16379）5,7。 消息类型： MEET：新节点加入集群； FAIL：节点故障广播； PING/PONG：心跳检测与元数据同步5,7。 ⚙️ 关键工作机制 客户端请求路由 智能重定向：客户端连接任意节点，若 Key 不属于当前节点，返回 MOVED 错误并携带正确节点地址，客户端自动重试1,6,7。 迁移中的请求处理：槽位迁移期间，源节点返回 ASK 重定向，客户端临时访问目标节点6,7。 故障转移（Failover） 故障检测：半数以上主节点标记某节点为 PFAIL（疑似下线）后，升级为 FAIL（已下线）5,6。 从节点选举：从节点发起投票（FAILOVER_AUTH_REQUEST），获多数主节点同意后升主，并接管原主槽位5,6。 数据一致性：异步复制可能导致故障期间少量数据丢失（非强一致性）2,6。 集群扩容/缩容 扩容： 添加新节点：redis-cli --cluster add-node； 迁移槽位：redis-cli --cluster reshard2,5。 缩容： 迁移待删节点的槽位； 删除节点：redis-cli --cluster del-node5。 ⚡️ 核心特性与优势 高可用性 主从切换在秒级完成（默认节点超时时间 15 秒），服务不间断1,6。 支持读负载均衡：客户端可配置从节点处理读请求（FAILOVER_DISTRIBUTE 策略）4。 水平扩展能力 理论支持 ≤1000 个节点，数据分布均匀时可线性提升吞吐量1,5。 性能接近单机 Redis，单节点 QPS 可达 10 万+3,4。 无中心架构 无代理层，客户端直连节点，降低延迟与复杂性1,7。 ⚠️ 限制与应对策略 功能限制 跨槽位操作：事务（MULTI）、Lua 脚本、MGET/MSET 等需所有 Key 位于同一槽位（可用 {hash_tag}强制路由，如 {user}:1）1,3,6。 仅支持 db0：无法使用 SELECT 切换数据库2,5。 数据一致性风险 异步复制导致主节点写入成功后，从节点可能未同步（故障时丢失数据）2,6。 应对方案：对强一致性场景，需业务层补偿（如异步队列重试）6。 运维复杂度 扩缩容需手动迁移槽位，可能引发性能波动2,5。 优化建议：启用槽位缓存（如 phpredis 的 redis.clusters.cache_slots=1），减少重定向4。 💎 典型应用场景 高并发读写：如电商秒杀系统，分散请求至多节点1,3。 海量数据存储：突破单机内存限制，支持 PB 级数据1,7。 会话共享：在 PHP 等环境中存储分布式会话（需配置压缩与超时）4。 💎 总结 Redis Cluster 通过 分片机制 解决单机瓶颈，以 去中心化架构 确保高可用性，是 Redis 大规模部署的核心方案。尽管存在跨节点操作限制和数据一致性风险，其线性扩展能力和毫秒级故障转移仍使其成为高并发、大数据场景的首选。 \u200b实践建议\u200b：\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#redis-cluster>Redis Cluster</a><ol><li><a href=#-核心架构设计>🔍 核心架构设计</a></li><li><a href=#-关键工作机制>⚙️ 关键工作机制</a></li><li><a href=#-核心特性与优势>⚡️ 核心特性与优势</a></li><li><a href=#-限制与应对策略>⚠️ 限制与应对策略</a></li><li><a href=#-典型应用场景>💎 典型应用场景</a></li><li><a href=#-总结>💎 <strong>总结</strong></a></li></ol></li><li><a href=#异步复制>异步复制</a><ol><li><a href=#-异步复制的核心原理>🔧 异步复制的核心原理</a></li><li><a href=#-异步复制流程>⚙️ 异步复制流程</a><ol><li><a href=#全量复制初始化同步><strong>全量复制（初始化同步）</strong></a></li><li><a href=#增量复制命令传播><strong>增量复制（命令传播）</strong></a></li><li><a href=#心跳维持><strong>心跳维持</strong></a></li></ol></li><li><a href=#-异步复制的风险与挑战>⚠️ 异步复制的风险与挑战</a></li><li><a href=#-生产级优化方案>🛠️ 生产级优化方案</a><ol><li><a href=#减少全量复制><strong>减少全量复制</strong></a></li><li><a href=#增强一致性><strong>增强一致性</strong></a></li><li><a href=#高可用架构><strong>高可用架构</strong></a></li><li><a href=#关键参数配置参考><strong>关键参数配置参考</strong></a></li></ol></li><li><a href=#-总结-1>💎 总结</a></li></ol></li><li><a href=#哈希槽>哈希槽</a><ol><li><a href=#-哈希槽机制与数据定位>🔍 哈希槽机制与数据定位</a></li><li><a href=#-客户端请求路由与重定向>⚙️ 客户端请求路由与重定向</a></li><li><a href=#-负载均衡实现方式>⚖️ 负载均衡实现方式</a></li><li><a href=#-客户端库的优化实践>🛠️ 客户端库的优化实践</a></li><li><a href=#-总结-2>💎 总结</a></li></ol></li><li><a href=#哈希槽--一致性哈希>哈希槽 & 一致性哈希</a><ol><li><a href=#-核心区别总结>🔍 <strong>核心区别总结</strong></a></li><li><a href=#-关键差异详解>⚙️ <strong>关键差异详解</strong></a></li><li><a href=#-设计哲学对比>🏗️ <strong>设计哲学对比</strong></a></li><li><a href=#-适用场景建议>⚠️ <strong>适用场景建议</strong></a></li><li><a href=#-总结-3>💎 <strong>总结</strong></a></li></ol></li><li><a href=#crc16>CRC16</a><ol><li><a href=#-crc16的本质哈希算法的子类>🔍 CRC16的本质：哈希算法的子类</a></li><li><a href=#-crc16与加密哈希算法的关键区别>⚠️ CRC16与加密哈希算法的关键区别</a><ol><li><a href=#具体差异分析>具体差异分析：</a></li></ol></li><li><a href=#-crc16的核心应用场景>⚙️ CRC16的核心应用场景</a></li><li><a href=#-总结crc16的定位>💎 总结：CRC16的定位</a></li></ol></li><li><a href=#槽数>槽数</a><ol><li><a href=#-心跳包大小优化核心因素>⚙️ <strong>心跳包大小优化（核心因素）</strong></a></li><li><a href=#-集群规模限制1000节点原则>📏 <strong>集群规模限制（1000节点原则）</strong></a></li><li><a href=#-数据压缩效率>📦 <strong>数据压缩效率</strong></a></li><li><a href=#-工程实践权衡>⚖️ <strong>工程实践权衡</strong></a></li><li><a href=#-总结16384-的合理性>💎 <strong>总结：16384 的合理性</strong></a></li></ol></li><li><a href=#redisson>redisson</a><ol><li><a href=#-redisson-与-redisredis-cluster-的关系>🔍 Redisson 与 Redis/Redis Cluster 的关系</a></li><li><a href=#-redisson-如何适配不同模式>⚙️ Redisson 如何适配不同模式</a><ol><li><a href=#单节点-redis-的适配><strong>单节点 Redis 的适配</strong></a></li><li><a href=#redis-cluster-的适配><strong>Redis Cluster 的适配</strong></a></li></ol></li><li><a href=#-关键功能在不同模式下的行为对比>📊 关键功能在不同模式下的行为对比</a></li><li><a href=#-使用注意事项>⚠️ 使用注意事项</a></li><li><a href=#-总结-4>💎 总结</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/nutrition/ style=background-color:#93b5cf;color:>积雪粮
</a><a href=/categories/willow/ style=background-color:#dc9123;color:>满城风絮</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/rediscluster/>【Redis】Cluster</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jul 03, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>5 minute read</time></div></footer></div></header><section class=article-content><h2 id=redis-cluster>Redis Cluster</h2><p>Redis Cluster 是 Redis 官方推出的分布式集群解决方案，旨在解决单机 Redis 的内存限制、性能瓶颈和单点故障问题。它通过<strong>数据分片（Sharding）</strong>、<strong>主从复制（Replication）</strong> 和<strong>自动故障转移（Failover）</strong> 实现高可用性与水平扩展。以下从核心架构、工作机制、特性及限制四个维度展开详解：</p><hr><h3 id=-核心架构设计>🔍 核心架构设计</h3><ol><li><strong>数据分片（Hash Slot 机制）</strong><ul><li><strong>16384 个哈希槽</strong>：所有数据通过 <code>CRC16(key) % 16384</code> 计算槽位，分散到不同节点<a class=link href=@ref>1,5,7</a>。</li><li><strong>槽位分配</strong>：每个主节点负责部分槽位（如节点 A 管理槽 0-5000），集群通过槽位映射表快速定位数据节点<a class=link href=@ref>1,6</a>。</li><li><strong>动态迁移</strong>：扩容/缩容时，槽位可在线迁移（<code>redis-cli --cluster reshard</code>），过程中通过 <code>ASK</code> 重定向保证数据一致性<a class=link href=@ref>2,6</a>。</li></ul></li><li><strong>节点角色</strong><ul><li><strong>主节点（Master）</strong>：处理读写请求，参与故障检测与槽位管理。</li><li><strong>从节点（Slave）</strong>：异步复制主节点数据，主节点故障时通过选举升主（Raft 算法）<a class=link href=@ref>1,5,6</a>。</li><li><strong>最小集群配置</strong>：3 主 + 3 从，确保半数以上节点可投票完成故障转移<a class=link href=@ref>1,2</a>。</li></ul></li><li><strong>去中心化通信（Gossip 协议）</strong><ul><li>节点间通过 TCP 通道定期交换状态（Ping/Pong 消息），端口号为服务端口 +10000（如 6379 → 16379）<a class=link href=@ref>5,7</a>。</li><li>消息类型：<ul><li><code>MEET</code>：新节点加入集群；</li><li><code>FAIL</code>：节点故障广播；</li><li><code>PING/PONG</code>：心跳检测与元数据同步<a class=link href=@ref>5,7</a>。</li></ul></li></ul></li></ol><hr><h3 id=-关键工作机制>⚙️ 关键工作机制</h3><ol><li><strong>客户端请求路由</strong><ul><li><strong>智能重定向</strong>：客户端连接任意节点，若 Key 不属于当前节点，返回 <code>MOVED</code> 错误并携带正确节点地址，客户端自动重试<a class=link href=@ref>1,6,7</a>。</li><li><strong>迁移中的请求处理</strong>：槽位迁移期间，源节点返回 <code>ASK</code> 重定向，客户端临时访问目标节点<a class=link href=@ref>6,7</a>。</li></ul></li><li><strong>故障转移（Failover）</strong><ul><li><strong>故障检测</strong>：半数以上主节点标记某节点为 <code>PFAIL</code>（疑似下线）后，升级为 <code>FAIL</code>（已下线）<a class=link href=@ref>5,6</a>。</li><li><strong>从节点选举</strong>：从节点发起投票（<code>FAILOVER_AUTH_REQUEST</code>），获多数主节点同意后升主，并接管原主槽位<a class=link href=@ref>5,6</a>。</li><li><strong>数据一致性</strong>：异步复制可能导致故障期间少量数据丢失（非强一致性）<a class=link href=@ref>2,6</a>。</li></ul></li><li><strong>集群扩容/缩容</strong><ul><li>扩容：<ol><li>添加新节点：<code>redis-cli --cluster add-node</code>；</li></ol></li></ul></li><li>迁移槽位：<code>redis-cli --cluster reshard</code><a class=link href=@ref>2,5</a>。</li></ol><ul><li>缩容：<ol><li>迁移待删节点的槽位；</li></ol></li></ul><ol start=2><li>删除节点：<code>redis-cli --cluster del-node</code><a class=link href=@ref>5</a>。</li></ol><hr><h3 id=-核心特性与优势>⚡️ 核心特性与优势</h3><ol><li><strong>高可用性</strong><ul><li>主从切换在秒级完成（默认节点超时时间 15 秒），服务不间断<a class=link href=@ref>1,6</a>。</li><li>支持<strong>读负载均衡</strong>：客户端可配置从节点处理读请求（<code>FAILOVER_DISTRIBUTE</code> 策略）<a class=link href=@ref>4</a>。</li></ul></li><li><strong>水平扩展能力</strong><ul><li>理论支持 ≤1000 个节点，数据分布均匀时可线性提升吞吐量<a class=link href=@ref>1,5</a>。</li><li>性能接近单机 Redis，单节点 QPS 可达 10 万+<a class=link href=@ref>3,4</a>。</li></ul></li><li><strong>无中心架构</strong><ul><li>无代理层，客户端直连节点，降低延迟与复杂性<a class=link href=@ref>1,7</a>。</li></ul></li></ol><hr><h3 id=-限制与应对策略>⚠️ 限制与应对策略</h3><ol><li><strong>功能限制</strong><ul><li><strong>跨槽位操作</strong>：事务（MULTI）、Lua 脚本、<code>MGET/MSET</code> 等需所有 Key 位于同一槽位（可用 <code>{hash_tag}</code>强制路由，如 <code>{user}:1</code>）<a class=link href=@ref>1,3,6</a>。</li><li><strong>仅支持 db0</strong>：无法使用 <code>SELECT</code> 切换数据库<a class=link href=@ref>2,5</a>。</li></ul></li><li><strong>数据一致性风险</strong><ul><li>异步复制导致主节点写入成功后，从节点可能未同步（故障时丢失数据）<a class=link href=@ref>2,6</a>。</li><li><strong>应对方案</strong>：对强一致性场景，需业务层补偿（如异步队列重试）<a class=link href=@ref>6</a>。</li></ul></li><li><strong>运维复杂度</strong><ul><li>扩缩容需手动迁移槽位，可能引发性能波动<a class=link href=@ref>2,5</a>。</li><li><strong>优化建议</strong>：启用槽位缓存（如 phpredis 的 <code>redis.clusters.cache_slots=1</code>），减少重定向<a class=link href=@ref>4</a>。</li></ul></li></ol><hr><h3 id=-典型应用场景>💎 典型应用场景</h3><ul><li><strong>高并发读写</strong>：如电商秒杀系统，分散请求至多节点<a class=link href=@ref>1,3</a>。</li><li><strong>海量数据存储</strong>：突破单机内存限制，支持 PB 级数据<a class=link href=@ref>1,7</a>。</li><li><strong>会话共享</strong>：在 PHP 等环境中存储分布式会话（需配置压缩与超时）<a class=link href=@ref>4</a>。</li></ul><hr><h3 id=-总结>💎 <strong>总结</strong></h3><p>Redis Cluster 通过 <strong>分片机制</strong> 解决单机瓶颈，以 <strong>去中心化架构</strong> 确保高可用性，是 Redis 大规模部署的核心方案。尽管存在跨节点操作限制和数据一致性风险，其线性扩展能力和毫秒级故障转移仍使其成为高并发、大数据场景的首选。
​<strong>实践建议</strong>​：</p><ul><li>✅ 生产环境采用 6 节点（3 主 3 从）起步；</li><li>⚠️ 避免热点 Key 与跨槽事务；</li><li>🔧 使用客户端优化（如 Jedis/phpredis 的槽位缓存）提升性能<a class=link href=@ref>1,4,7</a>。</li></ul><h2 id=异步复制>异步复制</h2><p>Redis主从节点的异步数据复制是其高可用架构的核心机制，通过<strong>非阻塞式数据同步</strong>在保证主节点高性能的同时实现数据冗余。以下从核心原理、流程、问题及优化四个维度展开详解：</p><hr><h3 id=-异步复制的核心原理>🔧 异步复制的核心原理</h3><ol><li><strong>非阻塞设计</strong><ul><li>主节点处理写命令后立即响应客户端，<strong>异步</strong>将数据同步到从节点，避免因等待从节点确认而阻塞主节点性能<a class=link href=@ref>1,3</a>。</li><li><strong>数据流向</strong>：主节点 → 复制缓冲区 → 从节点（单向流动，不可反向）<a class=link href=@ref>3,6</a>。</li></ul></li><li><strong>关键数据结构</strong><ul><li><strong>Replication Buffer</strong>：主节点为每个从节点独立分配的缓冲区，临时存储待同步的写命令。若从节点处理慢或网络延迟，缓冲区积压可能导致主节点内存压力<a class=link href=@ref>8</a>。</li><li><strong>Repl-Backlog Buffer</strong>：全局环形缓冲区（默认1MB），存储最近写命令。用于网络闪断后的增量同步，避免全量复制<a class=link href=@ref>4,8</a>。
<em>示例</em>：若从节点断开后重连，主节点检查其复制偏移量（offset）是否在积压缓冲区范围内，是则发送缺失数据，否则触发全量同步<a class=link href=@ref>8</a>。</li></ul></li></ol><hr><h3 id=-异步复制流程>⚙️ 异步复制流程</h3><h4 id=全量复制初始化同步><strong>全量复制（初始化同步）</strong></h4><ul><li><strong>触发场景</strong>：从节点首次连接主节点，或复制偏移量不连续（如网络中断过久导致积压缓冲区数据被覆盖）<a class=link href=@ref>6,8</a>。</li><li>步骤：<ol><li>从节点发送<code>PSYNC ? -1</code>命令请求同步<a class=link href=@ref>8</a>。</li><li>主节点执行<code>BGSAVE</code>生成RDB快照，同时缓存新写命令至<strong>Replication Buffer</strong><a class=link href=@ref>1,6</a>。</li><li>RDB文件传输至从节点，从节点清空旧数据并加载RDB。</li><li>主节点发送积压的写命令，使从节点数据与主节点一致<a class=link href=@ref>4,9</a>。</li></ol></li></ul><h4 id=增量复制命令传播><strong>增量复制（命令传播）</strong></h4><ul><li><strong>持续同步</strong>：全量复制完成后，主节点将新写命令实时推送至从节点<a class=link href=@ref>6</a>。</li><li>断点续传：<ul><li>网络中断期间，主节点写命令存入<strong>Repl-Backlog Buffer</strong>（环形队列）<a class=link href=@ref>8</a>。</li><li>网络恢复后，从节点发送<code>PSYNC &lt;runid> &lt;offset></code>，主节点校验偏移量有效性后发送缺失数据<a class=link href=@ref>4,8</a>。</li></ul></li></ul><h4 id=心跳维持><strong>心跳维持</strong></h4><ul><li>从节点每秒发送<code>REPLCONF ACK &lt;offset></code>报告自身复制偏移量<a class=link href=@ref>7</a>。</li><li>主节点通过偏移量监控从节点延迟，超时（默认60秒）则断开连接<a class=link href=@ref>6</a>。</li></ul><hr><h3 id=-异步复制的风险与挑战>⚠️ 异步复制的风险与挑战</h3><ol><li><strong>数据不一致风险</strong><ul><li><strong>延迟问题</strong>：主节点写入成功后，从节点可能未同步即宕机，导致数据丢失（尤其短时间高并发写入）<a class=link href=@ref>1,3</a>。</li><li><strong>监控手段</strong>：通过<code>INFO replication</code>查看<code>master_repl_offset</code>与<code>slave_repl_offset</code>差值，延迟超过阈值需告警<a class=link href=@ref>1</a>。</li></ul></li><li><strong>脑裂问题（Split-Brain）</strong><ul><li><strong>场景</strong>：网络分区时，原主节点和提升的新主节点同时写入，恢复后数据冲突<a class=link href=@ref>1,5</a>。</li><li>规避方案：<ul><li>配置<code>min-slaves-to-write 1</code>和<code>min-slaves-max-lag 10</code>，要求至少1个从节点延迟≤10秒，否则主节点拒绝写入<a class=link href=@ref>1,5</a>。</li></ul></li></ul></li><li><strong>资源消耗</strong><ul><li><strong>内存压力</strong>：全量复制时<code>BGSAVE</code>的<code>fork</code>操作可能阻塞主线程（尤其内存过大时）<a class=link href=@ref>1</a>。</li><li><strong>网络带宽</strong>：RDB文件传输占用带宽，影响其他服务（建议低峰期扩容）<a class=link href=@ref>6</a>。</li></ul></li></ol><hr><h3 id=-生产级优化方案>🛠️ 生产级优化方案</h3><h4 id=减少全量复制><strong>减少全量复制</strong></h4><ul><li><strong>增大积压缓冲区</strong>：调整<code>repl-backlog-size</code>（建议512MB以上），避免网络抖动触发全量复制<a class=link href=@ref>6,8</a>。</li><li><strong>无盘复制</strong>：Redis 6.0+支持<code>repl-diskless-sync yes</code>，主节点直接通过Socket发送RDB，避免磁盘IO<a class=link href=@ref>6</a>。</li></ul><h4 id=增强一致性><strong>增强一致性</strong></h4><ul><li><strong>WAIT命令</strong>：强制等待N个从节点同步完成（如<code>WAIT 2 5000</code>等待2个从节点或超时5秒），但牺牲性能换取强一致性<a class=link href=@ref>1,3</a>。</li><li>从节点配置：<pre tabindex=0><code>replica-serve-stale-data no  # 同步中断时拒绝读请求，避免脏数据[1](@ref)
</code></pre></li></ul><h4 id=高可用架构><strong>高可用架构</strong></h4><ul><li><strong>哨兵模式</strong>：自动监控主节点状态并故障转移，需部署奇数个Sentinel节点<a class=link href=@ref>5</a>。</li><li><strong>集群模式</strong>：数据分片到多主节点，每个主节点配从节点，规避单点故障<a class=link href=@ref>5</a>。</li></ul><h4 id=关键参数配置参考><strong>关键参数配置参考</strong></h4><div class=table-wrapper><table><thead><tr><th><strong>参数</strong></th><th><strong>推荐值</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>repl-backlog-size</code></td><td>512mb</td><td>扩大积压缓冲区，支持更长中断恢复</td></tr><tr><td><code>repl-timeout</code></td><td>60</td><td>复制超时时间（秒）</td></tr><tr><td><code>min-slaves-to-write</code></td><td>1</td><td>至少需同步的从节点数</td></tr><tr><td><code>min-slaves-max-lag</code></td><td>10</td><td>从节点最大延迟（秒）</td></tr></tbody></table></div><hr><h3 id=-总结-1>💎 总结</h3><p>Redis异步复制通过<strong>非阻塞设计</strong>平衡性能与数据冗余，但需警惕数据延迟和脑裂风险。<strong>生产建议</strong>：</p><ul><li>✅ <strong>监控延迟</strong>：定期检查<code>INFO replication</code>的偏移量差值<a class=link href=@ref>1</a>；</li><li>✅ <strong>优化配置</strong>：增大<code>repl-backlog-size</code>、启用无盘复制<a class=link href=@ref>6,8</a>；</li><li>✅ <strong>容灾设计</strong>：结合哨兵/集群模式，并通过<code>min-slaves-*</code>限制写入条件<a class=link href=@ref>1,5</a>。</li></ul><blockquote><p>异步复制是Redis高性能的基石，理解其机制与局限，方能构建稳定可靠的分布式缓存系统。</p></blockquote><h2 id=哈希槽>哈希槽</h2><p>Redis Cluster 中客户端实现负载均衡和数据定位的核心机制是<strong>哈希槽（Hash Slot）分配</strong>与<strong>智能重定向</strong>。以下是详细流程及原理：</p><hr><h3 id=-哈希槽机制与数据定位>🔍 哈希槽机制与数据定位</h3><ol><li><strong>哈希槽分配</strong><ul><li>Redis Cluster 将数据划分为 <strong>16384 个固定槽位</strong>（Slots），每个主节点负责一部分槽位（如节点 A 管理 0-5000，节点 B 管理 5001-10000）<a class=link href=@ref>1,3,6</a>。</li><li><strong>键值映射规则</strong>：客户端对 Key 执行 <code>CRC16(key) % 16384</code> 计算槽位号，例如 <code>user:123</code> 的 CRC16 值为 9876，则归属槽位 9876<a class=link href=@ref>3,6</a>。</li></ul></li><li><strong>客户端槽位缓存</strong><ul><li>客户端首次连接集群时，随机选择一个节点获取<strong>槽位映射表</strong>（Slot-Node Mapping），记录每个槽位对应的节点 IP 和端口<a class=link href=@ref>6,8</a>。</li><li>后续请求直接根据本地映射表路由到目标节点，避免重复查询<a class=link href=@ref>6</a>。</li></ul></li></ol><hr><h3 id=-客户端请求路由与重定向>⚙️ 客户端请求路由与重定向</h3><ol><li><strong>正常路由流程</strong><ul><li>客户端计算 Key 的槽位号，查询本地映射表，直接发送请求至负责该槽位的节点<a class=link href=@ref>6</a>。</li><li><strong>示例</strong>：若槽位 5001 由节点 B 管理，请求 <code>SET order:100 "data"</code> 会直接发送至节点 B<a class=link href=@ref>3</a>。</li></ul></li><li><strong>重定向机制</strong><ul><li><strong>MOVED 重定向</strong>：若请求发送到错误节点（如槽位 5001 的请求发到节点 A），节点 A 返回 <code>MOVED 5001 192.168.1.2:7001</code>，客户端更新本地映射表并重试<a class=link href=@ref>3,6</a>。</li><li><strong>ASK 重定向</strong>：在数据迁移过程中，若槽位正在从节点 A 迁移到节点 B：<ul><li>节点 A 若仍存有数据，则直接响应。</li><li>若数据已迁移，返回 <code>ASK 5001 192.168.1.3:7002</code>，客户端向节点 B 发送 <code>ASKING</code> 命令后重新执行原请求<a class=link href=@ref>6,8</a>。</li></ul></li></ul></li></ol><hr><h3 id=-负载均衡实现方式>⚖️ 负载均衡实现方式</h3><ol><li><strong>数据分片均衡</strong><ul><li>集群启动时槽位<strong>平均分配</strong>到主节点（如 3 节点时各占 5461 个槽位）<a class=link href=@ref>3,8</a>。</li><li><strong>动态再平衡</strong>：新增节点时，集群自动从其他节点迁移部分槽位到新节点；节点下线时，其槽位重新分配给存活节点<a class=link href=@ref>1,6</a>。</li></ul></li><li><strong>请求分散</strong><ul><li>客户端通过<strong>本地槽位映射表</strong>将请求均匀分发到不同主节点，避免单点压力<a class=link href=@ref>6,8</a>。</li><li>读写操作均在主节点完成，从节点仅作备份（故障时提升为主节点）<a class=link href=@ref>3,4</a>。</li></ul></li><li><strong>客户端库优化</strong><ul><li>如 Jedis Cluster、Lettuce 等库<strong>自动维护槽位映射表</strong>，处理重定向逻辑，对业务透明<a class=link href=@ref>5,6</a>。</li><li>支持连接池复用和故障节点自动排除，减少网络开销<a class=link href=@ref>5</a>。</li></ul></li></ol><hr><h3 id=-客户端库的优化实践>🛠️ 客户端库的优化实践</h3><ol><li><strong>启动初始化</strong><ul><li>客户端连接集群时，通过 <code>CLUSTER SLOTS</code> 命令获取全量槽位映射，并缓存节点连接池<a class=link href=@ref>6,8</a>。</li></ul></li><li><strong>重定向处理优化</strong><ul><li>对 <code>MOVED</code> 响应更新本地映射表；对 <code>ASK</code> 响应仅临时跳转，不更新缓存<a class=link href=@ref>6</a>。</li><li>限制重试次数，避免网络环路<a class=link href=@ref>5</a>。</li></ul></li><li><strong>容错与高可用</strong><ul><li>节点故障时，客户端收到 <code>ConnectionError</code> 后随机选择其他节点重试，并由新节点通过 <code>MOVED</code> 响应纠正路由<a class=link href=@ref>6</a>。</li><li>集群主从切换期间，客户端自动切换到新主节点<a class=link href=@ref>3,4</a>。</li></ul></li></ol><hr><h3 id=-总结-2>💎 总结</h3><p>Redis Cluster 的负载均衡和数据定位依赖 <strong>16384 哈希槽</strong>的精细分片和客户端<strong>智能路由机制</strong>：</p><ul><li>✅ <strong>定位效率</strong>：通过槽位计算和本地缓存实现快速定位。</li><li>✅ <strong>负载均衡</strong>：数据均匀分布 + 动态迁移 + 客户端直连分发请求。</li><li>✅ <strong>容错性</strong>：<code>MOVED</code>/<code>ASK</code> 重定向保障请求可达性。</li><li>✅ <strong>客户端优化</strong>：主流库（如 Jedis Cluster）封装复杂性，开发者无需关注底层细节。</li></ul><blockquote><p><strong>生产建议</strong>：使用支持 Cluster 的客户端库（如 Lettuce），并配置合理的连接池大小；避免跨槽位操作（如多 Key 事务），以规避性能损耗<a class=link href=@ref>5,6</a>。</p></blockquote><h2 id=哈希槽--一致性哈希>哈希槽 & 一致性哈希</h2><p>哈希槽（Hash Slot）和一致性哈希（Consistent Hashing）是两种不同的分布式数据分片算法，它们在设计目标、实现机制和适用场景上存在显著差异。以下是核心对比：</p><hr><h3 id=-核心区别总结>🔍 <strong>核心区别总结</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>维度</strong></th><th><strong>哈希槽（Hash Slot）</strong></th><th><strong>一致性哈希（Consistent Hashing）</strong></th></tr></thead><tbody><tr><td><strong>数据结构</strong></td><td>固定 16384 个槽位（Redis Cluster）<a class=link href=@ref>1,7</a></td><td>虚拟环状结构（范围 0~2³²-1）<a class=link href=@ref>9,10</a></td></tr><tr><td><strong>数据定位逻辑</strong></td><td>键 → CRC16取模 → 槽位 → 节点<a class=link href=@ref>7,8</a></td><td>键哈希 → 环上位置 → 顺时针首个节点<a class=link href=@ref>9,10</a></td></tr><tr><td><strong>动态扩缩容</strong></td><td>需手动迁移整槽数据（如 <code>CLUSTER ADDSLOTS</code>）<a class=link href=@ref>2,4</a></td><td>自动迁移相邻数据，影响局部<a class=link href=@ref>3,9</a></td></tr><tr><td><strong>负载均衡</strong></td><td>强制槽位均匀分配，天然均衡<a class=link href=@ref>1,4</a></td><td>依赖虚拟节点优化，否则易倾斜<a class=link href=@ref>2,10</a></td></tr><tr><td><strong>实现复杂度</strong></td><td>简单（槽位映射表+固定计算）<a class=link href=@ref>4,8</a></td><td>复杂（需维护环+虚拟节点映射）<a class=link href=@ref>2,9</a></td></tr><tr><td><strong>典型应用</strong></td><td>Redis Cluster、强一致性数据库<a class=link href=@ref>8,7</a></td><td>Memcached、Cassandra、CDN<a class=link href=@ref>9,10</a></td></tr></tbody></table></div><hr><h3 id=-关键差异详解>⚙️ <strong>关键差异详解</strong></h3><ol><li><strong>数据分布机制</strong><ul><li>哈希槽：<ul><li>数据通过 <code>CRC16(key) % 16384</code> 映射到固定槽位，槽位与节点绑定<a class=link href=@ref>7,8</a>。</li><li><strong>优势</strong>：槽位分配可控（如高性能节点分配更多槽位），避免数据倾斜<a class=link href=@ref>4,5</a>。</li></ul></li><li>一致性哈希：<ul><li>数据哈希后定位到环上，由顺时针方向的第一个节点管理<a class=link href=@ref>9,10</a>。</li></ul></li><li><strong>问题</strong>：节点较少时易倾斜，需虚拟节点（如1物理节点=1000虚拟节点）分散数据<a class=link href=@ref>3,9</a>。</li></ul></li><li><strong>动态扩缩容效率</strong></li></ol><ul><li>哈希槽：<ul><li>扩容时需迁移整槽数据（如从节点A迁移1000个槽到节点B），迁移粒度大但操作集中<a class=link href=@ref>2,4</a>。<ul><li><strong>代价</strong>：迁移期间网络带宽压力大，但数据路由不变（客户端缓存槽位映射）<a class=link href=@ref>4,8</a>。</li></ul></li><li>一致性哈希：<ul><li>增减节点时仅影响相邻数据（约 1/N 数据迁移，N为节点数）<a class=link href=@ref>9,10</a>。</li></ul></li><li><strong>代价</strong>：需重新计算虚拟节点分布，可能引发临时缓存穿透<a class=link href=@ref>4,10</a>。</li></ul></li></ul><ol start=3><li><strong>元数据管理开销</strong><ul><li>哈希槽：<ul><li>槽位分配信息仅需 2KB（16384槽用bitmap压缩）<a class=link href=@ref>4,5</a>。</li><li>适合大规模集群（如1000节点），心跳包轻量<a class=link href=@ref>5,8</a>。</li></ul></li><li>一致性哈希：<ul><li>虚拟节点元数据庞大（1000节点×1000虚拟节点=百万级条目），心跳包可达8KB<a class=link href=@ref>4,9</a>。</li></ul></li></ul></li></ol><hr><h3 id=-设计哲学对比>🏗️ <strong>设计哲学对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th>哈希槽</th><th>一致性哈希</th></tr></thead><tbody><tr><td><strong>核心目标</strong></td><td>强数据一致性 + 集群管理便捷<a class=link href=@ref>8</a></td><td>高动态扩展性 + 最小化数据迁移<a class=link href=@ref>9</a></td></tr><tr><td><strong>数据控制</strong></td><td>支持手动分配槽位（如按硬件性能调整）<a class=link href=@ref>5</a></td><td>依赖哈希函数分布，人工干预难<a class=link href=@ref>10</a></td></tr><tr><td><strong>故障恢复</strong></td><td>槽位整体切换（主宕机时从节点接管槽位）<a class=link href=@ref>7</a></td><td>数据自动迁移到相邻节点，但可能引发连锁故障<a class=link href=@ref>10</a></td></tr></tbody></table></div><hr><h3 id=-适用场景建议>⚠️ <strong>适用场景建议</strong></h3><ul><li><strong>选择哈希槽</strong>的场景：
✅ ​<strong>Redis Cluster</strong>​：需强一致性、事务支持（尽管有限）及运维简化<a class=link href=@ref>7,8</a>。
✅ ​<strong>金融交易系统</strong>​：要求毫秒级定位，避免环查找延迟<a class=link href=@ref>4</a>。
✅ ​<strong>中小规模集群</strong>​：节点数≤1000，避免元数据膨胀<a class=link href=@ref>5,8</a>。</li><li><strong>选择一致性哈希</strong>的场景：
✅ ​<strong>分布式缓存</strong>​（如Memcached）：节点频繁变动，需最小化迁移成本<a class=link href=@ref>9,10</a>。
✅ ​<strong>超大规模系统</strong>​：节点数＞1000，灵活性优于管理成本<a class=link href=@ref>2,4</a>。
✅ ​<strong>CDN负载均衡</strong>​：请求按地理位置路由，动态调整节点<a class=link href=@ref>10</a>。</li></ul><hr><h3 id=-总结-3>💎 <strong>总结</strong></h3><ul><li><strong>哈希槽</strong>是 <strong>空间分区策略</strong>，以固定槽位为中介解耦数据与节点，适合需强管控的场景<a class=link href=@ref>4,8</a>。</li><li><strong>一致性哈希</strong>是 <strong>拓扑路由算法</strong>，通过环形虚拟空间实现动态伸缩，适合高流动性场景<a class=link href=@ref>9,10</a>。</li></ul><blockquote><p>二者本质是 <strong>分治思想</strong> 的不同实践：哈希槽以“分槽治之”优先管理效率，一致性哈希以“动态寻址”优先弹性，无绝对优劣，只有适用与否<a class=link href=@ref>2,4</a>。</p></blockquote><h2 id=crc16>CRC16</h2><p>CRC16是一种<strong>校验算法</strong>，属于<strong>哈希算法（Hash Algorithm）的范畴</strong>，但其设计目标和技术特性与<strong>加密级哈希算法</strong>（如SHA-256、MD5）存在显著差异。以下是详细分析：</p><hr><h3 id=-crc16的本质哈希算法的子类>🔍 CRC16的本质：哈希算法的子类</h3><ol><li><strong>哈希算法的核心特征</strong><ul><li><strong>固定长度输出</strong>：将任意长度输入映射为固定长度的散列值（如CRC16输出16位）<a class=link href=@ref>8,10</a>。</li><li><strong>确定性</strong>：相同输入始终产生相同输出<a class=link href=@ref>9</a>。</li><li><strong>高效性</strong>：计算速度快，适合实时处理<a class=link href=@ref>6,9</a>。
CRC16完全满足上述特征，因此属于哈希算法的一种<a class=link href=@ref>1,6</a>。</li></ul></li><li><strong>CRC16的哈希属性</strong><ul><li><strong>生成数据摘要</strong>：通过多项式除法生成16位校验码，作为数据的“指纹”<a class=link href=@ref>4,5</a>。</li><li><strong>雪崩效应</strong>：输入数据的微小变化（如1比特翻转）会导致输出校验码大幅变化<a class=link href=@ref>10,6</a>。</li></ul></li></ol><hr><h3 id=-crc16与加密哈希算法的关键区别>⚠️ CRC16与加密哈希算法的关键区别</h3><p>尽管CRC16是哈希算法，但<strong>不具备加密级安全性</strong>，主要差异如下：</p><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>CRC16</strong></th><th><strong>加密哈希（如SHA-256）</strong></th></tr></thead><tbody><tr><td><strong>设计目标</strong></td><td>错误检测（数据完整性）</td><td>数据安全（防篡改、抗碰撞）</td></tr><tr><td><strong>碰撞风险</strong></td><td>较高，可能被故意构造碰撞<a class=link href=@ref>10</a></td><td>极低（强抗碰撞性）<a class=link href=@ref>9</a></td></tr><tr><td><strong>不可逆性</strong></td><td>弱（可被逆向工程破解）<a class=link href=@ref>6</a></td><td>强（无法从哈希值还原输入）<a class=link href=@ref>8</a></td></tr><tr><td><strong>安全场景适用</strong></td><td>❌ 不适用于密码存储、数字签名</td><td>✅ 专为安全场景设计</td></tr></tbody></table></div><h4 id=具体差异分析>具体差异分析：</h4><ol><li><strong>抗碰撞性不足</strong>
CRC16的16位输出仅支持65,536种组合，碰撞概率远高于SHA-256（2²⁵⁶种组合）<a class=link href=@ref>9</a>。攻击者可轻易找到不同数据生成相同CRC16值，无法用于防伪造<a class=link href=@ref>10</a>。</li><li><strong>无加密特性</strong><ul><li><strong>非单向性</strong>：CRC16可通过数学推导或查表反向逼近原始数据<a class=link href=@ref>6</a>，而加密哈希是单向函数<a class=link href=@ref>8</a>。</li><li><strong>无盐值支持</strong>：CRC16计算无需盐值（Salt），无法抵御彩虹表攻击<a class=link href=@ref>9</a>。</li></ul></li></ol><hr><h3 id=-crc16的核心应用场景>⚙️ CRC16的核心应用场景</h3><p>CRC16的定位是<strong>高效检错</strong>，而非加密，主要应用于：</p><ol><li><strong>通信协议校验</strong><ul><li>串口通信（如Modbus）、以太网帧校验，检测传输中的比特错误<a class=link href=@ref>4,7</a>。</li><li>例如Modbus RTU使用CRC16-IBM（多项式0x8005）验证数据帧完整性<a class=link href=@ref>7</a>。</li></ul></li><li><strong>存储介质校验</strong><ul><li>SD卡、Flash存储器用CRC16确保读写数据无物理损坏<a class=link href=@ref>5,7</a>。</li></ul></li><li><strong>嵌入式系统优化</strong><ul><li>硬件加速实现（如STM32的CRC外设），满足实时性要求<a class=link href=@ref>6,4</a>。</li><li>查表法优化计算速度，减少CPU开销<a class=link href=@ref>5,6</a>。</li></ul></li></ol><hr><h3 id=-总结crc16的定位>💎 总结：CRC16的定位</h3><ul><li>✅ <strong>是哈希算法</strong>：符合固定输出、确定性、高效性等基本特征。</li><li>❌ <strong>非加密哈希</strong>：缺乏抗碰撞性、不可逆性等安全属性，不能用于加密场景。</li><li>适用场景建议：<ul><li>选择CRC16 → 通信错误检测、存储校验等<strong>非安全领域</strong><a class=link href=@ref>4,6</a>。</li></ul></li><li>选择SHA-256 → 密码存储、数字签名等<strong>安全敏感领域</strong><a class=link href=@ref>9,10</a>。</li></ul><blockquote><p>简言之：CRC16是哈希家族的“实用派”，专攻<strong>效率与检错</strong>；而加密哈希是“安全专家”，专攻<strong>防破解与抗冲突</strong>。二者各司其职，不可互换。</p></blockquote><h2 id=槽数>槽数</h2><p>Redis 集群选择 <strong>16384（2¹⁴）</strong> 个哈希槽（Hash Slot）作为分片数量，是综合考量网络开销、集群规模、数据分布效率等因素后的工程最优解。以下是核心原因及详细分析：</p><hr><h3 id=-心跳包大小优化核心因素>⚙️ <strong>心跳包大小优化（核心因素）</strong></h3><ul><li><strong>槽位信息存储方式</strong>：
Redis 节点通过心跳包（<code>PING/PONG</code>）交换集群状态信息，其中包含节点负责的槽位分配信息。该信息以 ​<strong>位图（bitmap）​</strong>​ 存储，每个槽位占 1 比特（bit）。</li><li><strong>16384 槽位的空间占用</strong>：
<code>16384 bits / 8 = 2048 字节 = 2KB</code><a class=link href=@ref>1,3,4</a>。</li><li><strong>若采用 65536 槽位</strong>：
<code>65536 bits / 8 = 8192 字节 = 8KB</code>，是 16384 方案的 ​<strong>4 倍</strong>。</li><li><strong>影响</strong>：
心跳包默认每秒发送多次，若槽位信息占用 8KB，会显著消耗网络带宽，尤其在节点数多时可能引发网络拥堵<a class=link href=@ref>1,4,6</a>。</li></ul><blockquote><p>💡 <strong>类比</strong>：如同快递员每日汇报包裹位置，精简的清单（2KB）比冗长清单（8KB）更高效<a class=link href=@ref>4</a>。</p></blockquote><hr><h3 id=-集群规模限制1000节点原则>📏 <strong>集群规模限制（1000节点原则）</strong></h3><p>Redis 官方建议集群主节点数量 <strong>不超过 1000 个</strong><a class=link href=@ref>1,4,6</a>，原因如下：</p><ol><li><strong>节点数量与心跳包负载</strong>：
节点越多，心跳包中携带的节点状态信息（如槽位、地址）越多，超过 1000 节点易导致网络拥堵。</li><li><strong>槽位分配的合理性</strong>：</li></ol><ul><li><strong>16384 槽位</strong>：在 1000 节点时，平均每个节点负责约 <strong>16 个槽位</strong>（16384 ÷ 1000），分布均匀且易于管理<a class=link href=@ref>4,7</a>。<ul><li><strong>若槽位过少（如 1000）</strong>：每个节点仅分到 1 个槽位，哈希算法退化为简单取模，失去灵活扩缩容能力<a class=link href=@ref>4</a>。</li></ul></li></ul><ol start=3><li><strong>数据迁移粒度</strong>：
槽位作为数据迁移的最小单位，16384 的细粒度支持更平滑的扩容（如新节点从多个老节点各迁移少量槽位）<a class=link href=@ref>5,8</a>。</li></ol><hr><h3 id=-数据压缩效率>📦 <strong>数据压缩效率</strong></h3><ul><li><strong>槽位信息压缩机制</strong>：
心跳包中的槽位位图（bitmap）在传输前会进行压缩（如 <code>zlib</code>）。</li><li><strong>压缩率与填充率的关系</strong>：
压缩率取决于 ​<strong>填充率</strong>​（<code>slots / N</code>，N 为节点数）。填充率越低（即槽位稀疏），压缩效果越好<a class=link href=@ref>3,4</a>。</li><li><strong>16384 的优势</strong>：
在节点较少（如 10 节点）时，16384 槽位的填充率较低（约 0.06%），压缩后体积远小于 65536 槽位方案<a class=link href=@ref>3,7</a>。</li></ul><blockquote><p>⚡️ <strong>对比</strong>：16384 槽位在小型集群中压缩率更高，传输效率提升明显<a class=link href=@ref>4</a>。</p></blockquote><hr><h3 id=-工程实践权衡>⚖️ <strong>工程实践权衡</strong></h3><ol><li><strong>计算效率</strong>：
<code>16384 = 2¹⁴</code> 是 2 的幂次方，取模运算（<code>CRC16(key) % 16384</code>）可通过位操作（<code>& 0x3FFF</code>）优化，比通用取模快 3-5 倍<a class=link href=@ref>7,8</a>。</li><li><strong>运维友好性</strong>：
固定槽位数简化了集群管理工具的设计，如槽位迁移命令 <code>CLUSTER ADDSLOTS</code> 可直接操作槽位编号<a class=link href=@ref>5,6</a>。</li><li><strong>避免极端数据倾斜</strong>：
16384 的槽位数远大于典型集群规模（如 100 节点），结合 CRC16 的均匀分布特性，有效规避了数据热点问题<a class=link href=@ref>4,8</a>。</li></ol><hr><h3 id=-总结16384-的合理性>💎 <strong>总结：16384 的合理性</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>维度</strong></th><th><strong>16384 槽位方案</strong></th><th><strong>65536 槽位方案</strong></th></tr></thead><tbody><tr><td><strong>心跳包大小</strong></td><td>2KB（带宽占用低）</td><td>8KB（易引发拥堵）</td></tr><tr><td><strong>千节点负载</strong></td><td>每节点约 16 槽（均衡）</td><td>每节点约 65 槽（仍可行）</td></tr><tr><td><strong>压缩效率</strong></td><td>填充率低，压缩率高</td><td>填充率高，压缩率低</td></tr><tr><td><strong>计算效率</strong></td><td>位运算优化，速度快</td><td>标准取模，速度慢</td></tr><tr><td><strong>运维复杂度</strong></td><td>工具链成熟，易操作</td><td>管理成本高</td></tr></tbody></table></div><blockquote><p>🔑 <strong>设计本质</strong>：16384 是 <strong>工程最优解</strong>（而非理论最优），在心跳开销、集群规模、计算效率三者间取得平衡<a class=link href=@ref>4,6,7</a>。
正如 Redis 作者 Antirez 所述：<em>“16384 足以覆盖 1000 节点集群的需求，同时避免心跳包过大”</em><a class=link href=@ref>5</a>。</p></blockquote><h2 id=redisson>redisson</h2><p>Redisson 是一个高级的 <strong>Java 客户端库</strong>，它既支持单节点 Redis，也支持 Redis Cluster 集群模式。其核心设计是<strong>抽象底层 Redis 的部署架构</strong>，开发者可通过同一套 API 操作不同部署模式的 Redis，无需关注底层差异。以下是详细解析：</p><hr><h3 id=-redisson-与-redisredis-cluster-的关系>🔍 Redisson 与 Redis/Redis Cluster 的关系</h3><ol><li><strong>基础定位</strong><ul><li><strong>Redis</strong>：是开源的内存键值数据库，提供数据结构存储能力（如字符串、哈希、列表等）<a class=link href=@ref>5</a>。</li><li><strong>Redisson</strong>：是 Java 客户端库，封装 Redis 的操作并提供分布式高级功能（如锁、队列、集合），<strong>同时适配单节点和集群模式</strong><a class=link href=@ref>4,5</a>。</li></ul></li><li><strong>支持模式</strong><ul><li><strong>单节点 Redis</strong>：通过 <code>useSingleServer()</code> 配置连接单个 Redis 实例<a class=link href=@ref>2,7</a>。</li><li><strong>Redis Cluster</strong>：通过 <code>useClusterServers()</code> 配置，自动处理集群节点发现、数据分片、故障转移等复杂性<a class=link href=@ref>6,8</a>。</li><li><strong>其他模式</strong>：还支持哨兵（Sentinel）、主从（Master/Slave）等部署架构<a class=link href=@ref>1,4</a>。</li></ul></li></ol><hr><h3 id=-redisson-如何适配不同模式>⚙️ Redisson 如何适配不同模式</h3><h4 id=单节点-redis-的适配><strong>单节点 Redis 的适配</strong></h4><ul><li>配置示例：<pre tabindex=0><code>Config config = new Config();
config.useSingleServer().setAddress(&#34;redis://127.0.0.1:6379&#34;);
RedissonClient client = Redisson.create(config);
</code></pre></li><li><strong>特点</strong>：
所有操作直接发送到单一节点，无需处理分片或路由逻辑<a class=link href=@ref>7</a>。</li></ul><h4 id=redis-cluster-的适配><strong>Redis Cluster 的适配</strong></h4><ul><li>配置示例：<pre tabindex=0><code>Config config = new Config();
config.useClusterServers()
      .addNodeAddress(&#34;redis://node1:7001&#34;, &#34;redis://node2:7002&#34;);
RedissonClient client = Redisson.create(config);
</code></pre></li><li>关键技术机制：<ul><li><strong>节点发现</strong>：通过 <code>CLUSTER NODES</code> 命令自动获取集群拓扑，维护节点状态表<a class=link href=@ref>6</a>。</li></ul></li><li><strong>数据路由</strong>：基于 <strong>哈希槽（Hash Slot）</strong> 计算键的归属节点（如 <code>CRC16(key) % 16384</code>），将请求发送到正确节点<a class=link href=@ref>6</a>。<ul><li><strong>故障转移</strong>：监控节点心跳，主节点故障时自动切换到从节点，并更新本地路由表<a class=link href=@ref>6,8</a>。</li></ul></li><li><strong>命令批处理</strong>：跨槽位操作自动拆分为批量命令，发送到多个节点执行<a class=link href=@ref>6</a>。</li></ul><hr><h3 id=-关键功能在不同模式下的行为对比>📊 关键功能在不同模式下的行为对比</h3><div class=table-wrapper><table><thead><tr><th><strong>功能</strong></th><th><strong>单节点 Redis</strong></th><th><strong>Redis Cluster</strong></th></tr></thead><tbody><tr><td><strong>分布式锁（RLock）</strong></td><td>直接通过 <code>SETNX</code> 命令实现锁</td><td>通过红锁（RedLock）算法跨多节点协商锁<a class=link href=@ref>7</a></td></tr><tr><td><strong>分布式集合（RMap）</strong></td><td>所有数据存储在单一节点</td><td>数据按键分片存储到不同节点<a class=link href=@ref>6</a></td></tr><tr><td><strong>事务支持</strong></td><td>单节点事务（<code>MULTI/EXEC</code>）</td><td>仅支持同一槽位内的键的事务<a class=link href=@ref>6</a></td></tr><tr><td><strong>跨节点操作</strong></td><td>天然支持（无分片）</td><td>需通过 <code>RBatch</code> 批量处理跨节点命令<a class=link href=@ref>6</a></td></tr></tbody></table></div><hr><h3 id=-使用注意事项>⚠️ 使用注意事项</h3><ol><li><strong>集群限制</strong><ul><li><strong>跨槽位事务</strong>：Redis Cluster 不支持跨槽位事务，需确保事务内的键属于同一槽位<a class=link href=@ref>6</a>。</li><li><strong>多键操作</strong>：如 <code>RMap.getAll(keys)</code> 需所有键在同一节点，否则需遍历多个节点<a class=link href=@ref>6</a>。</li></ul></li><li><strong>性能优化</strong><ul><li><strong>连接池配置</strong>：集群模式下需增大连接池，避免节点过多导致连接不足<a class=link href=@ref>2</a>。</li><li><strong>本地缓存</strong>：对热点数据启用 <code>RMapCache</code> 本地缓存，减少网络请求<a class=link href=@ref>4</a>。</li></ul></li><li><strong>运维建议</strong><ul><li><strong>动态扩缩容</strong>：集群扩容时，Redisson 自动感知新节点并更新路由，但迁移期间可能有短暂重定向（<code>MOVED</code> 响应）<a class=link href=@ref>6</a>。</li><li><strong>监控</strong>：通过 <code>CLUSTER INFO</code> 监控集群状态，结合 Redisson 日志排查路由异常<a class=link href=@ref>6,8</a>。</li></ul></li></ol><hr><h3 id=-总结-4>💎 总结</h3><ul><li><strong>核心结论</strong>：
Redisson ​<strong>同时支持单节点 Redis 和 Redis Cluster</strong>，通过统一 API 屏蔽底层差异，开发者只需调整配置即可切换模式<a class=link href=@ref>4,6</a>。</li><li><strong>选型建议</strong>：</li><li>中小规模应用 → 单节点模式（简单高效）。<ul><li>高并发/大数据量 → Redis Cluster 模式（水平扩展、高可用）<a class=link href=@ref>1,5</a>。</li></ul></li><li><strong>设计价值</strong>：
Redisson 的本质是 ​<strong>Redis 的智能客户端</strong>，无论底层是单节点还是集群，它都提供一致的分布式编程体验，大幅降低分布式系统复杂度<a class=link href=@ref>8</a>。</li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/redis/>Redis</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Jul 31, 2025 19:25 CST</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/redisconcepts/><div class=article-details><h2 class=article-title>【Redis】Concepts</h2></div></a></article><article><a href=/p/milvusfundamentals/><div class=article-details><h2 class=article-title>【Milvus】Fundamentals</h2></div></a></article><article><a href=/p/mongodbfundamentals/><div class=article-details><h2 class=article-title>【MongoDB】Fundamentals</h2></div></a></article><article><a href=/p/nebulafundamentals/><div class=article-details><h2 class=article-title>【Nebula】Fundamentals</h2></div></a></article><article><a href=/p/distributedlock/><div class=article-details><h2 class=article-title>【Distributed】Lock</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>