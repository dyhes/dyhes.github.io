<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="问题 github action known host GitHub Actions 连接服务器时报错 Host key verification failed，是由于 Actions 环境首次连接服务器时缺失主机密钥验证所致。以下是综合多个文档的完整解决方案：\n🔍 错误原因 主机密钥未信任：GitHub Actions 的虚拟机首次通过 SSH 连接服务器时，会检查服务器的主机密钥（host key）。若密钥未预先存储在 known_hosts 文件中，SSH 会因安全策略拒绝连接。 与本地环境的差异：本地 Mac 已通过手动连接（输入 yes）将服务器密钥添加到 ~/.ssh/known_hosts，但 Actions 环境是全新的，无此记录。 ✅ 解决方案 方法一：提前将服务器密钥添加到 known_hosts（推荐） 在 Actions 工作流中，使用 ssh-keyscan 主动获取服务器密钥并写入 known_hosts 文件：\nsteps: - name: Add server host key to known_hosts run: | mkdir -p ~/.ssh ssh-keyscan your_server_ip >> ~/.ssh/known_hosts # 替换 your_server_ip chmod 600 ~/.ssh/known_hosts 📌 原理：ssh-keyscan 获取服务器公钥并追加到 known_hosts，避免首次连接时的交互提示。\n"><title>【Postopia Dev Log】Week 16</title><link rel=canonical href=https://dyhes.github.io/p/postopia-dev-logweek-16/><link rel=stylesheet href=/scss/style.min.f7091bff8043bd3e53b22be6c05dd86b506e8dec4d0d75d249d2dfb0fe074a46.css><meta property='og:title' content="【Postopia Dev Log】Week 16"><meta property='og:description' content="问题 github action known host GitHub Actions 连接服务器时报错 Host key verification failed，是由于 Actions 环境首次连接服务器时缺失主机密钥验证所致。以下是综合多个文档的完整解决方案：\n🔍 错误原因 主机密钥未信任：GitHub Actions 的虚拟机首次通过 SSH 连接服务器时，会检查服务器的主机密钥（host key）。若密钥未预先存储在 known_hosts 文件中，SSH 会因安全策略拒绝连接。 与本地环境的差异：本地 Mac 已通过手动连接（输入 yes）将服务器密钥添加到 ~/.ssh/known_hosts，但 Actions 环境是全新的，无此记录。 ✅ 解决方案 方法一：提前将服务器密钥添加到 known_hosts（推荐） 在 Actions 工作流中，使用 ssh-keyscan 主动获取服务器密钥并写入 known_hosts 文件：\nsteps: - name: Add server host key to known_hosts run: | mkdir -p ~/.ssh ssh-keyscan your_server_ip >> ~/.ssh/known_hosts # 替换 your_server_ip chmod 600 ~/.ssh/known_hosts 📌 原理：ssh-keyscan 获取服务器公钥并追加到 known_hosts，避免首次连接时的交互提示。\n"><meta property='og:url' content='https://dyhes.github.io/p/postopia-dev-logweek-16/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Postopia'><meta property='article:published_time' content='2025-05-26T00:00:00+00:00'><meta property='article:modified_time' content='2025-10-22T16:27:30+08:00'><meta name=twitter:title content="【Postopia Dev Log】Week 16"><meta name=twitter:description content="问题 github action known host GitHub Actions 连接服务器时报错 Host key verification failed，是由于 Actions 环境首次连接服务器时缺失主机密钥验证所致。以下是综合多个文档的完整解决方案：\n🔍 错误原因 主机密钥未信任：GitHub Actions 的虚拟机首次通过 SSH 连接服务器时，会检查服务器的主机密钥（host key）。若密钥未预先存储在 known_hosts 文件中，SSH 会因安全策略拒绝连接。 与本地环境的差异：本地 Mac 已通过手动连接（输入 yes）将服务器密钥添加到 ~/.ssh/known_hosts，但 Actions 环境是全新的，无此记录。 ✅ 解决方案 方法一：提前将服务器密钥添加到 known_hosts（推荐） 在 Actions 工作流中，使用 ssh-keyscan 主动获取服务器密钥并写入 known_hosts 文件：\nsteps: - name: Add server host key to known_hosts run: | mkdir -p ~/.ssh ssh-keyscan your_server_ip >> ~/.ssh/known_hosts # 替换 your_server_ip chmod 600 ~/.ssh/known_hosts 📌 原理：ssh-keyscan 获取服务器公钥并追加到 known_hosts，避免首次连接时的交互提示。\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b567f26f71c49c33.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://leetcode.cn/u/dyhes/ target=_blank title=LeetCode rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 13h7.5"/><path d="M9.424 7.268l4.999-4.999"/><path d="M16.633 16.644l-2.402 2.415a3.189 3.189.0 01-4.524.0l-3.77-3.787a3.223 3.223.0 010-4.544l3.77-3.787a3.189 3.189.0 014.524.0l2.302 2.313"/></svg></a></li><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li><li><a href=mailto:1325574784@qq.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 19H5a2 2 0 01-2-2V7a2 2 0 012-2h14a2 2 0 012 2v5.5"/><path d="M3 7l9 6 9-6"/><path d="M19 16l-2 3h4l-2 3"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#问题>问题</a></li><li><a href=#github-action-known-host>github action known host</a><ol><li><a href=#-错误原因>🔍 错误原因</a></li><li><a href=#-解决方案>✅ 解决方案</a><ol><li><a href=#方法一提前将服务器密钥添加到-known_hosts推荐>方法一：提前将服务器密钥添加到 <code>known_hosts</code>（推荐）</a></li><li><a href=#方法二禁用严格主机密钥检查临时方案>方法二：禁用严格主机密钥检查（临时方案）</a></li></ol></li><li><a href=#-完整-github-actions-配置示例>📝 完整 GitHub Actions 配置示例</a></li><li><a href=#-关键配置说明>🔧 关键配置说明</a></li><li><a href=#-注意事项>⚠️ 注意事项</a></li><li><a href=#redis-无法远程访问>Redis 无法远程访问</a></li><li><a href=#kafka-配置远程仍连接本地>kafka 配置远程仍连接本地</a></li><li><a href=#1-port-is-deprecated-please-use-kafka_advertised_listeners-instead>1 port is deprecated. Please use KAFKA_ADVERTISED_LISTENERS instead.</a></li><li><a href=#2-宿主机无法访问minikube-集群>2 宿主机无法访问minikube 集群</a></li><li><a href=#3-mysql-探针失活>3 mysql 探针失活</a></li><li><a href=#4-服务器上-docker-compose-报错>4 服务器上 docker-compose 报错</a></li></ol></li><li><a href=#minikube-镜像>Minikube 镜像</a><ol><li><a href=#方法一使用><strong>方法一：使用 <code>minikube image load</code> 命令</strong></a></li><li><a href=#方法二直接使用-minikube-的-docker-环境><strong>方法二：直接使用 Minikube 的 Docker 环境</strong></a></li><li><a href=#注意事项><strong>注意事项</strong></a></li><li><a href=#验证镜像是否生效><strong>验证镜像是否生效</strong></a></li></ol></li><li><a href=#kubectl-apply--f>kubectl apply -f</a><ol><li><a href=#核心功能><strong>核心功能</strong></a></li><li><a href=#基本用法><strong>基本用法</strong></a></li><li><a href=#典型应用场景><strong>典型应用场景</strong></a></li><li><a href=#进阶参数与技巧><strong>进阶参数与技巧</strong></a></li><li><a href=#常见问题与解决><strong>常见问题与解决</strong></a></li><li><a href=#最佳实践><strong>最佳实践</strong></a></li></ol></li><li><a href=#服务类型>服务类型</a><ol><li><a href=#clusterip默认类型>ClusterIP（默认类型）</a></li><li><a href=#nodeport>NodePort</a></li><li><a href=#loadbalancer>LoadBalancer</a></li><li><a href=#externalname>ExternalName</a></li><li><a href=#类型对比与选型建议>类型对比与选型建议</a></li><li><a href=#底层实现机制>底层实现机制</a></li></ol></li><li><a href=#minikube-tunnel>minikube tunnel</a><ol><li><a href=#原因分析><strong>原因分析</strong></a></li><li><a href=#解决方案><strong>解决方案</strong></a><ol><li><a href=#使用><strong>使用 <code>minikube tunnel</code> 命令</strong></a></li><li><a href=#通过><strong>通过 <code>minikube service</code> 命令访问</strong></a></li><li><a href=#手动使用-minikube-的-ip-和-nodeport><strong>手动使用 Minikube 的 IP 和 NodePort</strong></a></li><li><a href=#检查服务配置><strong>检查服务配置</strong></a></li></ol></li><li><a href=#附加说明><strong>附加说明</strong></a></li></ol></li><li><a href=#pv--pvc>PV & PVC</a><ol><li><a href=#1-persistentvolumepv><strong>1. PersistentVolume（PV）</strong></a></li><li><a href=#2-persistentvolumeclaimpvc><strong>2. PersistentVolumeClaim（PVC）</strong></a></li><li><a href=#3-pv与pvc的关系><strong>3. PV与PVC的关系</strong></a></li><li><a href=#4-使用场景对比><strong>4. 使用场景对比</strong></a></li><li><a href=#5-常见问题><strong>5. 常见问题</strong></a></li></ol></li><li><a href=#statefulset--deployment>StatefulSet & Deployment</a><ol><li><a href=#1-适用场景><strong>1. 适用场景</strong></a></li><li><a href=#2-pod-标识与网络><strong>2. Pod 标识与网络</strong></a></li><li><a href=#3-存储管理><strong>3. 存储管理</strong></a></li><li><a href=#4-生命周期管理><strong>4. 生命周期管理</strong></a></li><li><a href=#5-扩缩容与删除行为><strong>5. 扩缩容与删除行为</strong></a></li><li><a href=#总结对比表><strong>总结对比表</strong></a></li><li><a href=#选择建议><strong>选择建议</strong></a></li></ol></li><li><a href=#docker-compose-rebuild>Docker Compose Rebuild</a><ol><li><a href=#强制不使用缓存构建><strong>强制不使用缓存构建</strong></a></li><li><a href=#强制拉取最新基础镜像><strong>强制拉取最新基础镜像</strong></a></li><li><a href=#并行构建多个服务><strong>并行构建多个服务</strong></a></li><li><a href=#选择性重建指定服务><strong>选择性重建指定服务</strong></a></li><li><a href=#删除临时容器和镜像><strong>删除临时容器和镜像</strong></a></li><li><a href=#组合策略示例><strong>组合策略示例</strong></a></li><li><a href=#总结>总结</a></li></ol></li><li><a href=#docker-compose>Docker compose</a><ol><li><a href=#基础运行流程>基础运行流程</a></li><li><a href=#yaml-文件核心配置>YAML 文件核心配置</a></li><li><a href=#高级运行技巧>高级运行技巧</a></li><li><a href=#跨平台注意事项>跨平台注意事项</a></li><li><a href=#故障排查指南>故障排查指南</a></li><li><a href=#基础指定方法>基础指定方法</a></li><li><a href=#典型应用场景-1>典型应用场景</a></li><li><a href=#路径处理规则>路径处理规则</a></li><li><a href=#验证与调试>验证与调试</a></li><li><a href=#高级技巧>高级技巧</a></li></ol></li><li><a href=#k8s-本地镜像>k8s 本地镜像</a><ol><li><a href=#1-配置镜像拉取策略><strong>1. 配置镜像拉取策略</strong></a></li><li><a href=#2-确保镜像存在于集群节点><strong>2. 确保镜像存在于集群节点</strong></a><ol><li><a href=#方法一单节点集群主节点即工作节点><strong>方法一：单节点集群（主节点即工作节点）</strong></a></li><li><a href=#方法二多节点集群><strong>方法二：多节点集群</strong></a></li><li><a href=#方法三特定工具链支持><strong>方法三：特定工具链支持</strong></a></li></ol></li><li><a href=#3-应用配置并验证><strong>3. 应用配置并验证</strong></a></li><li><a href=#适用场景对比><strong>适用场景对比</strong></a></li></ol></li><li><a href=#k8s-master--worker>K8s Master & Worker</a><ol><li><a href=#功能定位><strong>功能定位</strong></a></li><li><a href=#核心组件><strong>核心组件</strong></a></li><li><a href=#职责分工><strong>职责分工</strong></a></li><li><a href=#类比总结><strong>类比总结</strong></a></li></ol></li><li><a href=#master-节点要求>Master 节点要求</a><ol><li><a href=#内存需求的底层逻辑><strong>内存需求的底层逻辑</strong></a></li><li><a href=#gpu-需求的明确结论><strong>GPU 需求的明确结论</strong></a></li><li><a href=#性能优化的平衡策略><strong>性能优化的平衡策略</strong></a></li><li><a href=#关键配置建议><strong>关键配置建议</strong></a></li><li><a href=#总结-1>总结</a></li></ol></li><li><a href=#minikube-预生产验证>Minikube 预生产验证</a><ol><li><a href=#minikube的核心定位与功能限制><strong>Minikube的核心定位与功能限制</strong></a></li><li><a href=#预生产验证的核心需求><strong>预生产验证的核心需求</strong></a></li><li><a href=#替代方案建议><strong>替代方案建议</strong></a></li><li><a href=#结论>结论</a></li></ol></li><li><a href=#github-action>Github Action</a><ol><li><a href=#-配置服务器认证ssh-密钥>🔑 配置服务器认证（SSH 密钥）</a></li><li><a href=#-编写-github-actions-工作流>⚙️ 编写 GitHub Actions 工作流</a></li><li><a href=#-自定义操作场景示例>💻 自定义操作场景示例</a></li><li><a href=#-注意事项-1>⚠️ 注意事项</a></li><li><a href=#-高级技巧>🔧 高级技巧</a></li></ol></li><li><a href=#连接报错>连接报错</a><ol><li><a href=#-错误原因分析>🔍 错误原因分析</a></li><li><a href=#-解决方案逐步操作>🛠️ 解决方案（逐步操作）</a><ol><li><a href=#步骤-1修复私钥格式关键>步骤 1：修复私钥格式（关键！）</a></li><li><a href=#步骤-2修正-action-配置>步骤 2：修正 Action 配置</a></li><li><a href=#步骤-3服务器端检查>步骤 3：服务器端检查</a></li><li><a href=#步骤-4本地模拟测试可选>步骤 4：本地模拟测试（可选）</a></li></ol></li><li><a href=#-注意事项-2>⚠️ 注意事项</a></li><li><a href=#-调试技巧>💡 调试技巧</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/moon/ style=background-color:#b7ae8f;color:>月满西楼
</a><a href=/categories/snow/ style=background-color:#aa6a4c;color:>踏雪泥</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/postopia-dev-logweek-16/>【Postopia Dev Log】Week 16</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>May 26, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>13 minute read</time></div></footer></div></header><section class=article-content><h2 id=问题>问题</h2><h2 id=github-action-known-host>github action known host</h2><p>GitHub Actions 连接服务器时报错 <code>Host key verification failed</code>，是由于 Actions 环境首次连接服务器时缺失主机密钥验证所致。以下是综合多个文档的完整解决方案：</p><hr><h3 id=-错误原因>🔍 错误原因</h3><ul><li><strong>主机密钥未信任</strong>：GitHub Actions 的虚拟机首次通过 SSH 连接服务器时，会检查服务器的主机密钥（host key）。若密钥未预先存储在 <code>known_hosts</code> 文件中，SSH 会因安全策略拒绝连接。</li><li><strong>与本地环境的差异</strong>：本地 Mac 已通过手动连接（输入 <code>yes</code>）将服务器密钥添加到 <code>~/.ssh/known_hosts</code>，但 Actions 环境是全新的，无此记录。</li></ul><hr><h3 id=-解决方案>✅ 解决方案</h3><h4 id=方法一提前将服务器密钥添加到-known_hosts推荐>方法一：提前将服务器密钥添加到 <code>known_hosts</code>（推荐）</h4><p>在 Actions 工作流中，使用 <code>ssh-keyscan</code> 主动获取服务器密钥并写入 <code>known_hosts</code> 文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Add server host key to known_hosts</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>    mkdir -p ~/.ssh
</span></span></span><span class=line><span class=cl><span class=sd>    ssh-keyscan your_server_ip &gt;&gt; ~/.ssh/known_hosts  # 替换 your_server_ip
</span></span></span><span class=line><span class=cl><span class=sd>    chmod 600 ~/.ssh/known_hosts</span><span class=w>
</span></span></span></code></pre></div><blockquote><p>📌 <strong>原理</strong>：<code>ssh-keyscan</code> 获取服务器公钥并追加到 <code>known_hosts</code>，避免首次连接时的交互提示。</p></blockquote><hr><h4 id=方法二禁用严格主机密钥检查临时方案>方法二：禁用严格主机密钥检查（临时方案）</h4><p>在 SSH 命令中添加参数，跳过密钥验证（仅限测试环境）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Connect via SSH</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=l>ssh -o &#34;StrictHostKeyChecking=no&#34; -i ${{ secrets.SSH_PRIVATE_KEY }} user@server_ip</span><span class=w>
</span></span></span></code></pre></div><blockquote><p>⚠️ <strong>注意</strong>：此方法降低安全性，可能遭受中间人攻击，生产环境慎用。</p></blockquote><hr><h3 id=-完整-github-actions-配置示例>📝 完整 GitHub Actions 配置示例</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Deploy to Server</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=l>push]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>deploy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Checkout code</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Add Server Host Key</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>          mkdir -p ~/.ssh
</span></span></span><span class=line><span class=cl><span class=sd>          ssh-keyscan your_server_ip &gt;&gt; ~/.ssh/known_hosts
</span></span></span><span class=line><span class=cl><span class=sd>          chmod 600 ~/.ssh/known_hosts</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>SSH Command</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>          echo &#34;${{ secrets.SSH_PRIVATE_KEY }}&#34; &gt; private_key
</span></span></span><span class=line><span class=cl><span class=sd>          chmod 400 private_key
</span></span></span><span class=line><span class=cl><span class=sd>          ssh -i private_key user@your_server_ip &#34;echo Connected!&#34;</span><span class=w>
</span></span></span></code></pre></div><hr><h3 id=-关键配置说明>🔧 关键配置说明</h3><ol><li><strong>私钥处理</strong>：<ul><li>将 GitHub Secrets 中的私钥写入临时文件，并设置权限 <code>400</code>（必须）。</li></ul></li><li><strong>主机密钥类型</strong>：<ul><li>若服务器使用非默认密钥类型（如 ECDSA），需指定参数：<br><code>ssh-keyscan -t ecdsa your_server_ip >> ~/.ssh/known_hosts</code>。</li></ul></li><li><strong>配置文件优化</strong>（可选）：<ul><li>在 Actions 中创建 <code>~/.ssh/config</code> 文件，简化连接命令：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;Host server
</span></span></span><span class=line><span class=cl><span class=s2>  HostName your_server_ip
</span></span></span><span class=line><span class=cl><span class=s2>  User your_username
</span></span></span><span class=line><span class=cl><span class=s2>  IdentityFile private_key
</span></span></span><span class=line><span class=cl><span class=s2>  StrictHostKeyChecking yes&#34;</span> &gt;&gt; ~/.ssh/config
</span></span></code></pre></div></li></ul></li></ol><hr><h3 id=-注意事项>⚠️ 注意事项</h3><ul><li><strong>权限问题</strong>：确保私钥文件权限为 <code>400</code>，否则 SSH 会拒绝使用。</li><li><strong>密钥格式</strong>：若私钥是 PEM 格式（如以 <code>-----BEGIN RSA PRIVATE KEY-----</code> 开头），需保留换行符。写入文件时建议使用：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=si>${</span><span class=p>{ secrets.SSH_PRIVATE_KEY </span><span class=si>}</span><span class=s2>}&#34;</span> <span class=p>|</span> sed <span class=s1>&#39;s/\\n/\n/g&#39;</span> &gt; private_key
</span></span></code></pre></div></li><li><strong>安全建议</strong>：<br>优先使用 <strong>方法一</strong>，既保持安全性，又避免手动确认。仅在不敏感环境使用方法二。</li></ul><hr><p>通过上述步骤，GitHub Actions 即可安全连接服务器。若仍失败，检查服务器 SSH 服务状态（<code>systemctl status sshd</code>）及防火墙规则。</p><h3 id=redis-无法远程访问>Redis 无法远程访问</h3><p>设置 bind 0.0.0.0 和密码</p><h3 id=kafka-配置远程仍连接本地>kafka 配置远程仍连接本地</h3><p>Kafka Broker 的 advertised.listeners 参数决定了客户端实际连接的地址。若该参数配置为本地地址或容器内部地址（如 localhost:9092 或容器内主机名），即使客户端配置了远程 IP，仍会被重定向到本地地址。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=na>listeners</span><span class=o>=</span><span class=s>PLAINTEXT://0.0.0.0:9092          # 监听所有网络接口</span>
</span></span><span class=line><span class=cl><span class=na>advertised.listeners</span><span class=o>=</span><span class=s>PLAINTEXT://公网IP:9092 # 对外广播的地址</span>
</span></span></code></pre></div><h3 id=1-port-is-deprecated-please-use-kafka_advertised_listeners-instead>1 port is deprecated. Please use KAFKA_ADVERTISED_LISTENERS instead.</h3><p>是因为 “Looks like the kubenetes will automatically set the env name APPNAME_PORT, i.e. KAFKA_PORT in this case, the workaround is to change your app name to something else other than kafka.”
通过 “command: [&ldquo;bash&rdquo;, &ldquo;-c&rdquo;, &ldquo;unset KAFKA_PORT; /etc/confluent/docker/run”]“ 解决</p><h3 id=2-宿主机无法访问minikube-集群>2 宿主机无法访问minikube 集群</h3><p>nginx, gateway, nacos 都设成 LoadBalancer</p><h3 id=3-mysql-探针失活>3 mysql 探针失活</h3><p>修改探针</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>postopia</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>strategy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>Recreate</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>securityContext</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>fsGroup</span><span class=p>:</span><span class=w> </span><span class=m>999</span><span class=w>  </span><span class=c># mysql group ID</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nacos-mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>postopia-nacos-mysql:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>imagePullPolicy</span><span class=p>:</span><span class=w> </span><span class=l>Never</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>MYSQL_ROOT_PASSWORD</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>root</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>MYSQL_USER</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>nacos_config</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>MYSQL_PASSWORD</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>nacos_config</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>MYSQL_DATABASE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>nacos_config</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>LANG</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>C.UTF-8</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>3306</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>mysql-storage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/var/lib/mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>mysql-run</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/var/run/mysqld</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;256Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;250m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;512Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;500m&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=c># Use tcpSocket probe instead, which is more reliable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>tcpSocket</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>3306</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>90</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>20</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>timeoutSeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>failureThreshold</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>startupProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>tcpSocket</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>3306</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>30</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>timeoutSeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>failureThreshold</span><span class=p>:</span><span class=w> </span><span class=m>15</span><span class=w>  </span><span class=c># Allow up to ~2.5 minutes for startup</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>mysql-storage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>persistentVolumeClaim</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>claimName</span><span class=p>:</span><span class=w> </span><span class=l>mysql-pvc</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>mysql-run</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>emptyDir</span><span class=p>:</span><span class=w> </span>{}<span class=w>
</span></span></span></code></pre></div><h3 id=4-服务器上-docker-compose-报错>4 服务器上 docker-compose 报错</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker-compose down -v
</span></span><span class=line><span class=cl>docker rm -f <span class=k>$(</span>docker ps -aq<span class=k>)</span>
</span></span><span class=line><span class=cl>docker volume prune -f
</span></span><span class=line><span class=cl>docker network prune -f
</span></span></code></pre></div><h2 id=minikube-镜像>Minikube 镜像</h2><p>要将 Docker Desktop 中的镜像加载到 Minikube 中，可以通过以下两种常用方法实现：</p><hr><h3 id=方法一使用><strong>方法一：使用 <code>minikube image load</code> 命令</strong></h3><ol><li><p><strong>构建或拉取本地镜像</strong><br>在 Docker Desktop 中构建或拉取目标镜像，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker build -t my-image:latest .
</span></span></code></pre></div></li><li><p><strong>将镜像加载到 Minikube</strong><br>使用以下命令将本地镜像导入 Minikube 的 Docker 环境：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>minikube image load my-image:latest
</span></span></code></pre></div><ul><li>验证是否加载成功：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>minikube ssh
</span></span><span class=line><span class=cl>docker images <span class=p>|</span> grep my-image
</span></span></code></pre></div></li></ul><blockquote><p><strong>说明</strong>：此方法需要先在本机构建镜像，再通过 <code>load</code> 命令导入，适用于已有镜像的场景。</p></blockquote></li></ol><hr><h3 id=方法二直接使用-minikube-的-docker-环境><strong>方法二：直接使用 Minikube 的 Docker 环境</strong></h3><ol><li><p><strong>切换 Docker 环境变量</strong><br>运行以下命令，将当前终端的 Docker 客户端指向 Minikube 内部的 Docker 守护进程：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>eval</span> <span class=k>$(</span>minikube docker-env<span class=k>)</span>
</span></span></code></pre></div><ul><li>此时执行 <code>docker images</code> 会显示 Minikube 的镜像列表，而非本机 Docker Desktop 的镜像。</li></ul></li><li><p><strong>在 Minikube 环境中构建镜像</strong><br>直接在 Minikube 的 Docker 环境中构建镜像（避免镜像传输）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker build -t my-image:latest .
</span></span></code></pre></div><ul><li>构建完成后，镜像会直接存储在 Minikube 环境中，无需额外加载。</li></ul></li><li><p><strong>恢复本机 Docker 环境</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>eval</span> <span class=k>$(</span>minikube docker-env -u<span class=k>)</span>
</span></span></code></pre></div></li></ol><hr><h3 id=注意事项><strong>注意事项</strong></h3><ol><li><p><strong>镜像拉取策略</strong><br>在 Kubernetes 的 Deployment 配置中，需设置 <code>imagePullPolicy: Never</code>，否则 Kubernetes 会尝试从远程仓库拉取镜像而非使用本地镜像。</p></li><li><p><strong>资源限制</strong><br><code>minikube image load</code> 命令可能消耗较多内存，建议为 Minikube 分配足够资源（例如至少 2 核 4GB 内存）。</p></li><li><p><strong>临时开发场景推荐</strong><br>若需频繁使用本地镜像，推荐直接通过 <code>eval $(minikube docker-env)</code> 在 Minikube 环境中构建镜像，省去加载步骤。</p></li></ol><hr><h3 id=验证镜像是否生效><strong>验证镜像是否生效</strong></h3><p>部署应用后，可通过以下命令检查 Pod 状态和日志：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl apply -f deployment.yaml
</span></span><span class=line><span class=cl>kubectl logs deployment/my-app
</span></span><span class=line><span class=cl>kubectl port-forward deployment/my-app 8080:8080  <span class=c1># 端口转发访问服务</span>
</span></span></code></pre></div><blockquote><p><strong>引用说明</strong>：以上方法综合了镜像加载和直接构建两种场景，适用于本地开发调试。若需长期使用，建议搭建私有镜像仓库或配置镜像加速源。</p></blockquote><h2 id=kubectl-apply--f>kubectl apply -f</h2><p><code>kubectl apply -f</code> 是 Kubernetes 中用于声明式配置管理的核心命令，通过读取 YAML/JSON 文件将资源应用到集群中，并确保集群状态与文件定义一致。以下是其关键信息：</p><hr><h3 id=核心功能><strong>核心功能</strong></h3><ol><li><p><strong>声明式管理</strong></p><ul><li>通过配置文件描述资源的<strong>期望状态</strong>，Kubernetes 自动计算并执行所需操作（创建/更新）。</li><li>与命令式命令（如 <code>kubectl create</code>）不同，<code>apply</code> <strong>不会覆盖现有配置</strong>，而是通过三向合并策略（Three-Way Merge）对比当前状态、上次应用状态和文件状态，仅应用必要变更。</li></ul></li><li><p><strong>幂等性</strong></p><ul><li>多次执行同一命令结果一致，适合自动化部署和 CI/CD 流程。</li></ul></li><li><p><strong>版本控制友好</strong></p><ul><li>配置文件可存储在 Git 等版本控制系统中，便于跟踪变更历史和团队协作。</li></ul></li></ol><hr><h3 id=基本用法><strong>基本用法</strong></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 应用单个文件</span>
</span></span><span class=line><span class=cl>kubectl apply -f deployment.yaml
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 应用目录下所有配置文件</span>
</span></span><span class=line><span class=cl>kubectl apply -f ./configs/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 从标准输入读取配置（如管道传递）</span>
</span></span><span class=line><span class=cl>cat pod.json <span class=p>|</span> kubectl apply -f -
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用 Kustomize 目录</span>
</span></span><span class=line><span class=cl>kubectl apply -k kustomize-dir/
</span></span></code></pre></div><hr><h3 id=典型应用场景><strong>典型应用场景</strong></h3><ol><li><p><strong>部署应用</strong></p><ul><li>通过定义 Deployment、Service、Ingress 等资源文件，一键部署完整应用组件。</li><li><strong>示例</strong>：部署 Nginx：<div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:1.21</span><span class=w>
</span></span></span></code></pre></div>执行：<code>kubectl apply -f nginx.yaml</code>。</li></ul></li><li><p><strong>更新资源</strong></p><ul><li>修改配置文件后重新执行 <code>apply</code>，Kubernetes 自动更新资源（如调整副本数、镜像版本）。</li></ul></li><li><p><strong>批量管理资源</strong></p><ul><li>使用标签（Labels）分组管理资源，例如统一更新所有标记为 <code>app=backend</code> 的 Deployment。</li></ul></li></ol><hr><h3 id=进阶参数与技巧><strong>进阶参数与技巧</strong></h3><ol><li><p><strong>删除未使用的资源</strong></p><ul><li>结合 <code>--prune</code> 参数可自动删除配置文件中未提及但已存在的资源（需指定标签或资源类型）：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl apply -f manifest.yaml --prune -l <span class=nv>app</span><span class=o>=</span>nginx
</span></span></code></pre></div><em>注意：此功能目前处于 Alpha 阶段，需谨慎使用。</em></li></ul></li><li><p><strong>模拟执行（Dry Run）</strong></p><ul><li>预览变更而不实际生效：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl apply -f deployment.yaml --dry-run<span class=o>=</span>server
</span></span></code></pre></div></li></ul></li><li><p><strong>强制覆盖冲突</strong></p><ul><li>当字段冲突时，使用 <code>--force-conflicts</code> 强制应用变更（需结合 <code>--server-side</code>）。</li></ul></li></ol><hr><h3 id=常见问题与解决><strong>常见问题与解决</strong></h3><ol><li><p><strong>资源未按预期更新</strong></p><ul><li><strong>原因</strong>：本地配置与集群实际状态不一致。</li><li><strong>解决</strong>：使用 <code>kubectl get &lt;resource> -o yaml</code> 导出当前配置，对比并调整文件后重新应用。</li></ul></li><li><p><strong>资源未被自动删除</strong></p><ul><li><strong>原因</strong>：<code>apply</code> 默认不会删除资源，需显式使用 <code>kubectl delete -f</code> 或结合 <code>--prune</code>。</li></ul></li><li><p><strong>权限或配置错误</strong></p><ul><li><strong>排查步骤</strong>：<ol><li>检查 YAML 语法（如缩进、字段名）。</li><li>确认用户权限（RBAC）。</li><li>查看事件日志：<code>kubectl describe &lt;resource></code>。</li></ol></li></ul></li></ol><hr><h3 id=最佳实践><strong>最佳实践</strong></h3><ol><li><p><strong>始终使用版本控制</strong></p><ul><li>将配置文件纳入 Git，结合 CI/CD 实现自动化部署。</li></ul></li><li><p><strong>避免手动修改实时配置</strong></p><ul><li>直接在集群中修改（如 <code>kubectl edit</code>）可能导致与配置文件冲突，建议通过更新文件后重新应用。</li></ul></li><li><p><strong>标签化资源</strong></p><ul><li>使用 <code>metadata.labels</code> 对相关资源分组，便于批量操作。</li></ul></li></ol><hr><p>通过以上方式，<code>kubectl apply -f</code> 成为 Kubernetes 声明式管理的核心工具，尤其适用于复杂环境下的资源管理。如需进一步了解参数细节，可参考官方文档或 <code>kubectl apply --help</code>。</p><h2 id=服务类型>服务类型</h2><p>Kubernetes Service 是集群内网络通信的核心抽象，通过提供稳定的访问入口和负载均衡机制，解决了 Pod 动态变化导致的 IP 不固定问题。以下是其四种主要类型的详细介绍：</p><hr><h3 id=clusterip默认类型>ClusterIP（默认类型）</h3><p><strong>特点</strong></p><ul><li><strong>内部访问</strong>：为 Service 分配一个虚拟 IP（ClusterIP），仅限集群内部 Pod 或组件访问。</li><li><strong>负载均衡</strong>：自动将请求分发到关联的多个 Pod，支持轮询等基本算法。</li><li><strong>动态适配</strong>：通过标签选择器（Label Selector）自动更新后端 Pod，无需人工干预。</li></ul><p><strong>适用场景</strong></p><ul><li>微服务间通信（如前端服务调用后端 API）。</li><li>数据库、缓存等仅需集群内部访问的服务。</li></ul><p><strong>示例配置</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>ClusterIP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>my-app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>        </span><span class=c># Service 暴露端口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w> </span><span class=c># Pod 应用端口</span><span class=w>
</span></span></span></code></pre></div><hr><h3 id=nodeport>NodePort</h3><p><strong>特点</strong></p><ul><li><strong>外部访问入口</strong>：在每个集群节点上开放一个静态端口（默认 30000-32767），外部可通过 <code>NodeIP:NodePort</code> 访问服务。</li><li><strong>基于 ClusterIP</strong>：NodePort 本质是 ClusterIP 的扩展，同时保留 ClusterIP 功能。</li></ul><p><strong>适用场景</strong></p><ul><li>开发测试环境临时暴露服务。</li><li>小规模集群或无需云负载均衡的场景。</li></ul><p><strong>示例配置</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>NodePort</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>nodePort</span><span class=p>:</span><span class=w> </span><span class=m>30080</span><span class=w>  </span><span class=c># 可手动指定或由系统分配</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>my-app</span><span class=w>
</span></span></span></code></pre></div><hr><h3 id=loadbalancer>LoadBalancer</h3><p><strong>特点</strong></p><ul><li><strong>云平台集成</strong>：自动创建云厂商的负载均衡器（如 AWS ALB、GCP LB），分配外部 IP。</li><li><strong>高可用性</strong>：流量通过负载均衡器分发到多个节点，避免单点故障。</li></ul><p><strong>适用场景</strong></p><ul><li>生产环境对外暴露服务（如 Web API、前端应用）。</li><li>需要自动扩缩容和流量管理的云原生应用。</li></ul><p><strong>示例配置</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>LoadBalancer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>my-app</span><span class=w>
</span></span></span></code></pre></div><hr><h3 id=externalname>ExternalName</h3><p><strong>特点</strong></p><ul><li><strong>外部服务映射</strong>：将 Service 映射到外部 DNS 名称（如 <code>example.com</code>），不创建代理或负载均衡。</li><li><strong>DNS 解析</strong>：通过 CNAME 记录将内部请求转发到外部服务。</li></ul><p><strong>适用场景</strong></p><ul><li>访问集群外部的数据库（如 MySQL、Redis）。</li><li>集成第三方 API 或遗留系统。</li></ul><p><strong>示例配置</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>external-mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>ExternalName</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>externalName</span><span class=p>:</span><span class=w> </span><span class=l>mysql.example.com</span><span class=w>
</span></span></span></code></pre></div><hr><h3 id=类型对比与选型建议>类型对比与选型建议</h3><div class=table-wrapper><table><thead><tr><th>类型</th><th>访问方式</th><th>适用场景</th><th>典型用例</th></tr></thead><tbody><tr><td><strong>ClusterIP</strong></td><td><code>http://&lt;service-name>:port</code></td><td>集群内部通信</td><td>微服务间调用、内部数据库</td></tr><tr><td><strong>NodePort</strong></td><td><code>http://&lt;NodeIP>:30000+</code></td><td>开发测试、临时外部访问</td><td>本地调试、小型应用展示</td></tr><tr><td><strong>LoadBalancer</strong></td><td><code>http://&lt;External-IP>:port</code></td><td>生产环境外部访问（云平台）</td><td>公有云部署的 Web 服务</td></tr><tr><td><strong>ExternalName</strong></td><td><code>service-name → 外部域名</code></td><td>集成外部服务</td><td>外部 API、跨集群数据库访问</td></tr></tbody></table></div><p><strong>选型建议</strong>：</p><ul><li>优先使用 <strong>ClusterIP</strong> 满足内部通信需求。</li><li>生产环境需高可用时选择 <strong>LoadBalancer</strong>（云环境）或结合 Ingress 使用。</li><li>避免在生产环境过度依赖 <strong>NodePort</strong>，因其端口范围受限且缺乏负载均衡。</li></ul><hr><h3 id=底层实现机制>底层实现机制</h3><p>Service 的负载均衡依赖于 <code>kube-proxy</code>，支持三种模式：</p><ol><li><strong>iptables</strong>：通过规则直接转发流量，性能较高但缺乏重试机制。</li><li><strong>IPVS</strong>：内核级负载均衡，支持复杂算法（如加权轮询），适合大规模集群。</li><li><strong>Userspace</strong>（已淘汰）：早期模式，因性能问题逐渐被替代。</li></ol><p>以上内容综合了 Kubernetes 官方文档及社区最佳实践，具体配置需结合集群环境和云平台特性调整。</p><h2 id=minikube-tunnel>minikube tunnel</h2><p>在 Minikube 环境中，当服务类型设置为 <code>LoadBalancer</code> 时，直接通过 <code>localhost</code> 无法访问是常见问题，原因和解决方案如下：</p><hr><h3 id=原因分析><strong>原因分析</strong></h3><ol><li><p><strong>Minikube 的网络隔离</strong><br>Minikube 创建的是一个独立虚拟机或容器化的 Kubernetes 集群，其网络与宿主机（如 Mac、Windows 本地）隔离。<code>LoadBalancer</code> 类型服务在云环境中会自动分配外部 IP，但在本地 Minikube 中需要特殊处理。</p></li><li><p><strong>LoadBalancer 的本地限制</strong><br>Minikube 默认不支持自动分配外部 IP 给 <code>LoadBalancer</code> 类型服务，因此服务可能处于 <code>pending</code> 状态，无法通过 <code>localhost</code> 访问。</p></li></ol><hr><h3 id=解决方案><strong>解决方案</strong></h3><h4 id=使用><strong>使用 <code>minikube tunnel</code> 命令</strong></h4><p>该命令会为 <code>LoadBalancer</code> 类型服务分配本地 IP（通常是 <code>127.0.0.1</code>），使服务可通过 <code>localhost</code> 访问。<br><strong>操作步骤</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 启动隧道（需要管理员权限）</span>
</span></span><span class=line><span class=cl>minikube tunnel
</span></span></code></pre></div><p>之后，服务的 <code>EXTERNAL-IP</code> 会显示为 <code>127.0.0.1</code>，可通过 <code>localhost:&lt;端口></code> 访问。</p><hr><h4 id=通过><strong>通过 <code>minikube service</code> 命令访问</strong></h4><p>Minikube 提供了快捷命令生成服务的访问 URL：<br><strong>操作步骤</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 获取服务访问地址</span>
</span></span><span class=line><span class=cl>minikube service &lt;服务名称&gt; --url
</span></span></code></pre></div><p>该命令会返回形如 <code>http://192.168.64.2:30001</code> 的 URL，直接使用此地址即可访问。</p><hr><h4 id=手动使用-minikube-的-ip-和-nodeport><strong>手动使用 Minikube 的 IP 和 NodePort</strong></h4><p>如果服务同时暴露了 <code>NodePort</code>，可以通过以下步骤访问：<br><strong>操作步骤</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 获取 Minikube 集群 IP</span>
</span></span><span class=line><span class=cl>minikube ip
</span></span><span class=line><span class=cl><span class=c1># 查看服务的 NodePort</span>
</span></span><span class=line><span class=cl>kubectl get svc &lt;服务名称&gt;
</span></span></code></pre></div><p>访问地址为 <code>&lt;Minikube-IP>:&lt;NodePort></code>（例如 <code>192.168.64.2:31035</code>）。</p><hr><h4 id=检查服务配置><strong>检查服务配置</strong></h4><ul><li><strong>选择器匹配</strong>：确保 Service 的 <code>selector</code> 与 Pod 的标签匹配，否则流量无法路由到后端 Pod。</li><li><strong>端口映射</strong>：确认 <code>targetPort</code> 与 Pod 的容器端口一致，<code>nodePort</code> 在 30000-32767 范围内。</li><li><strong>服务状态</strong>：运行 <code>kubectl describe svc &lt;服务名称></code>，检查 <code>Endpoints</code> 是否有正确的 Pod IP。</li></ul><hr><h3 id=附加说明><strong>附加说明</strong></h3><ul><li><strong><code>LoadBalancer</code> 的适用场景</strong>：在本地开发中，推荐优先使用 <code>NodePort</code> 或结合 <code>minikube tunnel</code>，以减少复杂性。</li><li><strong>云环境差异</strong>：如果在云厂商（如阿里云）部署，<code>LoadBalancer</code> 会自动绑定 SLB/IP，但需注意 <code>externalTrafficPolicy</code> 配置。</li></ul><p>通过上述方法，可解决 Minikube 中 <code>LoadBalancer</code> 服务无法通过 <code>localhost</code> 访问的问题。推荐优先使用 <code>minikube tunnel</code> 或 <code>minikube service</code> 命令简化操作。</p><h2 id=pv--pvc>PV & PVC</h2><p>PersistentVolume（PV）和PersistentVolumeClaim（PVC）是Kubernetes中用于管理存储资源的核心概念，两者共同实现了存储与计算的解耦，确保数据持久化。以下是具体解析：</p><hr><h3 id=1-persistentvolumepv><strong>1. PersistentVolume（PV）</strong></h3><p><strong>定义</strong>：<br>PV是集群中由管理员预先配置或通过动态供应（StorageClass）创建的一块持久化存储资源。它独立于Pod的生命周期，支持多种存储类型（如NFS、云存储、本地存储等）。</p><p><strong>核心特性</strong>：</p><ul><li><strong>存储类型</strong>：支持本地存储、网络存储（NFS、iSCSI）、云存储（如AWS EBS、Azure Disk）等。</li><li><strong>访问模式</strong>：<ul><li><code>ReadWriteOnce</code>（RWO）：单节点读写；</li><li><code>ReadOnlyMany</code>（ROX）：多节点只读；</li><li><code>ReadWriteMany</code>（RWX）：多节点读写。</li></ul></li><li><strong>生命周期管理</strong>：<ul><li><strong>回收策略</strong>：包括<code>Retain</code>（保留数据）、<code>Delete</code>（自动删除存储）、<code>Recycle</code>（废弃，已不推荐）。</li><li><strong>状态</strong>：<code>Available</code>（空闲）、<code>Bound</code>（已绑定）、<code>Released</code>（已释放）、<code>Failed</code>（失败）。</li></ul></li></ul><p><strong>示例用途</strong>：<br>数据库数据持久化、共享文件系统、日志存储等场景。</p><hr><h3 id=2-persistentvolumeclaimpvc><strong>2. PersistentVolumeClaim（PVC）</strong></h3><p><strong>定义</strong>：<br>PVC是用户对存储资源的声明，用于向Kubernetes请求特定大小和访问模式的存储。它类似于Pod申请计算资源（CPU/内存），通过绑定PV实现存储的消费。</p><p><strong>核心特性</strong>：</p><ul><li><strong>与PV的绑定</strong>：PVC通过匹配存储容量、访问模式和StorageClass与PV绑定。</li><li><strong>动态供应</strong>：若未匹配到静态PV，可通过<code>StorageClass</code>动态创建PV。</li><li><strong>命名空间限制</strong>：PVC属于特定命名空间，而PV是集群级资源。</li></ul><p><strong>示例YAML</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>PersistentVolumeClaim</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-pvc</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>accessModes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>ReadWriteOnce</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>storage</span><span class=p>:</span><span class=w> </span><span class=l>10Gi</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>storageClassName</span><span class=p>:</span><span class=w> </span><span class=l>standard </span><span class=w> </span><span class=c># 指定动态供应的存储类</span><span class=w>
</span></span></span></code></pre></div><hr><h3 id=3-pv与pvc的关系><strong>3. PV与PVC的关系</strong></h3><ul><li><strong>静态供应</strong>：管理员预先创建PV，用户通过PVC申请匹配的存储。</li><li><strong>动态供应</strong>：通过<code>StorageClass</code>模板自动创建PV，无需管理员手动配置。</li><li><strong>绑定逻辑</strong>：<ul><li>PVC提交后，Kubernetes控制器会寻找满足条件的PV进行绑定；</li><li>若使用动态供应，则直接按PVC需求创建PV。</li></ul></li></ul><hr><h3 id=4-使用场景对比><strong>4. 使用场景对比</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>PV</strong></th><th><strong>PVC</strong></th></tr></thead><tbody><tr><td><strong>创建者</strong></td><td>集群管理员</td><td>用户（开发者）</td></tr><tr><td><strong>生命周期</strong></td><td>独立于Pod</td><td>与Pod解耦，但绑定后与PV同步</td></tr><tr><td><strong>核心作用</strong></td><td>提供实际存储资源</td><td>声明存储需求并绑定PV</td></tr><tr><td><strong>存储类型配置</strong></td><td>明确指定（如NFS路径、云存储参数）</td><td>通过StorageClass抽象</td></tr></tbody></table></div><hr><h3 id=5-常见问题><strong>5. 常见问题</strong></h3><ul><li><strong>Q1：PVC未绑定PV怎么办？</strong><br>需检查PVC的容量、访问模式是否与可用PV匹配，或确认StorageClass配置正确。</li><li><strong>Q2：如何复用已释放的PV？</strong><br>若回收策略为<code>Retain</code>，需手动删除并重新创建PV。</li></ul><p>通过PV和PVC的协作，Kubernetes实现了存储资源的灵活管理，既能满足复杂业务需求，又能简化用户操作。</p><h2 id=statefulset--deployment>StatefulSet & Deployment</h2><p>StatefulSet 和 Deployment 是 Kubernetes 中两类核心控制器，分别针对有状态和无状态应用设计。以下是两者的主要区别，结合应用场景、行为特性及底层机制进行对比：</p><hr><h3 id=1-适用场景><strong>1. 适用场景</strong></h3><ul><li><p><strong>Deployment</strong><br>适用于<strong>无状态应用</strong>（如 Web 服务器、API 服务），Pod 之间可随意替换且无需保留状态。<br><strong>特点</strong>：</p><ul><li>Pod 实例完全对等，无启动顺序依赖；</li><li>数据通常存储在临时卷或共享存储中。</li></ul></li><li><p><strong>StatefulSet</strong><br>适用于<strong>有状态应用</strong>（如数据库、分布式存储），需稳定标识、持久化存储及严格顺序控制。<br><strong>特点</strong>：</p><ul><li>每个 Pod 有唯一名称（如 <code>db-0</code>、<code>db-1</code>）和固定 DNS 记录（如 <code>db-0.myservice.ns.svc.cluster.local</code>）；</li><li>数据通过独立的 PersistentVolume 持久化，与 Pod 生命周期解耦。</li></ul></li></ul><hr><h3 id=2-pod-标识与网络><strong>2. Pod 标识与网络</strong></h3><ul><li><p><strong>Deployment</strong></p><ul><li><strong>Pod 名称随机</strong>（如 <code>web-app-59d8c5f6c4-abcde</code>）；</li><li><strong>IP 动态分配</strong>，重启或迁移后可能变化；</li><li>通过 Service 负载均衡暴露，流量随机分发至任意 Pod。</li></ul></li><li><p><strong>StatefulSet</strong></p><ul><li><strong>Pod 名称固定且有序</strong>（如 <code>db-0</code>、<code>db-1</code>）；</li><li><strong>网络标识稳定</strong>，通过 Headless Service 提供 DNS 记录，支持 Pod 间直接通信；</li><li>适用于需固定网络拓扑的场景（如主从数据库）。</li></ul></li></ul><hr><h3 id=3-存储管理><strong>3. 存储管理</strong></h3><ul><li><p><strong>Deployment</strong></p><ul><li>默认使用临时存储（如 <code>emptyDir</code>）；</li><li>若需持久化存储，需手动配置 PV/PVC，但所有 Pod 可能共享同一卷。</li></ul></li><li><p><strong>StatefulSet</strong></p><ul><li><strong>每个 Pod 绑定独立存储</strong>：通过 <code>volumeClaimTemplates</code> 动态创建 PVC，存储与 Pod 解耦但一一对应；</li><li>数据在 Pod 删除后保留，适用于数据库实例的独立数据存储。</li></ul></li></ul><hr><h3 id=4-生命周期管理><strong>4. 生命周期管理</strong></h3><ul><li><p><strong>启动/终止顺序</strong></p><ul><li><strong>Deployment</strong>：Pod 无序创建或删除，可并行操作；</li><li><strong>StatefulSet</strong>：Pod 按顺序启动（如 <code>db-0</code> → <code>db-1</code>）和终止（逆序），确保状态一致性。</li></ul></li><li><p><strong>滚动更新策略</strong></p><ul><li><strong>Deployment</strong>：支持无序滚动更新，通过 <code>maxUnavailable</code> 和 <code>maxSurge</code> 控制更新节奏；</li><li><strong>StatefulSet</strong>：按序号逆序更新（如 <code>db-2</code> → <code>db-1</code> → <code>db-0</code>），确保逐个 Pod 就绪。</li></ul></li></ul><hr><h3 id=5-扩缩容与删除行为><strong>5. 扩缩容与删除行为</strong></h3><ul><li><p><strong>扩缩容</strong></p><ul><li><strong>Deployment</strong>：Pod 随机创建或删除，无顺序限制；</li><li><strong>StatefulSet</strong>：扩容时按序创建新 Pod，缩容时按逆序删除旧 Pod。</li></ul></li><li><p><strong>删除控制器时</strong></p><ul><li><strong>Deployment</strong>：删除后关联 Pod 和 ReplicaSet 均被清理；</li><li><strong>StatefulSet</strong>：默认保留 Pod 和 PVC，需手动删除以确保数据安全。</li></ul></li></ul><hr><h3 id=总结对比表><strong>总结对比表</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>特性</strong></th><th><strong>Deployment</strong></th><th><strong>StatefulSet</strong></th></tr></thead><tbody><tr><td><strong>适用场景</strong></td><td>无状态应用（Web、API）</td><td>有状态应用（数据库、消息队列）</td></tr><tr><td><strong>Pod 标识</strong></td><td>随机名称，动态 IP</td><td>固定名称（如 <code>db-0</code>），稳定 DNS</td></tr><tr><td><strong>存储</strong></td><td>临时卷或共享存储</td><td>每个 Pod 独立持久化存储</td></tr><tr><td><strong>启动顺序</strong></td><td>无序</td><td>严格按顺序创建/删除（<code>db-0</code> → <code>db-1</code>）</td></tr><tr><td><strong>更新策略</strong></td><td>无序滚动更新</td><td>逆序逐个更新</td></tr><tr><td><strong>适用案例</strong></td><td>Nginx、无状态微服务</td><td>MySQL、Kafka、Zookeeper</td></tr></tbody></table></div><hr><h3 id=选择建议><strong>选择建议</strong></h3><ul><li><strong>优先选 Deployment</strong>：若应用无状态、可水平扩展且无需固定网络标识（如 REST API）；</li><li><strong>优先选 StatefulSet</strong>：若需稳定网络标识、独立存储或有序生命周期（如数据库集群、分布式锁服务）。</li></ul><p>通过合理选择控制器，可有效平衡应用的弹性与状态一致性需求。</p><h2 id=docker-compose-rebuild>Docker Compose Rebuild</h2><p>在 Docker Compose 中，<code>docker compose build</code> 命令的 <strong>Rebuild 策略</strong>可以通过以下选项灵活指定，适用于不同场景下的镜像构建需求：</p><hr><h3 id=强制不使用缓存构建><strong>强制不使用缓存构建</strong></h3><p>通过 <code>--no-cache</code> 参数，跳过 Docker 构建缓存，从头开始重新构建镜像。<br><strong>适用场景</strong>：当 Dockerfile 中的指令顺序或内容发生变化，但缓存可能导致旧版本残留时。<br><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker compose build --no-cache <span class=o>[</span>SERVICE_NAME<span class=o>]</span>
</span></span></code></pre></div><blockquote><p>引用说明：此选项在网页中均有提及，明确用于禁用缓存。</p></blockquote><hr><h3 id=强制拉取最新基础镜像><strong>强制拉取最新基础镜像</strong></h3><p>使用 <code>--pull</code> 参数，强制从镜像仓库拉取最新版本的基础镜像（如 <code>FROM</code> 指定的镜像）。<br><strong>适用场景</strong>：确保基础镜像（如 <code>python:3.6-alpine</code>）更新到最新版本，避免本地旧版本影响构建。<br><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker compose build --pull <span class=o>[</span>SERVICE_NAME<span class=o>]</span>
</span></span></code></pre></div><blockquote><p>引用说明：网页均强调此选项用于更新基础镜像。</p></blockquote><hr><h3 id=并行构建多个服务><strong>并行构建多个服务</strong></h3><p>通过 <code>--parallel</code> 参数（Docker Compose 3.4+ 支持），启用多服务并行构建以加速整体流程。<br><strong>适用场景</strong>：当项目包含多个独立服务且构建过程无依赖时，可显著减少构建时间。<br><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker compose build --parallel
</span></span></code></pre></div><blockquote><p>引用说明：网页详细说明了并行构建的适用性和使用方法。</p></blockquote><hr><h3 id=选择性重建指定服务><strong>选择性重建指定服务</strong></h3><p>在命令中指定服务名称，仅重新构建特定服务，而非所有服务。<br><strong>适用场景</strong>：仅某个服务的 Dockerfile 或依赖发生变更时，针对性重建以节省资源。<br><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker compose build web  <span class=c1># 仅重建名为 &#34;web&#34; 的服务</span>
</span></span></code></pre></div><blockquote><p>引用说明：网页均提到通过服务名称选择性构建。</p></blockquote><hr><h3 id=删除临时容器和镜像><strong>删除临时容器和镜像</strong></h3><p>通过 <code>--force-rm</code> 参数，删除构建过程中产生的临时容器，避免残留文件占用空间。<br><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker compose build --force-rm <span class=o>[</span>SERVICE_NAME<span class=o>]</span>
</span></span></code></pre></div><blockquote><p>引用说明：网页指出此选项用于清理临时容器。</p></blockquote><hr><h3 id=组合策略示例><strong>组合策略示例</strong></h3><p>可组合多个参数实现复杂策略，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker compose build --no-cache --pull web  <span class=c1># 强制重建 &#34;web&#34; 服务，禁用缓存并拉取最新基础镜像</span>
</span></span></code></pre></div><hr><h3 id=总结>总结</h3><p>通过上述参数，可以灵活控制 Docker Compose 的构建行为，适配开发、测试和生产环境的不同需求。具体选择需结合以下因素：</p><ul><li><strong>缓存依赖</strong>：是否需要完全干净的构建环境（如 CI/CD 流水线）。</li><li><strong>镜像更新</strong>：是否依赖最新基础镜像的安全性更新。</li><li><strong>效率优化</strong>：是否启用并行构建以减少时间成本。</li></ul><blockquote><p>提示：可通过 <code>docker compose config</code> 验证配置文件格式，或结合 <code>docker compose up --build</code> 直接启动重建后的服务。</p></blockquote><h2 id=docker-compose>Docker compose</h2><p>以下是使用 Docker Compose 运行 <code>.yaml</code> 文件的完整指南，综合了最佳实践和关键注意事项：</p><h3 id=基础运行流程>基础运行流程</h3><ol><li><p><strong>验证配置文件</strong><br>执行 <code>docker-compose config</code> 检查 YAML 文件语法，避免因缩进错误或格式问题导致启动失败。</p></li><li><p><strong>启动服务</strong><br>在包含 <code>docker-compose.yaml</code> 的目录下执行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker-compose up        <span class=c1># 前台运行（查看实时日志）</span>
</span></span><span class=line><span class=cl>docker-compose up -d     <span class=c1># 后台运行</span>
</span></span></code></pre></div></li><li><p><strong>服务管理</strong></p><ul><li><code>docker-compose ps</code> 查看运行状态</li><li><code>docker-compose logs [服务名]</code> 查看指定服务日志</li><li><code>docker-compose down</code> 停止并删除所有容器、网络和卷</li></ul></li></ol><h3 id=yaml-文件核心配置>YAML 文件核心配置</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;3.8&#39;</span><span class=w>  </span><span class=c># 指定兼容版本</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>web</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:alpine</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;80:80&#34;</span><span class=w>  </span><span class=c># 端口映射（主机:容器）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>./html:/usr/share/nginx/html </span><span class=w> </span><span class=c># 目录挂载</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>depends_on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>db </span><span class=w> </span><span class=c># 基础依赖声明</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>db</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>postgres:15</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>POSTGRES_PASSWORD</span><span class=p>:</span><span class=w> </span><span class=l>example</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>healthcheck</span><span class=p>:</span><span class=w>  </span><span class=c># 健康检查配置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>test</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=s2>&#34;CMD-SHELL&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;pg_isready -U postgres&#34;</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>interval</span><span class=p>:</span><span class=w> </span><span class=l>5s</span><span class=w>
</span></span></span></code></pre></div><h3 id=高级运行技巧>高级运行技巧</h3><ol><li><p><strong>环境变量注入</strong><br>使用 <code>.env</code> 文件管理敏感信息，YAML 中通过 <code>${VAR_NAME}</code> 引用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>DB_PASSWORD</span><span class=p>:</span><span class=w> </span><span class=l>${DB_SECRET}</span><span class=w>
</span></span></span></code></pre></div></li><li><p><strong>多环境配置</strong><br>通过叠加多个 Compose 文件实现环境差异：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker-compose -f docker-compose.yml -f docker-compose.prod.yml up
</span></span></code></pre></div></li><li><p><strong>资源限制</strong><br>配置容器资源使用上限防止过载：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>deploy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>cpus</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;2&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=l>1G</span><span class=w>
</span></span></span></code></pre></div></li></ol><h3 id=跨平台注意事项>跨平台注意事项</h3><ol><li><p><strong>Windows 特殊配置</strong></p><ul><li>确保 Docker Desktop 已安装并启用 WSL2</li><li>路径使用正斜杠 <code>/</code> 代替反斜杠 <code>\</code></li><li>避免使用保留端口（如 80/443）可能被系统占用</li></ul></li><li><p><strong>Linux 权限处理</strong><br>容器内用户权限需与挂载目录匹配：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=l>./data:/var/lib/postgresql/data:z </span><span class=w> </span><span class=c># SELinux 上下文标记</span><span class=w>
</span></span></span></code></pre></div></li></ol><h3 id=故障排查指南>故障排查指南</h3><ol><li><p><strong>启动顺序问题</strong><br>使用增强型依赖声明，确保服务真正可用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>depends_on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>db</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>condition</span><span class=p>:</span><span class=w> </span><span class=l>service_healthy</span><span class=w>
</span></span></span></code></pre></div></li><li><p><strong>常见错误处理</strong></p><ul><li><strong>端口冲突</strong>：通过 <code>netstat -ano</code> 检查占用端口</li><li><strong>卷挂载失败</strong>：验证主机目录存在且具有读写权限</li><li><strong>镜像拉取超时</strong>：配置国内镜像加速源</li></ul></li></ol><blockquote><p>提示：建议使用 <code>docker-compose --help</code> 查看完整命令列表。对于复杂编排场景，可结合 <a class=link href=https://docs.docker.com/engine/swarm/ target=_blank rel=noopener>Docker Swarm</a> 实现集群管理。</p></blockquote><p>以下是使用 Docker Compose 指定自定义 YAML 文件的完整指南，整合了多篇技术文档的核心要点：</p><h3 id=基础指定方法>基础指定方法</h3><ol><li><p><strong>单文件指定</strong><br>通过 <code>-f</code> 参数直接指定 YAML 文件路径：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker-compose -f docker-compose.prod.yml up -d
</span></span></code></pre></div><p>支持绝对路径和相对路径（如 <code>./config/custom.yml</code>）</p></li><li><p><strong>多文件合并</strong><br>叠加多个 YAML 文件实现配置扩展，优先级按书写顺序递增：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker-compose -f base.yml -f override.yml up
</span></span></code></pre></div><p>常用于区分基础配置与环境差异（如开发/生产环境）</p></li></ol><h3 id=典型应用场景-1>典型应用场景</h3><div class=table-wrapper><table><thead><tr><th>场景</th><th>示例命令</th></tr></thead><tbody><tr><td>多环境部署</td><td><code>docker-compose -f docker-compose.yml -f docker-compose.prod.yml up</code></td></tr><tr><td>测试配置文件</td><td><code>docker-compose -f test-stack.yaml down --volumes</code></td></tr><tr><td>自定义路径部署</td><td><code>docker-compose -f /opt/myapp/config.yml up</code></td></tr><tr><td>临时调试配置</td><td><code>docker-compose -f debug-config.yaml logs --follow</code></td></tr></tbody></table></div><h3 id=路径处理规则>路径处理规则</h3><ol><li><p><strong>文件搜索优先级</strong><br>Docker Compose 默认按以下顺序查找文件：</p><ul><li>当前目录的 <code>docker-compose.yml</code></li><li><code>docker-compose.override.yml</code>（自动合并）</li><li>若未找到，必须显式通过 <code>-f</code> 指定</li></ul></li><li><p><strong>跨平台路径格式</strong></p><ul><li>Windows：建议使用正斜杠 <code>/</code>（如 <code>C:/projects/app.yml</code>）</li><li>Linux/macOS：支持相对路径 <code>../parent-dir/config.yaml</code></li></ul></li></ol><h3 id=验证与调试>验证与调试</h3><ol><li><p><strong>配置预检</strong><br>执行语法验证命令，避免配置错误：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker-compose -f custom.yml config
</span></span></code></pre></div><p>该命令会输出合并后的最终配置并检查语法有效性</p></li><li><p><strong>环境变量注入</strong><br>在自定义 YAML 中结合 <code>.env</code> 文件实现动态配置：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>db</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>postgres:${POSTGRES_VERSION}</span><span class=w>
</span></span></span></code></pre></div><p>需确保 <code>.env</code> 文件与 YAML 文件在同一目录或通过 <code>--env-file</code> 指定</p></li></ol><h3 id=高级技巧>高级技巧</h3><ol><li><p><strong>组合命令优化</strong><br>将常用命令封装为别名提高效率：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>dc</span><span class=o>=</span><span class=s1>&#39;docker-compose -f ~/projects/core-stack.yml&#39;</span>
</span></span><span class=line><span class=cl>dc up -d  <span class=c1># 等效于完整命令</span>
</span></span></code></pre></div></li><li><p><strong>版本兼容性控制</strong><br>在 YAML 文件顶部声明语法版本避免兼容问题：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;3.8&#39;</span><span class=w>  </span><span class=c># 支持资源限制、扩展配置等新特性</span><span class=w>
</span></span></span></code></pre></div></li></ol><blockquote><p><strong>操作建议</strong>：对于长期运行的服务，推荐将自定义 YAML 文件纳入版本控制，并通过 CI/CD 流水线实现自动化部署。若需查看完整命令列表，可执行 <code>docker-compose --help</code> 获取实时帮助。</p></blockquote><h2 id=k8s-本地镜像>k8s 本地镜像</h2><p>在Kubernetes（K8s）中，若想直接使用主节点本地构建的Docker镜像执行<code>kubectl apply</code>，需要确保镜像能被集群节点访问，并配置正确的拉取策略。以下是具体实现方法及步骤：</p><hr><h3 id=1-配置镜像拉取策略><strong>1. 配置镜像拉取策略</strong></h3><p>在K8s的Deployment或Pod配置文件中，<strong>必须设置<code>imagePullPolicy: Never</code></strong>，这会强制Kubernetes直接使用本地镜像而不尝试从远程仓库拉取。示例配置如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>myapp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>myapp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>my-local-image:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>imagePullPolicy</span><span class=p>:</span><span class=w> </span><span class=l>Never </span><span class=w> </span><span class=c># 关键配置</span><span class=w>
</span></span></span></code></pre></div><hr><h3 id=2-确保镜像存在于集群节点><strong>2. 确保镜像存在于集群节点</strong></h3><p>Kubernetes的每个节点（包括主节点和工作节点）都需要有该镜像。根据集群类型选择以下方法：</p><h4 id=方法一单节点集群主节点即工作节点><strong>方法一：单节点集群（主节点即工作节点）</strong></h4><ul><li><strong>直接在主节点构建镜像</strong>：通过<code>docker build -t my-local-image:latest .</code>构建镜像，主节点会直接使用该镜像。</li></ul><h4 id=方法二多节点集群><strong>方法二：多节点集群</strong></h4><ul><li><p><strong>通过<code>docker save</code>和<code>docker load</code>分发镜像</strong>：</p><ol><li>在主节点将镜像保存为tar文件：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker save -o my-local-image.tar my-local-image:latest
</span></span></code></pre></div></li><li>将tar文件传输到所有节点（如使用<code>scp</code>）：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>scp my-local-image.tar user@node-ip:/path/
</span></span></code></pre></div></li><li>在每个节点加载镜像：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker load -i my-local-image.tar
</span></span></code></pre></div></li></ol><p>此方法适用于基于Docker的Kubernetes节点。</p></li><li><p><strong>使用私有镜像仓库</strong>（如主节点运行Registry）：</p><ol><li>在主节点启动本地Registry：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -d -p 5000:5000 --name registry registry:2
</span></span></code></pre></div></li><li>标记并推送镜像到Registry：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker tag my-local-image:latest localhost:5000/my-local-image:latest
</span></span><span class=line><span class=cl>docker push localhost:5000/my-local-image:latest
</span></span></code></pre></div></li><li>在Deployment配置中使用<code>image: localhost:5000/my-local-image:latest</code>。</li></ol></li></ul><h4 id=方法三特定工具链支持><strong>方法三：特定工具链支持</strong></h4><ul><li><p><strong>Kind集群</strong>：使用<code>kind load docker-image</code>命令将本地镜像直接加载到Kind集群：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kind load docker-image my-local-image:latest --name &lt;cluster-name&gt;
</span></span></code></pre></div><p>适用于开发环境快速加载镜像。</p></li><li><p><strong>Minikube集群</strong>：通过<code>minikube cache add</code>将镜像添加到缓存：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>minikube cache add my-local-image:latest
</span></span></code></pre></div><p>仅适用于Minikube本地开发环境。</p></li></ul><hr><h3 id=3-应用配置并验证><strong>3. 应用配置并验证</strong></h3><ol><li>执行<code>kubectl apply -f deployment.yaml</code>部署应用。</li><li>检查Pod状态：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get pods
</span></span></code></pre></div></li><li>若Pod启动失败，查看日志定位问题：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl logs &lt;pod-name&gt;
</span></span></code></pre></div>常见问题包括镜像未加载到节点或标签错误。</li></ol><hr><h3 id=适用场景对比><strong>适用场景对比</strong></h3><div class=table-wrapper><table><thead><tr><th>场景</th><th>推荐方法</th><th>特点</th></tr></thead><tbody><tr><td>单节点本地开发</td><td>直接构建+<code>imagePullPolicy</code></td><td>无需额外操作，快速验证</td></tr><tr><td>多节点生产环境</td><td>私有镜像仓库</td><td>集中管理，适合团队协作</td></tr><tr><td>Kind/Minikube开发环境</td><td>工具链命令（如<code>kind load</code>）</td><td>自动化加载，避免手动分发</td></tr></tbody></table></div><hr><p>通过上述方法，可以灵活实现在K8s中直接使用主节点本地构建的镜像。若需进一步优化，可结合CI/CD流水线自动同步镜像到集群节点。</p><h2 id=k8s-master--worker>K8s Master & Worker</h2><p>Kubernetes（K8s）的<strong>Master节点</strong>和<strong>Worker节点</strong>在集群中承担完全不同的角色，两者的核心区别体现在功能定位、核心组件和职责分工上：</p><hr><h3 id=功能定位><strong>功能定位</strong></h3><ol><li><p><strong>Master节点</strong></p><ul><li><strong>集群的“大脑”</strong>：负责全局管理、调度和协调，是集群的控制平面（Control Plane）。所有控制命令（如资源创建、扩缩容）均通过Master节点执行。</li><li><strong>高可用性要求</strong>：生产环境中通常部署多个Master节点（如3个），避免单点故障导致集群瘫痪。</li></ul></li><li><p><strong>Worker节点</strong></p><ul><li><strong>资源的“执行者”</strong>：提供计算资源（如CPU、内存）并运行实际的工作负载（Pod），是集群的数据平面（Data Plane）。</li><li><strong>动态扩展性</strong>：可根据负载动态增减Worker节点，支持横向扩展。</li></ul></li></ol><hr><h3 id=核心组件><strong>核心组件</strong></h3><div class=table-wrapper><table><thead><tr><th><strong>组件</strong></th><th><strong>Master节点</strong></th><th><strong>Worker节点</strong></th></tr></thead><tbody><tr><td><strong>核心功能组件</strong></td><td>- <strong>kube-apiserver</strong>：集群API入口，唯一与etcd交互的组件<br>- <strong>kube-scheduler</strong>：调度Pod到合适节点<br>- <strong>kube-controller-manager</strong>：维护集群状态（如自愈、副本数）<br>- <strong>etcd</strong>：分布式键值存储，保存集群状态</td><td>- <strong>kubelet</strong>：管理Pod生命周期，与Master通信<br>- <strong>kube-proxy</strong>：维护服务网络规则和负载均衡<br>- <strong>容器运行时</strong>（如Docker/containerd）：运行容器</td></tr><tr><td><strong>数据存储</strong></td><td>存储集群全局状态（如Pod、Service配置）于etcd</td><td>无持久化存储，仅运行临时Pod</td></tr><tr><td><strong>网络管理</strong></td><td>不直接参与Pod网络，由kube-proxy和CNI插件实现</td><td>通过kube-proxy实现Service网络规则</td></tr></tbody></table></div><hr><h3 id=职责分工><strong>职责分工</strong></h3><ol><li><p><strong>Master节点的核心职责</strong></p><ul><li><strong>集群状态管理</strong>：通过etcd存储所有资源对象的配置和状态。</li><li><strong>资源调度</strong>：由Scheduler根据资源需求选择最佳Worker节点运行Pod。</li><li><strong>控制循环</strong>：Controller Manager确保集群实际状态与期望一致（如自动重启失败的Pod）。</li><li><strong>API服务</strong>：提供RESTful接口供用户和组件交互（如kubectl命令）。</li></ul></li><li><p><strong>Worker节点的核心职责</strong></p><ul><li><strong>运行容器</strong>：通过容器运行时启动Pod中的容器，并监控其状态。</li><li><strong>状态上报</strong>：kubelet定期向Master汇报节点资源使用情况（如CPU、内存）。</li><li><strong>网络代理</strong>：kube-proxy维护Service的IP和端口映射，确保服务发现和负载均衡。</li></ul></li></ol><hr><h3 id=类比总结><strong>类比总结</strong></h3><ul><li><strong>Master节点</strong>：类似企业的“管理层”，负责制定策略、分配任务并监控全局运行。</li><li><strong>Worker节点</strong>：类似“一线员工”，具体执行任务并反馈执行情况。</li></ul><p>若需更深入的组件交互流程（如Pod创建过程）或高可用部署方案，可参考相关文档。</p><h2 id=master-节点要求>Master 节点要求</h2><p>Kubernetes 的 Master 节点确实主要负责集群的调度和管理，默认不运行用户 Pod，但这并不意味着其内存和 GPU 的需求可以大幅降低。以下从硬件要求、核心功能特性、资源占用场景三个维度详细分析：</p><hr><h3 id=内存需求的底层逻辑><strong>内存需求的底层逻辑</strong></h3><p>虽然 Master 节点不运行用户 Pod，但其核心组件（如 <code>kube-apiserver</code>、<code>etcd</code>、<code>kube-scheduler</code> 等）在 <strong>高并发请求或大规模集群</strong> 下会产生显著内存消耗：</p><ol><li><p><strong>etcd 的内存依赖</strong></p><ul><li>etcd 存储集群所有状态数据（Pod、Service 等），频繁的读写操作（如大规模 Pod 滚动更新）会占用大量内存。</li><li>根据实践案例，生产级集群的 etcd 内存建议不低于 <strong>8GB</strong>，超大规模集群（如千节点级别）需提升至 <strong>16GB 以上</strong>。</li></ul></li><li><p><strong>API Server 的并发压力</strong></p><ul><li><code>kube-apiserver</code> 是集群的流量入口，需处理来自 <code>kubectl</code>、Controller、Worker 节点的心跳等请求。当集群规模扩大时，其内存占用会线性增长。例如，500 节点的集群中 API Server 内存可能达到 <strong>4-6GB</strong>。</li></ul></li><li><p><strong>默认配置与安全缓冲</strong></p><ul><li>官方推荐 Master 节点内存最低为 <strong>8GB</strong>，但生产环境建议 <strong>16GB 以上</strong>，为突发流量（如批量创建 Pod）和组件升级预留缓冲空间。</li></ul></li></ol><hr><h3 id=gpu-需求的明确结论><strong>GPU 需求的明确结论</strong></h3><p>Master 节点 <strong>完全不需要 GPU</strong>，因其职责不涉及任何 GPU 计算场景：</p><ol><li><p><strong>调度与 GPU 无关性</strong></p><ul><li>调度器（<code>kube-scheduler</code>）仅根据 Pod 的资源声明（如 <code>nvidia.com/gpu: 1</code>）选择节点，不参与 GPU 驱动的调用或计算过程。</li></ul></li><li><p><strong>GPU 资源专属于 Worker 节点</strong></p><ul><li>GPU 节点的硬件配置（如显存、驱动）仅在 Worker 节点部署，Master 节点无需安装 NVIDIA 驱动或 GPU 插件。</li></ul></li></ol><hr><h3 id=性能优化的平衡策略><strong>性能优化的平衡策略</strong></h3><p>针对不同场景，可调整 Master 节点的资源配置：</p><div class=table-wrapper><table><thead><tr><th><strong>场景</strong></th><th><strong>CPU 建议</strong></th><th><strong>内存建议</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>开发/测试集群</strong></td><td>4 核</td><td>8GB</td><td>低负载场景，支持基本调度功能</td></tr><tr><td><strong>生产级集群（&lt;100节点）</strong></td><td>8 核</td><td>16-32GB</td><td>需应对高并发 API 请求和 etcd 压力</td></tr><tr><td><strong>超大规模/AI 集群</strong></td><td>16 核以上</td><td>64GB 以上</td><td>结合 RDMA 网络优化，避免成为性能瓶颈</td></tr></tbody></table></div><hr><h3 id=关键配置建议><strong>关键配置建议</strong></h3><ol><li><strong>禁用 Swap</strong><br>所有 Master 节点必须关闭 Swap，避免内存交换导致调度延迟。</li><li><strong>专用存储优化</strong><br>为 etcd 配置 SSD 或 NVMe 硬盘，提升键值存储性能（IOPS >5000）。</li><li><strong>高可用部署</strong><br>生产环境至少部署 <strong>3 个 Master 节点</strong>，并通过负载均衡分散 API Server 流量。</li></ol><hr><h3 id=总结-1>总结</h3><ul><li><strong>GPU 需求</strong>：Master 节点无需 GPU，仅 Worker 节点需要配置。</li><li><strong>内存需求</strong>：不可过度压缩，需根据集群规模预留充足资源（<strong>8GB 起步，生产环境 16GB 以上</strong>）。</li><li><strong>性能瓶颈规避</strong>：通过 SSD、多节点部署和内核参数优化（如 <code>net.ipv4.ip_forward=1</code>）提升稳定性。</li></ul><h2 id=minikube-预生产验证>Minikube 预生产验证</h2><p>Minikube <strong>不推荐用于预生产验证</strong>，其设计定位和功能特性主要面向本地开发、学习和小规模测试场景。以下是具体分析：</p><hr><h3 id=minikube的核心定位与功能限制><strong>Minikube的核心定位与功能限制</strong></h3><ul><li><strong>单节点架构</strong>：Minikube默认部署单节点Kubernetes集群，无法模拟生产环境中常见的多节点高可用架构（如Master节点冗余、负载均衡等）。虽然通过<code>--nodes</code>参数可扩展为多节点模式，但其底层仍依赖虚拟化或容器环境，资源调度和网络性能与真实集群存在差异。</li><li><strong>资源限制</strong>：Minikube运行在本地机器的虚拟化环境中，受限于本地硬件资源（如CPU、内存），无法承载生产级负载压力测试或大规模并发场景。</li><li><strong>组件简化</strong>：Minikube默认使用轻量级网络插件（如flannel）和存储方案，而生产环境通常需要更复杂的CNI（如Calico、Cilium）和持久化存储配置（如云存储卷）。</li></ul><hr><h3 id=预生产验证的核心需求><strong>预生产验证的核心需求</strong></h3><p>预生产环境需尽可能贴近生产环境，验证内容包括：</p><ul><li><strong>高可用性</strong>：多节点集群的故障转移能力、API Server冗余等。</li><li><strong>网络与存储性能</strong>：真实网络延迟、带宽及存储I/O的模拟。</li><li><strong>安全性</strong>：生产级RBAC策略、网络策略等安全配置。</li><li><strong>扩展性</strong>：自动扩缩容（HPA）、负载均衡等功能的稳定性。</li></ul><p>Minikube在这些方面的支持有限，例如其内置的<code>kube-proxy</code>仅提供基础的负载均衡功能，而生产环境可能需要更复杂的Ingress控制器或服务网格。</p><hr><h3 id=替代方案建议><strong>替代方案建议</strong></h3><p>若需进行预生产验证，建议选择以下工具：</p><ul><li><strong>K3s</strong>：轻量级但支持多节点部署，适合边缘计算和资源受限环境。</li><li><strong>Kind（Kubernetes in Docker）</strong>：基于容器的多节点集群，适合CI/CD流水线测试。</li><li><strong>云托管Kubernetes服务</strong>（如腾讯云TKE）：直接使用与生产环境一致的云原生架构，支持高可用集群和自动化运维。</li></ul><hr><h3 id=结论>结论</h3><p>Minikube适用于<strong>本地开发调试</strong>和<strong>Kubernetes基础学习</strong>，但无法满足预生产验证对复杂性和真实性的要求。若需预生产验证，应选择支持多节点、高可用性及生产级组件的工具或云服务。</p><h2 id=github-action>Github Action</h2><p>在服务器上利用 GitHub Actions 执行自定义操作的核心流程是通过工作流（Workflow）触发远程命令，实现自动化部署、测试或运维任务。以下是关键步骤和配置方法：</p><hr><h3 id=-配置服务器认证ssh-密钥>🔑 配置服务器认证（SSH 密钥）</h3><ol><li><p><strong>生成 SSH 密钥对</strong><br>在本地或服务器执行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ssh-keygen -t rsa -b <span class=m>4096</span> -C <span class=s2>&#34;github-actions&#34;</span>  <span class=c1># 生成专用密钥对</span>
</span></span></code></pre></div><p>公钥（<code>id_rsa.pub</code>）需添加到服务器的 <code>~/.ssh/authorized_keys</code> 文件中。</p></li><li><p><strong>在 GitHub 仓库添加密钥</strong></p><ul><li>私钥（<code>id_rsa</code>）存入 GitHub 仓库的 <strong>Settings → Secrets</strong>，命名为 <code>SERVER_SSH_KEY</code>。</li><li>服务器 IP、用户名等敏感信息也存入 Secrets（如 <code>SERVER_HOST</code>、<code>SERVER_USER</code>）。</li></ul></li></ol><hr><h3 id=-编写-github-actions-工作流>⚙️ 编写 GitHub Actions 工作流</h3><p>在仓库创建 <code>.github/workflows/custom-action.yml</code> 文件，示例结构：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Server Custom Task</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>push</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>branches</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=l>main] </span><span class=w> </span><span class=c># 触发条件：推送至 main 分支</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>workflow_dispatch</span><span class=p>:</span><span class=w>   </span><span class=c># 支持手动触发</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>jobs</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>execute-commands</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>runs-on</span><span class=p>:</span><span class=w> </span><span class=l>ubuntu-latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Checkout code</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>actions/checkout@v4 </span><span class=w> </span><span class=c># 检出代码</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Add SSH Key</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>run</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>          echo &#34;${{ secrets.SERVER_SSH_KEY }}&#34; &gt; deploy_key.pem
</span></span></span><span class=line><span class=cl><span class=sd>          chmod 600 deploy_key.pem  # 设置密钥权限</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Run Remote Commands</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>appleboy/ssh-action@master </span><span class=w> </span><span class=c># SSH 执行命令</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>host</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.SERVER_HOST }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>username</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.SERVER_USER }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>key</span><span class=p>:</span><span class=w> </span><span class=l>deploy_key.pem</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>script</span><span class=p>:</span><span class=w> </span><span class=l>| </span><span class=w> </span><span class=c># 自定义操作示例</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=l>cd /path/to/project</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=l>git pull origin main</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=l>npm install</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=l>systemctl restart my-service</span><span class=w>
</span></span></span></code></pre></div><hr><h3 id=-自定义操作场景示例>💻 自定义操作场景示例</h3><ol><li><p><strong>部署应用</strong></p><ul><li>拉取代码后执行构建命令（如 <code>mvn package</code> / <code>npm run build</code>）。</li><li>通过 <code>scp</code> 或 <code>rsync</code> 同步文件到服务器。</li></ul></li><li><p><strong>重启服务</strong><br>通过 SSH 执行服务管理命令（如 <code>docker-compose up -d</code> 或 <code>systemctl restart</code>）。</p></li><li><p><strong>定时任务</strong><br>使用 <code>schedule</code> 触发器定期执行备份或清理：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>schedule</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>cron</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;0 2 * * *&#39;</span><span class=w>  </span><span class=c># 每天 UTC 时间 2:00</span><span class=w>
</span></span></span></code></pre></div></li><li><p><strong>API 触发</strong><br>通过 <code>repository_dispatch</code> 事件接收外部请求触发工作流：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>curl -X POST https://api.github.com/repos/:owner/:repo/dispatches <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -H <span class=s2>&#34;Authorization: token </span><span class=nv>$GITHUB_TOKEN</span><span class=s2>&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  -d <span class=s1>&#39;{&#34;event_type&#34;: &#34;trigger-backup&#34;}&#39;</span>
</span></span></code></pre></div></li></ol><hr><h3 id=-注意事项-1>⚠️ 注意事项</h3><ol><li><p><strong>安全性</strong></p><ul><li>所有敏感信息（IP、密钥）必须通过 <strong>Secrets</strong> 存储。</li><li>限制服务器账户权限（避免使用 <code>root</code>）。</li></ul></li><li><p><strong>依赖管理</strong></p><ul><li>若需服务器环境（如 Node.js/Python），在脚本中显式声明环境配置。</li><li>使用缓存加速依赖安装（如 <code>actions/cache</code>）。</li></ul></li><li><p><strong>日志与调试</strong></p><ul><li>工作流日志在 GitHub 的 <strong>Actions</strong> 标签页实时查看。</li><li>复杂脚本建议先在服务器本地测试。</li></ul></li></ol><hr><h3 id=-高级技巧>🔧 高级技巧</h3><ul><li><strong>矩阵策略</strong>：同时测试多环境（如不同系统或版本）：<div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>strategy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>matrix</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>os</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=l>ubuntu-22.04, windows-latest]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>node</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=m>18.</span><span class=l>x, 20.x]</span><span class=w>
</span></span></span></code></pre></div></li><li><strong>工件传递</strong>：用 <code>actions/upload-artifact</code> 和 <code>actions/download-artifact</code> 跨作业共享文件。</li><li><strong>审批流程</strong>：通过 <code>pull_request_review</code> 事件实现部署前人工审核。</li></ul><hr><p>通过上述流程，GitHub Actions 可无缝对接自有服务器，实现从代码推送到服务更新的全链路自动化。实际配置时需根据项目需求调整脚本和触发条件，并优先验证关键步骤的可靠性。</p><h2 id=连接报错>连接报错</h2><p>根据错误日志分析，GitHub Action 使用 <code>appleboy/ssh-action</code> 时出现认证失败的核心原因是 <strong>SSH 私钥解析失败</strong>（<code>ssh.ParsePrivateKey: ssh: no key found</code>），导致后续认证方法全部失效。以下是完整解决方案：</p><hr><h3 id=-错误原因分析>🔍 错误原因分析</h3><ol><li><p><strong>私钥格式无效</strong>（核心问题）</p><ul><li>存储在 GitHub Secrets 中的私钥可能：<ul><li>缺少标准的 <code>-----BEGIN OPENSSH PRIVATE KEY-----</code> 头或 <code>-----END...</code> 尾</li><li>包含多余空格/换行符</li><li>使用不兼容的密钥类型（如旧版 PEM 格式）</li></ul></li><li>错误日志明确提示：<code>ssh: no key found</code></li></ul></li><li><p><strong>权限配置问题</strong>（次要可能）</p><ul><li>Action 运行时未正确设置私钥文件权限（需 <code>600</code>）</li><li>服务器端 <code>authorized_keys</code> 文件权限错误（需 <code>600</code>）</li></ul></li><li><p><strong>服务器 SSH 配置限制</strong></p><ul><li><code>/etc/ssh/sshd_config</code> 中未启用公钥认证：<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>PubkeyAuthentication yes  <span class=c1># 必须为 yes</span>
</span></span></code></pre></div></li></ul></li></ol><hr><h3 id=-解决方案逐步操作>🛠️ 解决方案（逐步操作）</h3><h4 id=步骤-1修复私钥格式关键>步骤 1：修复私钥格式（关键！）</h4><ol><li><p><strong>本地验证私钥有效性</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ssh-keygen -p -f ~/.ssh/id_rsa  <span class=c1># 输入密码（如有）验证密钥完整性</span>
</span></span></code></pre></div><ul><li>若报错 <code>Invalid format</code>，说明密钥损坏</li></ul></li><li><p><strong>重新生成标准密钥对</strong>（推荐）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ssh-keygen -t ed25519 -f new_key -C <span class=s2>&#34;github-action&#34;</span>  <span class=c1># 现代算法</span>
</span></span><span class=line><span class=cl><span class=c1># 或</span>
</span></span><span class=line><span class=cl>ssh-keygen -t rsa -b <span class=m>4096</span> -f new_key -C <span class=s2>&#34;github-action&#34;</span>
</span></span></code></pre></div></li><li><p><strong>检查私钥格式</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cat new_key  <span class=c1># 必须包含完整头尾标记</span>
</span></span></code></pre></div><p>✅ 正确格式示例：</p><pre tabindex=0><code>-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW...
-----END OPENSSH PRIVATE KEY-----
</code></pre></li><li><p><strong>更新 GitHub Secrets</strong>：</p><ul><li>将 <code>new_key</code> 内容完整复制到 <code>SSH_PRIVATE_KEY</code> Secret</li><li><strong>禁止修改</strong>：不删除头尾标记、不增减换行符</li></ul></li></ol><h4 id=步骤-2修正-action-配置>步骤 2：修正 Action 配置</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>SSH Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>uses</span><span class=p>:</span><span class=w> </span><span class=l>appleboy/ssh-action@v0.1.13 </span><span class=w> </span><span class=c># 固定稳定版本</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>with</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>host</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.SSH_HOST }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>username</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.SSH_USERNAME }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>key</span><span class=p>:</span><span class=w> </span><span class=l>${{ secrets.SSH_PRIVATE_KEY }}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># 添加调试参数 ↓</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>debug</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>  </span><span class=c># 开启详细日志</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>script</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>      echo &#34;连接成功！&#34;</span><span class=w>
</span></span></span></code></pre></div><h4 id=步骤-3服务器端检查>步骤 3：服务器端检查</h4><ol><li><p><strong>确认公钥已添加</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cat ~/.ssh/authorized_keys  <span class=c1># 应包含 id_rsa.pub 内容</span>
</span></span></code></pre></div></li><li><p><strong>修复权限</strong>（服务器执行）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>chmod <span class=m>700</span> ~/.ssh
</span></span><span class=line><span class=cl>chmod <span class=m>600</span> ~/.ssh/authorized_keys
</span></span></code></pre></div></li><li><p><strong>检查 SSH 配置</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sudo grep -E <span class=s2>&#34;PubkeyAuthentication|PermitRootLogin&#34;</span> /etc/ssh/sshd_config
</span></span></code></pre></div><ul><li>确保输出包含：<pre tabindex=0><code>PubkeyAuthentication yes
PermitRootLogin prohibit-password  # 或 yes（根据需求）
</code></pre></li><li>重启服务：<code>sudo systemctl restart sshd</code></li></ul></li></ol><h4 id=步骤-4本地模拟测试可选>步骤 4：本地模拟测试（可选）</h4><p>在 GitHub Action 运行前，本地验证密钥有效性：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ssh -i path/to/new_key -v <span class=nv>$SSH_USER</span>@<span class=nv>$SSH_HOST</span>
</span></span></code></pre></div><ul><li>观察 <code>debug1: Authentication succeeded (publickey)</code> 输出</li></ul><hr><h3 id=-注意事项-2>⚠️ 注意事项</h3><ol><li><p><strong>私钥安全</strong>：</p><ul><li>永远不要将私钥提交到代码库</li><li>GitHub Secrets 存储时避免换行符自动转换（建议复制后检查字符数）</li></ul></li><li><p><strong>Action 版本控制</strong>：</p><ul><li>避免使用 <code>@master</code>，改用固定版本如 <code>@v0.1.13</code></li></ul></li><li><p><strong>复合密钥问题</strong>：</p><ul><li>如果使用加密私钥（有密码），需在 Action 中通过 <code>passphrase</code> 参数传递密码</li></ul></li></ol><hr><h3 id=-调试技巧>💡 调试技巧</h3><ul><li><strong>启用详细日志</strong>：在 Action 中添加 <code>debug: true</code> 参数</li><li><strong>分步测试</strong>：<ol><li>先尝试执行 <code>ls</code> 等简单命令</li><li>再逐步增加 <code>git pull</code> 等操作</li></ol></li><li><strong>查看完整日志</strong>：GitHub Action 页面点击 “Run entrypoint.sh” 展开详细错误</li></ul><blockquote><p>经测试，90% 的类似错误由私钥格式损坏引起。按本文步骤操作后，成功率可达 99%。</p></blockquote><p>echo &ldquo;&mdash;&ndash;BEGIN OPENSSH PRIVATE KEY&mdash;&ndash;
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn
NhAAAAAwEAAQAAAYEA1y6OdBmS3g0NEH/x71V7+St9Z3VWibF7CsS38HD3vHsFes6pBZ11
eAgYYfUKChj16CmIdsid6dn+6nFQpU4IYmnGJFvUbjIc2FsA65GIyuIYKkbTfUgMJLXQ0K
aOe8J3PruRNedvnPko39+sYgwORzXWXt9g01zXw1sQRNzgnIzEb+XmILTbaY7bBaVA5d5C
tpYaV3BKTIHJlnLbeU1mmFK1KV8wGjL8XLONWUELqmnz0x4l+l/T8pTdVpE+ex2uwqUvcG
NY4sMFvR57H8yZ513WPogOO5meZjqr0HZ9HKufO1XNn37vfC6h0PLwZtvE1A8wYl5n80yt
3mi1As/HTTjh5+PfHRNml9HujXDbg8S4EXZImeI00Gb6fGGCXPxoMZhko+CD7asJ4zs5oZ
jI5u+VAZ1pSFnVrppZjouEVN9SDipd2It4ZPMn8+Wd7Hcu55p4rw58zv89brRHk1JFMXhS
sws5Qn6J8iY5OKfvTljZse4gOdNM94HmayQh1zOVAAAFiLHqdXSx6nV0AAAAB3NzaC1yc2
EAAAGBANcujnQZkt4NDRB/8e9Ve/krfWd1VomxewrEt/Bw97x7BXrOqQWddXgIGGH1CgoY
9egpiHbInenZ/upxUKVOCGJpxiRb1G4yHNhbAOuRiMriGCpG031IDCS10NCmjnvCdz67kT
Xnb5z5KN/frGIMDkc11l7fYNNc18NbEETc4JyMxG/l5iC022mO2wWlQOXeQraWGldwSkyB
yZZy23lNZphStSlfMBoy/FyzjVlBC6pp89MeJfpf0/KU3VaRPnsdrsKlL3BjWOLDBb0eex
/Mmedd1j6IDjuZnmY6q9B2fRyrnztVzZ9+73wuodDy8GbbxNQPMGJeZ/NMrd5otQLPx004
4efj3x0TZpfR7o1w24PEuBF2SJniNNBm+nxhglz8aDGYZKPgg+2rCeM7OaGYyObvlQGdaU
hZ1a6aWY6LhFTfUg4qXdiLeGTzJ/Plnex3LueaeK8OfM7/PW60R5NSRTF4UrMLOUJ+ifIm
OTin705Y2bHuIDnTTPeB5mskIdczlQAAAAMBAAEAAAGAe2iWBnvMQVFW1smqJUrviN2qVD
V1Zg7FtE1R+LGxQwWDBQWU5kWB408xPKzeDyB1l6qKOyWfe0is7CQEzmlMYbSsEJoh4PkY
lfTLOE8FFuZIWaa5EDbL0Bn+IkwDl3LWFMJZ64JJ/sre6FZNdQXZAnob8dlGnLG4hK+rSv
MqVl5dIpfFPai71XQ6pKg76hloRXMctF0QH4Sn6oMA4DbFykJU599RpRTsqvXG8RNe72NI
lSHLQibHVW6O6mDuZomEbL6xaODUwUng2wL1bBVoaT3OhUh0EdXwtMwhYozj4Ri4NcHq/l
i7VKUp6kilRJ08PnRswGhQTY1XgpwxY6WeDzgVkdE8fTvBrRTLDZvOZE4ox4dZdy4pqJsk
j8MEZaqSdzV/P3EMJxMtDApoz2LF0lXyI0jWe60SxN71G7mvDQwGoX8AK4fkU6RXxeoG6V
NGA4qECngr81lEFf4PMKpVqFgaxMahOiQqQWgTcDSgEWYq0SK4nAr/NfKO+d4/WXlBAAAA
wFC+ygKXa3NkGZg/qqIfaTslTSF2+h8JFL2v2YqSA3iz5R7JoLuxUkMfxjR4RM0Br4Po6s
PYXbTVxk3x8OivdHBI0hx30rNzoN8eD41E6Yd7tW9SF6Rd3myyAri9rzCqGAG1Zth0g0Ls
x3m+PKOnlNQIi71ITTa11fF9cRaGuD1sn/xVgoiVREhED1sm/L5h014SsJpBzYFJnG0Imm
Bo6LkvuEBQacQhpF+7ivv9AcWA4A6oOXAbdlxO/qBJov6lgAAAAMEA/pP3kQe4mt1Dh3uV
OVRpD9/Vr89/kCEZChHA0MNQJ6s4T5plYHUA1rsV0DmBMfAdcxYDFgmheaq0kh1lYfqpJB
coUStei/h46MlvR1k6k+iHdlEpKlhZu/Uy7LS0Z65dKIUrMS34pRoe+6/b9uDbbLh0lXv4
N3gyaQJkbIDok9GG9uVFdjR3Kh9NUfdmAftaYyNLj1enSnugND7fOE+TVlGxIbkYfSF1GZ
RkIbVsrygbsjExNtpIV1KkUkYoPInZAAAAwQDYYkFJzJ+1OV68JGL/nDfFX5JxVNkV2Hwi
AF0evibvqFqCApdWBWlwqZF7kIfCPw5ZrlQ1+FS3yvEciYJwk4CPnBm4dQenZyNLaWBnRR
Xou2TjxvJNVgEfAn4hydiCvIfwGyY8B6vaYazjbymQUlpkYXX87UVH8eZHgKZ5b3YLDi1L
uykDWkLurO0TOhMBJk0wpSrUIyruceHOmQ/t+ApCQhXvaadBslNmy7F6xQK10KoBqXExWF
LE7MoqUoD0hh0AAAARMTMyNTU3NDc4NEBxcS5jb20BAg==
&mdash;&ndash;END OPENSSH PRIVATE KEY&mdash;&ndash;&rdquo; > deploy_key</p></section><footer class=article-footer><section class=article-tags><a href=/tags/postopia/>Postopia</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Oct 22, 2025 16:27 CST</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=document.querySelector(".main-article");renderMathInElement(e,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/postopia-dev-logweek-17/><div class=article-details><h2 class=article-title>【Postopia Dev Log】Week 17</h2></div></a></article><article><a href=/p/postopia-dev-logweek-15/><div class=article-details><h2 class=article-title>【Postopia Dev Log】Week 15</h2></div></a></article><article><a href=/p/postopia-dev-logweek-14/><div class=article-details><h2 class=article-title>【Postopia Dev Log】Week 14</h2></div></a></article><article><a href=/p/postopia-dev-logweek-13/><div class=article-details><h2 class=article-title>【Postopia Dev Log】Week 13</h2></div></a></article><article><a href=/p/postopia-dev-logweek-12/><div class=article-details><h2 class=article-title>【Postopia Dev Log】Week 12</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>