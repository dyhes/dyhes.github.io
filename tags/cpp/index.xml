<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CPP on 飞鸿踏雪泥</title><link>https://dyhes.github.io/tags/cpp/</link><description>Recent content in CPP on 飞鸿踏雪泥</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 22 Oct 2025 16:27:30 +0800</lastBuildDate><atom:link href="https://dyhes.github.io/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>【NowCoder】CPP</title><link>https://dyhes.github.io/p/nowcodercpp/</link><pubDate>Tue, 09 Sep 2025 00:00:00 +0000</pubDate><guid>https://dyhes.github.io/p/nowcodercpp/</guid><description>&lt;h2 id="运算符重载"&gt;运算符重载
&lt;/h2&gt;&lt;p&gt;C++ 的运算符重载功能允许你为用户自定义类型（如类或结构体）赋予与内置类型相似的操作行为。下面通过一个表格汇总了可重载与不可重载的运算符，并解释了相关规则和注意事项。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;可重载的运算符&lt;/th&gt;
&lt;th&gt;不可重载的运算符&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;算术运算符&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;关系运算符&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;位运算符&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;, `&lt;/td&gt;
&lt;td&gt;&lt;code&gt;,&lt;/code&gt;^&lt;code&gt;（按位异或）,&lt;/code&gt;~&lt;code&gt;（按位取反）,&lt;/code&gt;&amp;laquo;&lt;code&gt;（左移）,&lt;/code&gt;&amp;raquo;&lt;code&gt;（右移）,&lt;/code&gt;&amp;amp;=&lt;code&gt;,&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;逻辑运算符&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!&lt;/code&gt;（逻辑非）, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;（逻辑与）, `&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;其他运算符&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[]&lt;/code&gt;（下标）, &lt;code&gt;()&lt;/code&gt;（函数调用）, &lt;code&gt;-&amp;gt;&lt;/code&gt;（成员指针访问）, &lt;code&gt;,&lt;/code&gt;（逗号）, &lt;code&gt;=&lt;/code&gt;（赋值）, &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;new[]&lt;/code&gt;, &lt;code&gt;delete[]&lt;/code&gt;, &lt;code&gt;.*&lt;/code&gt;（成员指针访问，&lt;strong&gt;只能作为成员函数重载&lt;/strong&gt;）&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;不可重载运算符&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;::&lt;/code&gt;（作用域解析）, &lt;code&gt;.*&lt;/code&gt;（成员对象选择？）, &lt;code&gt;.&lt;/code&gt;（成员访问）, &lt;code&gt;?:&lt;/code&gt;（三目条件）, &lt;code&gt;sizeof&lt;/code&gt;, &lt;code&gt;typeid&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;⚠️ &lt;strong&gt;重载运算符的核心规则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不改变优先级和结合性&lt;/strong&gt;：重载不会改变运算符原有的优先级和结合性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不改变操作数个数&lt;/strong&gt;：例如，重载的 &lt;code&gt;+&lt;/code&gt;运算符仍然是二元运算符。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;至少一个用户定义类型&lt;/strong&gt;：重载运算符的函数其参数中必须至少有一个是用户自定义的类型（类或结构体）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不能创建新运算符&lt;/strong&gt;：只能重载 C++ 语言中已有的、允许重载的运算符。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保持语义一致性&lt;/strong&gt;：重载的运算符应与其原有功能类似，避免滥用导致代码可读性下降（例如，不应使用 &lt;code&gt;+&lt;/code&gt;运算符来实现减法操作）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;📝 &lt;strong&gt;如何重载运算符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运算符重载可以通过两种方式实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;成员函数形式&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;二元运算符的参数列表中只有一个显式参数（另一个是隐含的 &lt;code&gt;this&lt;/code&gt;指针），一元运算符则没有显式参数。&lt;/li&gt;
&lt;li&gt;例如：&lt;code&gt;ClassName operator+(const ClassName&amp;amp; other) const;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;赋值运算符(&lt;code&gt;=&lt;/code&gt;)、下标运算符(&lt;code&gt;[]&lt;/code&gt;)、函数调用运算符(&lt;code&gt;()&lt;/code&gt;)、成员访问运算符(&lt;code&gt;-&amp;gt;&lt;/code&gt;) &lt;strong&gt;必须&lt;/strong&gt;作为成员函数重载。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非成员函数形式（通常声明为友元）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;二元运算符需要两个显式参数，一元运算符需要一个显式参数。&lt;/li&gt;
&lt;li&gt;通常需要将其声明为类的 &lt;code&gt;友元（friend）&lt;/code&gt;函数以便访问私有成员。&lt;/li&gt;
&lt;li&gt;这种形式对于需要&lt;strong&gt;对称性&lt;/strong&gt;的操作（如 &lt;code&gt;(你的类对象 + 整数)&lt;/code&gt;和 &lt;code&gt;(整数 + 你的类对象)&lt;/code&gt;）或当左操作数不是该类对象时（如重载 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;用于输出）非常有用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;💡 &lt;strong&gt;一些实用建议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;成对重载&lt;/strong&gt;：例如，如果重载了 &lt;code&gt;==&lt;/code&gt;，通常也应重载 &lt;code&gt;!=&lt;/code&gt;；重载了 &lt;code&gt;&amp;lt;&lt;/code&gt;，往往也应考虑重载 &lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;=&lt;/code&gt;、&lt;code&gt;&amp;gt;=&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意返回值&lt;/strong&gt;：赋值运算符（&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;等）通常应返回当前对象的引用（&lt;code&gt;ClassName&amp;amp;&lt;/code&gt;）以支持链式赋值（如 &lt;code&gt;a = b = c&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;前后缀区分&lt;/strong&gt;：重载前置 &lt;code&gt;++&lt;/code&gt;和后置 &lt;code&gt;++&lt;/code&gt;时，后置版本接受一个额外的 &lt;code&gt;int&lt;/code&gt;类型占位参数以示区分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;运算符重载能极大提升代码的可读性和易用性，但务必谨慎使用，确保其行为符合直觉，并严格遵守 C++ 的规则。&lt;/p&gt;
&lt;h2 id="友元运算符"&gt;友元运算符
&lt;/h2&gt;&lt;p&gt;在 C++ 中，将运算符重载为&lt;strong&gt;友元函数&lt;/strong&gt;还是&lt;strong&gt;成员函数&lt;/strong&gt;，主要区别在于封装性、参数传递方式以及对操作数位置的灵活性上。下面这个表格汇总了核心差异，方便你快速了解：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;友元运算符重载 (Friend Operator Overloading)&lt;/th&gt;
&lt;th&gt;成员函数运算符重载 (Member Function Operator Overloading)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;基本定义&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;全局函数，使用 &lt;code&gt;friend&lt;/code&gt;关键字在类内声明&lt;/td&gt;
&lt;td&gt;类的成员函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;this&lt;/code&gt;指针&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;没有 &lt;code&gt;this&lt;/code&gt;指针&lt;/td&gt;
&lt;td&gt;隐含 &lt;code&gt;this&lt;/code&gt;指针，指向左操作数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;参数个数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;双目运算符需两个显式参数，单目运算符需一个显式参数&lt;/td&gt;
&lt;td&gt;双目运算符需一个显式参数（左操作数由 &lt;code&gt;this&lt;/code&gt;指出），单目运算符无需参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;左操作数类型限制&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;可以是任意类型（包括非类类型）&lt;/td&gt;
&lt;td&gt;必须是该类的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;对称性操作支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;⭐ 支持（如 &lt;code&gt;obj + 3&lt;/code&gt;和 &lt;code&gt;3 + obj&lt;/code&gt;都可行）&lt;/td&gt;
&lt;td&gt;❌ 不支持（若左操作数非该类对象则无法编译）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;访问私有成员&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;声明为友元后可以访问&lt;/td&gt;
&lt;td&gt;天然可以访问&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;封装性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;会破坏封装性（因其不是成员函数却可访问私有部分）&lt;/td&gt;
&lt;td&gt;良好地封装在类内部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;某些运算符的限制&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;不能重载 &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;()&lt;/code&gt;, &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;-&amp;gt;&lt;/code&gt;为友元函数&lt;/td&gt;
&lt;td&gt;赋值运算符(&lt;code&gt;=&lt;/code&gt;)、下标运算符(&lt;code&gt;[]&lt;/code&gt;)、函数调用运算符(&lt;code&gt;()&lt;/code&gt;)、成员访问运算符(&lt;code&gt;-&amp;gt;&lt;/code&gt;) &lt;strong&gt;必须&lt;/strong&gt;作为成员函数重载&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;📌 &lt;strong&gt;如何选择友元还是成员函数形式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优先考虑友元函数的情况&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;需要&lt;strong&gt;支持对称性运算&lt;/strong&gt;（例如 &lt;code&gt;a + b&lt;/code&gt;和 &lt;code&gt;b + a&lt;/code&gt;都应有效），尤其是左操作数可能是基本类型或其他类类型时。&lt;/li&gt;
&lt;li&gt;运算符的&lt;strong&gt;左操作数不是当前类的对象&lt;/strong&gt;（例如重载 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;用于输出时，左操作数是 &lt;code&gt;std::ostream&lt;/code&gt;对象，必须使用友元或非成员函数）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关系运算符&lt;/strong&gt;（如 &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;等）通常也建议重载为友元函数以实现对称性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先考虑成员函数的情况&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;赋值类运算符&lt;/strong&gt;，如 &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;等，因为它们通常直接修改左操作数对象的状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一元运算符&lt;/strong&gt;，如 &lt;code&gt;++&lt;/code&gt;（前置和后置）、&lt;code&gt;--&lt;/code&gt;（前置和后置）、&lt;code&gt;*&lt;/code&gt;（解引用）、&lt;code&gt;-&amp;gt;&lt;/code&gt;（成员访问）等，通常也使用成员函数形式重载。&lt;/li&gt;
&lt;li&gt;当运算符&lt;strong&gt;自然地将左操作数作为当前对象&lt;/strong&gt;，且不需要对称性时。&lt;/li&gt;
&lt;li&gt;希望&lt;strong&gt;保持良好的封装性&lt;/strong&gt;，避免友元机制带来的封装突破。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;💡 &lt;strong&gt;一个简单例子&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
class MyNumber {
private:
int value;
public:
MyNumber(int v = 0) : value(v) {}
// 成员函数重载：MyNumber + int
MyNumber operator+(int rhs) const {
return MyNumber(value + rhs);
}
// 友元函数重载：int + MyNumber (需要访问私有成员value，故声明为友元)
friend MyNumber operator+(int lhs, const MyNumber&amp;amp; rhs);
void print() const {
std::cout &amp;lt;&amp;lt; value &amp;lt;&amp;lt; std::endl;
}
};
// 友元函数实现：int + MyNumber
MyNumber operator+(int lhs, const MyNumber&amp;amp; rhs) {
return MyNumber(lhs + rhs.value);
}
int main() {
MyNumber num(5);
MyNumber result1 = num + 10; // 使用成员运算符：MyNumber + int
MyNumber result2 = 10 + num; // 使用友元运算符：int + MyNumber
result1.print(); // 输出 15
result2.print(); // 输出 15
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;⚡ &lt;strong&gt;重要提醒&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;谨慎使用友元&lt;/strong&gt;：友元关系会&lt;strong&gt;破坏封装性&lt;/strong&gt;，应仅在必要时使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无法重载为友元的运算符&lt;/strong&gt;：&lt;code&gt;=&lt;/code&gt;、&lt;code&gt;()&lt;/code&gt;、&lt;code&gt;[]&lt;/code&gt;、&lt;code&gt;-&amp;gt;&lt;/code&gt;这些运算符&lt;strong&gt;不能&lt;/strong&gt;被重载为友元函数，它们&lt;strong&gt;必须&lt;/strong&gt;作为类的成员函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt;：重载运算符时，应确保其行为符合该运算符的直观含义，避免滥用导致代码难以理解。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;希望这些解释能帮助你更好地理解 C++ 中友元运算符重载和成员函数运算符重载的区别。&lt;/p&gt;
&lt;h2 id="类型转换"&gt;类型转换
&lt;/h2&gt;&lt;p&gt;C++ 中的类型转换机制丰富且各有其特定用途，理解它们对编写安全且高效的代码至关重要。下面我将为你系统介绍 C++ 中的各种类型转换方式。&lt;/p&gt;
&lt;h3 id="-一隐式类型转换-implicit-conversion"&gt;🔄 一、隐式类型转换 (Implicit Conversion)
&lt;/h3&gt;&lt;p&gt;隐式转换由&lt;strong&gt;编译器自动完成&lt;/strong&gt;，无需程序员显式指定。常见于以下几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;算术转换 (Arithmetic Conversion)&lt;/strong&gt;：在表达式中不同类型数据运算时，精度较低的类型通常会转换为精度较高的类型。例如 &lt;code&gt;int&lt;/code&gt;与 &lt;code&gt;double&lt;/code&gt;运算时，&lt;code&gt;int&lt;/code&gt;会被转换为 &lt;code&gt;double&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;赋值转换&lt;/strong&gt;：将一种类型的值赋给另一种类型的变量时发生。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数调用转换&lt;/strong&gt;：传递实参给形参时，若类型不匹配，会尝试隐式转换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化转换&lt;/strong&gt;：用不同类型初始化变量时可能发生转换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;派生类向基类转换&lt;/strong&gt;：在继承关系中，派生类的指针或引用可以安全地转换为基类的指针或引用（向上转型）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：隐式转换虽然方便，但可能导致&lt;strong&gt;精度损失&lt;/strong&gt;或&lt;strong&gt;意想不到的行为&lt;/strong&gt;，应密切关注。&lt;/p&gt;
&lt;h3 id="-二显式类型转换-explicit-conversion"&gt;⌨️ 二、显式类型转换 (Explicit Conversion)
&lt;/h3&gt;&lt;p&gt;当需要明确控制转换过程时，需使用显式转换。&lt;/p&gt;
&lt;h4 id="1-c-风格转换-typeexpression"&gt;1. C 风格转换 [(type)expression]
&lt;/h4&gt;&lt;p&gt;C 风格转换使用 &lt;code&gt;(目标类型)&lt;/code&gt;的语法，功能强大但&lt;strong&gt;不够安全&lt;/strong&gt;，因其几乎允许任何类型间的转换，容易引发未定义行为，且转换意图不够清晰。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;double d = 3.14;
int i = (int)d; // C 风格转换，将 double 转换为 int
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="2-函数式转换-typeexpression"&gt;2. 函数式转换 [type(expression)]
&lt;/h4&gt;&lt;p&gt;函数式转换在 C++ 中也可用，但与 C 风格转换存在类似的安全性问题。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;int i = int(d); // 函数式风格转换
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="3-c-命名强制转换运算符-named-cast-operators"&gt;3. C++ 命名强制转换运算符 (Named Cast Operators)
&lt;/h4&gt;&lt;p&gt;C++ 引入了四种显式的强制转换运算符，更安全且意图更清晰：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;转换运算符&lt;/th&gt;
&lt;th&gt;主要用途&lt;/th&gt;
&lt;th&gt;检查时机&lt;/th&gt;
&lt;th&gt;安全性&lt;/th&gt;
&lt;th&gt;常见应用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;static_cast&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;相关类型间的转换&lt;/td&gt;
&lt;td&gt;编译时&lt;/td&gt;
&lt;td&gt;相对安全，但下行转换（基类→派生类）可能不安全&lt;/td&gt;
&lt;td&gt;基本类型转换、向上转型、空指针转换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;多态类型间的安全向下转换和交叉转换&lt;/td&gt;
&lt;td&gt;运行时&lt;/td&gt;
&lt;td&gt;安全，转换失败返回 &lt;code&gt;nullptr&lt;/code&gt;（指针）或抛出 &lt;code&gt;bad_cast&lt;/code&gt;异常（引用）&lt;/td&gt;
&lt;td&gt;在继承层次中进行安全的向下转型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;const_cast&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;添加或移除 &lt;code&gt;const&lt;/code&gt;或 &lt;code&gt;volatile&lt;/code&gt;限定符&lt;/td&gt;
&lt;td&gt;编译时&lt;/td&gt;
&lt;td&gt;需谨慎使用，修改原常量对象是未定义行为&lt;/td&gt;
&lt;td&gt;去除常量性以适配函数参数（但不应修改常量对象）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;低级别的重新解释位模式，几乎不受限制的类型转换&lt;/td&gt;
&lt;td&gt;编译时&lt;/td&gt;
&lt;td&gt;非常不安全，高度依赖平台和编译器&lt;/td&gt;
&lt;td&gt;指针与整数间的转换、不同类型指针间的转换（如网络数据包处理）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面是这四种转换的详细说明和示例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;static_cast&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于相关类型之间的转换，是最通用且最常用的 C++ 转换方式。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;double d = 3.14;
int i = static_cast&amp;lt;int&amp;gt;(d); // 基本数据类型转换
class Base {};
class Derived : public Base {};
Derived* derivedPtr = new Derived;
Base* basePtr = static_cast&amp;lt;Base*&amp;gt;(derivedPtr); // 向上转型，安全
// Base* basePtr2 = new Base;
// Derived* derivedPtr2 = static_cast&amp;lt;Derived*&amp;gt;(basePtr2); // 向下转型，不安全！
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;dynamic_cast&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;专门用于&lt;strong&gt;含有虚函数&lt;/strong&gt;的多态类体系，在运行时进行类型检查，确保转换安全。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;class Base { virtual void dummy() {} }; // 至少有一个虚函数
class Derived : public Base {};
Base* basePtr = new Derived;
Derived* derivedPtr = dynamic_cast&amp;lt;Derived*&amp;gt;(basePtr); // 安全向下转型
if (derivedPtr) { // 检查是否转换成功
// 转换成功，使用 derivedPtr
} else {
// 转换失败
}
delete basePtr;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;const_cast&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要用于&lt;strong&gt;添加或移除 &lt;code&gt;const&lt;/code&gt;&lt;/strong&gt;（或 &lt;code&gt;volatile&lt;/code&gt;）限定符。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;const int ci = 10;
int* modifiable = const_cast&amp;lt;int*&amp;gt;(&amp;amp;ci); // 移除 const 限定
// *modifiable = 20; // 危险！原对象是常量，这是未定义行为
void print(char* str);
const char* msg = &amp;#34;hello&amp;#34;;
print(const_cast&amp;lt;char*&amp;gt;(msg)); // 合法使用：适配函数参数（但函数不应修改 msg）
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;reinterpret_cast&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供低级别的重新解释，&lt;strong&gt;不进行任何类型检查&lt;/strong&gt;，极其不安全，应谨慎使用。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;int i = 42;
int* p = &amp;amp;i;
uintptr_t addr = reinterpret_cast&amp;lt;uintptr_t&amp;gt;(p); // 将指针转换为整数
char* charPtr = reinterpret_cast&amp;lt;char*&amp;gt;(p); // 将 int* 重新解释为 char*
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-三用户定义的类型转换-user-defined-conversions"&gt;🧪 三、用户定义的类型转换 (User-Defined Conversions)
&lt;/h3&gt;&lt;p&gt;用户可以为自定义类型（类）定义转换行为，主要通过两种方式：&lt;/p&gt;
&lt;h4 id="1-转换构造函数-conversion-constructor"&gt;1. 转换构造函数 (Conversion Constructor)
&lt;/h4&gt;&lt;p&gt;一个只有一个参数（或多个参数但只有第一个无默认值）的非 explicit 构造函数，可以从参数类型隐式转换为该类类型。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;class Meter {
public:
Meter(double value) : m_value(value) {} // 允许从 double 到 Meter 的转换
double getValue() const { return m_value; }
private:
double m_value;
};
void printLength(Meter m) {
std::cout &amp;lt;&amp;lt; m.getValue() &amp;lt;&amp;lt; &amp;#34; meters&amp;#34; &amp;lt;&amp;lt; std::endl;
}
int main() {
Meter m = 5.5; // 隐式转换：double -&amp;gt; Meter
printLength(10.2); // 隐式转换：double -&amp;gt; Meter
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 &lt;code&gt;explicit&lt;/code&gt;关键字可以防止隐式转换，避免意外行为。&lt;/p&gt;
&lt;h4 id="2-类型转换运算符-type-conversion-operator"&gt;2. 类型转换运算符 (Type Conversion Operator)
&lt;/h4&gt;&lt;p&gt;允许将类类型对象转换为其他类型。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;class Inch {
public:
Inch(double value) : m_value(value) {}
explicit operator double() const { // 显式定义从 Inch 到 double 的转换
return m_value;
}
operator Meter() const { // 隐式定义从 Inch 到 Meter 的转换（可能不推荐）
return Meter(m_value * 0.0254);
}
private:
double m_value;
};
int main() {
Inch i(12);
double d = static_cast&amp;lt;double&amp;gt;(i); // 显式调用 operator double()
Meter m = i; // 隐式调用 operator Meter()
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同样，&lt;code&gt;explicit&lt;/code&gt;关键字可用于转换运算符以防止隐式转换。&lt;/p&gt;
&lt;h3 id="-四类型转换的选择指南与最佳实践"&gt;💡 四、类型转换的选择指南与最佳实践
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;优先使用 C++ 风格转换&lt;/strong&gt;：相比 C 风格转换，&lt;code&gt;static_cast&lt;/code&gt;, &lt;code&gt;dynamic_cast&lt;/code&gt;, &lt;code&gt;const_cast&lt;/code&gt;, &lt;code&gt;reinterpret_cast&lt;/code&gt;更安全，意图更清晰，便于检查和维护。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;谨慎使用隐式转换&lt;/strong&gt;：注意隐式转换可能带来的精度损失或意想不到行为，对单参数构造函数考虑使用 &lt;code&gt;explicit&lt;/code&gt;关键字。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;向下转型时优先使用 &lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/strong&gt;：在继承层次中进行向下转型时，&lt;code&gt;dynamic_cast&lt;/code&gt;提供运行时检查，比 &lt;code&gt;static_cast&lt;/code&gt;更安全。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;敬畏 &lt;code&gt;reinterpret_cast&lt;/code&gt;&lt;/strong&gt;：这是最不安全的转换，除非底层编程（如硬件交互、特定系统编程）等必需场景，否则尽量避免。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尊重 &lt;code&gt;const&lt;/code&gt;正确性&lt;/strong&gt;：不要轻易使用 &lt;code&gt;const_cast&lt;/code&gt;来修改常量对象，这常导致未定义行为。主要用于适配旧接口等特殊场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免转换歧义&lt;/strong&gt;：为用户自定义类型定义转换函数时，确保转换路径唯一，避免编译器因多个转换路径而无法抉择。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="-五其他类型转换工具"&gt;⚙️ 五、其他类型转换工具
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::any_cast&lt;/code&gt;&lt;/strong&gt; (C++17 引入)：与 &lt;code&gt;std::any&lt;/code&gt;配合使用，安全地获取 &lt;code&gt;std::any&lt;/code&gt;对象中存储的值。如果类型不匹配，会抛出 &lt;code&gt;std::bad_any_cast&lt;/code&gt;异常。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;#include &amp;lt;any&amp;gt;
#include &amp;lt;string&amp;gt;
std::any a = std::string(&amp;#34;hello&amp;#34;);
try {
std::string s = std::any_cast&amp;lt;std::string&amp;gt;(a);
} catch(const std::bad_any_cast&amp;amp; e) {
// 处理类型不匹配
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标准库字符串与数值的转换&lt;/strong&gt;：如 &lt;code&gt;std::stoi&lt;/code&gt;(string to int), &lt;code&gt;std::stod&lt;/code&gt;(string to double), &lt;code&gt;std::to_string&lt;/code&gt;(number to string) 等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;掌握 C++ 的类型转换机制，能帮助你在代码的灵活性、安全性和清晰度之间找到最佳平衡。&lt;/p&gt;
&lt;h2 id="类型转换函数"&gt;类型转换函数
&lt;/h2&gt;&lt;p&gt;C++ 中的&lt;strong&gt;类型转换函数&lt;/strong&gt;（Type Conversion Function）是一种特殊的成员函数，它允许你将&lt;strong&gt;类类型的对象&lt;/strong&gt;隐式或显式地转换为&lt;strong&gt;其他指定类型&lt;/strong&gt;（基本类型或其他类类型）。这增强了类的互操作性和灵活性。&lt;/p&gt;
&lt;p&gt;下面是一个快速对比，帮助你理解类型转换函数与其他相关概念：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;类型转换函数 (Type Conversion Function)&lt;/th&gt;
&lt;th&gt;转换构造函数 (Conversion Constructor)&lt;/th&gt;
&lt;th&gt;C++风格强制转换 (static_cast等)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;定义位置&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;类的成员函数&lt;/td&gt;
&lt;td&gt;类的构造函数&lt;/td&gt;
&lt;td&gt;语言内置关键字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;转换方向&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;从类类型&lt;/strong&gt;转换为其他类型&lt;/td&gt;
&lt;td&gt;从其他类型&lt;strong&gt;转换为类类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;任意类型间（需有关联）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;operator TargetType() const { ... }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ClassName(SourceType value) { ... }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;static_cast&amp;lt;TargetType&amp;gt;(expression)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;调用方式&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;隐式或显式（若为 &lt;code&gt;explicit&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;隐式或显式（若为 &lt;code&gt;explicit&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;必须显式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;控制权&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;在&lt;strong&gt;源类&lt;/strong&gt;中定义&lt;/td&gt;
&lt;td&gt;在&lt;strong&gt;目标类&lt;/strong&gt;中定义&lt;/td&gt;
&lt;td&gt;在&lt;strong&gt;使用方&lt;/strong&gt;代码中指定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="-类型转换函数的特点"&gt;💡 类型转换函数的特点
&lt;/h3&gt;&lt;p&gt;类型转换函数有几个非常重要的语法规定和特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;成员函数&lt;/strong&gt;：它必须是类的&lt;strong&gt;成员函数&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无返回类型&lt;/strong&gt;：在函数声明中&lt;strong&gt;不需要指定返回类型&lt;/strong&gt;，因为返回类型已经由 &lt;code&gt;operator&lt;/code&gt;后面的目标类型明确指出了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无参数&lt;/strong&gt;：它&lt;strong&gt;不能有任何参数&lt;/strong&gt;，因为它的操作对象是当前类实例（通过 &lt;code&gt;this&lt;/code&gt;指针访问）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常函数&lt;/strong&gt;：它通常不应修改当前对象的内容，因此最好被声明为 &lt;strong&gt;&lt;code&gt;const&lt;/code&gt;&lt;/strong&gt; 成员函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可继承和虚函数&lt;/strong&gt;：类型转换函数可以被继承，也可以被声明为虚函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-如何定义类型转换函数"&gt;📝 如何定义类型转换函数
&lt;/h3&gt;&lt;p&gt;其语法格式如下：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;class SourceClass {
public:
operator TargetType() const { // TargetType 是你要转换到的目标类型
// ... 转换逻辑
return data; // 返回一个 TargetType 类型的值
}
};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="-代码示例"&gt;🧪 代码示例
&lt;/h3&gt;&lt;pre tabindex="0"&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
class Number {
private:
int value;
public:
Number(int v) : value(v) {}
// 类型转换函数：将 Number 对象转换为 int
operator int() const {
return value;
}
// 类型转换函数：将 Number 对象转换为 double（显式转换）
explicit operator double() const {
return static_cast&amp;lt;double&amp;gt;(value);
}
};
int main() {
Number num(42);
// 隐式转换：调用 operator int()
int x = num;
std::cout &amp;lt;&amp;lt; &amp;#34;Converted to int: &amp;#34; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;
// 显式转换：调用 operator double() (因为使用了explicit关键字)
double d = static_cast&amp;lt;double&amp;gt;(num);
std::cout &amp;lt;&amp;lt; &amp;#34;Converted to double: &amp;#34; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; std::endl;
// 在表达式中使用隐式转换
int sum = num + 10; // Number -&amp;gt; int, 然后 42 + 10
std::cout &amp;lt;&amp;lt; &amp;#34;Sum: &amp;#34; &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; std::endl;
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Converted to int: 42
Converted to double: 42
Sum: 52
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="-注意要点与最佳实践"&gt;⚠️ 注意要点与最佳实践
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;谨慎使用隐式转换&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;隐式转换虽然方便，但可能会让代码的意图变得不清晰，甚至在某些情况下导致意想不到的行为或难以发现的错误。例如，编译器可能会在你未察觉的情况下调用转换函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用 &lt;code&gt;explicit&lt;/code&gt;关键字&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;在 C++11 之后，你可以使用 &lt;strong&gt;&lt;code&gt;explicit&lt;/code&gt;&lt;/strong&gt; 关键字来修饰类型转换函数，这样可以&lt;strong&gt;防止隐式转换&lt;/strong&gt;，只允许通过显式类型转换（如 &lt;code&gt;static_cast&lt;/code&gt;）来调用它。这能有效增加代码的安全性和可读性。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;explicit operator TargetType() const { ... }
// 使用时必须显式：TargetType t = static_cast&amp;lt;TargetType&amp;gt;(myObject);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免二义性&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;如果一个类定义了多个转换目标类型&lt;strong&gt;相近&lt;/strong&gt;的类型转换函数（例如同时存在 &lt;code&gt;operator int()&lt;/code&gt;和 &lt;code&gt;operator double()&lt;/code&gt;），在某些表达式中有可能让编译器无法决定使用哪一个，从而引发&lt;strong&gt;二义性错误&lt;/strong&gt;。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;class AmbiguousClass {
public:
operator int() const { return 1; }
operator double() const { return 1.5; }
};
void foo(double d) {}
void foo(int i) {}
AmbiguousClass obj;
// foo(obj); // 错误！调用具有二义性
foo(static_cast&amp;lt;int&amp;gt;(obj)); // 正确：显式指定
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;与转换构造函数的区别&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;类型转换函数&lt;/strong&gt;：将&lt;strong&gt;当前类类型&lt;/strong&gt;转换为&lt;strong&gt;其他类型&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;转换构造函数&lt;/strong&gt;：将&lt;strong&gt;其他类型&lt;/strong&gt;转换为&lt;strong&gt;当前类类型&lt;/strong&gt;（通常是一个参数的构造函数）。&lt;/p&gt;
&lt;p&gt;它们共同决定了类与外部类型之间相互转换的规则。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="-总结"&gt;💎 总结
&lt;/h3&gt;&lt;p&gt;类型转换函数是 C++ 中实现用户自定义类型转换的强大工具之一。它允许类对象在必要时自动或强制转换为其他类型。使用时请牢记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;operator TargetType() const&lt;/code&gt;语法在类内定义。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先考虑使用 &lt;code&gt;explicit&lt;/code&gt;关键字&lt;/strong&gt;来避免可能带来问题的隐式转换，提高代码安全性。&lt;/li&gt;
&lt;li&gt;注意避免因多个转换函数可能导致的二义性问题。&lt;/li&gt;
&lt;li&gt;它与转换构造函数相辅相成，共同定义了类与类型系统交互的接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;希望这些信息能帮助你更好地理解和使用 C++ 中的类型转换函数。&lt;/p&gt;
&lt;h2 id="菱形继承"&gt;菱形继承
&lt;/h2&gt;&lt;p&gt;菱形继承是 C++ 等多重继承语言中一个经典又棘手的问题。它会导致&lt;strong&gt;数据冗余&lt;/strong&gt;和&lt;strong&gt;访问二义性&lt;/strong&gt;这两个核心问题。&lt;/p&gt;
&lt;p&gt;为了更直观地理解传统的菱形继承架构及其问题，以及虚继承如何从结构上改变这一局面，可以参考下面的对比示意图。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;flowchart TD
subgraph A [传统菱形继承结构]
A1[Base&amp;lt;br&amp;gt;基类]
B1[Derived1&amp;lt;br&amp;gt;派生类1]
B2[Derived2&amp;lt;br&amp;gt;派生类2]
C1[MostDerived&amp;lt;br&amp;gt;最终派生类]
A1 -- 继承 --&amp;gt; B1
A1 -- 继承 --&amp;gt; B2
B1 -- 继承 --&amp;gt; C1
B2 -- 继承 --&amp;gt; C1
subgraph C1_Mem[MostDerived 对象内存布局]
D1[Derived1 部分&amp;lt;br&amp;gt;包含 Base 实例 1]
D2[Derived2 部分&amp;lt;br&amp;gt;包含 Base 实例 2]
D3[MostDerived 自身成员]
end
end
subgraph B [虚继承解决后结构]
A2[Base&amp;lt;br&amp;gt;基类（虚基类）]
B3[Derived1&amp;lt;br&amp;gt;派生类1（虚继承）]
B4[Derived2&amp;lt;br&amp;gt;派生类2（虚继承）]
C2[MostDerived&amp;lt;br&amp;gt;最终派生类]
A2 -- 虚继承 --&amp;gt; B3
A2 -- 虚继承 --&amp;gt; B4
B3 -- 继承 --&amp;gt; C2
B4 -- 继承 --&amp;gt; C2
subgraph C2_Mem[MostDerived 对象内存布局（虚继承）]
D4[Derived1 部分]
D5[Derived2 部分]
D6[MostDerived 自身成员]
D7[共享的 Base 实例]
end
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上图所示，传统的菱形继承会导致最终派生类(&lt;code&gt;MostDerived&lt;/code&gt;)中包含两份基类(&lt;code&gt;Base&lt;/code&gt;)的实例，从而引发以下问题：&lt;/p&gt;
&lt;h3 id="-1-数据冗余-data-redundancy"&gt;⚠️ 1. 数据冗余 (Data Redundancy)
&lt;/h3&gt;&lt;p&gt;如传统菱形继承结构所示，最终派生类 (&lt;code&gt;MostDerived&lt;/code&gt;) 会通过两条不同的继承路径（经由 &lt;code&gt;Derived1&lt;/code&gt;和 &lt;code&gt;Derived2&lt;/code&gt;）继承基类 (&lt;code&gt;Base&lt;/code&gt;)。这意味着 &lt;code&gt;MostDerived&lt;/code&gt;类的对象内部会&lt;strong&gt;包含两份 &lt;code&gt;Base&lt;/code&gt;类的成员&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，若 &lt;code&gt;Base&lt;/code&gt;类有一个 &lt;code&gt;int data;&lt;/code&gt;成员，那么一个 &lt;code&gt;MostDerived&lt;/code&gt;对象里就会有两个 &lt;code&gt;data&lt;/code&gt;变量。这不仅仅是内存浪费的问题，更严重的是逻辑上的混乱：你实际上并不需要两份相同的数据，但继承机制却导致了这种冗余。&lt;/p&gt;
&lt;h3 id="-2-访问的二义性-ambiguity"&gt;❓ 2. 访问的二义性 (Ambiguity)
&lt;/h3&gt;&lt;p&gt;当你想在 &lt;code&gt;MostDerived&lt;/code&gt;对象中访问 &lt;code&gt;Base&lt;/code&gt;的成员（例如 &lt;code&gt;data&lt;/code&gt;）时，编译器无法确定你希望使用哪一条继承路径上的 &lt;code&gt;Base&lt;/code&gt;成员——是来自 &lt;code&gt;Derived1&lt;/code&gt;的还是来自 &lt;code&gt;Derived2&lt;/code&gt;的？&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;MostDerived obj;
obj.data = 10; // 编译错误：对成员‘data’的请求不明确
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就导致了&lt;strong&gt;编译错误&lt;/strong&gt;。为了解决这个二义性，你不得不通过作用域解析运算符 &lt;code&gt;::&lt;/code&gt;来显式指定路径：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;obj.Derived1::data = 10; // 指定通过 Derived1 继承来的 data
obj.Derived2::data = 20; // 指定通过 Derived2 继承来的 data
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但这不仅让代码变得冗长和难以维护，而且从逻辑上看，给两个本质上应该相同的 &lt;code&gt;data&lt;/code&gt;成员分别赋不同的值，通常也违背了业务逻辑的初衷。&lt;/p&gt;
&lt;h3 id="-主要的解决方案虚继承-virtual-inheritance"&gt;💡 主要的解决方案：虚继承 (Virtual Inheritance)
&lt;/h3&gt;&lt;p&gt;在 C++ 中，解决菱形继承问题的标准方法是使用&lt;strong&gt;虚继承 (Virtual Inheritance)&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;做法&lt;/strong&gt;：在中间派生类（&lt;code&gt;Derived1&lt;/code&gt;和 &lt;code&gt;Derived2&lt;/code&gt;）继承基类（&lt;code&gt;Base&lt;/code&gt;）时，使用 &lt;code&gt;virtual&lt;/code&gt;关键字。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;class Derived1 : virtual public Base { /* ... */ }; // 虚继承
class Derived2 : virtual public Base { /* ... */ }; // 虚继承
class MostDerived : public Derived1, public Derived2 { /* ... */ };
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;效果&lt;/strong&gt;：如虚继承解决后的结构所示，&lt;strong&gt;虚继承确保了在最终的派生类 &lt;code&gt;MostDerived&lt;/code&gt;中，无论基类 &lt;code&gt;Base&lt;/code&gt;在继承层次中出现多少次，都只会包含它的一个实例&lt;/strong&gt;。&lt;code&gt;Derived1&lt;/code&gt;和 &lt;code&gt;Derived2&lt;/code&gt;会共享这唯一的基础实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代价与注意&lt;/strong&gt;：虚继承通常通过&lt;strong&gt;虚基类表指针&lt;/strong&gt;来实现，这会带来少量的内存开销（存储指针）和间接访问的开销（通过指针找到唯一的基类实例）。并且，&lt;strong&gt;最底层的派生类（如 &lt;code&gt;MostDerived&lt;/code&gt;）需要负责直接初始化虚基类&lt;/strong&gt;（&lt;code&gt;Base&lt;/code&gt;），即使 &lt;code&gt;Base&lt;/code&gt;并不是它的直接父类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-编程启示"&gt;🧠 编程启示
&lt;/h3&gt;&lt;p&gt;菱形继承及其问题也解释了为什么许多现代编程语言（如 &lt;strong&gt;Java&lt;/strong&gt;、&lt;strong&gt;C#&lt;/strong&gt;）&lt;strong&gt;刻意不支持类的多重继承&lt;/strong&gt;，而只允许实现多个接口（Interface）。接口通常只定义行为契约而不包含状态（数据成员），从而从根源上避免了数据冗余和二义性的问题。&lt;/p&gt;
&lt;p&gt;在 C++ 开发中，一个良好的实践是：&lt;strong&gt;优先使用组合（Composition）而不是继承（尤其是多重继承）来构建复杂对象&lt;/strong&gt;。如果确实需要多重继承，并且遇到了菱形继承问题，应谨慎使用虚继承。&lt;/p&gt;
&lt;p&gt;希望以上的解释能帮助你理解菱形继承的问题。&lt;/p&gt;
&lt;h2 id="虚继承"&gt;虚继承
&lt;/h2&gt;&lt;p&gt;C++ 中的 &lt;strong&gt;虚继承&lt;/strong&gt;（Virtual Inheritance）是一种特殊的继承机制，主要用于解决多重继承中的 &lt;strong&gt;“菱形继承”&lt;/strong&gt;（Diamond Inheritance）问题，确保在复杂的继承体系结构中，公共基类（虚基类）的子对象在最终派生类中只存在一份副本，从而避免数据冗余和成员访问的二义性。&lt;/p&gt;
&lt;p&gt;下面我将为你详细解析虚继承的各个方面。&lt;/p&gt;
&lt;h1 id="-c-虚继承详解"&gt;🧩 C++ 虚继承详解
&lt;/h1&gt;&lt;h2 id="-应对菱形继承问题的关键机制"&gt;↳ 应对菱形继承问题的关键机制
&lt;/h2&gt;&lt;h3 id="1-什么是菱形继承问题"&gt;1. 什么是菱形继承问题？
&lt;/h3&gt;&lt;p&gt;菱形继承问题是多重继承中一个经典且棘手的场景。它发生在以下继承结构中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个派生类同时继承自两个或多个基类。&lt;/li&gt;
&lt;li&gt;而这些基类又都继承自同一个共同的基类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这将导致最终的派生类中包含多份共同基类的子对象，引发&lt;strong&gt;数据冗余&lt;/strong&gt;和&lt;strong&gt;访问二义性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，有以下类结构：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;class Animal { public: int age; };
class Mammal : public Animal {};
class Bird : public Animal {};
class Bat : public Mammal, public Bird {};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个 &lt;code&gt;Bat&lt;/code&gt;对象内部将包含&lt;strong&gt;两份&lt;/strong&gt; &lt;code&gt;Animal&lt;/code&gt;子对象（分别来自 &lt;code&gt;Mammal&lt;/code&gt;和 &lt;code&gt;Bird&lt;/code&gt;的继承路径）。这会导致：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据冗余&lt;/strong&gt;：&lt;code&gt;Bat&lt;/code&gt;对象中有两个 &lt;code&gt;age&lt;/code&gt;成员，浪费内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问二义性&lt;/strong&gt;：直接调用 &lt;code&gt;bat.age&lt;/code&gt;或 &lt;code&gt;bat.functionInAnimal()&lt;/code&gt;时，编译器无法确定应使用哪一条继承路径上的 &lt;code&gt;Animal&lt;/code&gt;成员，从而引发编译错误。必须使用作用域解析运算符来明确指定，如 &lt;code&gt;bat.Mammal::age&lt;/code&gt;或 &lt;code&gt;bat.Bird::age&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-虚继承如何解决菱形问题"&gt;2. 虚继承如何解决菱形问题？
&lt;/h3&gt;&lt;p&gt;虚继承通过 &lt;code&gt;virtual&lt;/code&gt;关键字声明。&lt;strong&gt;让中间派生类（如 &lt;code&gt;Mammal&lt;/code&gt;和 &lt;code&gt;Bird&lt;/code&gt;）虚拟继承自共同基类（如 &lt;code&gt;Animal&lt;/code&gt;）&lt;/strong&gt;，从而通知编译器：希望这个基类在最终的派生类中被共享。&lt;/p&gt;
&lt;p&gt;将上述例子改为虚继承：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;class Animal { public: int age; };
class Mammal : virtual public Animal {}; // 虚继承
class Bird : virtual public Animal {}; // 虚继承
class Bat : public Mammal, public Bird {};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，&lt;strong&gt;&lt;code&gt;Bat&lt;/code&gt;对象中只包含一份 &lt;code&gt;Animal&lt;/code&gt;子对象的副本&lt;/strong&gt;。所有对 &lt;code&gt;Animal&lt;/code&gt;成员的访问都指向这同一个实例，从而彻底消除了数据冗余和访问的二义性。&lt;/p&gt;
&lt;h3 id="3-虚继承的实现原理编译器幕后做的事"&gt;3. 虚继承的实现原理（编译器幕后做的事）
&lt;/h3&gt;&lt;p&gt;虚继承的实现通常依赖于 &lt;strong&gt;虚基类表指针（vbptr&lt;/strong&gt;）和 &lt;strong&gt;虚基类表（vbtable）&lt;/strong&gt; 的机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚基类指针（vbptr）&lt;/strong&gt;：编译器会为每个虚继承的派生类对象添加一个或多个隐藏的 &lt;strong&gt;虚基类指针（vbptr）&lt;/strong&gt;。这些指针指向一个 &lt;strong&gt;虚基类表（vbtable）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚基类表（vbtable）&lt;/strong&gt;：该表中存储了&lt;strong&gt;虚基类子对象相对于当前对象起始地址的偏移量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问共享成员&lt;/strong&gt;：当通过一个可能为虚继承的路径访问基类成员时，代码会通过对象的 vbptr 查找 vbtable，获得偏移量，然后计算出虚基类子对象的实际地址，从而进行访问。这是一个间接寻址的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，一个 &lt;code&gt;Bat&lt;/code&gt;对象的内存布局可能如下：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;+-------------------+
| Mammal 部分 |
| vbptr_Mammal | --&amp;gt; 指向Mammal的虚基类表（记录Animal的偏移）
+-------------------+
| Bird 部分 |
| vbptr_Bird | --&amp;gt; 指向Bird的虚基类表（记录Animal的偏移）
+-------------------+
| Animal 部分 | &amp;lt;-- 共享的唯一实例
| age |
+-------------------+
| Bat 自身成员（如果有）|
+-------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种机制确保了无论通过 &lt;code&gt;Mammal&lt;/code&gt;还是 &lt;code&gt;Bird&lt;/code&gt;的路径去访问 &lt;code&gt;Animal&lt;/code&gt;的成员，最终都能定位到同一个内存地址。&lt;/p&gt;
&lt;h3 id="4-虚继承对构造函数调用顺序的影响"&gt;4. 虚继承对构造函数调用顺序的影响
&lt;/h3&gt;&lt;p&gt;虚继承&lt;strong&gt;改变了构造函数的调用顺序&lt;/strong&gt;，有一条非常重要的规则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚基类的构造函数由最底层派生类（Most Derived Class）直接调用，而非由中间派生类调用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这意味着：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在普通继承中，每个派生类负责调用其直接基类的构造函数。&lt;/li&gt;
&lt;li&gt;在虚继承中，&lt;strong&gt;所有虚基类的构造函数都会最先被调用&lt;/strong&gt;（优先于任何非虚基类），并且是由最终创建对象的那个派生类直接调用。&lt;/li&gt;
&lt;li&gt;中间派生类（如 &lt;code&gt;Mammal&lt;/code&gt;或 &lt;code&gt;Bird&lt;/code&gt;）的构造函数初始化列表中对于虚基类（&lt;code&gt;Animal&lt;/code&gt;）的构造函数调用会被编译器忽略，以避免多次初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;class Animal {
public:
Animal(int a) : age(a) {}
int age;
};
class Mammal : virtual public Animal {
public:
Mammal() : Animal(10) {} // 这里的 Animal(10) 在创建 Bat 时会被忽略
};
class Bird : virtual public Animal {
public:
Bird() : Animal(20) {} // 这里的 Animal(20) 在创建 Bat 时也会被忽略
};
class Bat : public Mammal, public Bird {
public:
Bat(int age) : Animal(age) {} // 必须由 Bat 直接初始化虚基类 Animal
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当创建 &lt;code&gt;Bat&lt;/code&gt;对象时，构造顺序是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Animal&lt;/code&gt;的构造函数（由 &lt;code&gt;Bat&lt;/code&gt;直接调用）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mammal&lt;/code&gt;的构造函数（但其对 &lt;code&gt;Animal&lt;/code&gt;的初始化被忽略）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bird&lt;/code&gt;的构造函数（但其对 &lt;code&gt;Animal&lt;/code&gt;的初始化被忽略）&lt;/li&gt;
&lt;li&gt;最后是 &lt;code&gt;Bat&lt;/code&gt;自身的构造函数体&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果 &lt;code&gt;Animal&lt;/code&gt;没有默认构造函数，而 &lt;code&gt;Bat&lt;/code&gt;又没有显式调用 &lt;code&gt;Animal&lt;/code&gt;的构造函数，会导致编译错误。&lt;/p&gt;
&lt;h3 id="5-虚继承的优缺点与使用建议"&gt;5. 虚继承的优缺点与使用建议
&lt;/h3&gt;&lt;h4 id="-优点"&gt;✅ 优点
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解决核心问题&lt;/strong&gt;：优雅地解决了菱形继承带来的数据冗余和二义性问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节省空间&lt;/strong&gt;：当公共基类体积较大且继承路径很多时，共享一份实例可以显著节省内存空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="-缺点与开销"&gt;❌ 缺点与开销
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;性能开销&lt;/strong&gt;：每次访问虚基类的成员都需要通过虚基类指针和虚基类表进行间接寻址，比直接访问多一次指针跳转，有额外的运行时开销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存开销&lt;/strong&gt;：每个虚继承的派生类对象都需要存储至少一个额外的虚基类指针（vbptr），增加了对象的内存占用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复杂性&lt;/strong&gt;：内存布局变得更复杂，给调试和深入理解带来一定困难。构造顺序的规则也更容易让人混淆。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="-使用建议"&gt;💡 使用建议
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;谨慎使用&lt;/strong&gt;：&lt;strong&gt;不要滥用虚继承&lt;/strong&gt;。仅在明确面临菱形继承问题且确实需要共享基类状态时才使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先考虑组合&lt;/strong&gt;：在设计类体系时，优先考虑使用&lt;strong&gt;组合（Composition）&lt;/strong&gt;（即将一个类作为另一个类的成员变量）而不是多重继承来复用代码，这通常能带来更清晰、更灵活的设计。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口继承&lt;/strong&gt;：虚继承常用于&lt;strong&gt;接口类&lt;/strong&gt;（即只包含纯虚函数的抽象类）。因为接口通常没有数据成员，主要目的是实现多态，此时使用虚继承可以避免菱形继承带来的二义性，而又不会有数据冗余和太大的性能开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="6-代码示例"&gt;6. 代码示例
&lt;/h3&gt;&lt;p&gt;下面的代码示例展示了虚继承如何解决菱形继承问题：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
class Animal {
public:
Animal(int a) : age(a) {
std::cout &amp;lt;&amp;lt; &amp;#34;Animal constructed with age: &amp;#34; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; std::endl;
}
void breathe() {
std::cout &amp;lt;&amp;lt; &amp;#34;Animal is breathing...\n&amp;#34;;
}
int age;
};
class Mammal : virtual public Animal { // 虚继承
public:
Mammal() : Animal(10) { // 此初始化在构建最终对象时可能被忽略
std::cout &amp;lt;&amp;lt; &amp;#34;Mammal constructed\n&amp;#34;;
}
};
class Bird : virtual public Animal { // 虚继承
public:
Bird() : Animal(20) { // 此初始化在构建最终对象时可能被忽略
std::cout &amp;lt;&amp;lt; &amp;#34;Bird constructed\n&amp;#34;;
}
};
class Bat : public Mammal, public Bird {
public:
Bat(int a) : Animal(a) { // 必须由最底层派生类直接初始化虚基类
std::cout &amp;lt;&amp;lt; &amp;#34;Bat constructed\n&amp;#34;;
}
};
int main() {
Bat bat(5); // 输出构造顺序
std::cout &amp;lt;&amp;lt; &amp;#34;\nBat&amp;#39;s age is: &amp;#34; &amp;lt;&amp;lt; bat.age &amp;lt;&amp;lt; std::endl; // 访问无二义性
bat.breathe(); // 调用无二义性
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;Animal constructed with age: 5
Mammal constructed
Bird constructed
Bat constructed
Bat&amp;#39;s age is: 5
Animal is breathing...
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="7-虚继承-vs-普通继承"&gt;7. 虚继承 vs. 普通继承
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;普通继承&lt;/th&gt;
&lt;th&gt;虚继承&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;继承语法&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;class B : public A {}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;class B : virtual public A {}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;副本数量&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;多个副本（可能数据冗余）&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;单个共享副本&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;访问二义性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;可能存在（需作用域解析）&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;无&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;内存布局&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;相对简单&lt;/td&gt;
&lt;td&gt;复杂（含虚基类指针/表）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;构造顺序&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;由直接派生类初始化&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;由最底层派生类直接初始化&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;典型应用&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;一般的&amp;quot;is-a&amp;quot;关系，单继承&lt;/td&gt;
&lt;td&gt;解决菱形继承问题&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="总结"&gt;总结
&lt;/h3&gt;&lt;p&gt;C++ 中的虚继承是一种强大的工具，专门用于解决多重继承中的菱形问题。它通过共享公共基类的实例，确保了内存中只有一份副本，消除了数据冗余和访问二义性。&lt;/p&gt;
&lt;p&gt;然而，这种强大功能也带来了额外的复杂性和性能开销，包括间接寻址和内存中的虚基类指针开销。因此，在实际开发中应谨慎使用虚继承，仔细评估其必要性，并优先考虑使用组合等替代设计模式。当你确实需要让多个派生类共享一个共同基类的唯一实例时，虚继承才是正确的选择。&lt;/p&gt;</description></item><item><title>【CPP】v.size()</title><link>https://dyhes.github.io/p/cppv.size/</link><pubDate>Thu, 19 Jun 2025 00:00:00 +0000</pubDate><guid>https://dyhes.github.io/p/cppv.size/</guid><description>&lt;p&gt;在C++中使用&lt;code&gt;std::vector&lt;/code&gt;时，&lt;code&gt;for (int i = 0; i &amp;lt; v.size(); i++)&lt;/code&gt; 与预先定义 &lt;code&gt;int n = v.size()&lt;/code&gt; 再循环 (&lt;code&gt;for (int i = 0; i &amp;lt; n; i++)&lt;/code&gt;) 的性能差异主要受&lt;strong&gt;编译器优化水平&lt;/strong&gt;和&lt;strong&gt;代码上下文&lt;/strong&gt;影响。以下是关键分析：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="-性能差异的本质"&gt;🔍 &lt;strong&gt;性能差异的本质&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;v.size()&lt;/code&gt; 的特性&lt;/strong&gt;：
&lt;code&gt;std::vector::size()&lt;/code&gt; 是时间复杂度 &lt;code&gt;O(1)&lt;/code&gt; 的操作，直接返回内部维护的元素数量计数器，​&lt;strong&gt;并非通过遍历计算&lt;/strong&gt;。因此，单次调用本身无显著开销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环中的重复调用问题&lt;/strong&gt;：
若直接写 &lt;code&gt;i &amp;lt; v.size()&lt;/code&gt;，​&lt;strong&gt;每次迭代需重新调用 &lt;code&gt;size()&lt;/code&gt;&lt;/strong&gt;。理论上，这可能带来额外开销（例如函数调用、寄存器操作），尤其在未优化的Debug模式下。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="-编译器优化的关键作用"&gt;⚙️ &lt;strong&gt;编译器优化的关键作用&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优化后的等价性&lt;/strong&gt;：
在Release模式（启用编译器优化如 &lt;code&gt;-O2&lt;/code&gt;/&lt;code&gt;-O3&lt;/code&gt;）下，编译器会&lt;strong&gt;自动将 &lt;code&gt;v.size()&lt;/code&gt; 提取到循环外&lt;/strong&gt;，存储为临时变量。此时两种写法生成的汇编代码几乎相同，性能无差异。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Debug模式的差异&lt;/strong&gt;：
未优化时，&lt;code&gt;i &amp;lt; v.size()&lt;/code&gt; 可能导致每次循环都调用 &lt;code&gt;size()&lt;/code&gt;。而预先存储 &lt;code&gt;n = v.size()&lt;/code&gt; 可避免此开销，此时后者可能更快（实测可差10倍以上）。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="-实测结果参考"&gt;📊 &lt;strong&gt;实测结果参考&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Debug模式：
&lt;ul&gt;
&lt;li&gt;预先存储 &lt;code&gt;n = v.size()&lt;/code&gt; 的循环：&lt;strong&gt;更快&lt;/strong&gt;（避免重复调用）。&lt;/li&gt;
&lt;li&gt;直接调用 &lt;code&gt;v.size()&lt;/code&gt; 的循环：&lt;strong&gt;显著更慢&lt;/strong&gt;（&lt;strong&gt;函数调用开销&lt;/strong&gt;累积）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Release模式&lt;/strong&gt;：
两种写法&lt;strong&gt;性能相同&lt;/strong&gt;​（编译器优化消除差异）。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;💡 例如：&lt;a class="link" href="https://www.cnblogs.com/zhuyingchun/p/8933907.html" target="_blank" rel="noopener"
&gt;测试代码&lt;/a&gt; 显示，Debug模式下 &lt;code&gt;VectorRead_1&lt;/code&gt;（直接 &lt;code&gt;v.size()&lt;/code&gt;）耗时5663ms，而 &lt;code&gt;VectorRead_2&lt;/code&gt;（预先存储size）仅需0ms；Release模式下二者均接近0ms。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id="-类型安全与正确性"&gt;⚠️ &lt;strong&gt;类型安全与正确性&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无符号整数问题&lt;/strong&gt;：
&lt;code&gt;v.size()&lt;/code&gt; 返回 &lt;code&gt;size_type&lt;/code&gt;（无符号类型）。若用 &lt;code&gt;int i&lt;/code&gt; 与之比较，当 &lt;code&gt;i&lt;/code&gt; 为负数时可能引发错误（编译器通常警告）。建议用 &lt;code&gt;size_t i&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环中修改容器的风险&lt;/strong&gt;：
若在循环内修改vector（如 &lt;code&gt;v.push_back()&lt;/code&gt;），&lt;code&gt;v.size()&lt;/code&gt; 会动态变化，导致未定义行为。此时&lt;strong&gt;必须预先存储size&lt;/strong&gt;或确保无修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="-编程建议"&gt;📝 &lt;strong&gt;编程建议&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;性能优先场景：
&lt;ul&gt;
&lt;li&gt;Release模式：&lt;strong&gt;无需优化&lt;/strong&gt;，写法按需选择。&lt;/li&gt;
&lt;li&gt;Debug模式：&lt;strong&gt;预先存储 &lt;code&gt;size()&lt;/code&gt;&lt;/strong&gt; 可提升调试效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码可读性与安全：
&lt;ul&gt;
&lt;li&gt;推荐使用基于范围的循环（C++11）：
&lt;pre tabindex="0"&gt;&lt;code&gt;for (const auto&amp;amp; elem : v) { /* 操作elem */ }
&lt;/code&gt;&lt;/pre&gt;简洁且避免索引错误，性能与优化后的下标循环&lt;strong&gt;相当&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;若需索引：用 &lt;code&gt;size_t i&lt;/code&gt; 而非 &lt;code&gt;int i&lt;/code&gt;，避免符号不匹配警告。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="-结论"&gt;💎 结论
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;性能差异仅在未优化的Debug模式下显著&lt;/strong&gt;，Release模式无区别。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先考虑安全性与可读性&lt;/strong&gt;：使用 &lt;code&gt;size_t i&lt;/code&gt; 或基于范围的循环，避免类型错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环中修改vector时&lt;/strong&gt;：必须预先存储 &lt;code&gt;n = v.size()&lt;/code&gt; 以固定循环次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="int--size_t"&gt;int &amp;amp; size_t
&lt;/h2&gt;&lt;p&gt;在C++中，&lt;code&gt;int n = v.size()&lt;/code&gt; 和 &lt;code&gt;size_t n = v.size()&lt;/code&gt; 的性能差异通常可以忽略不计，但&lt;strong&gt;类型安全性和潜在风险&lt;/strong&gt;才是关键区别。以下是综合分析：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="-性能差异分析"&gt;⚙️ &lt;strong&gt;性能差异分析&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;底层机制&lt;/strong&gt;：
&lt;code&gt;v.size()&lt;/code&gt; 返回 &lt;code&gt;size_t&lt;/code&gt;（无符号整数），时间复杂度为 &lt;code&gt;O(1)&lt;/code&gt;，仅读取内部计数器，无计算开销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;赋值操作&lt;/strong&gt;：
将 &lt;code&gt;size_t&lt;/code&gt; 赋值给 &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;size_t&lt;/code&gt; 变量均为一次简单的内存拷贝或寄存器操作，​&lt;strong&gt;现代编译器在优化模式下（如 &lt;code&gt;-O2&lt;/code&gt;）会消除类型转换的额外指令&lt;/strong&gt;，因此两者性能几乎无差异。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Debug模式下的微小开销&lt;/strong&gt;：
未优化时，&lt;code&gt;int n = v.size()&lt;/code&gt; 可能多一次&lt;strong&gt;符号扩展（Sign Extension）​&lt;/strong&gt;​ 指令（将无符号数转为有符号数），但影响极微（纳秒级）。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;💡 &lt;strong&gt;实测结论&lt;/strong&gt;：性能差异通常低于测量误差，优化后完全一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id="-核心区别类型安全与正确性"&gt;⚠️ &lt;strong&gt;核心区别：类型安全与正确性&lt;/strong&gt;
&lt;/h3&gt;&lt;h4 id="1-数据范围与溢出风险"&gt;(1) &lt;strong&gt;数据范围与溢出风险&lt;/strong&gt;
&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;范围（64位系统）&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;风险场景&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-2³¹ ~ 2³¹-1（约±21亿）&lt;/td&gt;
&lt;td&gt;若 &lt;code&gt;v.size() &amp;gt; 2³¹-1&lt;/code&gt;，赋值导致&lt;strong&gt;溢出&lt;/strong&gt;（负数或错误值）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;size_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;0 ~ 2⁶⁴-1（约184亿亿）&lt;/td&gt;
&lt;td&gt;完全匹配容器大小，无溢出风险。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;large_vec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&amp;#39;000&amp;#39;000&amp;#39;000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 30亿元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;large_vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// n1 可能为负值（溢出）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;large_vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// n2 = 3e9（正确）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="2-无符号与有符号的隐式转换"&gt;(2) &lt;strong&gt;无符号与有符号的隐式转换&lt;/strong&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;比较陷阱：若后续代码出现 &lt;code&gt;n &amp;lt; v.size()&lt;/code&gt;的比较（n为&lt;code&gt;int&lt;/code&gt;，&lt;code&gt;v.size()&lt;/code&gt;为&lt;code&gt;size_t&lt;/code&gt;），编译器会将n隐式转为无符号数。若n为负数（如-1），会变成极大正数，导致逻辑错误。
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c++" data-lang="c++"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 条件恒成立（-1 → 2⁶⁴-1）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="c1"&gt;// 错误执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环风险&lt;/strong&gt;：
使用 &lt;code&gt;int i&lt;/code&gt; 遍历容器时，若 &lt;code&gt;i&lt;/code&gt; 减至负数，与 &lt;code&gt;v.size()&lt;/code&gt; 比较会引发无限循环或越界。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="-编程建议-1"&gt;📌 &lt;strong&gt;编程建议&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;优先使用 &lt;code&gt;size_t&lt;/code&gt;&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;避免溢出和隐式转换问题，提高代码健壮性。&lt;/li&gt;
&lt;li&gt;直接匹配容器接口（如 &lt;code&gt;std::vector::size_type&lt;/code&gt; 即 &lt;code&gt;size_t&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环索引的最佳实践&lt;/strong&gt;：
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 推荐写法（避免类型不匹配）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 或使用范围循环（C++11起）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nl"&gt;item&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;必须用 &lt;code&gt;int&lt;/code&gt; 的场景&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;若需处理负数（如偏移量），或与其他有符号接口交互，可显式转换但需校验范围：
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;size_t&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;numeric_limits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt; &lt;span class="c1"&gt;// 安全转换
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="-总结"&gt;💎 &lt;strong&gt;总结&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;性能&lt;/strong&gt;：无显著差异，优化后等价。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全性&lt;/strong&gt;：&lt;code&gt;size_t&lt;/code&gt; 无溢出和隐式转换风险，&lt;strong&gt;是首选方案&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可读性&lt;/strong&gt;：使用 &lt;code&gt;size_t&lt;/code&gt; 能明确表达“容器大小”的语义，提升代码清晰度。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在涉及大型容器（元素数 &amp;gt; 10亿）或跨平台开发时，务必使用 &lt;code&gt;size_t&lt;/code&gt; 以避免隐蔽错误。&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>【CPP】size_t</title><link>https://dyhes.github.io/p/cppsize_t/</link><pubDate>Sun, 18 May 2025 00:00:00 +0000</pubDate><guid>https://dyhes.github.io/p/cppsize_t/</guid><description>&lt;p&gt;&lt;code&gt;size_t&lt;/code&gt; 是 C/C++ 中用于表示&lt;strong&gt;对象大小、数组索引、内存容量等非负值&lt;/strong&gt;的无符号整数类型，其核心特性与用途如下：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="基本定义与平台相关性"&gt;&lt;strong&gt;基本定义与平台相关性&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无符号性&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;size_t&lt;/code&gt; 是无符号类型（&lt;code&gt;unsigned&lt;/code&gt;），只能表示非负数。例如，&lt;code&gt;sizeof&lt;/code&gt; 运算符的返回值类型即为 &lt;code&gt;size_t&lt;/code&gt;，其数值范围覆盖从 &lt;code&gt;0&lt;/code&gt; 到当前系统可寻址的最大内存容量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;平台依赖性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;32位系统&lt;/strong&gt;：通常定义为 &lt;code&gt;typedef unsigned int size_t&lt;/code&gt;，占用 4 字节（32位）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;64位系统&lt;/strong&gt;：通常定义为 &lt;code&gt;typedef unsigned long size_t&lt;/code&gt; 或 &lt;code&gt;typedef unsigned long long size_t&lt;/code&gt;，占用 8 字节（64位）。&lt;br&gt;
这种设计确保了 &lt;code&gt;size_t&lt;/code&gt; 的宽度与指针大小一致，从而适配不同平台的寻址能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="主要用途"&gt;&lt;strong&gt;主要用途&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;表示对象大小&lt;/strong&gt;&lt;br&gt;
用于存储 &lt;code&gt;sizeof&lt;/code&gt; 运算符的结果，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;arr_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 获取数组总字节数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存分配与操作&lt;/strong&gt;&lt;br&gt;
动态内存管理函数（如 &lt;code&gt;malloc&lt;/code&gt;、&lt;code&gt;calloc&lt;/code&gt;）的参数和返回值使用 &lt;code&gt;size_t&lt;/code&gt; 类型，确保申请的内存大小合法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;byte_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;byte_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 申请 100 个 int 的内存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数组索引与循环计数&lt;/strong&gt;&lt;br&gt;
在遍历数组或容器时，使用 &lt;code&gt;size_t&lt;/code&gt; 可避免越界风险：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// vec.size() 返回 size_t
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="c1"&gt;// 操作元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字符串操作&lt;/strong&gt;&lt;br&gt;
字符串长度函数（如 &lt;code&gt;strlen&lt;/code&gt;）的返回值类型为 &lt;code&gt;size_t&lt;/code&gt;，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 长度为 5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="与"&gt;&lt;strong&gt;与 &lt;code&gt;int&lt;/code&gt; 的区别&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;&lt;code&gt;size_t&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;int&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;符号性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;无符号（仅非负值）&lt;/td&gt;
&lt;td&gt;有符号（可表示负值）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;范围&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;足够大以覆盖系统最大对象&lt;/td&gt;
&lt;td&gt;固定为 32 或 64 位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;内存大小、索引、长度&lt;/td&gt;
&lt;td&gt;通用整数计算（含负数）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;避免负数导致的逻辑错误&lt;/td&gt;
&lt;td&gt;可能因负值引发溢出/错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id="使用建议"&gt;&lt;strong&gt;使用建议&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优先用于内存相关操作&lt;/strong&gt;&lt;br&gt;
在涉及数组索引、内存分配或标准库函数（如 &lt;code&gt;std::vector::size()&lt;/code&gt;）时，优先使用 &lt;code&gt;size_t&lt;/code&gt; 以确保类型匹配和安全性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免与有符号类型混用&lt;/strong&gt;&lt;br&gt;
比较 &lt;code&gt;size_t&lt;/code&gt; 与有符号类型（如 &lt;code&gt;int&lt;/code&gt;）时需显式转换，防止隐式转换导致逻辑错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size_max&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 显式转换以避免警告
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="c1"&gt;// 操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跨平台兼容性&lt;/strong&gt;&lt;br&gt;
在编写跨平台代码时，依赖 &lt;code&gt;size_t&lt;/code&gt; 的自动适配特性，而非手动指定 &lt;code&gt;unsigned int&lt;/code&gt; 或 &lt;code&gt;unsigned long&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="示例代码"&gt;&lt;strong&gt;示例代码&lt;/strong&gt;
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;vec_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 获取容器大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;vec_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;vec[&amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;] = &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;总结来说，&lt;code&gt;size_t&lt;/code&gt; 是 C/C++ 中处理内存、容器、字符串等场景的&lt;strong&gt;标准无符号整数类型&lt;/strong&gt;，其设计兼顾了平台兼容性、安全性及性能优化需求。&lt;/p&gt;
&lt;h2 id="boost"&gt;Boost
&lt;/h2&gt;&lt;p&gt;Affinity Maps、Interaction Maps 和 Force Maps 是不同领域中的技术概念，其核心原理和应用场景存在显著差异。以下是三者的对比分析：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="affinity-maps亲和力地图"&gt;&lt;strong&gt;Affinity Maps（亲和力地图）&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义与领域&lt;/strong&gt;&lt;br&gt;
主要用于&lt;strong&gt;分子对接与药物设计&lt;/strong&gt;，通过网格化能量预计算评估配体与受体的结合能力。例如在 AutoDock Vina 中，Affinity Maps 存储了受体活性口袋内不同原子类型的范德华力、氢键等能量分布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;技术特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;能量网格化&lt;/strong&gt;：基于力场参数（如 AD4 力场）生成三维能量网格，加速对接计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态调整&lt;/strong&gt;：支持柔性残基的局部网格更新，模拟受体构象变化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：虚拟筛选、水合对接（如保留关键水分子的 &lt;code&gt;.W.map&lt;/code&gt; 文件）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例工具&lt;/strong&gt;&lt;br&gt;
AutoDock Tools、See&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="内核间数据共享"&gt;内核间数据共享
&lt;/h2&gt;&lt;p&gt;在CUDA编程中，GPU内核计算的结果是否可以直接被其他内核使用（不移动回CPU），取决于数据存储的位置、同步机制和GPU架构的支持。以下是关键要点分析：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="内存类型与作用域"&gt;&lt;strong&gt;内存类型与作用域&lt;/strong&gt;
&lt;/h3&gt;&lt;h4 id="全局内存global-memory"&gt;&lt;strong&gt;全局内存（Global Memory）&lt;/strong&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：全局内存是GPU中所有线程均可访问的存储空间，数据生命周期与应用程序一致。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨内核使用&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;一个内核写入全局内存的结果可直接被后续内核读取，无需CPU干预。&lt;/li&gt;
&lt;li&gt;示例：
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;__global__&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Kernel1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;d_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// 写入d_data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;__global__&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Kernel2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;d_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// 读取d_data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 调用顺序：先Kernel1，再Kernel2，共用d_data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化要求&lt;/strong&gt;：需确保内存访问合并（Coalesced Access）以减少延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="共享内存shared-memory"&gt;&lt;strong&gt;共享内存（Shared Memory）&lt;/strong&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：线程块内共享，速度快但作用域仅限于当前线程块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨内核限制&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;共享内存的生命周期与线程块绑定，不同内核（即使是同一线程块）无法直接复用。&lt;/li&gt;
&lt;li&gt;需通过全局内存中转：
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;__global__&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;KernelA&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;__shared__&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;s_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;s_data&lt;/span&gt;&lt;span class="p"&gt;[...]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;...;&lt;/span&gt; &lt;span class="c1"&gt;// 写入共享内存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="n"&gt;__syncthreads&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;global_mem&lt;/span&gt;&lt;span class="p"&gt;[...]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s_data&lt;/span&gt;&lt;span class="p"&gt;[...];&lt;/span&gt; &lt;span class="c1"&gt;// 将共享内存数据转存到全局内存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;__global__&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;KernelB&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;global_mem&lt;/span&gt;&lt;span class="p"&gt;[...];&lt;/span&gt; &lt;span class="c1"&gt;// 从全局内存读取
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="同步与一致性"&gt;&lt;strong&gt;同步与一致性&lt;/strong&gt;
&lt;/h3&gt;&lt;h4 id="显式同步"&gt;&lt;strong&gt;显式同步&lt;/strong&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;必要性&lt;/strong&gt;：GPU内核执行是异步的，需确保前序内核完成写入后再启动后续内核。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步方法&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;设备级同步&lt;/strong&gt;：&lt;code&gt;cudaDeviceSynchronize()&lt;/code&gt; 等待所有内核完成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流同步&lt;/strong&gt;：通过CUDA流（Stream）管理依赖关系：
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;cudaStream_t&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;cudaStreamCreate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Kernel1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;...,&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt; &lt;span class="c1"&gt;// 在stream中执行Kernel1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;Kernel2&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;...,&lt;/span&gt; &lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt; &lt;span class="c1"&gt;// Kernel2在Kernel1完成后自动启动
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件同步&lt;/strong&gt;：使用 &lt;code&gt;cudaEventRecord()&lt;/code&gt; 和 &lt;code&gt;cudaStreamWaitEvent()&lt;/code&gt; 实现精细控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="统一内存unified-memory"&gt;&lt;strong&gt;统一内存（Unified Memory）&lt;/strong&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：通过 &lt;code&gt;cudaMallocManaged&lt;/code&gt; 分配，CPU/GPU透明访问，自动按需迁移数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨内核使用&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;数据驻留GPU时，内核间可直接共享。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件要求&lt;/strong&gt;：计算能力6.x+的设备支持并发访问（&lt;code&gt;concurrentManagedAccess=1&lt;/code&gt;），否则需显式同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="架构差异与限制"&gt;&lt;strong&gt;架构差异与限制&lt;/strong&gt;
&lt;/h3&gt;&lt;h4 id="计算能力x前的设备"&gt;&lt;strong&gt;计算能力x前的设备&lt;/strong&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独占访问&lt;/strong&gt;：GPU执行任何内核时，所有托管内存均被锁定，CPU和其他内核无法访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：必须通过 &lt;code&gt;cudaDeviceSynchronize()&lt;/code&gt; 或流同步解除锁定。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="计算能力x的设备"&gt;&lt;strong&gt;计算能力x+的设备&lt;/strong&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;硬件一致性&lt;/strong&gt;：支持CPU/GPU并发访问托管内存，内核间数据共享更灵活。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原子操作支持&lt;/strong&gt;：部分设备支持硬件原子操作，避免竞争条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="性能优化建议"&gt;&lt;strong&gt;性能优化建议&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;减少全局内存竞争&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;使用原子操作（如 &lt;code&gt;atomicAdd&lt;/code&gt;）或设计无冲突访问模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预取数据&lt;/strong&gt;：通过 &lt;code&gt;cudaMemPrefetchAsync&lt;/code&gt; 将数据预取至GPU显存，减少延迟。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合并访问优化&lt;/strong&gt;：确保线程束（Warp）内连续访问全局内存，提升带宽利用率。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="典型应用场景"&gt;&lt;strong&gt;典型应用场景&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;场景&lt;/th&gt;
&lt;th&gt;推荐方案&lt;/th&gt;
&lt;th&gt;原因&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;内核间传递大规模数据&lt;/td&gt;
&lt;td&gt;全局内存 + 流同步&lt;/td&gt;
&lt;td&gt;容量大，支持异步传输&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;频繁读写的小数据块&lt;/td&gt;
&lt;td&gt;共享内存中转 + 全局内存持久化&lt;/td&gt;
&lt;td&gt;利用共享内存低延迟，避免全局内存带宽瓶颈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU/GPU混合流水线&lt;/td&gt;
&lt;td&gt;统一内存 + 预取机制&lt;/td&gt;
&lt;td&gt;简化编程，自动迁移数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id="总结"&gt;总结
&lt;/h3&gt;&lt;p&gt;在GPU中，内核计算结果可直接被其他内核使用，&lt;strong&gt;关键条件&lt;/strong&gt;包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据存储在全局内存或统一内存中&lt;/li&gt;
&lt;li&gt;通过同步机制确保写入完成后再读取&lt;/li&gt;
&lt;li&gt;根据GPU架构选择合适的内存模型（如6.x+设备的硬件一致性支持）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：避免未同步的竞态条件，优化内存访问模式以提升性能。&lt;/p&gt;
&lt;h2 id="线程索引"&gt;线程索引
&lt;/h2&gt;&lt;p&gt;在CUDA编程中，表达式 &lt;code&gt;int idx = blockIdx.x * blockDim.x + threadIdx.x;&lt;/code&gt; 用于计算线程在全局数据中的唯一索引。以下是其核心含义和作用的详细解释：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="变量定义与逻辑分解"&gt;变量定义与逻辑分解
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;blockIdx.x&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：当前线程所在的 &lt;strong&gt;线程块（Block）&lt;/strong&gt; 在 &lt;strong&gt;网格（Grid）&lt;/strong&gt; 中的 &lt;strong&gt;X维度索引&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;范围&lt;/strong&gt;：从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;gridDim.x - 1&lt;/code&gt;（&lt;code&gt;gridDim.x&lt;/code&gt; 是网格中X维度的线程块总数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;blockDim.x&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：每个线程块中 &lt;strong&gt;X维度的线程数量&lt;/strong&gt;。例如，若线程块配置为 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;128, 256&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;，则 &lt;code&gt;blockDim.x = 256&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;threadIdx.x&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：当前线程在其所属线程块内的 &lt;strong&gt;X维度索引&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;范围&lt;/strong&gt;：从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;blockDim.x - 1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="索引计算逻辑"&gt;索引计算逻辑
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;公式意义&lt;/strong&gt;：&lt;br&gt;
通过将 &lt;strong&gt;线程块的全局位置&lt;/strong&gt;（由 &lt;code&gt;blockIdx.x&lt;/code&gt; 确定）与 &lt;strong&gt;块内线程数量&lt;/strong&gt;（由 &lt;code&gt;blockDim.x&lt;/code&gt; 确定）相乘，得到当前线程块在全局数据中的起始位置；再结合 &lt;strong&gt;线程在块内的局部位置&lt;/strong&gt;（由 &lt;code&gt;threadIdx.x&lt;/code&gt; 确定），最终得到该线程在整个数据中的唯一索引 &lt;code&gt;idx&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;br&gt;
假设网格中X维度有3个线程块（&lt;code&gt;gridDim.x = 3&lt;/code&gt;），每个块包含4个线程（&lt;code&gt;blockDim.x = 4&lt;/code&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;blockIdx.x = 0&lt;/code&gt; 时，起始位置为 &lt;code&gt;0 * 4 = 0&lt;/code&gt;，线程索引范围为 &lt;code&gt;0-3&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;blockIdx.x = 1&lt;/code&gt; 时，起始位置为 &lt;code&gt;1 * 4 = 4&lt;/code&gt;，线程索引范围为 &lt;code&gt;4-7&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;blockIdx.x = 2&lt;/code&gt; 时，起始位置为 &lt;code&gt;2 * 4 = 8&lt;/code&gt;，线程索引范围为 &lt;code&gt;8-11&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="应用场景"&gt;应用场景
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据并行分配&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个线程通过 &lt;code&gt;idx&lt;/code&gt; 处理不同的数据元素。例如，在向量加法中，线程根据 &lt;code&gt;idx&lt;/code&gt; 分别读取 &lt;code&gt;a[idx]&lt;/code&gt; 和 &lt;code&gt;b[idx]&lt;/code&gt;，计算结果 &lt;code&gt;c[idx]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;任务划分与负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当数据总量（如数组长度 &lt;code&gt;N&lt;/code&gt;）超过总线程数时，通常配合循环使用 &lt;strong&gt;网格跨步（Grid-Stride Loop）&lt;/strong&gt;，使线程多次处理数据：
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;gridDim&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;blockDim&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 处理数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多维扩展&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在二维或三维场景中，类似逻辑可扩展为：
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 二维索引计算
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;blockIdx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;blockDim&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;threadIdx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;blockIdx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;blockDim&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;threadIdx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 适用于图像处理
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="硬件限制与优化"&gt;硬件限制与优化
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程块大小限制&lt;/strong&gt;：&lt;br&gt;
&lt;code&gt;blockDim.x&lt;/code&gt; 的最大值通常为 &lt;code&gt;1024&lt;/code&gt;（取决于GPU计算能力）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存访问优化&lt;/strong&gt;：&lt;br&gt;
需确保相邻线程访问连续内存地址（合并访问），以提升全局内存带宽利用率。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="总结-1"&gt;总结
&lt;/h3&gt;&lt;p&gt;该表达式是CUDA并行编程的基石，通过 &lt;strong&gt;层级化的线程组织模型&lt;/strong&gt;（Grid → Block → Thread）实现高效数据分配。理解其原理有助于编写高性能GPU代码，并规避线程竞争、内存访问冲突等问题。&lt;/p&gt;</description></item><item><title>【CPP】.hpp</title><link>https://dyhes.github.io/p/cpp.hpp/</link><pubDate>Mon, 31 Mar 2025 00:00:00 +0000</pubDate><guid>https://dyhes.github.io/p/cpp.hpp/</guid><description>&lt;p&gt;.hpp是C++语言中一种特殊的头文件后缀，其核心特点是将头文件（.h）与实现代码（.cpp）合并到同一个文件中，从而实现声明与定义的一体化。以下是其关键特性及作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义与实现合并&lt;/strong&gt;&lt;br&gt;
.hpp文件将类的声明和成员函数的实现代码直接写在同一个文件中，这与传统C++中声明在.h、实现在.cpp的分离模式不同。调用者只需包含.hpp文件即可，无需再单独编译对应的.cpp文件，从而减少了项目中的源文件数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编译优势&lt;/strong&gt;&lt;br&gt;
由于实现代码直接包含在头文件中，编译器会将代码编译到调用者的目标文件（.obj）中，避免了生成单独的中间文件。这种方式能显著减少编译次数和项目复杂度，尤其适合需要频繁复用的开源库开发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;模板类/泛型编程&lt;/strong&gt;：C++模板要求在编译时可见完整定义，因此.hpp常用于模板类的实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨平台库分发&lt;/strong&gt;：无需提供动态链接库（DLL）或静态库（LIB），仅通过.hpp即可实现功能共享。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VCL框架&lt;/strong&gt;：某些框架（如Borland的VCL）会使用预编译的.hpp文件加速编译。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;与.h文件的区别&lt;/strong&gt;&lt;br&gt;
传统.h文件仅包含声明，而.hpp同时包含声明和实现。例如，模板类的定义若写在.h中可能导致链接错误，而.hpp则能避免此问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;&lt;br&gt;
使用.hpp时需避免以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全局对象/函数&lt;/strong&gt;：多个包含会导致符号重定义，需改用类的静态方法封装；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环调用&lt;/strong&gt;：类之间相互引用需前置声明，但.hpp中需确保依赖关系无循环；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态成员&lt;/strong&gt;：非const静态成员需谨慎初始化，否则可能引发重定义错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结来说，.hpp通过简化代码结构提升了开发效率，但需遵循特定规范以避免潜在问题。&lt;/p&gt;</description></item><item><title>【CPP】Compiler</title><link>https://dyhes.github.io/p/cppcompiler/</link><pubDate>Mon, 31 Mar 2025 00:00:00 +0000</pubDate><guid>https://dyhes.github.io/p/cppcompiler/</guid><description>&lt;h2 id="o-file"&gt;.o file
&lt;/h2&gt;&lt;p&gt;在C/C++开发中，&lt;strong&gt;.o文件&lt;/strong&gt;（Object File）是编译过程中的中间产物，属于&lt;strong&gt;可重定位目标文件&lt;/strong&gt;。以下是关键信息解读：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="基本定义与生成阶段"&gt;&lt;strong&gt;基本定义与生成阶段&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;生成阶段&lt;/strong&gt;：在源代码（&lt;code&gt;.c&lt;/code&gt;/&lt;code&gt;.cpp&lt;/code&gt;）经过&lt;strong&gt;预处理&lt;/strong&gt;（生成&lt;code&gt;.i&lt;/code&gt;）、&lt;strong&gt;编译&lt;/strong&gt;（生成汇编代码&lt;code&gt;.s&lt;/code&gt;）、&lt;strong&gt;汇编&lt;/strong&gt;（生成&lt;code&gt;.o&lt;/code&gt;）后，由汇编器生成&lt;code&gt;.o&lt;/code&gt;文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内容&lt;/strong&gt;：包含未经链接的机器指令（二进制代码）、符号表、重定位信息等。例如，函数调用可能需要通过重定位表在链接阶段修正地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="文件结构与功能"&gt;&lt;strong&gt;文件结构与功能&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;机器代码&lt;/strong&gt;：源文件编译后的二进制指令，但函数和全局变量地址尚未确定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号表（Symbol Table）&lt;/strong&gt;：记录定义的符号（如函数名、全局变量）及其在文件中的偏移量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重定位表（Relocation Table）&lt;/strong&gt;：标记需要链接时修正的地址占位符（如外部函数调用）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据段&lt;/strong&gt;：已初始化的全局变量（&lt;code&gt;.data&lt;/code&gt;节）和未初始化变量占位（&lt;code&gt;.bss&lt;/code&gt;节）。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="实际应用场景"&gt;&lt;strong&gt;实际应用场景&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态库（.a文件）&lt;/strong&gt;：多个&lt;code&gt;.o&lt;/code&gt;文件通过&lt;code&gt;ar&lt;/code&gt;工具打包生成静态库，链接时直接嵌入最终可执行文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态库（.so文件）&lt;/strong&gt;：链接阶段仅记录依赖关系，运行时动态加载，但&lt;code&gt;.o&lt;/code&gt;仍是动态库的构建单元。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增量编译&lt;/strong&gt;：修改部分代码后，只需重新编译对应的&lt;code&gt;.o&lt;/code&gt;文件，加快编译速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="查看与分析工具"&gt;&lt;strong&gt;查看与分析工具&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;nm&lt;/code&gt;命令&lt;/strong&gt;：列出符号表，查看&lt;code&gt;.o&lt;/code&gt;文件中定义和引用的符号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;objdump&lt;/code&gt;/&lt;code&gt;readelf&lt;/code&gt;&lt;/strong&gt;：反汇编或解析ELF格式内容，显示代码段、数据段及重定位信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例&lt;/strong&gt;：执行&lt;code&gt;objdump -d example.o&lt;/code&gt;可查看反汇编后的机器指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="与其他文件的区别"&gt;&lt;strong&gt;与其他文件的区别&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件类型&lt;/th&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;.o（目标文件）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;未链接的中间文件，包含符号表和重定位信息，不可直接执行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;.a（静态库）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;多个&lt;code&gt;.o&lt;/code&gt;的归档文件，链接时复制到可执行文件中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;.so（动态库）&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;运行时加载，&lt;code&gt;.o&lt;/code&gt;是构建基础，但链接方式不同。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id="总结"&gt;总结
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;.o&lt;/code&gt;文件是C/C++编译流程中的核心中间产物，为链接器提供原始机器码和符号信息。理解其结构有助于调试和优化程序，尤其在处理静态库、动态库时不可或缺。&lt;/p&gt;
&lt;h2 id="makefile-vs-cmakeliststxt"&gt;Makefile vs. CMakeLists.txt
&lt;/h2&gt;&lt;p&gt;Makefile 和 CMakeLists.txt 是两种不同的构建系统工具，它们在语法、跨平台性、维护方式等方面存在显著差异。以下是两者的核心区别：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="语法与设计理念"&gt;&lt;strong&gt;语法与设计理念&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Makefile&lt;/strong&gt;&lt;br&gt;
基于规则的脚本语言，需要手动编写编译规则和依赖关系，语法较为底层。例如，需显式指定源文件、目标文件和编译命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-makefile" data-lang="makefile"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nv"&gt;CC&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; gcc
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nv"&gt;TARGET&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; app
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nv"&gt;OBJ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; main.o util.o
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;$(TARGET)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;OBJ&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;$(&lt;/span&gt;CC&lt;span class="k"&gt;)&lt;/span&gt; -o &lt;span class="nv"&gt;$@&lt;/span&gt; $^
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其优势是灵活性高，但复杂项目的依赖管理容易出错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CMakeLists.txt&lt;/strong&gt;&lt;br&gt;
采用声明式语法，抽象程度更高。通过预定义命令描述项目结构和编译逻辑，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cmake" data-lang="cmake"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;cmake_minimum_required&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;VERSION&lt;/span&gt; &lt;span class="s"&gt;3.10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="nb"&gt;project&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;MyProject&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="nb"&gt;add_executable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;myapp&lt;/span&gt; &lt;span class="s"&gt;main.cpp&lt;/span&gt; &lt;span class="s"&gt;util.cpp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种设计简化了跨平台配置，更适合大型项目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="跨平台支持"&gt;&lt;strong&gt;跨平台支持&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Makefile&lt;/strong&gt;&lt;br&gt;
通常针对特定平台（如Linux）编写，移植到其他系统（如Windows）时需手动修改编译规则或工具链配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CMakeLists.txt&lt;/strong&gt;&lt;br&gt;
通过生成器（Generator）机制，可自动生成多种构建系统的配置文件，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unix的&lt;code&gt;Makefile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Windows的&lt;code&gt;Visual Studio&lt;/code&gt;项目&lt;/li&gt;
&lt;li&gt;高性能构建工具&lt;code&gt;Ninja&lt;/code&gt;&lt;br&gt;
这种特性使其天然支持跨平台开发。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="维护复杂度"&gt;&lt;strong&gt;维护复杂度&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Makefile&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需手动管理文件依赖关系，容易遗漏更新（例如修改头文件后需重新编译依赖的源文件）。&lt;/li&gt;
&lt;li&gt;条件判断（如&lt;code&gt;ifeq&lt;/code&gt;）和变量替换语法复杂，调试困难。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CMakeLists.txt&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内置依赖扫描功能（如&lt;code&gt;target_link_libraries&lt;/code&gt;自动链接库文件）。&lt;/li&gt;
&lt;li&gt;支持模块化设计，可通过&lt;code&gt;find_package&lt;/code&gt;集成第三方库（如OpenCV），减少重复代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="适用场景"&gt;&lt;strong&gt;适用场景&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Makefile&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小型项目或单平台开发（如嵌入式Linux）。&lt;/li&gt;
&lt;li&gt;需要精细控制编译流程的场景（如自定义编译优化选项）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CMakeLists.txt&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨平台项目（如同时支持Windows/Linux/macOS）。&lt;/li&gt;
&lt;li&gt;大型复杂工程（如包含多个子模块和外部依赖的C++项目）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="工具链与生态"&gt;&lt;strong&gt;工具链与生态&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Makefile&lt;/strong&gt;&lt;br&gt;
依赖&lt;code&gt;make&lt;/code&gt;工具链，与编译器（如GCC）深度绑定，扩展性有限。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CMakeLists.txt&lt;/strong&gt;&lt;br&gt;
支持现代工具链（如Clang、MSVC），并能与CTest（测试）、CPack（打包）等工具无缝集成，形成完整的构建-测试-发布流程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="总结对比表"&gt;总结对比表
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Makefile&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;CMakeLists.txt&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;语法复杂度&lt;/td&gt;
&lt;td&gt;高（需手动编写规则）&lt;/td&gt;
&lt;td&gt;低（声明式配置）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;跨平台支持&lt;/td&gt;
&lt;td&gt;需手动适配&lt;/td&gt;
&lt;td&gt;自动生成多平台构建文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;依赖管理&lt;/td&gt;
&lt;td&gt;手动维护&lt;/td&gt;
&lt;td&gt;自动处理（如&lt;code&gt;find_package&lt;/code&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;典型应用场景&lt;/td&gt;
&lt;td&gt;小型/单平台项目&lt;/td&gt;
&lt;td&gt;大型/跨平台项目&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;建议选择&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若项目需要快速验证或仅在单一平台运行，优先使用Makefile。&lt;/li&gt;
&lt;li&gt;若涉及多平台协作或依赖复杂库（如Qt、Boost），CMake是更优解。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;gpg &amp;ndash;armor &amp;ndash;export 8ADB7E150F4034C5&lt;/p&gt;
&lt;h2 id="外部依赖"&gt;外部依赖
&lt;/h2&gt;&lt;p&gt;使用 &lt;code&gt;make&lt;/code&gt; 或 &lt;code&gt;CMake&lt;/code&gt; 生成的可执行文件在运行时是否依赖外部文件，取决于以下情况：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="静态链接与动态链接的差异"&gt;&lt;strong&gt;静态链接与动态链接的差异&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;静态链接&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若使用静态库（如 &lt;code&gt;.a&lt;/code&gt; 或 &lt;code&gt;.lib&lt;/code&gt;），所有依赖的库代码会被直接打包到可执行文件中。生成的可执行文件在运行时&lt;strong&gt;不依赖外部库文件&lt;/strong&gt;，但体积较大。&lt;/li&gt;
&lt;li&gt;示例：
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cmake" data-lang="cmake"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;add_library&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;mylib&lt;/span&gt; &lt;span class="s"&gt;STATIC&lt;/span&gt; &lt;span class="s"&gt;src.cpp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 生成静态库
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nb"&gt;target_link_libraries&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;executable&lt;/span&gt; &lt;span class="s"&gt;mylib&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 静态链接
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;动态链接&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若使用动态库（如 &lt;code&gt;.so&lt;/code&gt; 或 &lt;code&gt;.dll&lt;/code&gt;），可执行文件仅记录库的路径和符号，运行时需依赖系统中存在的动态库文件。若动态库缺失或路径错误，程序将无法运行。&lt;/li&gt;
&lt;li&gt;示例：
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cmake" data-lang="cmake"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;add_library&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;mylib&lt;/span&gt; &lt;span class="s"&gt;SHARED&lt;/span&gt; &lt;span class="s"&gt;src.cpp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 生成动态库
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;&lt;/span&gt;&lt;span class="nb"&gt;target_link_libraries&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;executable&lt;/span&gt; &lt;span class="s"&gt;mylib&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 动态链接
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="运行时依赖的其他文件"&gt;&lt;strong&gt;运行时依赖的其他文件&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;即使可执行文件本身不依赖外部库，仍可能因以下原因需要外部文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;配置文件或资源文件&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;若程序运行时需要读取配置文件（如 &lt;code&gt;.json&lt;/code&gt;、&lt;code&gt;.ini&lt;/code&gt;）或资源文件（如图片、数据库），这些文件需存在于指定路径中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;环境变量或系统库&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;动态链接的可执行文件可能依赖系统环境变量（如 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;）来定位动态库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三方工具链&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;若程序依赖特定工具（如 GPU 驱动、Python 解释器），需确保环境已正确安装这些工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="验证依赖的方法"&gt;&lt;strong&gt;验证依赖的方法&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;查看动态依赖&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;在 Linux 下使用 &lt;code&gt;ldd &amp;lt;可执行文件&amp;gt;&lt;/code&gt; 检查动态库依赖关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态编译检查&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;file&lt;/code&gt; 命令查看可执行文件类型（静态链接的文件会显示 &lt;code&gt;statically linked&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="如何减少依赖"&gt;&lt;strong&gt;如何减少依赖&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;强制静态链接&lt;/strong&gt;&lt;br&gt;
在 CMake 中通过 &lt;code&gt;set(CMAKE_EXE_LINKER_FLAGS &amp;quot;-static&amp;quot;)&lt;/code&gt; 强制静态编译。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;打包资源文件&lt;/strong&gt;&lt;br&gt;
将配置文件或资源嵌入代码（如 C++ 的 &lt;code&gt;xxd&lt;/code&gt; 工具生成二进制数组）。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="总结-1"&gt;总结
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;完全独立&lt;/strong&gt;：静态链接且无外部资源依赖的可执行文件可独立运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;部分依赖&lt;/strong&gt;：动态链接或需外部资源的程序需确保依赖文件存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;建议根据实际需求选择链接方式，并通过工具（如 &lt;code&gt;ldd&lt;/code&gt;）验证依赖关系。&lt;/p&gt;
&lt;h2 id="对比"&gt;对比
&lt;/h2&gt;&lt;p&gt;静态链接和动态链接作为两种不同的程序链接方式，各有其独特的优势和适用场景。以下是两者的核心优势对比：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="静态链接的优点"&gt;&lt;strong&gt;静态链接的优点&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;独立性高&lt;/strong&gt;&lt;br&gt;
静态链接将库代码直接嵌入可执行文件，运行时无需依赖外部库文件。即使目标环境中缺少相关库，程序仍可运行。例如，静态编译的 Go 程序可在未安装标准库的机器上直接执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启动速度快&lt;/strong&gt;&lt;br&gt;
由于无需运行时加载外部库，静态链接程序的启动速度更快，尤其适合对启动时间敏感的应用（如命令行工具）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行稳定性强&lt;/strong&gt;&lt;br&gt;
程序行为完全由自身代码决定，不受外部库版本或路径变化的影响，部署后行为可预测。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;简化部署流程&lt;/strong&gt;&lt;br&gt;
只需分发单个可执行文件，避免动态库安装和环境配置的复杂性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="动态链接的优点"&gt;&lt;strong&gt;动态链接的优点&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;节省系统资源&lt;/strong&gt;&lt;br&gt;
多个程序可共享同一动态库的内存实例，减少重复代码对内存和磁盘的占用。例如，Windows 系统的 &lt;code&gt;kernel32.dll&lt;/code&gt; 被所有程序共用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;便于库更新和维护&lt;/strong&gt;&lt;br&gt;
动态库可独立升级，只需替换库文件即可让所有依赖程序生效，无需重新编译主程序。例如，修复 OpenSSL 漏洞时，仅需更新动态库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;减小可执行文件体积&lt;/strong&gt;&lt;br&gt;
动态链接生成的文件不包含库代码，体积更小，适合网络传输和存储受限场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持灵活扩展&lt;/strong&gt;&lt;br&gt;
可通过动态加载不同库实现插件化架构（如 Photoshop 滤镜扩展）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="适用场景对比"&gt;&lt;strong&gt;适用场景对比&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;静态链接&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;动态链接&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;嵌入式系统、无依赖部署、性能敏感程序&lt;/td&gt;
&lt;td&gt;大型软件、共享库环境、需频繁更新的系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;资源占用&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;高（冗余代码）&lt;/td&gt;
&lt;td&gt;低（共享代码）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;维护成本&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;高（需全量重编译）&lt;/td&gt;
&lt;td&gt;低（仅更新库）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;启动速度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;慢（需加载库）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id="技术权衡建议"&gt;&lt;strong&gt;技术权衡建议&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;选择静态链接&lt;/strong&gt;：若对部署便捷性、独立性要求高，或目标环境动态库版本不可控（如旧版 Linux 系统）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选择动态链接&lt;/strong&gt;：若需节省资源、支持热更新，或开发大型模块化软件（如浏览器、数据库）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过工具如 &lt;code&gt;ldd&lt;/code&gt;（Linux）或依赖检查器（Windows）可分析程序的动态库依赖。实际开发中，混合使用两种方式（如核心模块静态链接、插件动态加载）可平衡性能与灵活性。&lt;/p&gt;</description></item><item><title>【CPP】C++程序设计-崔毅东</title><link>https://dyhes.github.io/p/cppc-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%B4%94%E6%AF%85%E4%B8%9C/</link><pubDate>Sun, 06 Dec 2020 00:00:00 +0000</pubDate><guid>https://dyhes.github.io/p/cppc-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%B4%94%E6%AF%85%E4%B8%9C/</guid><description>&lt;h2 id="history"&gt;History
&lt;/h2&gt;&lt;p&gt;符合C++11及之后标准的C++称之为“Modern C++”，即“现代C++”。之前的C++称为“Classic C++”，即“经典C++”&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Year&lt;/th&gt;
&lt;th&gt;C++ Standard&lt;/th&gt;
&lt;th&gt;Informal name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2020&lt;/td&gt;
&lt;td&gt;ISO/IEC 14882:2020&lt;/td&gt;
&lt;td&gt;C++20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2017&lt;/td&gt;
&lt;td&gt;ISO/IEC 14882:2017&lt;/td&gt;
&lt;td&gt;C++17, C++1z&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2014&lt;/td&gt;
&lt;td&gt;ISO/IEC 14882:2014&lt;/td&gt;
&lt;td&gt;C++14, C++1y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2011&lt;/td&gt;
&lt;td&gt;ISO/IEC 14882:2011&lt;/td&gt;
&lt;td&gt;C++11, C++0x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2003&lt;/td&gt;
&lt;td&gt;ISO/IEC 14882:2003&lt;/td&gt;
&lt;td&gt;C++03&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1998&lt;/td&gt;
&lt;td&gt;ISO/IEC 14882:1998&lt;/td&gt;
&lt;td&gt;C++98&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="glossary"&gt;Glossary
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编辑器（Editor）&lt;/p&gt;
&lt;p&gt;程序开发中的“编辑器”一般是指“代码编辑器”。代码编辑器主要用于用来编写和查看程序源代码。通常这种编辑器有语法加亮（Syntax-Highlighting）功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译器（Compiler）&lt;/p&gt;
&lt;p&gt;编译器（compiler），是一种计算机程序，它会将用某种编程语言写成的源代码（原始语言），转换成另一种编程语言（目标语言）。&lt;/p&gt;
&lt;p&gt;A compiler is a computer program that transforms computer code written in one programming language (the source language) into another programming language (the target language). Compilers are a type of translator that support digital devices, primarily computers. The name compiler is primarily used for programs that translate source code &lt;strong&gt;from a high-level programming language to a lower level language&lt;/strong&gt; (e.g., assembly language, object code, or machine code) to create an &lt;strong&gt;executable&lt;/strong&gt; program.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链接器（Linker）&lt;/p&gt;
&lt;p&gt;是一个程序，将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个&lt;strong&gt;可执行文件&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调试器（Debugger）&lt;/p&gt;
&lt;p&gt;调试器是指一种用于调试其它程序的计算机程序及工具。能够让代码在指令组模拟器（ISS）中可以检查运行状况以及选择性地运行，以便排错、调试。当开发的进度遇到瓶颈或找不出哪里有问题时，这技术将是非常有用的。但是将程序运行在调试器之下，这将比直接在运作的平台以及处理器上运行还要来得慢。&lt;/p&gt;
&lt;p&gt;典型的调试器通常能够在程序运行时拥有以下这些功能，例如单步运行（single-stepping）、利用中断点（breakpoint）使程序遇到各种种类的事件（event）时停止（breaking）（一般用于使程序停止在想要检查的状态）、以及追踪某些变量的变化。有些调试器也有能力在想要调试的程序在运行状态时，去改变它的状态，而不仅仅只是用来观察而己。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解释器（interpreter）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解释器是一种计算机程序，能够把高级编程语言一行一行解释运行。解释器像是一位“中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它不会一次把整个程序翻译出来，而是每翻译一行程序就立刻运行，然后再翻译下一行，再运行，如此不停地进行下去。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集成开发环境（Integrated Development Environment，简称IDE）&lt;/p&gt;
&lt;p&gt;集成开发环境是一种辅助程序开发人员开发软件的应用软件，在开发工具内部就可以辅助编写源代码文本、并编译打包成为可用的程序，有些甚至可以设计图形接口。&lt;/p&gt;
&lt;p&gt;IDE通常包括编程语言编辑器、自动构建工具、通常还包括调试器。有些IDE包含编译器／解释器，如微软的Microsoft Visual Studio，有些则不包含，如Eclipse、SharpDevelop等，这些IDE是通过调用第三方编译器来实现代码的编译工作的。有时IDE还会包含版本控制系统和一些可以设计图形用户界面的工具。许多支持面向对象的现代化IDE还包括了类别浏览器、对象查看器、对象结构图。虽然当前有一些IDE支持多种编程语言（例如Eclipse、NetBeans、Microsoft Visual Studio），但是一般而言，IDE主要还是针对特定的编程语言而量身打造（例如Visual Basic）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Visual Studio中包含的C++集成开发环境叫做 Visual C++。&lt;/p&gt;
&lt;h2 id="visial-studio"&gt;Visial Studio
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;工程/项目与解决方案&lt;/p&gt;
&lt;p&gt;Visual C++中，将一个C++项目所需的所有源代码文件、资源文件等组织在一起，形成一个“Project”，我们俗称“C++工程”或者“C++项目”。有时简称“项目”。&lt;/p&gt;
&lt;p&gt;Visual C++ 将一个或者多个C++项目组织在一起，形成一个“Solution”，也就是“解决方案”。&lt;/p&gt;
&lt;p&gt;解决方案中的项目可能有互相的依赖关系。解决方案中的项目可以一键全部编译。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案文件夹&lt;/p&gt;
&lt;p&gt;C++解决方案中，可以建立虚拟的“解决方案文件夹”，将多个项目分类管理。&lt;/p&gt;
&lt;p&gt;C++解决方案中的项目，可能在硬盘的不同目录下，甚至在不同的硬盘上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="命名空间"&gt;命名空间
&lt;/h2&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//not recomended
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;ha&amp;#34;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;ha&amp;#34;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//recomended
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="编译"&gt;编译
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://edu-image.nosdn.127.net/9B0617ED4BF4641BC9997B166B655E9E.jpg?imageView&amp;amp;thumbnail=890x0&amp;amp;quality=100"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;h2 id="输入输出流"&gt;输入输出流
&lt;/h2&gt;&lt;p&gt;&lt;img src="C:%5cUsers%5cdyhes%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20220425141514427.png"
loading="lazy"
alt="image-20220425141514427"
&gt;&lt;/p&gt;
&lt;h2 id="引用reference"&gt;引用（Reference）
&lt;/h2&gt;&lt;p&gt;大部分时候可视为指针的语法糖&lt;/p&gt;
&lt;p&gt;C++的引用主要是为了支持运算符重载；指针的存在主要是为了兼容C语言。&lt;/p&gt;
&lt;p&gt;用户自定义类型最好用引用传参，这样可以避免不必要的构造函数和析构函数调用；对于内置(C-like)类型，按值传参会比按引用传参更高效。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Any changes made through the reference variable are actually performed on the original variable (通过引用所做的读写操作实际上是作用于原变量上).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A reference must be initialized in declaration 引用必须在声明的时候初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Once initialized, the name of the reference cannot be assigned to other variables (引用一旦初始化，引用名字就不能再指定给其它变量)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You can use a reference variable as a parameter in a function and pass a regular variable to invoke the function. (引用可做函数参数，但调用时只需传普通变量即可)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When you change the value through the reference variable, the original value is actually changed. (在被调函数中改变引用变量的值，则改变的是实参的值)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="动态内存管理"&gt;动态内存管理
&lt;/h2&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initialValue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//申请一个变量的空间
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;literalExpression&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//申请数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;pointerName&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//删除一个变量/对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;pointerName&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//删除数组空间
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src="https://img.gejiba.com/images/aefd454d5d165b890c300704b3c34817.png"
loading="lazy"
alt="aefd454d5d165b890c300704b3c34817.png"
&gt;&lt;/p&gt;
&lt;h2 id="数据类型"&gt;数据类型
&lt;/h2&gt;&lt;h3 id="bool"&gt;bool
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;整数0和布尔false互相转化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布尔true转化为整数1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任意非0整数转化为布尔true&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="列表初始化c11"&gt;列表初始化（C++11）
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://img.gejiba.com/images/705cbabcbd800e2a6ab273005950b425.png"
loading="lazy"
alt="705cbabcbd800e2a6ab273005950b425.png"
&gt;&lt;/p&gt;
&lt;p&gt;List initialization is a new feature for C++11 (列表初始化是C++11的一个新特性)&lt;/p&gt;
&lt;p&gt;List: braced-init-list (“列表”是用花括号括起来的一(些)值)&lt;/p&gt;
&lt;p&gt;列表初始化的两个分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Direct list initialization (直接列表初始化)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;/* Variable initialization */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt; &lt;span class="c1"&gt;// x is 0;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// y is 1;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;/* Array initialization */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;array1&lt;/span&gt;&lt;span class="p"&gt;[]{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;o&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;k&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;s3&lt;/span&gt;&lt;span class="p"&gt;[]{&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Copy list initialization (拷贝列表初始化)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;/* Variable initialization */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cm"&gt;/* Array initialization */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;array2&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;s&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;s4&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;World&amp;#34;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;s5&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Aloha&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Omit curly braces (省略花括号)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;List initialization is also called &amp;ldquo;unified initialization&amp;rdquo; (列表初始化也被称为“&lt;strong&gt;统一初始化方法&lt;/strong&gt;”)
Variables and arrays are initialized in the same form (变量和数组用同样的形式初始化)&lt;/p&gt;
&lt;h3 id="when-to-use"&gt;when to use
&lt;/h3&gt;&lt;p&gt;Prefer {} initialization over alternatives unless you have a strong reason not to（尽量使用列表初始化，除非你有个很好的不用它的理由）&lt;/p&gt;
&lt;p&gt;Why: List initialization does not allow narrowing（原因：列表初始化不允许“窄化”，即不允许丢失数据精度的隐式类型转换）&lt;/p&gt;
&lt;h2 id="类型转换"&gt;类型转换
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;隐式类型转换
由编译器按照数据类型的转换规则自动转换，无需程序员干预。
可能导致数据精度损失，或者转换失败。应&lt;strong&gt;尽量避免&lt;/strong&gt;使用隐式类型转换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显式类型转换（即：强制类型转换）
由程序员用明确的类型转换语法写出类型转换代码。好处是，程序员知道自己要做什么并且把这个想法明确表达出来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c++" data-lang="c++"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;//c style
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mf"&gt;2.5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;//cpp style
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="auto-c11"&gt;auto (C++11)
&lt;/h2&gt;&lt;p&gt;C++03及之前的标准种，auto放在变量声明之前，声明变量的存储策略。但是这个关键字常省略不写。
C++11中，auto关键字放在变量之前，作用是在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;auto 变量必须在定义时初始化，这类似于const关键字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义在一个auto序列的变量必须始终推导成同一类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果初始化表达式是引用或const，则去除引用或const语义。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//c的类型为int而非int&amp;amp;（去除引用）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//b1的类型为int而非const int（去除const）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果auto关键字带上&amp;amp;号，则不去除引用或const语意&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//此时d的类型才为int&amp;amp;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//因为auto带上&amp;amp;，故不去除const，b2类型为const in
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化表达式为数组时，auto关键字推导类型为指针。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;b3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b3&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//输出int * （输出与编译器有关）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若表达式为数组且auto带上&amp;amp;，则推导类型为数组类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a7&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b7&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b7&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//输出int [3] （输出与编译器有关）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++14中，auto可以作为函数的返回值类型和参数类型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="why-almost-always-auto"&gt;Why Almost Always Auto
&lt;/h3&gt;&lt;p&gt;Using auto are for correctness, performance, maintainability, robustness—and convenience (使用auto是为了代码的正确性、性能、可维护性、健壮性，以及方便)&lt;/p&gt;
&lt;h2 id="decltype"&gt;decltype
&lt;/h2&gt;&lt;p&gt;decltype利用已知类型声明新变量。&lt;/p&gt;
&lt;p&gt;decltype是在编译期推导一个表达式的类型，它只做静态分析，因此它不会导致已知类型表达式执行。
decltype 主要用于泛型编程（模板）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&amp;lt;iostream&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;fun1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;//修改fun1()时不必改动其他
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="nf"&gt;fun2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// C++14
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Data type of x is same as return type of fun1()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="c1"&gt;// and type of y is same as return type of fun2()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun1&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 不会执行fun1()函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;decltype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun2&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fun2&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="内存模型"&gt;内存模型
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Stack&lt;/p&gt;
&lt;p&gt;编译器自动分配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Heap&lt;/p&gt;
&lt;p&gt;由程序员分配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Global/Static&lt;/p&gt;
&lt;p&gt;存储全局变量和静态变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Constant&lt;/p&gt;
&lt;p&gt;内容不可修改&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://img.gejiba.com/images/cd4f439f2e8ce127e9faa68307263fc5.png"
loading="lazy"
alt="cd4f439f2e8ce127e9faa68307263fc5.png"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img.gejiba.com/images/026ffeeb969e36bbacbd4febcec14441.png"
loading="lazy"
alt="026ffeeb969e36bbacbd4febcec14441.png"
&gt;&lt;/p&gt;
&lt;h2 id="常量与指针"&gt;常量与指针
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Pointer to Constant(常量指针、常指针)&lt;/p&gt;
&lt;p&gt;指针所指向的内容不可以通过指针的间接引用(*p)来改变。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;p1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//指针 p1的类型是 (const int*)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Error!
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Error!
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Correct!
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pointer Constant(指针常量)&lt;/p&gt;
&lt;p&gt;指针本身为常量，不可改变&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//常量 p2的类型是 (int*)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Okay! à x=10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;p2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Error! p2 is a constant
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://img.gejiba.com/images/9ac2198c912b3e54745e4267064f25dc.md.png"
loading="lazy"
alt="9ac2198c912b3e54745e4267064f25dc.png"
&gt;&lt;/p&gt;
&lt;h2 id="using-typedef-and-define"&gt;using, typedef, and #define
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;typedef&lt;/p&gt;
&lt;p&gt;定义类型别名&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;MyPointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;using (C11)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-CPP" data-lang="CPP"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;ConstPointer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;using的写法比typedef的写法更加直观，所以，我们应尽量使用using声明新类型名。而且当涉及到模版类型名时，只能使用using。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;#define&lt;/p&gt;
&lt;p&gt;定义宏，编译器对宏进行替换&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="作用域"&gt;作用域
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;全局作用域&lt;/li&gt;
&lt;li&gt;局部作用域
&lt;ul&gt;
&lt;li&gt;文件作用域&lt;/li&gt;
&lt;li&gt;函数作用域&lt;/li&gt;
&lt;li&gt;函数中的块级作用域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="一元作用域解析运算符unary-scope-resolution"&gt;一元作用域解析运算符（Unary Scope Resolution）
&lt;/h4&gt;&lt;p&gt;If a local variable name is the same as a global variable name, you can access the global variable using ::globalVariable. (局部变量名与全局变量名相同时，可使用 :: 访问全局变量)&lt;/p&gt;
&lt;p&gt;The :: operator is known as the unary scope resolution.（:: 这个运算符被称为一元作用域解析运算符）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;local variable v1 is &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;global variable v1 is &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;v1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="特殊函数"&gt;特殊函数
&lt;/h2&gt;&lt;h4 id="重载函数"&gt;重载函数
&lt;/h4&gt;&lt;p&gt;根据参数（个数，类型）判断，应避免二义性&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;2.1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;//出现二义性
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="默认参数"&gt;默认参数
&lt;/h4&gt;&lt;p&gt;默认值参数应后置&lt;/p&gt;
&lt;h4 id="内联函数inline-function"&gt;内联函数（Inline Function）
&lt;/h4&gt;&lt;p&gt;普通函数性能有额外开销&lt;/p&gt;
&lt;p&gt;内联函数可减小函数调用开销，将代码插入到调用处，会导致程序变大&lt;/p&gt;
&lt;p&gt;是一种请求而非命令&lt;/p&gt;
&lt;h2 id="面向对象"&gt;面向对象
&lt;/h2&gt;&lt;h4 id="构造函数"&gt;构造函数
&lt;/h4&gt;&lt;p&gt;A class may be declared without ctors (类可不声明构造函数)&lt;/p&gt;
&lt;p&gt;(1) A no-arg constructor with an empty body is implicitly declared in the class.
(编译器会提供一个带有空函数体的无参构造函数)&lt;/p&gt;
&lt;p&gt;(2) This constructor, called a default constructor is provided automatically only if no constructors are explicitly declared in the class.
(只有当未明确声明构造函数时，编译器才会提供这个构造函数，并称之为“默认构造函数”)&lt;/p&gt;
&lt;h4 id="拷贝构造函数"&gt;拷贝构造函数
&lt;/h4&gt;&lt;p&gt;Copy Constructor&lt;/p&gt;
&lt;p&gt;拷贝构造：用一个对象初始化另一个同类对象&lt;/p&gt;
&lt;p&gt;拷贝构造函数可以简写为 copy ctor，或者 cp ctor&lt;/p&gt;
&lt;p&gt;如何声明拷贝构造函数(copy ctor)&lt;/p&gt;
&lt;p&gt;Circle (Circle&amp;amp;);&lt;/p&gt;
&lt;p&gt;Circle (const Circle&amp;amp;);&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;X&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//来自C++11标准: 12.8节
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="nf"&gt;b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// calls X(const X&amp;amp;, int);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// calls X(const X&amp;amp;, int);
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In general, if the programmer does not provide a copy ctor, the compiler will generate one.(一般情况下，如果程序员不编写拷贝构造函数，那么编译器会自动生成一个)&lt;/p&gt;
&lt;p&gt;The generated copy ctor is called &amp;quot; implicitly-declared/defined copy ctor &amp;quot; (自动生成的拷贝构造函数叫做“隐式声明/定义的拷贝构造函数”&lt;/p&gt;
&lt;p&gt;In general, the implicitly-declared/defined copy ctor simply copies each data field in one object to its counterpart in the other object. (一般情况下，隐式声明的copy ctor简单地将作为参数的对象中的每个数据域复制到新对象中)&lt;/p&gt;
&lt;h4 id="析构函数"&gt;析构函数
&lt;/h4&gt;&lt;p&gt;Destructors are the opposite of constructors. (dtor vs ctor) 析构函数与构造函数正好相反&lt;/p&gt;
&lt;p&gt;下表中展示了ctor和dtor的对比&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Destructor&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Constructor&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;When to invoke(何时调用)&lt;/td&gt;
&lt;td&gt;when the object is destroyed(对象销毁时)&lt;/td&gt;
&lt;td&gt;when an object is created(对象创建时)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Prototype(原型)&lt;/td&gt;
&lt;td&gt;C::~C( )&lt;/td&gt;
&lt;td&gt;C::C(arguments)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Default prototype(默认函数的原型)&lt;/td&gt;
&lt;td&gt;C::~C( )&lt;/td&gt;
&lt;td&gt;C::C( ) 或参数带有默认值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;What if no explicit decl? (没有显式声明怎么办)&lt;/td&gt;
&lt;td&gt;Compiler will create a default one (编译器会生成默认函数)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Overloadable(可否重载)&lt;/td&gt;
&lt;td&gt;No, only 1&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="友元函数"&gt;友元函数
&lt;/h4&gt;&lt;p&gt;Private members: cannot be accessed from outside of the class. (私有成员无法从类外访问)&lt;/p&gt;
&lt;p&gt;Occasionally, it is convenient to allow some trusted functions and classes to access a class’s private members. (但有时又需要授权某些可信的函数和类访问这些私有成员)&lt;/p&gt;
&lt;p&gt;C++ enables you to use the friend keyword to declare friend functions and friend classes for a class (用friend关键字声明友元函数或者友元类)&lt;/p&gt;
&lt;p&gt;Disadvantage of &amp;ldquo;friend&amp;rdquo;: break the encapsulation (友元的缺点：打破了封装性)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Date&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;year&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;2019&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;month&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;day&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Kid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;year&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;/&amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;month&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;/&amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;day&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Kid&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="n"&gt;birthday&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Kid&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;I was born in &amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;birthday&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;year&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Kid&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="创建对象"&gt;创建对象
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="n"&gt;circle1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 正确，但不推荐这样写
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="nf"&gt;circle2&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 错误！C++编译器认为这是一个函数声明
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="n"&gt;circle3&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt; &lt;span class="c1"&gt;// 正确，推荐写法。这里面明确显示用空初始化列表初始化circle3对象（调用Circle默认构造函数）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="对象拷贝"&gt;对象拷贝
&lt;/h4&gt;&lt;p&gt;How to copy the contents from one object to the other?(如何将一个对象的内容拷贝给另外一个对象)&lt;/p&gt;
&lt;p&gt;(1) use the assignment operator( 使用赋值运算符) ： =&lt;/p&gt;
&lt;p&gt;(2) By default, &lt;strong&gt;each data field&lt;/strong&gt; of one object is copied to its counterpart in the other object. ( 默认情况下，对象中的每个数据域都被拷贝到另一对象的对应部分)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;circle2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;circle1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;将&lt;/span&gt;&lt;span class="n"&gt;circle1&lt;/span&gt; &lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt; &lt;span class="err"&gt;拷贝到&lt;/span&gt;&lt;span class="n"&gt;circle2&lt;/span&gt; &lt;span class="err"&gt;中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;拷贝后：&lt;/span&gt;&lt;span class="n"&gt;circle1&lt;/span&gt; &lt;span class="err"&gt;和&lt;/span&gt; &lt;span class="n"&gt;circle2&lt;/span&gt; &lt;span class="err"&gt;是两个不同的对象，但是半径的值是相同的。&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="err"&gt;但是各自有一个&lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt; &lt;span class="err"&gt;成员变量&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="浅拷贝与深拷贝"&gt;浅拷贝与深拷贝
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;前提条件&lt;/strong&gt;是，类A中有个指针p，指向一个外挂对象b（b是B类型的对象）；如果类A里面没有指针成员p，那也就不要谈深浅拷贝了。&lt;/p&gt;
&lt;p&gt;现在有一个类A的对象a1（a1的指针p指向外挂对象b1）。以拷贝构造的方式，创建a1的一个拷贝a2。&lt;/p&gt;
&lt;p&gt;(1) 如果仅仅将a1.p的值（这个值是个地址）拷贝给 a2.p，这就是浅拷贝。浅拷贝之后，a1.p和a2.p都指向外挂对象 b1&lt;/p&gt;
&lt;p&gt;(2) 如果创建一个外挂对象b2，将 a2.p指向b2；并且将b1的值拷贝给b2，这就是深拷贝&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Shallow copy: if the field is a pointer to some object, the address of the pointer is copied rather than its contents. (浅拷贝：数据域是一个指针，只拷指针的地址，而非指针指向的内容)&lt;/p&gt;
&lt;p&gt;在两种情况下会出现浅拷贝&lt;/p&gt;
&lt;p&gt;(1) Implicit/default copy ctor (创建新对象时，调用类的&lt;strong&gt;隐式/默认构造函数&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;(2) default assignment operator for copying = (为已有对象赋值时，使用&lt;strong&gt;默认赋值运算符&lt;/strong&gt;)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Employee&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;Jack&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1999&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Gender&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;male&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Employee&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;Anna&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nl"&gt;Gender&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;female&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Employee&lt;/span&gt; &lt;span class="n"&gt;e3&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;//cp ctor，执行一对一成员拷贝
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的代码执行之后，e3.birthday指针指向了 e1.birthday所指向的那个Date对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Deep copy: Copy the contents that pointed by the pointer (深拷贝：拷贝指针指向的内容)&lt;/p&gt;
&lt;p&gt;如何深拷贝&lt;/p&gt;
&lt;p&gt;(1) &lt;strong&gt;自行编写拷贝构造函数&lt;/strong&gt;，不使用编译器隐式生成的（默认）拷贝构造函数&lt;/p&gt;
&lt;p&gt;(2) &lt;strong&gt;重载赋值运算符&lt;/strong&gt;，不使用编译器隐式生成的（默认）赋值运算符函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Employee&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Employee(const Employee &amp;amp;e) = default; //浅拷贝ctor
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Employee&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Employee&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="c1"&gt;//深拷贝ctor
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;birthdate&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;birthdate&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Employee&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;Jack&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1999&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Gender&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;male&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Employee&lt;/span&gt; &lt;span class="n"&gt;e2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;Anna&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;),,&lt;/span&gt; &lt;span class="nl"&gt;Gender&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;female&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Employee&lt;/span&gt; &lt;span class="n"&gt;e3&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;e1&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;//cp ctor 深拷贝
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="anonymous-object"&gt;Anonymous Object
&lt;/h4&gt;&lt;p&gt;匿名对象&lt;/p&gt;
&lt;p&gt;Occasionally, you may create an object and use it only once. (有时需要创建一个只用一次的对象)&lt;/p&gt;
&lt;p&gt;An object without name is called anonymous objects. (这种不命名的对象叫做匿名对象)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mf"&gt;1.1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mf"&gt;2.2&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// 用匿名对象做拷贝列表初始化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="n"&gt;c3&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt; &lt;span class="c1"&gt;// 直接列表初始化,调默认Ctor
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;c3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mf"&gt;3.3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// 用匿名对象赋值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Area is &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mf"&gt;4.2&lt;/span&gt;&lt;span class="p"&gt;}.&lt;/span&gt;&lt;span class="n"&gt;getArea&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Area is &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getArea&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 不推荐
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Area is &amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;getArea&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 不推荐
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="local-class--nested-class"&gt;Local class &amp;amp; Nested class
&lt;/h4&gt;&lt;p&gt;局部类和嵌套类&lt;/p&gt;
&lt;p&gt;Local class : a class declared inside a function (局部类是在一个函数中声明的类)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;C&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// C及其对象只在f()中可用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 成员函数必须在C中实现
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="cm"&gt;/* 访问f()的成员受限 ……. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nested class: a class declared in another enclosing class (嵌套类是在另一个类中声明的类)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;E&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;N&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// N及其对象可访问E的成员
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="cm"&gt;/* 声明N的成员 ……. */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="object-pointerdynamic-object"&gt;Object Pointer&amp;amp;Dynamic Object
&lt;/h4&gt;&lt;p&gt;对象指针与动态对象&lt;/p&gt;
&lt;p&gt;Object pointers can be assigned new object names(对象指针可以指向新的对象名)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Arrow operator&lt;/strong&gt; -&amp;gt; : Using pointer to access object members (箭头运算符 -&amp;gt; ：用指针访问对象成员)&lt;/p&gt;
&lt;p&gt;Object declared in a function is created in the stack.(在函数中声明的对象都在&lt;strong&gt;栈&lt;/strong&gt;上创建)； When the function returns, the object is destroyed (&lt;strong&gt;函数返回，则对象被销毁&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;To retain the object, you may create it dynamically on the heap using the new operator. (为&lt;strong&gt;保留对象&lt;/strong&gt;，你可以用new运算符在堆上创建它)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCircle1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt; &lt;span class="c1"&gt;//用无参构造函数创建对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;ClassName&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;variable&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ClassName&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCircle2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mf"&gt;5.9&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;//用有参构造函数创建对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;//程序结束时，动态对象会被销毁，或者
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;pObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//用delete显式销毁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="array-of-objects"&gt;Array of objects
&lt;/h4&gt;&lt;p&gt;对象数组&lt;/p&gt;
&lt;p&gt;(1) 声明方式1&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="n"&gt;ca1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(2) 声明方式2&lt;/p&gt;
&lt;p&gt;用匿名对象构成的列表初始化数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="n"&gt;ca2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 注意：不可以写成： auto ca2[3]= 因为声明数组时不能用auto
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(3) 声明方式3&lt;/p&gt;
&lt;p&gt;用C++11列表初始化，列表成员为隐式构造的匿名对象&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="n"&gt;ca3&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mf"&gt;3.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="n"&gt;ca4&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mf"&gt;3.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(4) 声明方式4&lt;/p&gt;
&lt;p&gt;用new在&lt;strong&gt;堆区&lt;/strong&gt;生成对象数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]{&lt;/span&gt; &lt;span class="mf"&gt;3.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{},&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;p1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;nullptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="objects--function"&gt;Objects &amp;amp; Function
&lt;/h4&gt;&lt;h6 id="objects-as-function-arguments"&gt;Objects as Function Arguments
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;值传递：无法改变成员值&lt;/li&gt;
&lt;li&gt;引用传递&lt;/li&gt;
&lt;li&gt;指针传递&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说，&lt;strong&gt;能用引用尽量不用指针&lt;/strong&gt;。引用更加直观，更少出现意外的疏忽导致的错误。&lt;/p&gt;
&lt;p&gt;指针可以有二重、三重之分，比引用更加灵活。有些情况下，例如使用 new 运算符，只能用指针。&lt;/p&gt;
&lt;h6 id="objects-as-function-return-value"&gt;Objects as Function Return Value
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指针作为返回类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;evil way&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// class Object { ... };
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="cm"&gt;/*函数形参*/&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 这是“邪恶”的用法，不要这样做
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Do something
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// main() {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="cm"&gt;/*实参*/&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="cm"&gt;/*实参*/&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;memberFunction&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 记得要delete o
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// class Object { ... };
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/*其它形参*/&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Do something
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// main() {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="cm"&gt;/*实参*/&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 不应该delete o
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用作为返回类型（提高效率）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;evil way&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// class Object { ... };
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="cm"&gt;/*函数形参*/&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Do something
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//这是邪恶的用法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可行1&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// class Object { ... };
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;X&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="cm"&gt;/*实参*/&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Do something
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可行2&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// class Object { ... };
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/*其它形参*/&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Do something
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// main() {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="cm"&gt;/*实参*/&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="cm"&gt;/*实参*/&lt;/span&gt; &lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;memberFunction&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="成员作用域和this指针"&gt;成员作用域和this指针
&lt;/h4&gt;&lt;p&gt;The data members are accessible to all constructors and functions in the class. (数据成员可被类内所有函数访问)&lt;/p&gt;
&lt;p&gt;Data fields and functions can be declared in any order in a class. (数据域与函数可按任意顺序声明)&lt;/p&gt;
&lt;p&gt;If a local variable has the same name as a data field: (若成员函数中的局部变量与某数据域同名)&lt;/p&gt;
&lt;p&gt;(1) the local variable takes precedence ( 局部变量优先级高：就近原则)&lt;/p&gt;
&lt;p&gt;(2) the data field with the same name is hidden. ( 同名数据域在函数中被屏蔽)&lt;/p&gt;
&lt;p&gt;How do you reference a class’s hidden data field in a function? (如何在函数内访问类中被屏蔽的数据域)？ 可以使用 this 关键字&lt;/p&gt;
&lt;p&gt;This 关键字的特性&lt;/p&gt;
&lt;p&gt;(1) a special built-in pointer ( 特殊的内建指针)&lt;/p&gt;
&lt;p&gt;(2) references to the calling object. ( &lt;strong&gt;引用当前函数的调用对象&lt;/strong&gt;)&lt;/p&gt;
&lt;h4 id="default-member-initializers"&gt;Default Member Initializers
&lt;/h4&gt;&lt;p&gt;就地初始化&lt;/p&gt;
&lt;p&gt;In C++03, only static const members of integral types could be initialized in-class (在C++03标准中，只有静态常量整型成员才能在类中就地初始化)&lt;/p&gt;
&lt;p&gt;C++11 was to allow a non-static data member to be initialized where it is declared in its class (C++11标准中，非静态成员可以在它声明的时候初始化)&lt;/p&gt;
&lt;p&gt;数组必须声明长度&lt;/p&gt;
&lt;h4 id="constructor-initializer-lists"&gt;Constructor Initializer Lists
&lt;/h4&gt;&lt;p&gt;构造函数初始化列表&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;在构造函数中用初始化列表初始化数据域&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;ClassName&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parameterList&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dataField1&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value1&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="n"&gt;dataField2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Something to do
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A data field is an object type (Object in Object / Embedded Object) (类的数据域是一个对象类型，被称为对象中的对象，或者内嵌对象)&lt;/p&gt;
&lt;p&gt;The embedded object must be constructed before the body of ctor is executed (内嵌对象必须在被嵌对象的构造函数体执行前就构造完成)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Time&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* Code omitted */&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Action&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Action&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;hour&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;minute&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hour&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;minute&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//time对象应该在构造函数体之前构造完成
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Time&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Action&lt;/span&gt; &lt;span class="nf"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;59&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If object type members/embedded objects are not initialized explicitly (若对象类型成员/内嵌对象成员没有被显式初始化)&lt;/p&gt;
&lt;p&gt;(1) the default constructor of the embedded object is automatically invoked. ( 该内嵌对象的无参构造函数会被自动调用)&lt;/p&gt;
&lt;p&gt;(2) If a default constructor of the embedded object does not exist, a compilation error will be reported. ( 若内嵌对象没有无参构造函数，则编译器报错)&lt;/p&gt;
&lt;h4 id="order-of-member-initialization"&gt;Order of Member Initialization
&lt;/h4&gt;&lt;p&gt;Default Member Initialization (就地初始化)&lt;/p&gt;
&lt;p&gt;Constructor Initialization List (构造函数初始化列表)&lt;/p&gt;
&lt;p&gt;Assign Values to the members in Ctor Body (在构造函数体中为成员赋值)。注意，这个不是初始化，而是赋值。&lt;/p&gt;
&lt;p&gt;执行次序： 就地初始化 &amp;gt; Ctor 初始化列表 &amp;gt; 在Ctor 函数体中为成员赋值&lt;/p&gt;
&lt;p&gt;哪个起作用（初始化/赋值优先级）： 在Ctor 函数体中为成员赋值 &amp;gt; Ctor 初始化列表 &amp;gt; 就地初始化&lt;/p&gt;
&lt;h4 id="delegation-constructor"&gt;Delegation Constructor
&lt;/h4&gt;&lt;p&gt;代理构造：One ctor can call another ctor (一个构造函数可以调用另外的构造函数)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;average&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;average&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面例子中，构造函数的调用次序:&lt;/p&gt;
&lt;p&gt;A() &amp;gt; A(int) &amp;gt; A(int, int)&lt;/p&gt;
&lt;h4 id="static-members"&gt;Static Members
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：Inside a class definition, &amp;ldquo;static&amp;rdquo; declares members that are not bound to class instances
在类定义中，关键字 static 声明不绑定到类实例的成员( 该成员无需创建对象即可访问)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;(1) 声明为“constexpr”类型的静态数据成员必须 在类中声明 并初始化。自C++17 起，可不在类外定义&lt;/p&gt;
&lt;p&gt;(2) 声明为“inline”(C++17 起) 或者 “const int” 类型的静态数据成员可以 在类中声明 并初始化；&lt;/p&gt;
&lt;p&gt;(3) 其它须在类外定义并初始化，且不带static 关键字&lt;/p&gt;
&lt;p&gt;静态数据成员的定义规则复杂，在类外定义，大部分情况下不会出错&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;静态数据成员具有静态存储期(static storage duration)或者C++11线程存储期特性&lt;/p&gt;
&lt;p&gt;(1) Only one instance of the object exists ( 只存在对象的一个实例)&lt;/p&gt;
&lt;p&gt;(2) 静态存储器对象未明确初始化时会被自动“零初始化(Zero-Initialization)”&lt;/p&gt;
&lt;h4 id="accessibility"&gt;Accessibility
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;private&lt;/p&gt;
&lt;p&gt;Private members can only be accessed from the inside of the class (私有成员只能在类内的函数访问)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;protected: A protected data field or a protected function in a base class can be accessed by name in its derived classes (保护属性的数据或函数可被派生类成员访问)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;public: Public members can be accessed from any other classes. (公有成员可被任何其他类访问)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id="与继承结合"&gt;与继承结合
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;公有继承&lt;/p&gt;
&lt;p&gt;(1) 基类成员 在派生类中的访问属性不变。&lt;/p&gt;
&lt;p&gt;(2) 派生类的成员函数 可以访问基类的&lt;strong&gt;公有&lt;/strong&gt;成员和&lt;strong&gt;保护&lt;/strong&gt;成员，不能访问基类的私有成员;&lt;/p&gt;
&lt;p&gt;(3) 派生类以外的其它函数 可以通过派生类的对象，访问从基类继承的&lt;strong&gt;公有&lt;/strong&gt;成员, 但不能访问从基类继承的保护成员和私有成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保护继承&lt;/p&gt;
&lt;p&gt;) 基类成员 公有成员和保护成员变成protected，私有成员不变。&lt;/p&gt;
&lt;p&gt;(2) 派生类的成员函数 可以访问基类的&lt;strong&gt;公有&lt;/strong&gt;成员和&lt;strong&gt;保护&lt;/strong&gt;成员，不能访问基类的私有成员;&lt;/p&gt;
&lt;p&gt;(3) 派生类以外的其它函数 不能通过派生类的对象，访问从基类继承的任何成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;私有继承&lt;/p&gt;
&lt;p&gt;(1) 基类成员 在派生类中都变成 private。&lt;/p&gt;
&lt;p&gt;(2) 派生类的成员函数 可以访问基类的&lt;strong&gt;公有&lt;/strong&gt;成员和&lt;strong&gt;保护&lt;/strong&gt;成员，不能访问基类的私有成员;&lt;/p&gt;
&lt;p&gt;(3) 派生类以外的其它函数 不能通过派生类的对象，访问从基类继承的任何成员。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="abstract-class"&gt;Abstract Class
&lt;/h4&gt;&lt;p&gt;Sometimes a base class is so abstract that it cannot have any specific instances. Such a class is referred to as an abstract class (类太抽象以至于无法实例化就叫做抽象类)&lt;/p&gt;
&lt;p&gt;the class which contains abstract functions (包含抽象函数的类被称为抽象类)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract Functions / Pure Virtual Function (抽象函数/纯虚函数)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抽象函数(abstract functions)要求子类实现它&lt;/p&gt;
&lt;p&gt;virtual double getArea() = 0;&lt;/p&gt;
&lt;h4 id="dynamic-cast"&gt;Dynamic Cast
&lt;/h4&gt;&lt;p&gt;动态类型转换&lt;/p&gt;
&lt;p&gt;dynamic_cast 运算符&lt;/p&gt;
&lt;p&gt;(1) 沿继承层级向上、向下及侧向转换到类的指针和引用&lt;/p&gt;
&lt;p&gt;(2) 转指针：失败返回nullptr&lt;/p&gt;
&lt;p&gt;(3) 转引用：失败抛异常&lt;/p&gt;
&lt;h4 id="typeid"&gt;typeid
&lt;/h4&gt;&lt;p&gt;typeid operator (typeid运算符)&lt;/p&gt;
&lt;p&gt;typeid is used to obtain the information about the class of the object (typeid用于获取对象所属的类的信息)&lt;/p&gt;
&lt;p&gt;(1) typeid returns a reference to an object of class type_info. (typeid运算符返回一个type_info对象的引用)&lt;/p&gt;
&lt;p&gt;(2) typeid(AType).name() 返回实现定义的，含有类型名称的C风格字符串(char *)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;typeinfo&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt; &lt;/span&gt;&lt;span class="c1"&gt;//使用typeid，需要包含此头文件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// ……
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;a has type &amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="继承"&gt;继承
&lt;/h2&gt;&lt;p&gt;C++11引入&lt;em&gt;final&lt;/em&gt;特殊标识符，可以使得类不能被继承&lt;/p&gt;
&lt;p&gt;C++11:派生类&lt;strong&gt;不继承&lt;/strong&gt;的特殊函数&lt;/p&gt;
&lt;p&gt;(1) 析构函数&lt;/p&gt;
&lt;p&gt;(2) 友元函数&lt;/p&gt;
&lt;p&gt;继承基类构造函数&lt;/p&gt;
&lt;p&gt;(1) using A::A; 继承所有基类ctor&lt;/p&gt;
&lt;p&gt;(2) 不能仅继承指定的某个基类ctor&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 等价于 class A { public:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// C++11
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 继承基类所有构造函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// 就地初始化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 调A(int i)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="constructor-chaining-构造函数链"&gt;constructor chaining (构造函数链)
&lt;/h4&gt;&lt;p&gt;Constructing an instance of a class invokes all the base class along the inheritance chain. (构造类实例会沿着继承链调用所有的基类ctor)&lt;/p&gt;
&lt;p&gt;调用次序: base first, derive next (父先子后)&lt;/p&gt;
&lt;h4 id="destructor-chaining-析构函数链"&gt;destructor chaining (析构函数链)
&lt;/h4&gt;&lt;p&gt;Conversely, the destructors are automatically invoked in reverse order(dtor与ctor正好相反)&lt;/p&gt;
&lt;p&gt;调用次序: derive first, base next (子先父后)&lt;/p&gt;
&lt;h4 id="name-hiding-in-inheritance"&gt;Name Hiding in Inheritance
&lt;/h4&gt;&lt;p&gt;继承中的名字隐藏&lt;/p&gt;
&lt;p&gt;Names in inner scopes hide names in outer scopes. (内部作用域的名字隐藏外部作用域的(同名)名字)&lt;/p&gt;
&lt;p&gt;(1) The derived class acts as an inner scope (派生类视作内部作用域)&lt;/p&gt;
&lt;p&gt;(2) The base class as an outer scope(基类视作外部作用域)&lt;/p&gt;
&lt;p&gt;why?&lt;/p&gt;
&lt;p&gt;(1) To avoid certain potentially dangerous behavior (避免某些潜在的危险行为)&lt;/p&gt;
&lt;p&gt;(2) Each class starts with a &amp;ldquo;clean sheet&amp;rdquo; with respect to each method name it declares (每个类在创建时，它的函数名都是写在一张干净的白纸上面，不会被基类函数名干扰)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;using-declaration&lt;/strong&gt; : introduce base class members into derived class definitions (using 声明语句可以将基类成员引入到派生类定义中)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;P&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;C&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//此处不带小括号
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="多态"&gt;多态
&lt;/h2&gt;&lt;p&gt;截止目前：多态性有两种表现的方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重载多态&lt;/li&gt;
&lt;li&gt;子类型多态：不同的对象调用同名重定义函数，表现出不同的行为&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;联编(Binding):&lt;/strong&gt; 确定具有多态性的语句调用哪个函数的过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Static Binding (静态联编)&lt;/p&gt;
&lt;p&gt;在程序编译时(Compile-time)确定调用哪个函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dynamic Binding (动态联编)&lt;/p&gt;
&lt;p&gt;在程序运行时(Run-time)，才能够确定调用哪个函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="run-time-polymorphism"&gt;Run-time Polymorphism
&lt;/h4&gt;&lt;p&gt;用动态联编实现的多态，也称为运行时多态(Run-time Polymorphism)。&lt;/p&gt;
&lt;p&gt;实现运行时多态有两个要素：&lt;/p&gt;
&lt;p&gt;(1) virtual function (虚函数)&lt;/p&gt;
&lt;p&gt;(2) Override (覆写) : redefining a virtual function in a derived class. (在派生类中重定义一个虚函数)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同名虚函数的调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) 不由指针类型决定；&lt;/p&gt;
&lt;p&gt;(2) 而由指针所指的【实际对象】的类型决定&lt;/p&gt;
&lt;p&gt;(3) 运行时，检查指针所指对象类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用途&lt;/strong&gt;：可以用父类指针访问子类对象成员&lt;/p&gt;
&lt;p&gt;If a function is defined virtual in a base class, it is automatically virtual in all its derived classes. (基类定义了虚同名函数，那么派生类中的同名函数自动变为虚函数)&lt;/p&gt;
&lt;p&gt;类中保存着一个Virtual function table (虚函数表)&lt;/p&gt;
&lt;p&gt;Run-time binding (运行时联编/动态联编)&lt;/p&gt;
&lt;p&gt;More overhead in run-time than non-virtual function (比非虚函数开销大)&lt;/p&gt;
&lt;p&gt;基类与派生类中有同名函数&lt;/p&gt;
&lt;p&gt;(1) 通过派生类对象访问同名函数，是静态联编&lt;/p&gt;
&lt;p&gt;(2) 通过基类对象的指针访问同名函数，是静态联编&lt;/p&gt;
&lt;p&gt;(3) 通过基类对象的指针或引用访问同名虚函数，是动态联编&lt;/p&gt;
&lt;h4 id="override-and-final"&gt;override and final
&lt;/h4&gt;&lt;p&gt;C++11引入override标识符，指定一个虚函数覆写另一个虚函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 错误： B::foo 不覆写 A::foo
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// （签名不匹配）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;override&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// OK ： B::foo 覆写 A::foo
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt; &lt;span class="c1"&gt;// 错误： A::bar 非虚
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;// 错误： override只能放到类内使用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;C++11引入final特殊标识符，指定派生类不能覆写虚函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;final&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// A::foo 被覆写且是最终覆写
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;final&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 错误：非虚函数不能被覆写或是 final
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt; &lt;span class="k"&gt;final&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="c1"&gt;// struct B 为 final，不能被继承
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;override&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 错误： foo 不能被覆写，因为它在 A 中是 final
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;struct可与class互换；差别在于struct的默认访问属性是public&lt;/p&gt;
&lt;h2 id="structured-binding-declarationc17"&gt;Structured Binding Declaration（c++17）
&lt;/h2&gt;&lt;p&gt;结构化绑定声明&lt;/p&gt;
&lt;h4 id="for-array"&gt;for Array
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;cv-auto &amp;amp;/&amp;amp;&amp;amp;(可选) [标识符列表] = 表达式;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cv-auto &amp;amp;/&amp;amp;&amp;amp;(可选) [标识符列表] { 表达式 };&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cv-auto &amp;amp;/&amp;amp;&amp;amp;(可选) [标识符列表] ( 表达式 );&lt;/p&gt;
&lt;p&gt;cv-auto: 可能由const/volatile修饰的auto关键字&lt;/p&gt;
&lt;p&gt;&amp;amp;/&amp;amp;&amp;amp; 左值引用或者右值引用&lt;/p&gt;
&lt;p&gt;标识符列表：逗号分隔的标识符&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;priArr&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// ai/bi/ci 的基本类型都是int，只是cv标识或引用标识不同
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;priArr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// a1 是 priArr[0] 的拷贝，a2, a3类推
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;priArr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// b1 是 priArr[0] 的只读拷贝，b2, b3类推
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;priArr&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// c1 是 priArr[0] 的引用，c2, c3类推
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="n"&gt;c3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// priArr[2]的值变为14
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt; &lt;span class="n"&gt;stdArr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;d1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;stdArr&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="for-object-member"&gt;for Object member
&lt;/h4&gt;&lt;p&gt;若初始化表达式为类/结构体类型，则标识符列表中的名字绑定到类/结构体的非静态数据成员上&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 数据成员必须为公有成员
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 标识符数量必须等于数据成员的数量
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 标识符类型与数据成员类型一致
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="string-literals"&gt;String Literals
&lt;/h2&gt;&lt;h4 id="c11-raw-string-literals"&gt;C++11 Raw String Literals
&lt;/h4&gt;&lt;p&gt;R &amp;ldquo;&lt;em&gt;delimiter( raw_characters )delimiter&lt;/em&gt;&amp;rdquo;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;s3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;NoUse(Hello &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;World&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;NoUse&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;(Hello&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;World&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="c14-string-literals"&gt;C++14: String Literals
&lt;/h4&gt;&lt;p&gt;C++14将运算符 &amp;ldquo;&amp;ldquo;s 进行了重载，赋予了它新的含义，使得用这种运算符括起来的字符串字面量，自动变成了一个 std::string 类型的对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Hello!&amp;#34;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// hello is of std::string type
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;Hello!&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// equals to the above
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Hello!&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// hello is of const char* type
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="array类"&gt;array类
&lt;/h2&gt;&lt;h4 id="c-style-array-c-raw-array也叫做c原生数组"&gt;C Style Array (C++ raw array，也叫做C++原生数组)
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;arr 可能会退化为指针：void f(int a[]) { std::cout &amp;laquo; sizeof(a)/sizeof(a[0]); }&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;arr 不知道自己的大小： sizeof(arr)/sizeof(arr[0])&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个数组之间无法直接赋值: array1 = array2;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能自动推导类型：auto a1[] = {1,2,3};&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="c-style-array"&gt;C++ Style Array
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是一个容器类，所以有迭代器（可以认为是一种用于访问成员的高级指针）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可直接赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;知道自己大小：size()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能和另一个数组交换内容：swap()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能以指定值填充自己: fill()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;取某个位置的元素( 做越界检查) ：at()&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++数组类是一个模板类，可以容纳任何类型的数据&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;array&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;数组&lt;/span&gt; &lt;span class="err"&gt;类型&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;数组大小&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;数组名字&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;数组&lt;/span&gt; &lt;span class="err"&gt;类型&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;数组大小&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;数组&lt;/span&gt; &lt;span class="err"&gt;名字&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="err"&gt;值&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;值&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;限制与C风格数组相同&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;H&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;l&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;l&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;o&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;C++17 Type Deduction for std::array (std::array的类型推导)&lt;/p&gt;
&lt;p&gt;C++17引入了一种新特性，对类模板的参数进行推导&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt; &lt;span class="n"&gt;a1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// 推导出 std::array&amp;lt;int, 3&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt; &lt;span class="n"&gt;a2&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// 推导出 std::array&amp;lt;char, 4&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="constant-expressions"&gt;Constant Expressions
&lt;/h2&gt;&lt;p&gt;Constant expression is an expression that can be evaluated at compile time. (常量表达式是编译期可以计算值的一个表达式)&lt;/p&gt;
&lt;p&gt;// 例如：C++ 数组的大小要求是编译期的一个常量（原生数组以及std::array）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// error: n is not a constant expression
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cn&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// OK: cn is a constant expression
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="2"&gt;
&lt;li&gt;const 修饰的对象未必是编译期常量&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rcn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// rcn is runtime constant, compiler does
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// NOT know its value at compile-time
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;rcn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// error: rcn is read-only
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rcn&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// error: rcn is NOT known at compile-time
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;C++11 constexpr: 编译期常量表达式说明符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time. (constexpr说明符声明可在编译时计算函数或变量的值)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// c++11 引入 constexpr
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// c++14才允许constexpr函数中有分支循环等
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rcm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// rcm是运行期常量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 编译期常量，等价于: constexpr int cm = 4;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rcm&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt; &lt;span class="c1"&gt;// 错误：m &amp;amp; rcm 不是编译期常量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cm&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// OK: cm 和 5 是编译期常量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;const vs constexpr&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;const&lt;/strong&gt; ： 告知程序员，const 修饰的内容是不会被修改的。主要目的是帮程序员避免bug 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// C语言允许，但C++编译出错
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// C语言中，语法正确，但运行时会出错
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;World&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// C++ 要求加const
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// C++编译器报错
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;constexpr&lt;/strong&gt; ：用在所有被要求使用“constant expression”的地方（就是constexpr 修饰的东西可以在编译期计算得到值），主要目的是让编译器能够&lt;strong&gt;优化代码提升性能&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id="assert"&gt;assert
&lt;/h2&gt;&lt;p&gt;assert:为c语言的宏（Macro）&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;包含头文件 &lt;cassert&gt; 以调试模式编译程序&lt;/p&gt;
&lt;p&gt;assert( bool_expr ); // bool_expr 为假则中断程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;//C++17 类型参数推导
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//断言：i必须小于3，否则失败
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;&amp;#34;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="assert依赖于ndebug-宏"&gt;assert()依赖于NDEBUG 宏
&lt;/h4&gt;&lt;p&gt;NDEBUG这个宏是C/C++标准规定的，所有编译器都有对它的支持。&lt;/p&gt;
&lt;p&gt;(1) 调试(Debug)模式编译时，编译器不会定义NDEBUG，所以assert()宏起作用。&lt;/p&gt;
&lt;p&gt;(2) 发行(Release)模式编译时，编译器自动定义宏NDEBUG，使assert不起作用&lt;/p&gt;
&lt;p&gt;如果要强制使得assert()生效或者使得assert()不生效，只要手动 #define NDEBUG 或者 #undef NDEBUG即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#undef NDEBUG &lt;/span&gt;&lt;span class="c1"&gt;// 强制以debug模式使用&amp;lt;cassert&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Enter an int: &amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;i must be positive&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="static_assertc11静态断言"&gt;static_assert(C++11静态断言)
&lt;/h4&gt;&lt;p&gt;static_assert ( bool_constexpr, message)&lt;/p&gt;
&lt;p&gt;(1) bool_constexpr: &lt;strong&gt;编译期常量表达式&lt;/strong&gt;，可转换为bool 类型，不可出现变量表达式&lt;/p&gt;
&lt;p&gt;(2) message: 字符串字面量 ，是断言失败时显示的警告信息。自C++17起，message是可选的&lt;/p&gt;
&lt;h2 id="声明与定义"&gt;声明与定义
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A declaration introduces an identifier and describes its type, be it a type, object, or function. A declaration is what the &lt;strong&gt;compiler&lt;/strong&gt; needs to accept references to that identifier. (“声明”是引入标识符并描述其类型，无论是类型，对象还是函数。&lt;strong&gt;编译器&lt;/strong&gt;需要该“声明”，以便识别在它处使用该标识符。)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// extern can be omitted for function declarations
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// no extern allowed for type declarations
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A definition actually instantiates/implements this identifier. It&amp;rsquo;s what the &lt;strong&gt;linker&lt;/strong&gt; needs in order to link references to those entities (“定义”实例化/实现这个标识符。&lt;strong&gt;链接器&lt;/strong&gt;需要“定义”，以便将对标识符的引用链接到标识符所表示的实体)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1） A definition can be used in the place of a declaration ( 定义有时可取代声明，反之则不行)&lt;/p&gt;
&lt;p&gt;（2） An identifier can be declared more than once, but can be defined only once ( 标识符可被声明多次，但只能定义一次&lt;/p&gt;
&lt;p&gt;（3） 定义通常伴随着编译器为标识符分配内存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) Declaration: &amp;ldquo;Somewhere, there exists a foo.&amp;rdquo; ( 声明：某个地方有个foo)&lt;/p&gt;
&lt;p&gt;(2) Definition: &amp;ldquo;&amp;hellip;and here it is!&amp;rdquo; ( 定义：它在这儿，长成这样)&lt;/p&gt;
&lt;h2 id="实现与声明分离seperating-declaration-from-implementation"&gt;实现与声明分离（Seperating Declaration from Implementation）
&lt;/h2&gt;&lt;p&gt;C++ allows you to separate class declaration from implementation. (C++中，类声明与实现可以分离)&lt;/p&gt;
&lt;p&gt;(1) .h: 类声明，描述类的结构&lt;/p&gt;
&lt;p&gt;(2) .cpp: 类实现，描述类方法的实现&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;FunctionType&lt;/span&gt; &lt;span class="n"&gt;ClassName&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt; &lt;span class="n"&gt;FunctionName&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Arguments&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//… }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中，:: 这个运算符被称为binary scope resolution operator（二元作用域解析运算符），简称“域分隔符”&lt;/p&gt;
&lt;p&gt;When a function is implemented inside a class declaration, it automatically becomes an inline function. (当函数在类声明中实现，它自动成为内联函数)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//C++11
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="nf"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// f1自动称为内联函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// do something
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="nf"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// f2不是内联函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//do something
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//C++11
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="nf"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="nf"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//do something
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// f1是内联函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//do something
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="避免头文件被多次包含"&gt;避免头文件被多次包含
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#ifndef MY_HEADER_FILE_H
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#define MY_HEADER_FILE_H
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;&lt;span class="c1"&gt;//CONTENT
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="cp"&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#pragma once &lt;/span&gt;&lt;span class="c1"&gt;//c++03,c90
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;_Pragma&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;once&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//c++11,c99
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实际上为运算符&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="文件系统"&gt;文件系统
&lt;/h2&gt;&lt;p&gt;About std::filesystem(std::filesystem简介)&lt;/p&gt;
&lt;p&gt;C++17 std::filesystem provides facilities for performing operations on file systems and their components, such as paths, regular files, and directories。（标准库的filesystem提供在文件系统与其组件，例如路径、常规文件与目录上进行操作的方法）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;File(文件)：持有数据的文件系统对象，能被写入或读取。文件有名称和属性，属性之一是文件类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Path(路径)：标识文件所处位置的一系列元素，可能包含文件名&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;filesystem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;CheckPath.cpp&amp;#34;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Absolute Path (platform dependent) (绝对路径)：An absolute path contains a file name with its complete path and drive letter.(包含完整的路径和驱动器符号)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Relative Path (相对路径)&lt;/p&gt;
&lt;p&gt;Contains NO drive letter or leading &amp;ldquo;/&amp;rdquo; (不包含驱动器及开头的/符号)&lt;/p&gt;
&lt;p&gt;The file stores in the path Relative to &amp;ldquo;Current Path&amp;rdquo; (文件存在相对于“当前路径”的位置)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;OS Type&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Absolute path&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Directory path&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows(case insensitive)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;c:\example\scores.txt&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;c:\example&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Unix/Linux(case sensitive)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;/home/cyd/scores.txt&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;/home/cyd&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start="3"&gt;
&lt;li&gt;Differences between Windows and Linux(两种操作系统的不同)&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Linux&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;java&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;行结束字符&lt;/td&gt;
&lt;td&gt;\r\n&lt;/td&gt;
&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;System.getProperty(&amp;ldquo;line.separator&amp;rdquo;);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路径名分隔符&lt;/td&gt;
&lt;td&gt;&amp;lsquo;\&amp;rsquo;&lt;/td&gt;
&lt;td&gt;&amp;lsquo;/&amp;rsquo;&lt;/td&gt;
&lt;td&gt;std::filesystem::path::preferred_separator&lt;/td&gt;
&lt;td&gt;java.io.File.separator&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路径名&lt;/td&gt;
&lt;td&gt;a:\b\c 或\host\b\c&lt;/td&gt;
&lt;td&gt;/a/b/c&lt;/td&gt;
&lt;td&gt;std::filesystem::path&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// The directory separator for Windows is a backslash (\), which needs special treat
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;filesystem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;d:&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;cpp&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;hi.txt&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 字符串中的反斜杠要被转义
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;d:/cpp/hi.txt&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Windows也支持正斜杠
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="n"&gt;p3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;(d:\cpp\hi.txt)&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;// 使用原始字符串字面量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="path类"&gt;Path类
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Members functions of path class(path类的成员函数)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;path(string)&lt;/p&gt;
&lt;p&gt;构造函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;assign(string): path&amp;amp;&lt;/p&gt;
&lt;p&gt;为路径对象赋值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;连接&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;append(type p): path&amp;amp;&lt;/p&gt;
&lt;p&gt;将p追加到路径后。type是string、path或const char*。等价于 /= 运算符；自动添加目录分隔符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;concat(type p): path&amp;amp;&lt;/p&gt;
&lt;p&gt;将p追加到路径后。type是string、path或const char*。等价于+=运算符；不自动添加目录分隔符&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;修改器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;clear(): void&lt;/p&gt;
&lt;p&gt;清空存储的路径名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;remove_filename(): path&amp;amp;&lt;/p&gt;
&lt;p&gt;从给定的路径中移除文件名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;replace_filename(const path&amp;amp; replacement): path&amp;amp;&lt;/p&gt;
&lt;p&gt;以 replacement 替换文件名&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;分解&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;root_name(): path&lt;/p&gt;
&lt;p&gt;返回通用格式路径的根名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;root_directory(): path&lt;/p&gt;
&lt;p&gt;返回通用格式路径的根目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;root_path(): path&lt;/p&gt;
&lt;p&gt;返回路径的根路径，等价于 root_name() / root_directory()，即“路径的根名 / 路径的根目录”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;relative_path(): path&lt;/p&gt;
&lt;p&gt;返回相对于 root-path 的路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;parent_path(): path&lt;/p&gt;
&lt;p&gt;返回到父目录的路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;filename(): path&lt;/p&gt;
&lt;p&gt;返回路径中包含的文件名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stem(): path&lt;/p&gt;
&lt;p&gt;返回路径中包含的文件名，不包括文件的扩展名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;extension(): path&lt;/p&gt;
&lt;p&gt;返回路径中包含的文件名的扩展名&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;查询&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;empty(): bool&lt;/p&gt;
&lt;p&gt;检查路径是否为空&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;has_xxx(): bool&lt;/p&gt;
&lt;p&gt;其中“xxx”是上面“分解”类别中的函数名。这些函数检查路径是否含有相应路径元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Non-member functions (非成员函数)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;operator/( const path&amp;amp; lhs, const path&amp;amp; rhs )&lt;/p&gt;
&lt;p&gt;以偏好目录分隔符连接二个路径成分 lhs 和 rhs。比如 path p{&amp;ldquo;C:&amp;rdquo;}; p = p / &amp;ldquo;Users&amp;rdquo; / &amp;ldquo;batman&amp;rdquo;;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;operator &amp;laquo;, &amp;raquo; (path p)&lt;/p&gt;
&lt;p&gt;进行路径 p 上的流输入或输出&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;文件类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;s_regular_file( const path&amp;amp; p ): bool&lt;/p&gt;
&lt;p&gt;检查路径是否是常规文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;is_directory( const path&amp;amp; p ): bool&lt;/p&gt;
&lt;p&gt;检查路径是否是目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;is_empty( const path&amp;amp; p ): bool&lt;/p&gt;
&lt;p&gt;检查给定路径是否指代一个空文件或目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;查询&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;current_path(): path&lt;/p&gt;
&lt;p&gt;返回当前工作目录的绝对路径（类似linux指令 pwd）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;current_path( const path&amp;amp; p ): void&lt;/p&gt;
&lt;p&gt;更改当前路径为p （类似linux指令 cd）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;file_size( const path&amp;amp; p ): uintmax_t&lt;/p&gt;
&lt;p&gt;对于常规文件 p ，返回其大小；尝试确定目录(以及其他非常规文件)的大小的结果是由编译器决定的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;space(const path&amp;amp; p): space_info&lt;/p&gt;
&lt;p&gt;返回路径名 p 定位于其上的文件系统信息。space_info中有三个成员：capacity ——文件系统的总大小(字节)，free ——文件系统的空闲空间(字节)，available ——普通进程可用的空闲空间（小于或等于 free ）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;status(const path&amp;amp; p): file_status&lt;/p&gt;
&lt;p&gt;返回 p 所标识的文件系统对象的类型与属性。返回的file_status是一个类，其中包含文件的类型(type)和权限(permissions)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;remove(const path&amp;amp; p): bool&lt;/p&gt;
&lt;p&gt;删除路径 p 所标识的文件或空目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;remove_all(const path&amp;amp; p): uintmax_t&lt;/p&gt;
&lt;p&gt;递归删除 p 的内容（若它是目录）及其子目录的内容，然后删除 p 自身，返回被删文件及目录数量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rename(const path&amp;amp; old_p,const path&amp;amp; new_p): void&lt;/p&gt;
&lt;p&gt;移动或重命名 old_p 所标识的文件系统对象到 new_p(类似linux指令mv)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;copy( const path&amp;amp; from, const path&amp;amp; to ): void&lt;/p&gt;
&lt;p&gt;复制文件与目录。另外一个函数 bool copy_file(from, to) 拷贝单个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;create_directory( const path&amp;amp; p ): bool&lt;/p&gt;
&lt;p&gt;创建目录 p （父目录必须已经存在）,若 p 已经存在，则函数无操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;create_directories( const path&amp;amp; p ): bool&lt;/p&gt;
&lt;p&gt;创建目录 p （父目录不一定存在）,若 p 已经存在，则函数无操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="comparision-of-file-manipulation-between-c-and-c-文件操作对比"&gt;Comparision of File Manipulation between C and C++ (文件操作对比)
&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;C++&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;file input&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;ifstream &lt;em&gt;(i: input; f:file)&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Header File (头文件)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;file output&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;ofstream &lt;em&gt;(o: ouput; f:file)&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;stdio.h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;file input &amp;amp; output&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;fstream&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;read from file (读文件)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&amp;raquo;;get(); get(char); get(char*);getline();read(char*,streamsize);&lt;/td&gt;
&lt;td&gt;fscanf();fgets(char*, size_t , FILE*);fread(void *&lt;em&gt;ptr&lt;/em&gt;, &lt;em&gt;size&lt;/em&gt;, &lt;em&gt;nitems&lt;/em&gt;, FILE *&lt;em&gt;stream&lt;/em&gt;);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Read/Write (读写操作)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;write to file (写文件)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&amp;laquo;;put(char), put(int);write (const char*, streamsize);flush()&lt;/td&gt;
&lt;td&gt;fprintf();fwrite(const void *&lt;em&gt;ptr&lt;/em&gt;, &lt;em&gt;size&lt;/em&gt;, &lt;em&gt;nitems&lt;/em&gt;, FILE &lt;em&gt;&lt;em&gt;stream&lt;/em&gt;);fputs(const char&lt;/em&gt;, FILE *);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Status test (状态测试)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;eof(); bad(); good(); fail()&lt;/td&gt;
&lt;td&gt;feof(); ferror();&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="hierarchy-of-c-io-stream-classesc-io流类层次"&gt;Hierarchy of C++ I/O Stream Classes(C++ I/O流类层次)
&lt;/h4&gt;&lt;p&gt;&lt;img src="https://edu-image.nosdn.127.net/8C0A3ED498876420B3B389880C16AB06.jpg?imageView&amp;amp;thumbnail=890x0&amp;amp;quality=100"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;p&gt;C++的流类主要有五类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 流基类（ios_base和ios）
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 标准输入输出流类（istream/ostream/iostream）
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 字符串流类（istringstream/ostringstream）
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 文件流类（ifstream/ofstream/fstream）
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; 缓冲区类（streambuf/stringbuf/filebuf）
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;标准输入输出流对象 cin 和 cout 分别是类 istream 和 ostream 的实例&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="输出至文件"&gt;&lt;strong&gt;输出至文件&lt;/strong&gt;
&lt;/h4&gt;&lt;p&gt;&lt;img src="https://edu-image.nosdn.127.net/25E9455E1328577B96EF36ED9E09C3E7.jpg?imageView&amp;amp;thumbnail=890x0&amp;amp;quality=100"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;h4 id="自文件读入"&gt;自文件读入
&lt;/h4&gt;&lt;p&gt;&lt;img src="https://edu-image.nosdn.127.net/A08D7DA2B4D44442E89724B4256254CB.jpg?imageView&amp;amp;thumbnail=890x0&amp;amp;quality=100"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;p&gt;To read data correctly, you need to know exactly how data is stored.(若想正确读出数据，必须确切了解数据的存储格式)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Testing if a file is successfully opened (检测文件是否成功打开)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Errors may occur (可能出现错误):
&lt;ul&gt;
&lt;li&gt;the file does not exist when reading a file (读文件时文件不存在)&lt;/li&gt;
&lt;li&gt;the media is ReadOnly when writing a file (e.g. write to a CD) (写文件时介质只读)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To detect if a file is successfully opened: (检测文件是否正确打开的方法)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;invoke fail() immediately after open(). (open()之后马上调用fail()函数), if fail() returns true, the file is not opened (does not exist). (fail()返回true, 文件未打开)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;ofstream&lt;/span&gt; &lt;span class="nf"&gt;output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;scores.txt&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fail&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;(Can&amp;#39;t open file &amp;#34;&lt;/span&gt;&lt;span class="n"&gt;scores&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;!)&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Testing End of File (检测是否已到文件末尾)&lt;/p&gt;
&lt;p&gt;Use eof() function to detect the end of file (用eof()函数检查是否是文件末尾)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;ifstream&lt;/span&gt; &lt;span class="nf"&gt;in&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;scores.txt&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eof&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="functions-for-io-stream"&gt;Functions for I/O stream
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;getline()&lt;/p&gt;
&lt;p&gt;member function getline(char* buf, int size, char delimiter)&lt;/p&gt;
&lt;p&gt;non-member function std::getline(istream&amp;amp; is, string&amp;amp; str, char delimiter)&lt;/p&gt;
&lt;p&gt;When using (&amp;raquo;), data are delimited by whitespace. (&amp;raquo;运算符用空格分隔数据)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eof&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;// not end of file
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;name2&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eof&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;get() and put()&lt;/p&gt;
&lt;p&gt;Two other useful functions are get and put.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;get: read a character&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;istream&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;istream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;is&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;put:write a character.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;ostream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;put&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flush()&lt;/p&gt;
&lt;p&gt;Flush output stream buffer (将输出流缓存中的数据写入目标文件)&lt;/p&gt;
&lt;p&gt;ostream&amp;amp; flush();&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flush&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 其它输出流对象也可以调用 flush()
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;flush&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 与endl类似作为manipulator的调用方式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="格式化输出"&gt;格式化输出
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;setw manipulator(“设置域宽”控制符)&lt;/p&gt;
&lt;p&gt;要包含头文件 &lt;iomanip&gt;&lt;/p&gt;
&lt;p&gt;setw(n) 设置域宽，即数据所占的总字符数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;//_ _a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;setw()控制符只对其后输出的第一个数据有效，其他控制符则对其后的所有输入输出产生影响。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;b&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;//_ _ _ _ab
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;setw()的默认为setw(0)，按实际输出&lt;/p&gt;
&lt;p&gt;如果输出的数值占用的宽度超过setw(int n)设置的宽度，则按实际宽度输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;setprecision manipulator(“设置浮点精度”控制符)&lt;/p&gt;
&lt;p&gt;setprecision(int n)&lt;/p&gt;
&lt;p&gt;(1) 控制显示浮点数的有效位&lt;/p&gt;
&lt;p&gt;(2) n代表数字总位数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iomanip&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mf"&gt;7.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;setprecision&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;setprecision&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;setprecision&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;setprecision&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;setprecision&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;setprecision&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;setfill manipulator(“设置填充字符”控制符)&lt;/p&gt;
&lt;p&gt;setfill(c)&lt;/p&gt;
&lt;p&gt;设置填充字符，即“&amp;laquo;&amp;ldquo;符号后面的数据长度小于域宽时，使用什么字符进行填充&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setfill&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;//****a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;控制符&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;用途&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;setw(width)&lt;/td&gt;
&lt;td&gt;设置输出字段的宽度(仅对其后第一个输出有效)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setprecision(n)&lt;/td&gt;
&lt;td&gt;设置浮点数的输/入出精度(总有效数字个数等于n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fixed&lt;/td&gt;
&lt;td&gt;将浮点数以定点数形式输入/出(小数点后有效数字个数等于setprecision指定的n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;showpoint&lt;/td&gt;
&lt;td&gt;将浮点数以带小数点和结尾0的形式输入/出，即便该浮点数没有小数部分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;left&lt;/td&gt;
&lt;td&gt;输出内容左对齐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;right&lt;/td&gt;
&lt;td&gt;输出内容右对齐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hexfloat/defaultfloat&lt;/td&gt;
&lt;td&gt;C++11新增；前者以定点科学记数法的形式输出十六进制浮点数，后者还原默认浮点格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;get_money(money)put_money(money)&lt;/td&gt;
&lt;td&gt;C++11新增；从流中读取货币值，或者将货币值输出到流。支持不同语言和地区的货币格式https://en.cppreference.com/w/cpp/io/manip/get_moneyhttps://en.cppreference.com/w/cpp/io/manip/put_money&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;get_time(tm, format)put_time(tm,format)&lt;/td&gt;
&lt;td&gt;C++11新增；从流中读取日期时间值，或者将日期时间值输出到流。https://en.cppreference.com/w/cpp/io/manip/get_timehttps://en.cppreference.com/w/cpp/io/manip/put_time&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The stream manipulator also works to format output to a file(流控制符同样可以用于文件输入/输出)&lt;/p&gt;
&lt;h4 id="file-open-mode"&gt;File Open Mode
&lt;/h4&gt;&lt;p&gt;When opening an &lt;em&gt;fstream&lt;/em&gt; object, a &amp;ldquo;file open mode&amp;rdquo; should be specified(创建fstream对象时，应指定文件打开模式)。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Mode(模式)&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Description(描述)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ios::in&lt;/td&gt;
&lt;td&gt;打开文件读数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ios::out&lt;/td&gt;
&lt;td&gt;打开文件写数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ios::app&lt;/td&gt;
&lt;td&gt;把输出追加到文件末尾。app = append&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ios::ate&lt;/td&gt;
&lt;td&gt;打开文件，把文件光标移到末尾。ate = at end&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ios::trunc&lt;/td&gt;
&lt;td&gt;若文件存在则舍弃其内容。这是ios::out的默认行为。trunc = truncate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ios::binary&lt;/td&gt;
&lt;td&gt;打开文件以二进制模式读写&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;fstream&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ios&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;ios&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;binary&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h6 id="open-mode"&gt;Open Mode
&lt;/h6&gt;&lt;p&gt;Combine several modes (几种模式可以组合在一起)&lt;/p&gt;
&lt;p&gt;using the | operator (bitwise inclusive OR) (用“位或”运算符)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// std::ios_base::openmode 被ios继承
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="cm"&gt;/*implementation defined*/&lt;/span&gt; &lt;span class="n"&gt;openmode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;openmode&lt;/span&gt; &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="cm"&gt;/*implementation defined*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="binary-io"&gt;Binary IO
&lt;/h4&gt;&lt;p&gt;TEXT file vs BINARY file (not technically precise) (文本文件与二进制文件)&lt;/p&gt;
&lt;p&gt;(1) Both stores as a sequence of bits (in binary format) (都按二进制格式存储比特序列)&lt;/p&gt;
&lt;p&gt;(2) text file : interpreted as a sequence of characters (解释为一系列字符)&lt;/p&gt;
&lt;p&gt;(3) binary file : interpreted as a sequence of bits. (解释为一系列比特)&lt;/p&gt;
&lt;p&gt;Text I/O is built upon binary I/O to provide a level of abstraction for character encoding and decoding. (文本模式的读写是建立在二进制模式读写的基础上的，只不过是将二进制信息进行了字符编解码)&lt;/p&gt;
&lt;p&gt;By default, a file is opened in text mode.(文件默认以文本模式打开)&lt;/p&gt;
&lt;p&gt;open a file using the binary mode ios::binary.(用ios::binary以二进制模式打开文件)&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Text I/O (文本模式)&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Binary I/O function:(二进制模式)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读&lt;/td&gt;
&lt;td&gt;operator &amp;raquo;; get(); getline();&lt;/td&gt;
&lt;td&gt;read();&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;写&lt;/td&gt;
&lt;td&gt;operator &amp;laquo;; put();&lt;/td&gt;
&lt;td&gt;write();&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id="the-write-function-write函数"&gt;The write Function (write函数)
&lt;/h5&gt;&lt;p&gt;ostream&amp;amp; write( const char* s, std::streamsize count )&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;fstream&lt;/span&gt; &lt;span class="nf"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;GreatWall.dat&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ios&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;binary&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;ios&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;trunc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;ShanHaiGuan&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;JuYongGuan&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将非字符数据写入文件&lt;/p&gt;
&lt;p&gt;(1) Convert any data into a sequence of bytes (byte stream) (先将数据转换为字节序列，即字节流)&lt;/p&gt;
&lt;p&gt;(2) Write the sequence of bytes to file with write() (再用write函数将字节序列写入文件)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How to convert any data into byte stream? (如何将信息转换为字节流)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.1. reinterpret_cast&lt;/p&gt;
&lt;p&gt;该运算符有两种用途：&lt;/p&gt;
&lt;p&gt;(1) cast the address of a type to another type (将一种类型的地址转为另一种类型的地址)&lt;/p&gt;
&lt;p&gt;(2) cast the address to a number, i.e. integer (将地址转换为数值，比如转换为整数)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reinterpret_cast&lt;dataType&gt;(address)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;address is the starting address of the data (address是待转换的数据的起始地址)&lt;/p&gt;
&lt;p&gt;dataType is the data type you are converting to. (dataType是要转至的目标类型)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;For binary I/O, dataType is char &lt;em&gt;. (对于二进制I/O来说，dataType是 char&lt;/em&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;reinterpret_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// variable address
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;reinterpret_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// array address
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;reinterpret_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// object address
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id="the-read-function-read成员函数"&gt;The read Function (read成员函数)
&lt;/h5&gt;&lt;p&gt;istream&amp;amp; read ( char* s, std::streamsize count );&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 读字符串
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;fstream&lt;/span&gt; &lt;span class="nf"&gt;bio&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;GreatWall.dat&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ios&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ios&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;binary&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;bio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;bio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 读其它类型数据（整数），需要使用 reinterpret_cast
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;fstream&lt;/span&gt; &lt;span class="nf"&gt;bio&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;temp.dat&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ios&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ios&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;binary&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;bio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;reinterpret_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="file-positioner"&gt;File Positioner
&lt;/h4&gt;&lt;p&gt;文件位置指示器&lt;/p&gt;
&lt;p&gt;A file consists of a sequence of bytes.(文件由字节序列构成)&lt;/p&gt;
&lt;p&gt;File positioner is a special marker that is positioned at one of these bytes. (一个特殊标记指向其中一个字节)&lt;/p&gt;
&lt;p&gt;A read or write operation takes place at the location of the file positioner. (读写操作都是从文件位置指示器所标记的位置开始)&lt;/p&gt;
&lt;p&gt;When a file is opened, the fp is set at the beginning. (打开文件，fp指向文件头)&lt;/p&gt;
&lt;p&gt;When you read or write data to the file, the file pointer moves forward to the next data item. (读写文件时，文件位置指示器会向后移动到下一个数据项)&lt;/p&gt;
&lt;h4 id="random-acess"&gt;Random Acess
&lt;/h4&gt;&lt;p&gt;Random Access means one can read/write anywhere inside a file(随机访问意味着可以读写文件的任意位置)&lt;/p&gt;
&lt;p&gt;How?&lt;/p&gt;
&lt;p&gt;We are able to know where the file positioner is. (我们能知道文件定位器在什么位置)&lt;/p&gt;
&lt;p&gt;We are able to move the file positioner inside the file (我们能在文件中移动文件定位器)&lt;/p&gt;
&lt;p&gt;Maybe we need two file positioners : one for reading, another for writing&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;·&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;For reading (读文件时用)&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;For writing(写文件时用)&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;获知文件定位器指到哪里&lt;/td&gt;
&lt;td&gt;&lt;em&gt;tellg();&lt;/em&gt; tell是获知，g是get表示读文件&lt;/td&gt;
&lt;td&gt;&lt;em&gt;tellp();&lt;/em&gt; tell是获知，p是put表示写文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;移动文件定位器到指定位置&lt;/td&gt;
&lt;td&gt;&lt;em&gt;seekg();&lt;/em&gt; seek是寻找，g是get表示读文件&lt;/td&gt;
&lt;td&gt;&lt;em&gt;seekp();&lt;/em&gt; seek是寻找，p是put表示写文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;xxx_stream&amp;amp; seekg/seekp( pos_type pos );&lt;/p&gt;
&lt;p&gt;xxx_stream&amp;amp; seekg/seekp( off_type off, std::ios_base::seekdir dir);&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;seekdir&lt;/strong&gt; &lt;strong&gt;文件定位方向类型&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;std::ios_base::beg&lt;/td&gt;
&lt;td&gt;流的开始；beg = begin&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;std::ios_base::end&lt;/td&gt;
&lt;td&gt;流的结尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;std::ios_base::cur&lt;/td&gt;
&lt;td&gt;流位置指示器的当前位置；cur = current&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;seekg(42L);&lt;/td&gt;
&lt;td&gt;将文件位置指示器移动到文件的第42字节处&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;seekg(10L, std::ios::beg);&lt;/td&gt;
&lt;td&gt;将文件位置指示器移动到从文件开头算起的第10字节处&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;seekp(-20L, std::ios::end);&lt;/td&gt;
&lt;td&gt;将文件位置指示器移动到从文件末尾开始，倒数第20字节处&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;seekp(-36L, std::ios::cur);&lt;/td&gt;
&lt;td&gt;将文件位置指示器移动到从当前位置开始，倒数第36字节处&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="left-value-pure-right-value-and-expiring-value"&gt;Left Value, Pure Right Value and eXpiring Value
&lt;/h2&gt;&lt;h4 id="c03-lvalue-and-rvalue-c03的左值和右值"&gt;C++03 lvalue and rvalue (C++03的左值和右值)
&lt;/h4&gt;&lt;p&gt;通俗理解&lt;/p&gt;
&lt;p&gt;(1) 能放在等号左边的是lvalue&lt;/p&gt;
&lt;p&gt;(2) 只能放在等号右边的是rvalue&lt;/p&gt;
&lt;p&gt;(3) lvalue可以作为rvalue使用&lt;/p&gt;
&lt;h4 id="c11-left-value"&gt;C++11: Left Value
&lt;/h4&gt;&lt;p&gt;An lvalue designates a function or an object, which is an expression whose address can be taken (左值指定了一个&lt;strong&gt;函数或者对象&lt;/strong&gt;，它是一个可以取地址的表达式)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lv1&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// Object
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;lv2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;lv1&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// Lvalue reference to Object
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;lv3&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lv1&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// Pointer to Object
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;lv4&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;lv1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// Function returning Lvalue Reference
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="c11-pure-right-value"&gt;C++11: Pure Right Value
&lt;/h4&gt;&lt;p&gt;prvalue(Pure Right Value，纯右值)：是不和对象相关联的值(字面量)或者其求值结果是&lt;strong&gt;字面量&lt;/strong&gt;或者一个匿名的&lt;strong&gt;临时对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) 除字符串字面量以外的字面量，比如 32, &amp;lsquo;a&amp;rsquo;&lt;/p&gt;
&lt;p&gt;(2) 返回非引用类型的函数调用 int f() { return 1;}&lt;/p&gt;
&lt;p&gt;(3) 后置自增/自减表达式i++/i&amp;ndash;&lt;/p&gt;
&lt;p&gt;(4) 算术/逻辑/关系表达式（a+b、a&amp;amp;b、a&amp;laquo;b）（a&amp;amp;&amp;amp;b、a||b、~a）（a==b、a&amp;gt;=b、a&amp;lt;b）&lt;/p&gt;
&lt;p&gt;(5) 取地址（&amp;amp;x）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;左值可以当成右值使用&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="c11-expiring-value"&gt;C++11: eXpiring Value
&lt;/h4&gt;&lt;p&gt;xvalue(eXpiring Value，将亡值)：将亡值也指定了一个对象，是一个将&lt;strong&gt;纯右值转换为右值引用&lt;/strong&gt;的表达式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;prv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// pure rvalue
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;lvr5&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// 常量左值引用可引用纯右值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;lvr6&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;22&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// 错！非常量左值引用不可引用纯右值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rvr1&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;22&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// 右值引用可以引用纯右值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;lvr7&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;prv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// 错！非常量左值引用不可引用纯右值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rvr2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;prv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// 右值引用普通函数返回值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;rvr1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;rvr2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 右值引用做左值使用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="运算符重载"&gt;运算符重载
&lt;/h2&gt;&lt;p&gt;不可重载的运算符&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Operator&lt;/th&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;类属关系运算符&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.*&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;成员指针运算符&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;::&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;作用域运算符&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;? :&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;条件运算符&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;##&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;编译预处理符号&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Restrictions for operator overloading (运算符重载的限制)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) Precedence and Associativity are unchangeable (优先级和结合性不变)&lt;/p&gt;
&lt;p&gt;(2) NOT allowing to create new operator (不可创造新的运算符)&lt;/p&gt;
&lt;p&gt;重载的运算符必须和用户定义的class类型一起使用&lt;/p&gt;
&lt;p&gt;重载的运算符的参数至少应有一个是类对象(或类对象的引用)&lt;/p&gt;
&lt;p&gt;&lt;img src="https://edu-image.nosdn.127.net/26D6D0D7CCEA9856BC70B29511F82886.jpg?imageView&amp;amp;thumbnail=890x0&amp;amp;quality=100"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;h3 id="运算符函数的调用形式"&gt;运算符函数的调用形式
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;th&gt;作为成员函数&lt;/th&gt;
&lt;th&gt;作为非成员函数&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;@a&lt;/td&gt;
&lt;td&gt;(a).operator@ ( )&lt;/td&gt;
&lt;td&gt;operator@ (a)&lt;/td&gt;
&lt;td&gt;调用 &lt;a class="link" href="https://zh.cppreference.com/w/cpp/io/cin" target="_blank" rel="noopener"
&gt;std::cin&lt;/a&gt;.operator!()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a@b&lt;/td&gt;
&lt;td&gt;(a).operator@ (b)&lt;/td&gt;
&lt;td&gt;operator@ (a, b)&lt;/td&gt;
&lt;td&gt;&lt;a class="link" href="https://zh.cppreference.com/w/cpp/io/cout" target="_blank" rel="noopener"
&gt;std::cout&lt;/a&gt; &amp;laquo; 42 调用 &lt;a class="link" href="https://zh.cppreference.com/w/cpp/io/cout" target="_blank" rel="noopener"
&gt;std::cout&lt;/a&gt;.operator&amp;laquo;(42)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a=b&lt;/td&gt;
&lt;td&gt;(a).operator= (b)&lt;/td&gt;
&lt;td&gt;不能是非成员&lt;/td&gt;
&lt;td&gt;&lt;a class="link" href="https://zh.cppreference.com/w/cpp/string/basic_string" target="_blank" rel="noopener"
&gt;std::string&lt;/a&gt; s; s = &amp;ldquo;abc&amp;rdquo;; 调用 s.operator=(&amp;ldquo;abc&amp;rdquo;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a(b&amp;hellip;)&lt;/td&gt;
&lt;td&gt;(a).operator()(b&amp;hellip;)&lt;/td&gt;
&lt;td&gt;不能是非成员&lt;/td&gt;
&lt;td&gt;&lt;a class="link" href="https://zh.cppreference.com/w/cpp/numeric/random/random_device" target="_blank" rel="noopener"
&gt;std::random_device&lt;/a&gt; r; auto n = r(); 调用 r.operator()()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a[b]&lt;/td&gt;
&lt;td&gt;(a).operator&lt;a class="link" href="b" &gt;&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;不能是非成员&lt;/td&gt;
&lt;td&gt;&lt;a class="link" href="https://zh.cppreference.com/w/cpp/container/map" target="_blank" rel="noopener"
&gt;std::map&lt;/a&gt;&amp;lt;int, int&amp;gt; m; m[1] = 2; 调用 m.operator&lt;a class="link" href="1" &gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a-&amp;gt;&lt;/td&gt;
&lt;td&gt;(a).operator-&amp;gt; ( )&lt;/td&gt;
&lt;td&gt;不能是非成员&lt;/td&gt;
&lt;td&gt;auto p = &lt;a class="link" href="https://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique" target="_blank" rel="noopener"
&gt;std::make_unique&lt;/a&gt;&lt;S&gt;(); p-&amp;gt;bar() 调用 p.operator-&amp;gt;()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a@&lt;/td&gt;
&lt;td&gt;(a).operator@ (0)&lt;/td&gt;
&lt;td&gt;operator@ (a, 0)&lt;/td&gt;
&lt;td&gt;&lt;a class="link" href="https://zh.cppreference.com/w/cpp/container/vector" target="_blank" rel="noopener"
&gt;std::vector&lt;/a&gt;&lt;int&gt;::iterator i = v.begin(); i++ 调用 i.operator++(0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;此表中，&lt;strong&gt;@&lt;/strong&gt; 是表示所有匹配运算符的占位符：@a 为所有前缀运算符，a@ 为除 -&amp;gt; 以外的所有后缀运算符，a@b 为除 = 以外的所有其他运算符&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="二元"&gt;二元
&lt;/h3&gt;&lt;p&gt;复合二元运算符&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Vec2D&lt;/span&gt; &lt;span class="n"&gt;Vec2D&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Vec2D&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;secondVec2D&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;secondVec2D&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Vec2D&lt;/span&gt; &lt;span class="n"&gt;Vec2D&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Vec2D&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;secondVec2D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//prvalue
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x_&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;secondVec2D&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getX&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y_&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;secondVec2D&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;Vec2D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//临时的匿名对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;How to make v2[] an Lvalue? (如何使r2[]成为左值)&lt;/p&gt;
&lt;p&gt;declare the [] operator to return a reference (使[]返回一个引用)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Vec2D&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//lvalue
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//x_ can be modified
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;//...... Now, the Vec2D class is mutable.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="一元"&gt;一元
&lt;/h3&gt;&lt;p&gt;当编译器遇到 @obj; 时，&lt;/p&gt;
&lt;p&gt;若operator @是在obj的类中的成员，则调用&lt;/p&gt;
&lt;p&gt;obj.operator @()&lt;/p&gt;
&lt;p&gt;若operator @是obj的类的 friend 函数，则调用&lt;/p&gt;
&lt;p&gt;operator @(obj)&lt;/p&gt;
&lt;h4 id="-"&gt;-
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Vec2D&lt;/span&gt; &lt;span class="n"&gt;Vec2D&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="c1"&gt;//无参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;Vec2D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;y_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 返回匿名临时对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="自增自减"&gt;自增自减
&lt;/h4&gt;&lt;p&gt;前置++/&amp;ndash;重载无参数，返回引用类型&lt;/p&gt;
&lt;p&gt;后置++/&amp;ndash;重载带参数&amp;ndash;&amp;ldquo;dummy&amp;quot;参数 仅作占位&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;运算符名&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;可重载&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;原型示例（对于类&lt;/strong&gt; &lt;strong&gt;class T&lt;/strong&gt;**）**&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;类内定义&lt;/td&gt;
&lt;td&gt;类外定义&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;前自增&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;++a&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;T&amp;amp; T::operator++();&lt;/td&gt;
&lt;td&gt;T&amp;amp; operator++(T&amp;amp; a);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;前自减&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&amp;ndash;a&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;T&amp;amp; T::operator&amp;ndash;();&lt;/td&gt;
&lt;td&gt;T&amp;amp; operator&amp;ndash;(T&amp;amp; a);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;后自增&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;a++&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;T T::operator++(int &lt;em&gt;dummy&lt;/em&gt;);&lt;/td&gt;
&lt;td&gt;T operator++(T&amp;amp; a, int &lt;em&gt;dummy&lt;/em&gt;);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;后自减&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;a&amp;ndash;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;T T::operator&amp;ndash;(int &lt;em&gt;dummy&lt;/em&gt;);&lt;/td&gt;
&lt;td&gt;T operator&amp;ndash;(T&amp;amp; a, int &lt;em&gt;dummy&lt;/em&gt;);&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="流运算符"&gt;流运算符
&lt;/h3&gt;&lt;p&gt;运算符重载为类成员函数后,当调用该运算符时,左操作数必须是该类的实例。若&amp;laquo;和&amp;raquo;重载为成员函数，则只能用 v1&amp;laquo;cout;&lt;/p&gt;
&lt;p&gt;因此 &amp;laquo; (&amp;raquo;) should be overloaded as &amp;ldquo;friend function&amp;rdquo; (只能重载为友元函数)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Vec2D&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//重载为成员函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;istream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;istream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Vec2D&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;v1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//Vec2D对象只能作为第一个操作数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="nc"&gt;Vec2D&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//重载为友元函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="n"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vec2D&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="n"&gt;istream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;istream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Vec2D&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Vec2D&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="对象转换运算符"&gt;对象转换运算符
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Vec2D&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;//无返回值类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nf"&gt;magnitude&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Vec2D&lt;/span&gt; &lt;span class="nf"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mf"&gt;5.1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// d: 10.1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// e: 5.0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="赋值运算符"&gt;赋值运算符
&lt;/h3&gt;&lt;p&gt;By default, the = operator performs a memberwise copy from one object to the other. (默认情况下，赋值运算符执行对象成员的一对一拷贝)&lt;/p&gt;
&lt;p&gt;To change the way the default assignment operator = works, you need to overload the = operator. (重载赋值运算符，会改变其默认工作方式)&lt;/p&gt;
&lt;p&gt;一般情况下，如果拷贝构造函数需要执行深拷贝，那么赋值运算符需要重载&lt;/p&gt;
&lt;h2 id="异常处理"&gt;异常处理
&lt;/h2&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Code&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="nf"&gt;exception&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;statement&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;More&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;Code&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;exception&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;quotient&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;number1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;number2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;number1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;number1&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;number2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;quotient&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;#34;除数为0！&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="异常匹配与异常类"&gt;异常匹配与异常类
&lt;/h4&gt;&lt;p&gt;catch ( ExceptionType&amp;amp; parameter ) { /* 处理异常 */ }&lt;/p&gt;
&lt;p&gt;若try{}中所抛异常类型与catch()的参数类型(ExceptionType)匹配，则进入catch块&lt;/p&gt;
&lt;p&gt;若对异常对象的内容不感兴趣，可省略catch参数，只保留类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Base Class of Exception in Standard Library(标准库中的异常基类)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#include &lt;exception&gt;&lt;/p&gt;
&lt;p&gt;Class exception&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;exception&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 构造函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;what&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//返回解释性字符串
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;what()返回的指针指向拥有解释信息的空终止字符串的指针。该指针保证在获取它的异常对象被销毁前，或在调用该异常对象的非静态成员函数前合法&lt;/p&gt;
&lt;p&gt;&lt;img src="https://edu-image.nosdn.127.net/FC0524938D6AAFD2AA605AA2137C8880.jpg?imageView&amp;amp;thumbnail=890x0&amp;amp;quality=100"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;h4 id="c11-noexcept"&gt;c++11 noexcept
&lt;/h4&gt;&lt;p&gt;C++03将throw(ExceptionType)放到函数后面，说明函数会抛出什么类型的异常，也被称为“异常规约”&lt;/p&gt;
&lt;p&gt;java用 throws关键字做同样的事情&lt;/p&gt;
&lt;p&gt;C++11后基本没人用“异常规约”&lt;/p&gt;
&lt;p&gt;C++11使用noexcept指明函数是否抛出异常&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若函数不抛异常，则可做编译优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即便函数抛异常，也不再说明所抛异常类型(简化)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;noexcept不能用于区分重载函数 (对比：函数名后面的const可区分重载)&lt;/p&gt;
&lt;h4 id="重抛异常"&gt;重抛异常
&lt;/h4&gt;&lt;h4 id="when-to-rethrow-an-exception"&gt;When to &lt;strong&gt;rethrow&lt;/strong&gt; an exception?
&lt;/h4&gt;&lt;p&gt;(1) if the handler cannot process the exception (当它无法处理该异常)&lt;/p&gt;
&lt;p&gt;(2) the handler simply wants to let its caller be notified (或想通知它的调用者发生了一个异常)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// statements;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TheException&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// Do something;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id="模板"&gt;模板
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Programming(编程): Writing a program that creates, transforms, filters, aggregates and otherwise manipulates data. (写一个程序去处理数据)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Metaprogramming(元编程): Writing a program that creates, transforms, filters, aggregates and otherwise manipulates programs.(写个程序去处理程序)&lt;/p&gt;
&lt;p&gt;C++ implements MetaProgramming with &amp;ldquo;template&amp;rdquo; to produce template instance, i.e. programs, in compiling time. (C++用&lt;strong&gt;模板&lt;/strong&gt;实现元编程，由编译器在编译期根据模板生成模板实例，也就是程序)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generic Programming(泛型编程): Writing a program that creates, transforms, filters, aggregates and otherwise manipulates data, but makes only the minimum assumptions about the structure of the data, thus maximizing reuse across a wide range of datatypes.(写个程序去处理数据，但是只对数据的结构做最小假设以使该程序能重用于处理广泛的数据类型)&lt;/p&gt;
&lt;p&gt;Generic programming in C++ (i.e. &lt;strong&gt;compile-time polymorphism&lt;/strong&gt;) is accomplished by metaprogramming (i.e. code generation from templated code).(C++的泛型编程，即&lt;strong&gt;编译时多态&lt;/strong&gt;，是藉由元编程实现的，也就是由代码模板生成代码)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="template"&gt;Template
&lt;/h3&gt;&lt;p&gt;模板&lt;/p&gt;
&lt;p&gt;&lt;img src="https://edu-image.nosdn.127.net/6624DA8B3BC36817154DD38DF7F70F44.jpg?imageView&amp;amp;thumbnail=890x0&amp;amp;quality=100"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;x1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="n"&gt;x2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//C++14
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A function template is just a blueprint, not a type, or a function. (函数模板只是蓝图，本身不是不是类型、函数)&lt;/p&gt;
&lt;p&gt;编译器扫描代码，遇到模版定义时，并不立即产生代码&lt;/p&gt;
&lt;p&gt;The template arguments must be determined so that the compiler can generate an actual function (确定模板实参后，编译器生成实际函数代码)&lt;/p&gt;
&lt;p&gt;两种实例化方法 (确定模板实参的方法)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Explicit instantiation (显式实例化)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="p"&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 实例化，编译器生成代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt; &lt;span class="c1"&gt;// void f(double s) { // T: double
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 实例化 f&amp;lt;char&amp;gt;(char) ，推导出模板实参
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 实例化 f&amp;lt;int&amp;gt;(int) ，推导出模板实参
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Implicit instantiation (隐式实例化)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 实例化并调用 f&amp;lt;double&amp;gt;(double)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 实例化并调用 f&amp;lt;char&amp;gt;(char)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 实例化并调用 f&amp;lt;int&amp;gt;(int)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 实例化 f&amp;lt;string&amp;gt;(string)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A function instantiated from a function template is called an instantiated function. A class instantiated from a class template is called an instantiated class.(由函数模板实例化得到的函数叫做“实例函数”，由类模板实例化得到的类叫做“实例类”)&lt;/p&gt;
&lt;h3 id="default-type-parameter-默认类型参数"&gt;Default type parameter (默认类型参数)
&lt;/h3&gt;&lt;p&gt;You can assign a default type for a type parameter in a class template. (可以为类模板的类型参数指定一个默认类型)&lt;/p&gt;
&lt;p&gt;template&lt;typename T = int&gt;&lt;/p&gt;
&lt;p&gt;You can only use default type in class templates, &lt;strong&gt;NOT&lt;/strong&gt; in function templates&lt;/p&gt;
&lt;h3 id="non-type-parameters-非类型参数"&gt;Non-type Parameters (非类型参数)
&lt;/h3&gt;&lt;p&gt;Using nontype parameters in a template prefix. (在模板前缀中使用非类型参数)&lt;/p&gt;
&lt;p&gt;When instantiating a template, the nontype argument should be an object(实例化模板时，非类型实参应该是&lt;strong&gt;对象&lt;/strong&gt;)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Stack&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;charStack&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;//对象作为非类型参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Color&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Label&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="err"&gt;……&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Color&lt;/span&gt; &lt;span class="nf"&gt;color&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;255&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Label&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="templates-and-inheritance"&gt;Templates and inheritance
&lt;/h3&gt;&lt;p&gt;模板与继承&lt;/p&gt;
&lt;p&gt;A non-template class can be derived from a class template specialization(普通类可从类模板&lt;strong&gt;实例&lt;/strong&gt;继承).&lt;/p&gt;
&lt;p&gt;A class template can be derived from a nontemplate class.(模板可从普通类继承)&lt;/p&gt;
&lt;p&gt;A class template can be derived from a class template.(类模板可继承类模板)&lt;/p&gt;
&lt;p&gt;template&lt;typename T&gt; class T1;&lt;/p&gt;
&lt;p&gt;template&lt;typename T&gt; class T2;&lt;/p&gt;
&lt;p&gt;class C;&lt;/p&gt;
&lt;h2 id="stlstandard-template-library"&gt;STL(Standard Template Library)
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;containers&lt;/p&gt;
&lt;p&gt;store a collection of data, often referred to as elements&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Sequence container(顺序容器)&lt;/p&gt;
&lt;p&gt;represents &lt;strong&gt;linear&lt;/strong&gt; data structures&lt;/p&gt;
&lt;p&gt;vector,list,deque&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Associative containers（关联容器）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;non-linear&lt;/strong&gt; containers that can locate elements stored in the container quickly&lt;/p&gt;
&lt;p&gt;set,multiset,map and multimap&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关联容器和顺序容器统称为一级容器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Container adapters(容器适配器)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;constrained versions&lt;/strong&gt; of sequence containers, aiming at handling special cases&lt;/p&gt;
&lt;p&gt;stack,queue, and priority_queue&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Iterators&lt;/p&gt;
&lt;p&gt;facilitate &lt;strong&gt;traversing&lt;/strong&gt; through the elements in a container&lt;/p&gt;
&lt;p&gt;a generalization of pointers&lt;/p&gt;
&lt;p&gt;used extensively in the first-class containers for accessing and manipulating the elements(用于访问和处理一级容器中的元素)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Algorithm&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Function Objects&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Memory Allocation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="iterator"&gt;Iterator
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://img.gejiba.com/images/449192c22ffba9b55343590c5b4513de.png"
loading="lazy"
alt="449192c22ffba9b55343590c5b4513de.png"
&gt;
&lt;img src="https://img.gejiba.com/images/e3ed25cd470f85a4102057c2da9eb05c.png"
loading="lazy"
alt="e3ed25cd470f85a4102057c2da9eb05c.png"
&gt;
&lt;img src="https://img.gejiba.com/images/403cc08a2b568f5d4a751ada9c918696.png"
loading="lazy"
alt="403cc08a2b568f5d4a751ada9c918696.png"
&gt;&lt;/p&gt;
&lt;h2 id="规范"&gt;规范
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;The prefix is should be used for boolean variables and methods.&lt;/li&gt;
&lt;li&gt;Type conversions must always be done explicitly. Never rely on implicit type conversion.&lt;/li&gt;
&lt;li&gt;Named constants (including enumeration values) must be all uppercase using underscore to separate words.&lt;/li&gt;
&lt;li&gt;Names representing types must be in mixed case starting with upper case.&lt;/li&gt;
&lt;li&gt;If the parameter of a member function has the same name as a private class variable, then the parameter should have underscore suffix.&lt;/li&gt;
&lt;li&gt;Class variables should never be declared public.&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>【CPP】W3C C++</title><link>https://dyhes.github.io/p/cppw3c-c-/</link><pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate><guid>https://dyhes.github.io/p/cppw3c-c-/</guid><description>&lt;h2 id="introduction"&gt;Introduction
&lt;/h2&gt;&lt;p&gt;C++ is a cross-platform language that can be used to create high-performance applications.&lt;/p&gt;
&lt;p&gt;C++ was developed by Bjarne Stroustrup, as an extension to the &lt;a class="link" href="https://www.w3schools.com/c/index.php" target="_blank" rel="noopener"
&gt;C language&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;C++ gives programmers a &lt;strong&gt;high level of control&lt;/strong&gt; over system resources and memory.&lt;/p&gt;
&lt;p&gt;The language was updated &lt;strong&gt;4 major times&lt;/strong&gt; in 2011, 2014, 2017, and 2020 to C++11, C++14, C++17, C++20.&lt;/p&gt;
&lt;p&gt;To start using C++, you need two things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A text editor, like Notepad, to write C++ code&lt;/li&gt;
&lt;li&gt;A compiler, like GCC, to translate the C++ code into a language that the computer will understand&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="const"&gt;Const
&lt;/h2&gt;&lt;p&gt;the &lt;code&gt;const&lt;/code&gt; keyword will declare the variable as &amp;ldquo;constant&amp;rdquo;, which means &lt;strong&gt;unchangeable and read-only&lt;/strong&gt;)&lt;/p&gt;
&lt;h2 id="basic-data-type"&gt;Basic Data Type
&lt;/h2&gt;&lt;p&gt;The data type specifies the size and type of information the variable will store:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left"&gt;Data Type&lt;/th&gt;
&lt;th style="text-align: left"&gt;Size&lt;/th&gt;
&lt;th style="text-align: left"&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;1 byte&lt;/td&gt;
&lt;td style="text-align: left"&gt;Stores true or false values&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;char&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;1 byte&lt;/td&gt;
&lt;td style="text-align: left"&gt;Stores a single character/letter/number, or ASCII values&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;2 or 4 bytes&lt;/td&gt;
&lt;td style="text-align: left"&gt;Stores whole numbers, without decimals&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;float&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;4 bytes&lt;/td&gt;
&lt;td style="text-align: left"&gt;Stores fractional numbers, containing one or more decimals. Sufficient for storing 7 decimal digits&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;double&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;8 bytes&lt;/td&gt;
&lt;td style="text-align: left"&gt;Stores fractional numbers, containing one or more decimals. Sufficient for storing 15 decimal digits&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="strings"&gt;Strings
&lt;/h2&gt;&lt;p&gt;A &lt;code&gt;string&lt;/code&gt; variable contains a collection of characters surrounded by double quotes&lt;/p&gt;
&lt;p&gt;o use strings, you must include an additional header file in the source code, the &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; library&lt;/p&gt;
&lt;p&gt;It is possible to use the extraction operator &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; on &lt;code&gt;cin&lt;/code&gt; to display a string entered by a user. However, &lt;code&gt;cin&lt;/code&gt; considers a space (whitespace, tabs, etc) as a terminating character, which means that it can only display a single word . That&amp;rsquo;s why, when working with strings, we often use the &lt;code&gt;getline()&lt;/code&gt; function to read a line of text. It takes &lt;code&gt;cin&lt;/code&gt; as the first parameter, and the string variable as second.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-cpp" data-lang="cpp"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;getline&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fullName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item></channel></rss>